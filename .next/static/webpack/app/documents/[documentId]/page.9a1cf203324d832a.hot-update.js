"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/documents/[documentId]/page",{

/***/ "(app-pages-browser)/./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthMessageType: () => (/* binding */ AuthMessageType),\n/* harmony export */   ConnectionTimeout: () => (/* binding */ ConnectionTimeout),\n/* harmony export */   Forbidden: () => (/* binding */ Forbidden),\n/* harmony export */   MessageTooBig: () => (/* binding */ MessageTooBig),\n/* harmony export */   ResetConnection: () => (/* binding */ ResetConnection),\n/* harmony export */   Unauthorized: () => (/* binding */ Unauthorized),\n/* harmony export */   WsReadyStates: () => (/* binding */ WsReadyStates),\n/* harmony export */   awarenessStatesToArray: () => (/* binding */ awarenessStatesToArray),\n/* harmony export */   readAuthMessage: () => (/* binding */ readAuthMessage),\n/* harmony export */   writeAuthenticated: () => (/* binding */ writeAuthenticated),\n/* harmony export */   writeAuthentication: () => (/* binding */ writeAuthentication),\n/* harmony export */   writePermissionDenied: () => (/* binding */ writePermissionDenied),\n/* harmony export */   writeTokenSyncRequest: () => (/* binding */ writeTokenSyncRequest)\n/* harmony export */ });\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b;\n\n/* eslint-env browser */\n\nconst BIT8 = 128;\nconst BITS7 = 127;\n\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i));\n  }\n  return buf\n};\n\n/* c8 ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\n\n/* c8 ignore next */\nlet utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true });\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null;\n}\n\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > BITS7) {\n    write(encoder, BIT8 | (BITS7 & num));\n    num = floor(num / 128); // shift >>> 7\n  }\n  write(encoder, BITS7 & num);\n};\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000);\nconst _maxStrBSize = _strBuffer.length / 3;\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n    writeVarUint(encoder, written);\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i]);\n    }\n  } else {\n    writeVarUint8Array(encoder, encodeUtf8(str));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nconst writeVarString = (utf8TextEncoder && /** @type {any} */ (utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill;\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf);\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\n\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nconst create = s => new Error(s);\n\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n\nconst errorUnexpectedEndOfArray = create('Unexpected end of array');\nconst errorIntegerOutOfRange = create('Integer out of Range');\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view\n};\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder));\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++];\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0;\n  let mult = 1;\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & BITS7) * mult; // shift $r << (7*#iterations) and add it to num\n    mult *= 128; // next iteration, shift 7 \"more\" to the left\n    if (r < BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n};\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nconst _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n};\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nconst _readVarStringNative = decoder =>\n  /** @type any */ (utf8TextDecoder).decode(readVarUint8Array(decoder));\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nconst readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\n\nvar AuthMessageType;\n(function (AuthMessageType) {\n    AuthMessageType[AuthMessageType[\"Token\"] = 0] = \"Token\";\n    AuthMessageType[AuthMessageType[\"PermissionDenied\"] = 1] = \"PermissionDenied\";\n    AuthMessageType[AuthMessageType[\"Authenticated\"] = 2] = \"Authenticated\";\n})(AuthMessageType || (AuthMessageType = {}));\nconst writeAuthentication = (encoder, auth) => {\n    writeVarUint(encoder, AuthMessageType.Token);\n    writeVarString(encoder, auth);\n};\nconst writePermissionDenied = (encoder, reason) => {\n    writeVarUint(encoder, AuthMessageType.PermissionDenied);\n    writeVarString(encoder, reason);\n};\nconst writeAuthenticated = (encoder, scope) => {\n    writeVarUint(encoder, AuthMessageType.Authenticated);\n    writeVarString(encoder, scope);\n};\nconst writeTokenSyncRequest = (encoder) => {\n    writeVarUint(encoder, AuthMessageType.Token);\n};\nconst readAuthMessage = (decoder, sendToken, permissionDeniedHandler, authenticatedHandler) => {\n    switch (readVarUint(decoder)) {\n        case AuthMessageType.Token: {\n            sendToken();\n            break;\n        }\n        case AuthMessageType.PermissionDenied: {\n            permissionDeniedHandler(readVarString(decoder));\n            break;\n        }\n        case AuthMessageType.Authenticated: {\n            authenticatedHandler(readVarString(decoder));\n            break;\n        }\n    }\n};\n\n/**\n * The server is terminating the connection because a data frame was received\n * that is too large.\n * See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code\n */\nconst MessageTooBig = {\n    code: 1009,\n    reason: \"Message Too Big\",\n};\n/**\n * The server successfully processed the request, asks that the requester reset\n * its document view, and is not returning any content.\n */\nconst ResetConnection = {\n    code: 4205,\n    reason: \"Reset Connection\",\n};\n/**\n * Similar to Forbidden, but specifically for use when authentication is required and has\n * failed or has not yet been provided.\n */\nconst Unauthorized = {\n    code: 4401,\n    reason: \"Unauthorized\",\n};\n/**\n * The request contained valid data and was understood by the server, but the server\n * is refusing action.\n */\nconst Forbidden = {\n    code: 4403,\n    reason: \"Forbidden\",\n};\n/**\n * The server timed out waiting for the request.\n */\nconst ConnectionTimeout = {\n    code: 4408,\n    reason: \"Connection Timeout\",\n};\n\nconst awarenessStatesToArray = (states) => {\n    return Array.from(states.entries()).map(([key, value]) => {\n        return {\n            clientId: key,\n            ...value,\n        };\n    });\n};\n\n/**\n * State of the WebSocket connection.\n * https://developer.mozilla.org/de/docs/Web/API/WebSocket/readyState\n */\nvar WsReadyStates;\n(function (WsReadyStates) {\n    WsReadyStates[WsReadyStates[\"Connecting\"] = 0] = \"Connecting\";\n    WsReadyStates[WsReadyStates[\"Open\"] = 1] = \"Open\";\n    WsReadyStates[WsReadyStates[\"Closing\"] = 2] = \"Closing\";\n    WsReadyStates[WsReadyStates[\"Closed\"] = 3] = \"Closed\";\n})(WsReadyStates || (WsReadyStates = {}));\n\n\n//# sourceMappingURL=hocuspocus-common.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AaG9jdXNwb2N1cy9jb21tb24vZGlzdC9ob2N1c3BvY3VzLWNvbW1vbi5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxhQUFhOztBQUVoRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkZBQTZGLDhCQUE4Qjs7QUFFM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDOztBQUUrTTtBQUN0UCIsInNvdXJjZXMiOlsiL1VzZXJzL2FyeWFuZ295YWwvcmVhbC10aW1lLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AaG9jdXNwb2N1cy9jb21tb24vZGlzdC9ob2N1c3BvY3VzLWNvbW1vbi5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb21tb24gTWF0aCBleHByZXNzaW9ucy5cbiAqXG4gKiBAbW9kdWxlIG1hdGhcbiAqL1xuXG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNtYWxsZXIgZWxlbWVudCBvZiBhIGFuZCBiXG4gKi9cbmNvbnN0IG1pbiA9IChhLCBiKSA9PiBhIDwgYiA/IGEgOiBiO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiaWdnZXIgZWxlbWVudCBvZiBhIGFuZCBiXG4gKi9cbmNvbnN0IG1heCA9IChhLCBiKSA9PiBhID4gYiA/IGEgOiBiO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuY29uc3QgQklUOCA9IDEyODtcbmNvbnN0IEJJVFM3ID0gMTI3O1xuXG4vKipcbiAqIFV0aWxpdHkgaGVscGVycyBmb3Igd29ya2luZyB3aXRoIG51bWJlcnMuXG4gKlxuICogQG1vZHVsZSBudW1iZXJcbiAqL1xuXG5cbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBfZW5jb2RlVXRmOFBvbHlmaWxsID0gc3RyID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbiAgY29uc3QgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGg7XG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGVuY29kZWRTdHJpbmcuY29kZVBvaW50QXQoaSkpO1xuICB9XG4gIHJldHVybiBidWZcbn07XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCB1dGY4VGV4dEVuY29kZXIgPSAvKiogQHR5cGUge1RleHRFbmNvZGVyfSAqLyAodHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RW5jb2RlcigpIDogbnVsbCk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgX2VuY29kZVV0ZjhOYXRpdmUgPSBzdHIgPT4gdXRmOFRleHRFbmNvZGVyLmVuY29kZShzdHIpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCBlbmNvZGVVdGY4ID0gdXRmOFRleHRFbmNvZGVyID8gX2VuY29kZVV0ZjhOYXRpdmUgOiBfZW5jb2RlVXRmOFBvbHlmaWxsO1xuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xubGV0IHV0ZjhUZXh0RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUsIGlnbm9yZUJPTTogdHJ1ZSB9KTtcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5pZiAodXRmOFRleHREZWNvZGVyICYmIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxKSB7XG4gIC8vIFNhZmFyaSBkb2Vzbid0IGhhbmRsZSBCT00gY29ycmVjdGx5LlxuICAvLyBUaGlzIGZpeGVzIGEgYnVnIGluIFNhZmFyaSAxMy4wLjUgd2hlcmUgaXQgcHJvZHVjZXMgYSBCT00gdGhlIGZpcnN0IHRpbWUgaXQgaXMgY2FsbGVkLlxuICAvLyB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSBvbiB0aGUgZmlyc3QgY2FsbCBhbmRcbiAgLy8gdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEgb24gdGhlIHNlY29uZCBjYWxsXG4gIC8vIEFub3RoZXIgaXNzdWUgaXMgdGhhdCBmcm9tIHRoZW4gb24gbm8gQk9NIGNoYXJzIGFyZSByZWNvZ25pemVkIGFueW1vcmVcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgdXRmOFRleHREZWNvZGVyID0gbnVsbDtcbn1cblxuLyoqXG4gKiBFZmZpY2llbnQgc2NoZW1hLWxlc3MgYmluYXJ5IGVuY29kaW5nIHdpdGggc3VwcG9ydCBmb3IgdmFyaWFibGUgbGVuZ3RoIGVuY29kaW5nLlxuICpcbiAqIFVzZSBbbGliMC9lbmNvZGluZ10gd2l0aCBbbGliMC9kZWNvZGluZ10uIEV2ZXJ5IGVuY29kaW5nIGZ1bmN0aW9uIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjb2RpbmcgZnVuY3Rpb24uXG4gKlxuICogRW5jb2RlcyBudW1iZXJzIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgKGxlYXN0IHRvIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBvcmRlcilcbiAqIGFuZCBpcyBjb21wYXRpYmxlIHdpdGggR29sYW5nJ3MgYmluYXJ5IGVuY29kaW5nIChodHRwczovL2dvbGFuZy5vcmcvcGtnL2VuY29kaW5nL2JpbmFyeS8pXG4gKiB3aGljaCBpcyBhbHNvIHVzZWQgaW4gUHJvdG9jb2wgQnVmZmVycy5cbiAqXG4gKiBgYGBqc1xuICogLy8gZW5jb2Rpbmcgc3RlcFxuICogY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICogZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDI1NilcbiAqIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsICdIZWxsbyB3b3JsZCEnKVxuICogY29uc3QgYnVmID0gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVjb2Rpbmcgc3RlcFxuICogY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICogZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gPT4gMjU2XG4gKiBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpIC8vID0+ICdIZWxsbyB3b3JsZCEnXG4gKiBkZWNvZGluZy5oYXNDb250ZW50KGRlY29kZXIpIC8vID0+IGZhbHNlIC0gYWxsIGRhdGEgaXMgcmVhZFxuICogYGBgXG4gKlxuICogQG1vZHVsZSBlbmNvZGluZ1xuICovXG5cblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSB0byB0aGUgZW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgYnl0ZSB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IHdyaXRlID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBjb25zdCBidWZmZXJMZW4gPSBlbmNvZGVyLmNidWYubGVuZ3RoO1xuICBpZiAoZW5jb2Rlci5jcG9zID09PSBidWZmZXJMZW4pIHtcbiAgICBlbmNvZGVyLmJ1ZnMucHVzaChlbmNvZGVyLmNidWYpO1xuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbiAqIDIpO1xuICAgIGVuY29kZXIuY3BvcyA9IDA7XG4gIH1cbiAgZW5jb2Rlci5jYnVmW2VuY29kZXIuY3BvcysrXSA9IG51bTtcbn07XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggdW5zaWduZWQgaW50ZWdlci4gTWF4IGVuY29kYWJsZSBpbnRlZ2VyIGlzIDJeNTMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IHdyaXRlVmFyVWludCA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgd2hpbGUgKG51bSA+IEJJVFM3KSB7XG4gICAgd3JpdGUoZW5jb2RlciwgQklUOCB8IChCSVRTNyAmIG51bSkpO1xuICAgIG51bSA9IGZsb29yKG51bSAvIDEyOCk7IC8vIHNoaWZ0ID4+PiA3XG4gIH1cbiAgd3JpdGUoZW5jb2RlciwgQklUUzcgJiBudW0pO1xufTtcblxuLyoqXG4gKiBBIGNhY2hlIHRvIHN0b3JlIHN0cmluZ3MgdGVtcG9yYXJpbHlcbiAqL1xuY29uc3QgX3N0ckJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDMwMDAwKTtcbmNvbnN0IF9tYXhTdHJCU2l6ZSA9IF9zdHJCdWZmZXIubGVuZ3RoIC8gMztcblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCBzdHJpbmcuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IF93cml0ZVZhclN0cmluZ05hdGl2ZSA9IChlbmNvZGVyLCBzdHIpID0+IHtcbiAgaWYgKHN0ci5sZW5ndGggPCBfbWF4U3RyQlNpemUpIHtcbiAgICAvLyBXZSBjYW4gZW5jb2RlIHRoZSBzdHJpbmcgaW50byB0aGUgZXhpc3RpbmcgYnVmZmVyXG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICBjb25zdCB3cml0dGVuID0gdXRmOFRleHRFbmNvZGVyLmVuY29kZUludG8oc3RyLCBfc3RyQnVmZmVyKS53cml0dGVuIHx8IDA7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIHdyaXR0ZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JpdHRlbjsgaSsrKSB7XG4gICAgICB3cml0ZShlbmNvZGVyLCBfc3RyQnVmZmVyW2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGVuY29kZVV0Zjgoc3RyKSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCBfd3JpdGVWYXJTdHJpbmdQb2x5ZmlsbCA9IChlbmNvZGVyLCBzdHIpID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbiAgY29uc3QgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGg7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbmNvZGVkU3RyaW5nLmNvZGVQb2ludEF0KGkpKSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3Qgd3JpdGVWYXJTdHJpbmcgPSAodXRmOFRleHRFbmNvZGVyICYmIC8qKiBAdHlwZSB7YW55fSAqLyAodXRmOFRleHRFbmNvZGVyKS5lbmNvZGVJbnRvKSA/IF93cml0ZVZhclN0cmluZ05hdGl2ZSA6IF93cml0ZVZhclN0cmluZ1BvbHlmaWxsO1xuXG4vKipcbiAqIEFwcGVuZCBmaXhlZC1sZW5ndGggVWludDhBcnJheSB0byB0aGUgZW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKi9cbmNvbnN0IHdyaXRlVWludDhBcnJheSA9IChlbmNvZGVyLCB1aW50OEFycmF5KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGg7XG4gIGNvbnN0IGNwb3MgPSBlbmNvZGVyLmNwb3M7XG4gIGNvbnN0IGxlZnRDb3B5TGVuID0gbWluKGJ1ZmZlckxlbiAtIGNwb3MsIHVpbnQ4QXJyYXkubGVuZ3RoKTtcbiAgY29uc3QgcmlnaHRDb3B5TGVuID0gdWludDhBcnJheS5sZW5ndGggLSBsZWZ0Q29weUxlbjtcbiAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KDAsIGxlZnRDb3B5TGVuKSwgY3Bvcyk7XG4gIGVuY29kZXIuY3BvcyArPSBsZWZ0Q29weUxlbjtcbiAgaWYgKHJpZ2h0Q29weUxlbiA+IDApIHtcbiAgICAvLyBTdGlsbCBzb21ldGhpbmcgdG8gd3JpdGUsIHdyaXRlIHJpZ2h0IGhhbGYuLlxuICAgIC8vIEFwcGVuZCBuZXcgYnVmZmVyXG4gICAgZW5jb2Rlci5idWZzLnB1c2goZW5jb2Rlci5jYnVmKTtcbiAgICAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgc2l6ZSBvZiByZW1haW5pbmcgYnVmZmVyXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkobWF4KGJ1ZmZlckxlbiAqIDIsIHJpZ2h0Q29weUxlbikpO1xuICAgIC8vIGNvcHkgYXJyYXlcbiAgICBlbmNvZGVyLmNidWYuc2V0KHVpbnQ4QXJyYXkuc3ViYXJyYXkobGVmdENvcHlMZW4pKTtcbiAgICBlbmNvZGVyLmNwb3MgPSByaWdodENvcHlMZW47XG4gIH1cbn07XG5cbi8qKlxuICogQXBwZW5kIGFuIFVpbnQ4QXJyYXkgdG8gRW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKi9cbmNvbnN0IHdyaXRlVmFyVWludDhBcnJheSA9IChlbmNvZGVyLCB1aW50OEFycmF5KSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCB1aW50OEFycmF5LmJ5dGVMZW5ndGgpO1xuICB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdWludDhBcnJheSk7XG59O1xuXG4vKipcbiAqIEVycm9yIGhlbHBlcnMuXG4gKlxuICogQG1vZHVsZSBlcnJvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge0Vycm9yfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgY3JlYXRlID0gcyA9PiBuZXcgRXJyb3Iocyk7XG5cbi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBkZWNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZGVjb2RpbmddIHdpdGggW2xpYjAvZW5jb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAqIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAyNTYpXG4gKiBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCAnSGVsbG8gd29ybGQhJylcbiAqIGNvbnN0IGJ1ZiA9IGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIGRlY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZGVjb2RpbmdcbiAqL1xuXG5cbmNvbnN0IGVycm9yVW5leHBlY3RlZEVuZE9mQXJyYXkgPSBjcmVhdGUoJ1VuZXhwZWN0ZWQgZW5kIG9mIGFycmF5Jyk7XG5jb25zdCBlcnJvckludGVnZXJPdXRPZlJhbmdlID0gY3JlYXRlKCdJbnRlZ2VyIG91dCBvZiBSYW5nZScpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBVaW50OEFycmF5IHZpZXcgb2YgdGhlIG5leHQgYGxlbmAgYnl0ZXMgYW5kIGFkdmFuY2UgdGhlIHBvc2l0aW9uIGJ5IGBsZW5gLlxuICpcbiAqIEltcG9ydGFudDogVGhlIFVpbnQ4QXJyYXkgc3RpbGwgcG9pbnRzIHRvIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLiBNYWtlIHN1cmUgdG8gZGlzY2FyZCB0aGUgcmVzdWx0IGFzIHNvb24gYXMgcG9zc2libGUgdG8gcHJldmVudCBhbnkgbWVtb3J5IGxlYWtzLlxuICogICAgICAgICAgICBVc2UgYGJ1ZmZlci5jb3B5VWludDhBcnJheWAgdG8gY29weSB0aGUgcmVzdWx0IGludG8gYSBuZXcgVWludDhBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBUaGUgbGVuZ3RoIG9mIGJ5dGVzIHRvIHJlYWRcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IHJlYWRVaW50OEFycmF5ID0gKGRlY29kZXIsIGxlbikgPT4ge1xuICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2Rlci5hcnIuYnVmZmVyLCBkZWNvZGVyLnBvcyArIGRlY29kZXIuYXJyLmJ5dGVPZmZzZXQsIGxlbik7XG4gIGRlY29kZXIucG9zICs9IGxlbjtcbiAgcmV0dXJuIHZpZXdcbn07XG5cbi8qKlxuICogUmVhZCB2YXJpYWJsZSBsZW5ndGggVWludDhBcnJheS5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IHJlYWRWYXJVaW50OEFycmF5ID0gZGVjb2RlciA9PiByZWFkVWludDhBcnJheShkZWNvZGVyLCByZWFkVmFyVWludChkZWNvZGVyKSk7XG5cbi8qKlxuICogUmVhZCBvbmUgYnl0ZSBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEByZXR1cm4ge251bWJlcn0gVW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICovXG5jb25zdCByZWFkVWludDggPSBkZWNvZGVyID0+IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdO1xuXG4vKipcbiAqIFJlYWQgdW5zaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLmxlbmd0aFxuICovXG5jb25zdCByZWFkVmFyVWludCA9IGRlY29kZXIgPT4ge1xuICBsZXQgbnVtID0gMDtcbiAgbGV0IG11bHQgPSAxO1xuICBjb25zdCBsZW4gPSBkZWNvZGVyLmFyci5sZW5ndGg7XG4gIHdoaWxlIChkZWNvZGVyLnBvcyA8IGxlbikge1xuICAgIGNvbnN0IHIgPSBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcbiAgICAvLyBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbilcbiAgICBudW0gPSBudW0gKyAociAmIEJJVFM3KSAqIG11bHQ7IC8vIHNoaWZ0ICRyIDw8ICg3KiNpdGVyYXRpb25zKSBhbmQgYWRkIGl0IHRvIG51bVxuICAgIG11bHQgKj0gMTI4OyAvLyBuZXh0IGl0ZXJhdGlvbiwgc2hpZnQgNyBcIm1vcmVcIiB0byB0aGUgbGVmdFxuICAgIGlmIChyIDwgQklUOCkge1xuICAgICAgcmV0dXJuIG51bVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAobnVtID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgdGhyb3cgZXJyb3JJbnRlZ2VyT3V0T2ZSYW5nZVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICB9XG4gIHRocm93IGVycm9yVW5leHBlY3RlZEVuZE9mQXJyYXlcbn07XG5cbi8qKlxuICogV2UgZG9uJ3QgdGVzdCB0aGlzIGZ1bmN0aW9uIGFueW1vcmUgYXMgd2UgdXNlIG5hdGl2ZSBkZWNvZGluZy9lbmNvZGluZyBieSBkZWZhdWx0IG5vdy5cbiAqIEJldHRlciBub3QgbW9kaWZ5IHRoaXMgYW55bW9yZS4uXG4gKlxuICogVHJhbnNmb3JtaW5nIHV0ZjggdG8gYSBzdHJpbmcgaXMgcHJldHR5IGV4cGVuc2l2ZS4gVGhlIGNvZGUgcGVyZm9ybXMgMTB4IGJldHRlclxuICogd2hlbiBTdHJpbmcuZnJvbUNvZGVQb2ludCBpcyBmZWQgd2l0aCBhbGwgY2hhcmFjdGVycyBhcyBhcmd1bWVudHMuXG4gKiBCdXQgbW9zdCBlbnZpcm9ubWVudHMgaGF2ZSBhIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyBwZXIgZnVuY3Rpb25zLlxuICogRm9yIGVmZmllbmN5IHJlYXNvbnMgd2UgYXBwbHkgYSBtYXhpbXVtIG9mIDEwMDAwIGNoYXJhY3RlcnMgYXQgb25jZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVhZCBTdHJpbmcuXG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgX3JlYWRWYXJTdHJpbmdQb2x5ZmlsbCA9IGRlY29kZXIgPT4ge1xuICBsZXQgcmVtYWluaW5nTGVuID0gcmVhZFZhclVpbnQoZGVjb2Rlcik7XG4gIGlmIChyZW1haW5pbmdMZW4gPT09IDApIHtcbiAgICByZXR1cm4gJydcbiAgfSBlbHNlIHtcbiAgICBsZXQgZW5jb2RlZFN0cmluZyA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHJlYWRVaW50OChkZWNvZGVyKSk7IC8vIHJlbWVtYmVyIHRvIGRlY3JlYXNlIHJlbWFpbmluZ0xlblxuICAgIGlmICgtLXJlbWFpbmluZ0xlbiA8IDEwMCkgeyAvLyBkbyBub3QgY3JlYXRlIGEgVWludDhBcnJheSBmb3Igc21hbGwgc3RyaW5nc1xuICAgICAgd2hpbGUgKHJlbWFpbmluZ0xlbi0tKSB7XG4gICAgICAgIGVuY29kZWRTdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQocmVhZFVpbnQ4KGRlY29kZXIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHJlbWFpbmluZ0xlbiA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dExlbiA9IHJlbWFpbmluZ0xlbiA8IDEwMDAwID8gcmVtYWluaW5nTGVuIDogMTAwMDA7XG4gICAgICAgIC8vIHRoaXMgaXMgZGFuZ2Vyb3VzLCB3ZSBjcmVhdGUgYSBmcmVzaCBhcnJheSB2aWV3IGZyb20gdGhlIGV4aXN0aW5nIGJ1ZmZlclxuICAgICAgICBjb25zdCBieXRlcyA9IGRlY29kZXIuYXJyLnN1YmFycmF5KGRlY29kZXIucG9zLCBkZWNvZGVyLnBvcyArIG5leHRMZW4pO1xuICAgICAgICBkZWNvZGVyLnBvcyArPSBuZXh0TGVuO1xuICAgICAgICAvLyBTdGFydGluZyB3aXRoIEVTNS4xIHdlIGNhbiBzdXBwbHkgYSBnZW5lcmljIGFycmF5LWxpa2Ugb2JqZWN0IGFzIGFyZ3VtZW50c1xuICAgICAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIC8qKiBAdHlwZSB7YW55fSAqLyAoYnl0ZXMpKTtcbiAgICAgICAgcmVtYWluaW5nTGVuIC09IG5leHRMZW47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGVuY29kZWRTdHJpbmcpKVxuICB9XG59O1xuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVhZCBTdHJpbmdcbiAqL1xuY29uc3QgX3JlYWRWYXJTdHJpbmdOYXRpdmUgPSBkZWNvZGVyID0+XG4gIC8qKiBAdHlwZSBhbnkgKi8gKHV0ZjhUZXh0RGVjb2RlcikuZGVjb2RlKHJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcblxuLyoqXG4gKiBSZWFkIHN0cmluZyBvZiB2YXJpYWJsZSBsZW5ndGhcbiAqICogdmFyVWludCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZ1xuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZWFkIFN0cmluZ1xuICpcbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IHJlYWRWYXJTdHJpbmcgPSB1dGY4VGV4dERlY29kZXIgPyBfcmVhZFZhclN0cmluZ05hdGl2ZSA6IF9yZWFkVmFyU3RyaW5nUG9seWZpbGw7XG5cbnZhciBBdXRoTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKEF1dGhNZXNzYWdlVHlwZSkge1xuICAgIEF1dGhNZXNzYWdlVHlwZVtBdXRoTWVzc2FnZVR5cGVbXCJUb2tlblwiXSA9IDBdID0gXCJUb2tlblwiO1xuICAgIEF1dGhNZXNzYWdlVHlwZVtBdXRoTWVzc2FnZVR5cGVbXCJQZXJtaXNzaW9uRGVuaWVkXCJdID0gMV0gPSBcIlBlcm1pc3Npb25EZW5pZWRcIjtcbiAgICBBdXRoTWVzc2FnZVR5cGVbQXV0aE1lc3NhZ2VUeXBlW1wiQXV0aGVudGljYXRlZFwiXSA9IDJdID0gXCJBdXRoZW50aWNhdGVkXCI7XG59KShBdXRoTWVzc2FnZVR5cGUgfHwgKEF1dGhNZXNzYWdlVHlwZSA9IHt9KSk7XG5jb25zdCB3cml0ZUF1dGhlbnRpY2F0aW9uID0gKGVuY29kZXIsIGF1dGgpID0+IHtcbiAgICB3cml0ZVZhclVpbnQoZW5jb2RlciwgQXV0aE1lc3NhZ2VUeXBlLlRva2VuKTtcbiAgICB3cml0ZVZhclN0cmluZyhlbmNvZGVyLCBhdXRoKTtcbn07XG5jb25zdCB3cml0ZVBlcm1pc3Npb25EZW5pZWQgPSAoZW5jb2RlciwgcmVhc29uKSA9PiB7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIEF1dGhNZXNzYWdlVHlwZS5QZXJtaXNzaW9uRGVuaWVkKTtcbiAgICB3cml0ZVZhclN0cmluZyhlbmNvZGVyLCByZWFzb24pO1xufTtcbmNvbnN0IHdyaXRlQXV0aGVudGljYXRlZCA9IChlbmNvZGVyLCBzY29wZSkgPT4ge1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBBdXRoTWVzc2FnZVR5cGUuQXV0aGVudGljYXRlZCk7XG4gICAgd3JpdGVWYXJTdHJpbmcoZW5jb2Rlciwgc2NvcGUpO1xufTtcbmNvbnN0IHdyaXRlVG9rZW5TeW5jUmVxdWVzdCA9IChlbmNvZGVyKSA9PiB7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIEF1dGhNZXNzYWdlVHlwZS5Ub2tlbik7XG59O1xuY29uc3QgcmVhZEF1dGhNZXNzYWdlID0gKGRlY29kZXIsIHNlbmRUb2tlbiwgcGVybWlzc2lvbkRlbmllZEhhbmRsZXIsIGF1dGhlbnRpY2F0ZWRIYW5kbGVyKSA9PiB7XG4gICAgc3dpdGNoIChyZWFkVmFyVWludChkZWNvZGVyKSkge1xuICAgICAgICBjYXNlIEF1dGhNZXNzYWdlVHlwZS5Ub2tlbjoge1xuICAgICAgICAgICAgc2VuZFRva2VuKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEF1dGhNZXNzYWdlVHlwZS5QZXJtaXNzaW9uRGVuaWVkOiB7XG4gICAgICAgICAgICBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlcihyZWFkVmFyU3RyaW5nKGRlY29kZXIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQXV0aE1lc3NhZ2VUeXBlLkF1dGhlbnRpY2F0ZWQ6IHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0ZWRIYW5kbGVyKHJlYWRWYXJTdHJpbmcoZGVjb2RlcikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSBzZXJ2ZXIgaXMgdGVybWluYXRpbmcgdGhlIGNvbm5lY3Rpb24gYmVjYXVzZSBhIGRhdGEgZnJhbWUgd2FzIHJlY2VpdmVkXG4gKiB0aGF0IGlzIHRvbyBsYXJnZS5cbiAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQvY29kZVxuICovXG5jb25zdCBNZXNzYWdlVG9vQmlnID0ge1xuICAgIGNvZGU6IDEwMDksXG4gICAgcmVhc29uOiBcIk1lc3NhZ2UgVG9vIEJpZ1wiLFxufTtcbi8qKlxuICogVGhlIHNlcnZlciBzdWNjZXNzZnVsbHkgcHJvY2Vzc2VkIHRoZSByZXF1ZXN0LCBhc2tzIHRoYXQgdGhlIHJlcXVlc3RlciByZXNldFxuICogaXRzIGRvY3VtZW50IHZpZXcsIGFuZCBpcyBub3QgcmV0dXJuaW5nIGFueSBjb250ZW50LlxuICovXG5jb25zdCBSZXNldENvbm5lY3Rpb24gPSB7XG4gICAgY29kZTogNDIwNSxcbiAgICByZWFzb246IFwiUmVzZXQgQ29ubmVjdGlvblwiLFxufTtcbi8qKlxuICogU2ltaWxhciB0byBGb3JiaWRkZW4sIGJ1dCBzcGVjaWZpY2FsbHkgZm9yIHVzZSB3aGVuIGF1dGhlbnRpY2F0aW9uIGlzIHJlcXVpcmVkIGFuZCBoYXNcbiAqIGZhaWxlZCBvciBoYXMgbm90IHlldCBiZWVuIHByb3ZpZGVkLlxuICovXG5jb25zdCBVbmF1dGhvcml6ZWQgPSB7XG4gICAgY29kZTogNDQwMSxcbiAgICByZWFzb246IFwiVW5hdXRob3JpemVkXCIsXG59O1xuLyoqXG4gKiBUaGUgcmVxdWVzdCBjb250YWluZWQgdmFsaWQgZGF0YSBhbmQgd2FzIHVuZGVyc3Rvb2QgYnkgdGhlIHNlcnZlciwgYnV0IHRoZSBzZXJ2ZXJcbiAqIGlzIHJlZnVzaW5nIGFjdGlvbi5cbiAqL1xuY29uc3QgRm9yYmlkZGVuID0ge1xuICAgIGNvZGU6IDQ0MDMsXG4gICAgcmVhc29uOiBcIkZvcmJpZGRlblwiLFxufTtcbi8qKlxuICogVGhlIHNlcnZlciB0aW1lZCBvdXQgd2FpdGluZyBmb3IgdGhlIHJlcXVlc3QuXG4gKi9cbmNvbnN0IENvbm5lY3Rpb25UaW1lb3V0ID0ge1xuICAgIGNvZGU6IDQ0MDgsXG4gICAgcmVhc29uOiBcIkNvbm5lY3Rpb24gVGltZW91dFwiLFxufTtcblxuY29uc3QgYXdhcmVuZXNzU3RhdGVzVG9BcnJheSA9IChzdGF0ZXMpID0+IHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShzdGF0ZXMuZW50cmllcygpKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50SWQ6IGtleSxcbiAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTdGF0ZSBvZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kZS9kb2NzL1dlYi9BUEkvV2ViU29ja2V0L3JlYWR5U3RhdGVcbiAqL1xudmFyIFdzUmVhZHlTdGF0ZXM7XG4oZnVuY3Rpb24gKFdzUmVhZHlTdGF0ZXMpIHtcbiAgICBXc1JlYWR5U3RhdGVzW1dzUmVhZHlTdGF0ZXNbXCJDb25uZWN0aW5nXCJdID0gMF0gPSBcIkNvbm5lY3RpbmdcIjtcbiAgICBXc1JlYWR5U3RhdGVzW1dzUmVhZHlTdGF0ZXNbXCJPcGVuXCJdID0gMV0gPSBcIk9wZW5cIjtcbiAgICBXc1JlYWR5U3RhdGVzW1dzUmVhZHlTdGF0ZXNbXCJDbG9zaW5nXCJdID0gMl0gPSBcIkNsb3NpbmdcIjtcbiAgICBXc1JlYWR5U3RhdGVzW1dzUmVhZHlTdGF0ZXNbXCJDbG9zZWRcIl0gPSAzXSA9IFwiQ2xvc2VkXCI7XG59KShXc1JlYWR5U3RhdGVzIHx8IChXc1JlYWR5U3RhdGVzID0ge30pKTtcblxuZXhwb3J0IHsgQXV0aE1lc3NhZ2VUeXBlLCBDb25uZWN0aW9uVGltZW91dCwgRm9yYmlkZGVuLCBNZXNzYWdlVG9vQmlnLCBSZXNldENvbm5lY3Rpb24sIFVuYXV0aG9yaXplZCwgV3NSZWFkeVN0YXRlcywgYXdhcmVuZXNzU3RhdGVzVG9BcnJheSwgcmVhZEF1dGhNZXNzYWdlLCB3cml0ZUF1dGhlbnRpY2F0ZWQsIHdyaXRlQXV0aGVudGljYXRpb24sIHdyaXRlUGVybWlzc2lvbkRlbmllZCwgd3JpdGVUb2tlblN5bmNSZXF1ZXN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob2N1c3BvY3VzLWNvbW1vbi5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AwarenessError: () => (/* binding */ AwarenessError),\n/* harmony export */   HocuspocusProvider: () => (/* binding */ HocuspocusProvider),\n/* harmony export */   HocuspocusProviderWebsocket: () => (/* binding */ HocuspocusProviderWebsocket),\n/* harmony export */   MessageType: () => (/* binding */ MessageType),\n/* harmony export */   WebSocketStatus: () => (/* binding */ WebSocketStatus)\n/* harmony export */ });\n/* harmony import */ var _hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hocuspocus/common */ \"(app-pages-browser)/./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yjs */ \"(app-pages-browser)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _lifeomic_attempt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lifeomic/attempt */ \"(app-pages-browser)/./node_modules/@lifeomic/attempt/dist/es6/src/index.js\");\n\n\n\n\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b;\n\n/* eslint-env browser */\n\nconst BIT7 = 64;\nconst BIT8 = 128;\nconst BITS6 = 63;\nconst BITS7 = 127;\n\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nconst create$2 = () => new Set();\n\n/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nconst from = Array.from;\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i));\n  }\n  return buf\n};\n\n/* c8 ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\n\n/* c8 ignore next */\nlet utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true });\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null;\n}\n\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nclass Encoder {\n  constructor () {\n    this.cpos = 0;\n    this.cbuf = new Uint8Array(100);\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = [];\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nconst createEncoder = () => new Encoder();\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nconst length$1 = encoder => {\n  let len = encoder.cpos;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length;\n  }\n  return len\n};\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nconst toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length$1(encoder));\n  let curPos = 0;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i];\n    uint8arr.set(d, curPos);\n    curPos += d.length;\n  }\n  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n  return uint8arr\n};\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > BITS7) {\n    write(encoder, BIT8 | (BITS7 & num));\n    num = floor(num / 128); // shift >>> 7\n  }\n  write(encoder, BITS7 & num);\n};\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000);\nconst _maxStrBSize = _strBuffer.length / 3;\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n    writeVarUint(encoder, written);\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i]);\n    }\n  } else {\n    writeVarUint8Array(encoder, encodeUtf8(str));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nconst writeVarString = (utf8TextEncoder && /** @type {any} */ (utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill;\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf);\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\n\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nconst create$1 = s => new Error(s);\n\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n\nconst errorUnexpectedEndOfArray = create$1('Unexpected end of array');\nconst errorIntegerOutOfRange = create$1('Integer out of Range');\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nclass Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array;\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0;\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nconst createDecoder = uint8Array => new Decoder(uint8Array);\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view\n};\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder));\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++];\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0;\n  let mult = 1;\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & BITS7) * mult; // shift $r << (7*#iterations) and add it to num\n    mult *= 128; // next iteration, shift 7 \"more\" to the left\n    if (r < BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n};\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++];\n  let num = r & BITS6;\n  let mult = 64;\n  const sign = (r & BIT7) > 0 ? -1 : 1;\n  if ((r & BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & BITS7) * mult;\n    mult *= 128;\n    if (r < BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n};\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nconst _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n};\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nconst _readVarStringNative = decoder =>\n  /** @type any */ (utf8TextDecoder).decode(readVarUint8Array(decoder));\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nconst readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nconst peekVarString = decoder => {\n  const pos = decoder.pos;\n  const s = readVarString(decoder);\n  decoder.pos = pos;\n  return s\n};\n\n/**\n * Utility module to work with time.\n *\n * @module time\n */\n\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nconst getUnixTime = Date.now;\n\n/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nconst create = () => new Map();\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template {Map<any, any>} MAP\n * @template {MAP extends Map<any,infer V> ? function():V : unknown} CF\n * @param {MAP} map\n * @param {MAP extends Map<infer K,any> ? K : unknown} key\n * @param {CF} createT\n * @return {ReturnType<CF>}\n */\nconst setIfUndefined = (map, key, createT) => {\n  let set = map.get(key);\n  if (set === undefined) {\n    map.set(key, set = createT());\n  }\n  return set\n};\n\n/**\n * Observable class prototype.\n *\n * @module observable\n */\n\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nclass Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = create();\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    setIfUndefined(this._observers, name, create$2).add(f);\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f);\n      f(...args);\n    };\n    this.on(name, _f);\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name);\n    if (observers !== undefined) {\n      observers.delete(f);\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return from((this._observers.get(name) || create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = create();\n  }\n}\n/* c8 ignore end */\n\n/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n\n/**\n * @param {Object<string,any>} obj\n */\nconst keys = Object.keys;\n\n/**\n * @deprecated use object.size instead\n * @param {Object<string,any>} obj\n * @return {number}\n */\nconst length = obj => keys(obj).length;\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nconst hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\n\n/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nconst equalityStrict = (a, b) => a === b;\n\n/* c8 ignore start */\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (length(a) !== length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n};\n\n/**\n * @module awareness-protocol\n */\n\n\nconst outdatedTimeout = 30000;\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nclass Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super();\n    this.doc = doc;\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID;\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map();\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map();\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = getUnixTime();\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState());\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = [];\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid);\n        }\n      });\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout');\n      }\n    }, floor(outdatedTimeout / 10)));\n    doc.on('destroy', () => {\n      this.destroy();\n    });\n    this.setLocalState({});\n  }\n\n  destroy () {\n    this.emit('destroy', [this]);\n    this.setLocalState(null);\n    super.destroy();\n    clearInterval(this._checkInterval);\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID;\n    const currLocalMeta = this.meta.get(clientID);\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1;\n    const prevState = this.states.get(clientID);\n    if (state === null) {\n      this.states.delete(clientID);\n    } else {\n      this.states.set(clientID, state);\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: getUnixTime()\n    });\n    const added = [];\n    const updated = [];\n    const filteredUpdated = [];\n    const removed = [];\n    if (state === null) {\n      removed.push(clientID);\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID);\n      }\n    } else {\n      updated.push(clientID);\n      if (!equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID);\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local']);\n    }\n    this.emit('update', [{ added, updated, removed }, 'local']);\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState();\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      });\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nconst removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = [];\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i];\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID);\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID));\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: getUnixTime()\n        });\n      }\n      removed.push(clientID);\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin]);\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin]);\n  }\n};\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nconst encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length;\n  const encoder = createEncoder();\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i];\n    const state = states.get(clientID) || null;\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock;\n    writeVarUint(encoder, clientID);\n    writeVarUint(encoder, clock);\n    writeVarString(encoder, JSON.stringify(state));\n  }\n  return toUint8Array(encoder)\n};\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nconst applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = createDecoder(update);\n  const timestamp = getUnixTime();\n  const added = [];\n  const updated = [];\n  const filteredUpdated = [];\n  const removed = [];\n  const len = readVarUint(decoder);\n  for (let i = 0; i < len; i++) {\n    const clientID = readVarUint(decoder);\n    let clock = readVarUint(decoder);\n    const state = JSON.parse(readVarString(decoder));\n    const clientMeta = awareness.meta.get(clientID);\n    const prevState = awareness.states.get(clientID);\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock;\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++;\n        } else {\n          awareness.states.delete(clientID);\n        }\n      } else {\n        awareness.states.set(clientID, state);\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      });\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID);\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID);\n      } else if (state !== null) {\n        if (!equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID);\n        }\n        updated.push(clientID);\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin]);\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin]);\n  }\n};\n\nclass EventEmitter {\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n        this.callbacks = {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    on(event, fn) {\n        if (!this.callbacks[event]) {\n            this.callbacks[event] = [];\n        }\n        this.callbacks[event].push(fn);\n        return this;\n    }\n    emit(event, ...args) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            callbacks.forEach((callback) => callback.apply(this, args));\n        }\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    off(event, fn) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            if (fn) {\n                this.callbacks[event] = callbacks.filter((callback) => callback !== fn);\n            }\n            else {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    }\n    removeAllListeners() {\n        this.callbacks = {};\n    }\n}\n\nclass IncomingMessage {\n    constructor(data) {\n        this.data = data;\n        this.encoder = createEncoder();\n        this.decoder = createDecoder(new Uint8Array(this.data));\n    }\n    peekVarString() {\n        return peekVarString(this.decoder);\n    }\n    readVarUint() {\n        return readVarUint(this.decoder);\n    }\n    readVarString() {\n        return readVarString(this.decoder);\n    }\n    readVarUint8Array() {\n        return readVarUint8Array(this.decoder);\n    }\n    writeVarUint(type) {\n        return writeVarUint(this.encoder, type);\n    }\n    writeVarString(string) {\n        return writeVarString(this.encoder, string);\n    }\n    writeVarUint8Array(data) {\n        return writeVarUint8Array(this.encoder, data);\n    }\n    length() {\n        return length$1(this.encoder);\n    }\n}\n\nvar MessageType;\n(function (MessageType) {\n    MessageType[MessageType[\"Sync\"] = 0] = \"Sync\";\n    MessageType[MessageType[\"Awareness\"] = 1] = \"Awareness\";\n    MessageType[MessageType[\"Auth\"] = 2] = \"Auth\";\n    MessageType[MessageType[\"QueryAwareness\"] = 3] = \"QueryAwareness\";\n    MessageType[MessageType[\"Stateless\"] = 5] = \"Stateless\";\n    MessageType[MessageType[\"CLOSE\"] = 7] = \"CLOSE\";\n    MessageType[MessageType[\"SyncStatus\"] = 8] = \"SyncStatus\";\n})(MessageType || (MessageType = {}));\nvar WebSocketStatus;\n(function (WebSocketStatus) {\n    WebSocketStatus[\"Connecting\"] = \"connecting\";\n    WebSocketStatus[\"Connected\"] = \"connected\";\n    WebSocketStatus[\"Disconnected\"] = \"disconnected\";\n})(WebSocketStatus || (WebSocketStatus = {}));\n\nclass OutgoingMessage {\n    constructor() {\n        this.encoder = createEncoder();\n    }\n    get(args) {\n        return args.encoder;\n    }\n    toUint8Array() {\n        return toUint8Array(this.encoder);\n    }\n}\n\nclass CloseMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.CLOSE;\n        this.description = \"Ask the server to close the connection\";\n    }\n    get(args) {\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        return this.encoder;\n    }\n}\n\nclass HocuspocusProviderWebsocket extends EventEmitter {\n    constructor(configuration) {\n        super();\n        this.messageQueue = [];\n        this.configuration = {\n            url: \"\",\n            autoConnect: true,\n            // @ts-ignore\n            document: undefined,\n            WebSocketPolyfill: undefined,\n            // TODO: this should depend on awareness.outdatedTime\n            messageReconnectTimeout: 30000,\n            // 1 second\n            delay: 1000,\n            // instant\n            initialDelay: 0,\n            // double the delay each time\n            factor: 2,\n            // unlimited retries\n            maxAttempts: 0,\n            // wait at least 1 second\n            minDelay: 1000,\n            // at least every 30 seconds\n            maxDelay: 30000,\n            // randomize\n            jitter: true,\n            // retry forever\n            timeout: 0,\n            onOpen: () => null,\n            onConnect: () => null,\n            onMessage: () => null,\n            onOutgoingMessage: () => null,\n            onStatus: () => null,\n            onDisconnect: () => null,\n            onClose: () => null,\n            onDestroy: () => null,\n            onAwarenessUpdate: () => null,\n            onAwarenessChange: () => null,\n            handleTimeout: null,\n            providerMap: new Map(),\n        };\n        this.webSocket = null;\n        this.webSocketHandlers = {};\n        this.shouldConnect = true;\n        this.status = WebSocketStatus.Disconnected;\n        this.lastMessageReceived = 0;\n        this.identifier = 0;\n        this.intervals = {\n            connectionChecker: null,\n        };\n        this.connectionAttempt = null;\n        this.receivedOnOpenPayload = undefined;\n        this.closeTries = 0;\n        this.setConfiguration(configuration);\n        this.configuration.WebSocketPolyfill = configuration.WebSocketPolyfill\n            ? configuration.WebSocketPolyfill\n            : WebSocket;\n        this.on(\"open\", this.configuration.onOpen);\n        this.on(\"open\", this.onOpen.bind(this));\n        this.on(\"connect\", this.configuration.onConnect);\n        this.on(\"message\", this.configuration.onMessage);\n        this.on(\"outgoingMessage\", this.configuration.onOutgoingMessage);\n        this.on(\"status\", this.configuration.onStatus);\n        this.on(\"disconnect\", this.configuration.onDisconnect);\n        this.on(\"close\", this.configuration.onClose);\n        this.on(\"destroy\", this.configuration.onDestroy);\n        this.on(\"awarenessUpdate\", this.configuration.onAwarenessUpdate);\n        this.on(\"awarenessChange\", this.configuration.onAwarenessChange);\n        this.on(\"close\", this.onClose.bind(this));\n        this.on(\"message\", this.onMessage.bind(this));\n        this.intervals.connectionChecker = setInterval(this.checkConnection.bind(this), this.configuration.messageReconnectTimeout / 10);\n        if (this.shouldConnect) {\n            this.connect();\n        }\n    }\n    async onOpen(event) {\n        this.status = WebSocketStatus.Connected;\n        this.emit(\"status\", { status: WebSocketStatus.Connected });\n        this.cancelWebsocketRetry = undefined;\n        this.receivedOnOpenPayload = event;\n    }\n    attach(provider) {\n        this.configuration.providerMap.set(provider.configuration.name, provider);\n        if (this.status === WebSocketStatus.Disconnected && this.shouldConnect) {\n            this.connect();\n        }\n        if (this.receivedOnOpenPayload &&\n            this.status === WebSocketStatus.Connected) {\n            provider.onOpen(this.receivedOnOpenPayload);\n        }\n    }\n    detach(provider) {\n        if (this.configuration.providerMap.has(provider.configuration.name)) {\n            provider.send(CloseMessage, {\n                documentName: provider.configuration.name,\n            });\n            this.configuration.providerMap.delete(provider.configuration.name);\n        }\n    }\n    setConfiguration(configuration = {}) {\n        this.configuration = { ...this.configuration, ...configuration };\n        if (!this.configuration.autoConnect) {\n            this.shouldConnect = false;\n        }\n    }\n    async connect() {\n        if (this.status === WebSocketStatus.Connected) {\n            return;\n        }\n        // Always cancel any previously initiated connection retryer instances\n        if (this.cancelWebsocketRetry) {\n            this.cancelWebsocketRetry();\n            this.cancelWebsocketRetry = undefined;\n        }\n        this.receivedOnOpenPayload = undefined;\n        this.shouldConnect = true;\n        const abortableRetry = () => {\n            let cancelAttempt = false;\n            const retryPromise = (0,_lifeomic_attempt__WEBPACK_IMPORTED_MODULE_1__.retry)(this.createWebSocketConnection.bind(this), {\n                delay: this.configuration.delay,\n                initialDelay: this.configuration.initialDelay,\n                factor: this.configuration.factor,\n                maxAttempts: this.configuration.maxAttempts,\n                minDelay: this.configuration.minDelay,\n                maxDelay: this.configuration.maxDelay,\n                jitter: this.configuration.jitter,\n                timeout: this.configuration.timeout,\n                handleTimeout: this.configuration.handleTimeout,\n                beforeAttempt: (context) => {\n                    if (!this.shouldConnect || cancelAttempt) {\n                        context.abort();\n                    }\n                },\n            }).catch((error) => {\n                // If we aborted the connection attempt then dont throw an error\n                // ref: https://github.com/lifeomic/attempt/blob/master/src/index.ts#L136\n                if (error && error.code !== \"ATTEMPT_ABORTED\") {\n                    throw error;\n                }\n            });\n            return {\n                retryPromise,\n                cancelFunc: () => {\n                    cancelAttempt = true;\n                },\n            };\n        };\n        const { retryPromise, cancelFunc } = abortableRetry();\n        this.cancelWebsocketRetry = cancelFunc;\n        return retryPromise;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    attachWebSocketListeners(ws, reject) {\n        const { identifier } = ws;\n        const onMessageHandler = (payload) => this.emit(\"message\", payload);\n        const onCloseHandler = (payload) => this.emit(\"close\", { event: payload });\n        const onOpenHandler = (payload) => this.emit(\"open\", payload);\n        const onErrorHandler = (err) => {\n            reject(err);\n        };\n        this.webSocketHandlers[identifier] = {\n            message: onMessageHandler,\n            close: onCloseHandler,\n            open: onOpenHandler,\n            error: onErrorHandler,\n        };\n        const handlers = this.webSocketHandlers[ws.identifier];\n        Object.keys(handlers).forEach((name) => {\n            ws.addEventListener(name, handlers[name]);\n        });\n    }\n    cleanupWebSocket() {\n        if (!this.webSocket) {\n            return;\n        }\n        const { identifier } = this.webSocket;\n        const handlers = this.webSocketHandlers[identifier];\n        Object.keys(handlers).forEach((name) => {\n            var _a;\n            (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.removeEventListener(name, handlers[name]);\n            delete this.webSocketHandlers[identifier];\n        });\n        this.webSocket.close();\n        this.webSocket = null;\n    }\n    createWebSocketConnection() {\n        return new Promise((resolve, reject) => {\n            if (this.webSocket) {\n                this.messageQueue = [];\n                this.cleanupWebSocket();\n            }\n            this.lastMessageReceived = 0;\n            this.identifier += 1;\n            // Init the WebSocket connection\n            const ws = new this.configuration.WebSocketPolyfill(this.url);\n            ws.binaryType = \"arraybuffer\";\n            ws.identifier = this.identifier;\n            this.attachWebSocketListeners(ws, reject);\n            this.webSocket = ws;\n            // Reset the status\n            this.status = WebSocketStatus.Connecting;\n            this.emit(\"status\", { status: WebSocketStatus.Connecting });\n            // Store resolve/reject for later use\n            this.connectionAttempt = {\n                resolve,\n                reject,\n            };\n        });\n    }\n    onMessage(event) {\n        var _a;\n        this.resolveConnectionAttempt();\n        this.lastMessageReceived = getUnixTime();\n        const message = new IncomingMessage(event.data);\n        const documentName = message.peekVarString();\n        (_a = this.configuration.providerMap.get(documentName)) === null || _a === void 0 ? void 0 : _a.onMessage(event);\n    }\n    resolveConnectionAttempt() {\n        if (this.connectionAttempt) {\n            this.connectionAttempt.resolve();\n            this.connectionAttempt = null;\n            this.status = WebSocketStatus.Connected;\n            this.emit(\"status\", { status: WebSocketStatus.Connected });\n            this.emit(\"connect\");\n            this.messageQueue.forEach((message) => this.send(message));\n            this.messageQueue = [];\n        }\n    }\n    stopConnectionAttempt() {\n        this.connectionAttempt = null;\n    }\n    rejectConnectionAttempt() {\n        var _a;\n        (_a = this.connectionAttempt) === null || _a === void 0 ? void 0 : _a.reject();\n        this.connectionAttempt = null;\n    }\n    checkConnection() {\n        var _a;\n        // Dont check the connection when its not even established\n        if (this.status !== WebSocketStatus.Connected) {\n            return;\n        }\n        // Dont close the connection while waiting for the first message\n        if (!this.lastMessageReceived) {\n            return;\n        }\n        // Dont close the connection when a message was received recently\n        if (this.configuration.messageReconnectTimeout >=\n            getUnixTime() - this.lastMessageReceived) {\n            return;\n        }\n        // No message received in a long time, not even your own\n        // Awareness updates, which are updated every 15 seconds\n        // if awareness is enabled.\n        this.closeTries += 1;\n        // https://bugs.webkit.org/show_bug.cgi?id=247943\n        if (this.closeTries > 2) {\n            this.onClose({\n                event: {\n                    code: 4408,\n                    reason: \"forced\",\n                },\n            });\n            this.closeTries = 0;\n        }\n        else {\n            (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.close();\n            this.messageQueue = [];\n        }\n    }\n    // Ensure that the URL never ends with /\n    get serverUrl() {\n        while (this.configuration.url[this.configuration.url.length - 1] === \"/\") {\n            return this.configuration.url.slice(0, this.configuration.url.length - 1);\n        }\n        return this.configuration.url;\n    }\n    get url() {\n        return this.serverUrl;\n    }\n    disconnect() {\n        this.shouldConnect = false;\n        if (this.webSocket === null) {\n            return;\n        }\n        try {\n            this.webSocket.close();\n            this.messageQueue = [];\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    send(message) {\n        var _a;\n        if (((_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.readyState) === _hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.WsReadyStates.Open) {\n            this.webSocket.send(message);\n        }\n        else {\n            this.messageQueue.push(message);\n        }\n    }\n    onClose({ event }) {\n        this.closeTries = 0;\n        this.cleanupWebSocket();\n        if (this.connectionAttempt) {\n            // That connection attempt failed.\n            this.rejectConnectionAttempt();\n        }\n        // Lets update the connection status.\n        this.status = WebSocketStatus.Disconnected;\n        this.emit(\"status\", { status: WebSocketStatus.Disconnected });\n        this.emit(\"disconnect\", { event });\n        // trigger connect if no retry is running and we want to have a connection\n        if (!this.cancelWebsocketRetry && this.shouldConnect) {\n            setTimeout(() => {\n                this.connect();\n            }, this.configuration.delay);\n        }\n    }\n    destroy() {\n        this.emit(\"destroy\");\n        clearInterval(this.intervals.connectionChecker);\n        // If there is still a connection attempt outstanding then we should stop\n        // it before calling disconnect, otherwise it will be rejected in the onClose\n        // handler and trigger a retry\n        this.stopConnectionAttempt();\n        this.disconnect();\n        this.removeAllListeners();\n        this.cleanupWebSocket();\n    }\n}\n\n/**\n * @module sync-protocol\n */\n\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n *  YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n *  YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server should only reply to requests, and not initiate them.\n * Therefore it is necessary that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nconst messageYjsSyncStep1 = 0;\nconst messageYjsSyncStep2 = 1;\nconst messageYjsUpdate = 2;\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nconst writeSyncStep1 = (encoder, doc) => {\n  writeVarUint(encoder, messageYjsSyncStep1);\n  const sv = yjs__WEBPACK_IMPORTED_MODULE_2__.encodeStateVector(doc);\n  writeVarUint8Array(encoder, sv);\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nconst writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  writeVarUint(encoder, messageYjsSyncStep2);\n  writeVarUint8Array(encoder, yjs__WEBPACK_IMPORTED_MODULE_2__.encodeStateAsUpdate(doc, encodedStateVector));\n};\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nconst readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, readVarUint8Array(decoder));\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    yjs__WEBPACK_IMPORTED_MODULE_2__.applyUpdate(doc, readVarUint8Array(decoder), transactionOrigin);\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error('Caught error while handling a Yjs update', error);\n  }\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nconst writeUpdate = (encoder, update) => {\n  writeVarUint(encoder, messageYjsUpdate);\n  writeVarUint8Array(encoder, update);\n};\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readUpdate = readSyncStep2;\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Does not need to be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = readVarUint(decoder);\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc);\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin);\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin);\n      break\n    default:\n      throw new Error('Unknown message type')\n  }\n  return messageType\n};\n\nclass MessageReceiver {\n    constructor(message) {\n        this.message = message;\n    }\n    apply(provider, emitSynced) {\n        const { message } = this;\n        const type = message.readVarUint();\n        const emptyMessageLength = message.length();\n        switch (type) {\n            case MessageType.Sync:\n                this.applySyncMessage(provider, emitSynced);\n                break;\n            case MessageType.Awareness:\n                this.applyAwarenessMessage(provider);\n                break;\n            case MessageType.Auth:\n                this.applyAuthMessage(provider);\n                break;\n            case MessageType.QueryAwareness:\n                this.applyQueryAwarenessMessage(provider);\n                break;\n            case MessageType.Stateless:\n                provider.receiveStateless(readVarString(message.decoder));\n                break;\n            case MessageType.SyncStatus:\n                this.applySyncStatusMessage(provider, readVarInt(message.decoder) === 1);\n                break;\n            case MessageType.CLOSE:\n                // eslint-disable-next-line no-case-declarations\n                const event = {\n                    code: 1000,\n                    reason: readVarString(message.decoder),\n                    // @ts-ignore\n                    target: provider.configuration.websocketProvider.webSocket,\n                    type: \"close\",\n                };\n                provider.onClose();\n                provider.configuration.onClose({ event });\n                provider.forwardClose(event);\n                break;\n            default:\n                throw new Error(`Cant apply message of unknown type: ${type}`);\n        }\n        // Reply\n        if (message.length() > emptyMessageLength + 1) {\n            // length of documentName (considered in emptyMessageLength plus length of yjs sync type, set in applySyncMessage)\n            // @ts-ignore\n            provider.send(OutgoingMessage, { encoder: message.encoder });\n        }\n    }\n    applySyncMessage(provider, emitSynced) {\n        const { message } = this;\n        message.writeVarUint(MessageType.Sync);\n        // Apply update\n        const syncMessageType = readSyncMessage(message.decoder, message.encoder, provider.document, provider);\n        // Synced once we receive Step2\n        if (emitSynced && syncMessageType === messageYjsSyncStep2) {\n            provider.synced = true;\n        }\n    }\n    applySyncStatusMessage(provider, applied) {\n        if (applied) {\n            provider.decrementUnsyncedChanges();\n        }\n    }\n    applyAwarenessMessage(provider) {\n        if (!provider.awareness)\n            return;\n        const { message } = this;\n        applyAwarenessUpdate(provider.awareness, message.readVarUint8Array(), provider);\n    }\n    applyAuthMessage(provider) {\n        const { message } = this;\n        (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.readAuthMessage)(message.decoder, provider.sendToken.bind(provider), provider.permissionDeniedHandler.bind(provider), provider.authenticatedHandler.bind(provider));\n    }\n    applyQueryAwarenessMessage(provider) {\n        if (!provider.awareness)\n            return;\n        const { message } = this;\n        message.writeVarUint(MessageType.Awareness);\n        message.writeVarUint8Array(encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())));\n    }\n}\n\nclass MessageSender {\n    constructor(Message, args = {}) {\n        this.message = new Message();\n        this.encoder = this.message.get(args);\n    }\n    create() {\n        return toUint8Array(this.encoder);\n    }\n    send(webSocket) {\n        webSocket === null || webSocket === void 0 ? void 0 : webSocket.send(this.create());\n    }\n}\n\nclass AuthenticationMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Auth;\n        this.description = \"Authentication\";\n    }\n    get(args) {\n        if (typeof args.token === \"undefined\") {\n            throw new Error(\"The authentication message requires `token` as an argument.\");\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.writeAuthentication)(this.encoder, args.token);\n        return this.encoder;\n    }\n}\n\nclass AwarenessMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Awareness;\n        this.description = \"Awareness states update\";\n    }\n    get(args) {\n        if (typeof args.awareness === \"undefined\") {\n            throw new Error(\"The awareness message requires awareness as an argument\");\n        }\n        if (typeof args.clients === \"undefined\") {\n            throw new Error(\"The awareness message requires clients as an argument\");\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        let awarenessUpdate;\n        if (args.states === undefined) {\n            awarenessUpdate = encodeAwarenessUpdate(args.awareness, args.clients);\n        }\n        else {\n            awarenessUpdate = encodeAwarenessUpdate(args.awareness, args.clients, args.states);\n        }\n        writeVarUint8Array(this.encoder, awarenessUpdate);\n        return this.encoder;\n    }\n}\n\nclass StatelessMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Stateless;\n        this.description = \"A stateless message\";\n    }\n    get(args) {\n        var _a;\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeVarString(this.encoder, (_a = args.payload) !== null && _a !== void 0 ? _a : \"\");\n        return this.encoder;\n    }\n}\n\nclass SyncStepOneMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Sync;\n        this.description = \"First sync step\";\n    }\n    get(args) {\n        if (typeof args.document === \"undefined\") {\n            throw new Error(\"The sync step one message requires document as an argument\");\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeSyncStep1(this.encoder, args.document);\n        return this.encoder;\n    }\n}\n\nclass UpdateMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Sync;\n        this.description = \"A document update\";\n    }\n    get(args) {\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeUpdate(this.encoder, args.update);\n        return this.encoder;\n    }\n}\n\nclass AwarenessError extends Error {\n    constructor() {\n        super(...arguments);\n        this.code = 1001;\n    }\n}\nclass HocuspocusProvider extends EventEmitter {\n    constructor(configuration) {\n        var _a, _b, _c;\n        super();\n        this.configuration = {\n            name: \"\",\n            // @ts-ignore\n            document: undefined,\n            // @ts-ignore\n            awareness: undefined,\n            token: null,\n            forceSyncInterval: false,\n            onAuthenticated: () => null,\n            onAuthenticationFailed: () => null,\n            onOpen: () => null,\n            onConnect: () => null,\n            onMessage: () => null,\n            onOutgoingMessage: () => null,\n            onSynced: () => null,\n            onStatus: () => null,\n            onDisconnect: () => null,\n            onClose: () => null,\n            onDestroy: () => null,\n            onAwarenessUpdate: () => null,\n            onAwarenessChange: () => null,\n            onStateless: () => null,\n            onUnsyncedChanges: () => null,\n        };\n        this.isSynced = false;\n        this.unsyncedChanges = 0;\n        this.isAuthenticated = false;\n        this.authorizedScope = undefined;\n        // @internal\n        this.manageSocket = false;\n        this._isAttached = false;\n        this.intervals = {\n            forceSync: null,\n        };\n        this.boundDocumentUpdateHandler = this.documentUpdateHandler.bind(this);\n        this.boundAwarenessUpdateHandler = this.awarenessUpdateHandler.bind(this);\n        this.boundPageHide = this.pageHide.bind(this);\n        this.boundOnOpen = this.onOpen.bind(this);\n        this.boundOnClose = this.onClose.bind(this);\n        this.forwardConnect = () => this.emit(\"connect\");\n        this.forwardStatus = (e) => this.emit(\"status\", e);\n        this.forwardClose = (e) => this.emit(\"close\", e);\n        this.forwardDisconnect = (e) => this.emit(\"disconnect\", e);\n        this.forwardDestroy = () => this.emit(\"destroy\");\n        this.setConfiguration(configuration);\n        this.configuration.document = configuration.document\n            ? configuration.document\n            : new yjs__WEBPACK_IMPORTED_MODULE_2__.Doc();\n        this.configuration.awareness =\n            configuration.awareness !== undefined\n                ? configuration.awareness\n                : new Awareness(this.document);\n        this.on(\"open\", this.configuration.onOpen);\n        this.on(\"message\", this.configuration.onMessage);\n        this.on(\"outgoingMessage\", this.configuration.onOutgoingMessage);\n        this.on(\"synced\", this.configuration.onSynced);\n        this.on(\"destroy\", this.configuration.onDestroy);\n        this.on(\"awarenessUpdate\", this.configuration.onAwarenessUpdate);\n        this.on(\"awarenessChange\", this.configuration.onAwarenessChange);\n        this.on(\"stateless\", this.configuration.onStateless);\n        this.on(\"unsyncedChanges\", this.configuration.onUnsyncedChanges);\n        this.on(\"authenticated\", this.configuration.onAuthenticated);\n        this.on(\"authenticationFailed\", this.configuration.onAuthenticationFailed);\n        (_a = this.awareness) === null || _a === void 0 ? void 0 : _a.on(\"update\", () => {\n            this.emit(\"awarenessUpdate\", {\n                states: (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.awarenessStatesToArray)(this.awareness.getStates()),\n            });\n        });\n        (_b = this.awareness) === null || _b === void 0 ? void 0 : _b.on(\"change\", () => {\n            this.emit(\"awarenessChange\", {\n                states: (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.awarenessStatesToArray)(this.awareness.getStates()),\n            });\n        });\n        this.document.on(\"update\", this.boundDocumentUpdateHandler);\n        (_c = this.awareness) === null || _c === void 0 ? void 0 : _c.on(\"update\", this.boundAwarenessUpdateHandler);\n        this.registerEventListeners();\n        if (this.configuration.forceSyncInterval &&\n            typeof this.configuration.forceSyncInterval === \"number\") {\n            this.intervals.forceSync = setInterval(this.forceSync.bind(this), this.configuration.forceSyncInterval);\n        }\n        if (this.manageSocket) {\n            this.attach();\n        }\n    }\n    setConfiguration(configuration = {}) {\n        if (!configuration.websocketProvider) {\n            const websocketProviderConfig = configuration;\n            this.manageSocket = true;\n            this.configuration.websocketProvider = new HocuspocusProviderWebsocket({\n                url: websocketProviderConfig.url,\n            });\n        }\n        this.configuration = { ...this.configuration, ...configuration };\n    }\n    get document() {\n        return this.configuration.document;\n    }\n    get isAttached() {\n        return this._isAttached;\n    }\n    get awareness() {\n        return this.configuration.awareness;\n    }\n    get hasUnsyncedChanges() {\n        return this.unsyncedChanges > 0;\n    }\n    resetUnsyncedChanges() {\n        this.unsyncedChanges = 1;\n        this.emit(\"unsyncedChanges\", { number: this.unsyncedChanges });\n    }\n    incrementUnsyncedChanges() {\n        this.unsyncedChanges += 1;\n        this.emit(\"unsyncedChanges\", { number: this.unsyncedChanges });\n    }\n    decrementUnsyncedChanges() {\n        if (this.unsyncedChanges > 0) {\n            this.unsyncedChanges -= 1;\n        }\n        if (this.unsyncedChanges === 0) {\n            this.synced = true;\n        }\n        this.emit(\"unsyncedChanges\", { number: this.unsyncedChanges });\n    }\n    forceSync() {\n        this.resetUnsyncedChanges();\n        this.send(SyncStepOneMessage, {\n            document: this.document,\n            documentName: this.configuration.name,\n        });\n    }\n    pageHide() {\n        if (this.awareness) {\n            removeAwarenessStates(this.awareness, [this.document.clientID], \"page hide\");\n        }\n    }\n    registerEventListeners() {\n        if (typeof window === \"undefined\" || !(\"addEventListener\" in window)) {\n            return;\n        }\n        window.addEventListener(\"pagehide\", this.boundPageHide);\n    }\n    sendStateless(payload) {\n        this.send(StatelessMessage, {\n            documentName: this.configuration.name,\n            payload,\n        });\n    }\n    async sendToken() {\n        let token;\n        try {\n            token = await this.getToken();\n        }\n        catch (error) {\n            this.permissionDeniedHandler(`Failed to get token during sendToken(): ${error}`);\n            return;\n        }\n        this.send(AuthenticationMessage, {\n            token: token !== null && token !== void 0 ? token : \"\",\n            documentName: this.configuration.name,\n        });\n    }\n    documentUpdateHandler(update, origin) {\n        if (origin === this) {\n            return;\n        }\n        this.incrementUnsyncedChanges();\n        this.send(UpdateMessage, { update, documentName: this.configuration.name });\n    }\n    awarenessUpdateHandler({ added, updated, removed }, origin) {\n        const changedClients = added.concat(updated).concat(removed);\n        this.send(AwarenessMessage, {\n            awareness: this.awareness,\n            clients: changedClients,\n            documentName: this.configuration.name,\n        });\n    }\n    /**\n     * Indicates whether a first handshake with the server has been established\n     *\n     * Note: this does not mean all updates from the client have been persisted to the backend. For this,\n     * use `hasUnsyncedChanges`.\n     */\n    get synced() {\n        return this.isSynced;\n    }\n    set synced(state) {\n        if (this.isSynced === state) {\n            return;\n        }\n        this.isSynced = state;\n        if (state) {\n            this.emit(\"synced\", { state });\n        }\n    }\n    receiveStateless(payload) {\n        this.emit(\"stateless\", { payload });\n    }\n    // not needed, but provides backward compatibility with e.g. lexical/yjs\n    async connect() {\n        if (this.manageSocket) {\n            return this.configuration.websocketProvider.connect();\n        }\n        console.warn(\"HocuspocusProvider::connect() is deprecated and does not do anything. Please connect/disconnect on the websocketProvider, or attach/deattach providers.\");\n    }\n    disconnect() {\n        if (this.manageSocket) {\n            return this.configuration.websocketProvider.disconnect();\n        }\n        console.warn(\"HocuspocusProvider::disconnect() is deprecated and does not do anything. Please connect/disconnect on the websocketProvider, or attach/deattach providers.\");\n    }\n    async onOpen(event) {\n        this.isAuthenticated = false;\n        this.emit(\"open\", { event });\n        await this.sendToken();\n        this.startSync();\n    }\n    async getToken() {\n        if (typeof this.configuration.token === \"function\") {\n            const token = await this.configuration.token();\n            return token;\n        }\n        return this.configuration.token;\n    }\n    startSync() {\n        this.resetUnsyncedChanges();\n        this.send(SyncStepOneMessage, {\n            document: this.document,\n            documentName: this.configuration.name,\n        });\n        if (this.awareness && this.awareness.getLocalState() !== null) {\n            this.send(AwarenessMessage, {\n                awareness: this.awareness,\n                clients: [this.document.clientID],\n                documentName: this.configuration.name,\n            });\n        }\n    }\n    send(message, args) {\n        if (!this._isAttached)\n            return;\n        const messageSender = new MessageSender(message, args);\n        this.emit(\"outgoingMessage\", { message: messageSender.message });\n        messageSender.send(this.configuration.websocketProvider);\n    }\n    onMessage(event) {\n        const message = new IncomingMessage(event.data);\n        const documentName = message.readVarString();\n        message.writeVarString(documentName);\n        this.emit(\"message\", { event, message: new IncomingMessage(event.data) });\n        new MessageReceiver(message).apply(this, true);\n    }\n    onClose() {\n        this.isAuthenticated = false;\n        this.synced = false;\n        // update awareness (all users except local left)\n        if (this.awareness) {\n            removeAwarenessStates(this.awareness, Array.from(this.awareness.getStates().keys()).filter((client) => client !== this.document.clientID), this);\n        }\n    }\n    destroy() {\n        this.emit(\"destroy\");\n        if (this.intervals.forceSync) {\n            clearInterval(this.intervals.forceSync);\n        }\n        if (this.awareness) {\n            removeAwarenessStates(this.awareness, [this.document.clientID], \"provider destroy\");\n            this.awareness.off(\"update\", this.boundAwarenessUpdateHandler);\n            this.awareness.destroy();\n        }\n        this.document.off(\"update\", this.boundDocumentUpdateHandler);\n        this.removeAllListeners();\n        this.detach();\n        if (this.manageSocket) {\n            this.configuration.websocketProvider.destroy();\n        }\n        if (typeof window === \"undefined\" || !(\"removeEventListener\" in window)) {\n            return;\n        }\n        window.removeEventListener(\"pagehide\", this.boundPageHide);\n    }\n    detach() {\n        this.configuration.websocketProvider.off(\"connect\", this.configuration.onConnect);\n        this.configuration.websocketProvider.off(\"connect\", this.forwardConnect);\n        this.configuration.websocketProvider.off(\"status\", this.forwardStatus);\n        this.configuration.websocketProvider.off(\"status\", this.configuration.onStatus);\n        this.configuration.websocketProvider.off(\"open\", this.boundOnOpen);\n        this.configuration.websocketProvider.off(\"close\", this.boundOnClose);\n        this.configuration.websocketProvider.off(\"close\", this.configuration.onClose);\n        this.configuration.websocketProvider.off(\"close\", this.forwardClose);\n        this.configuration.websocketProvider.off(\"disconnect\", this.configuration.onDisconnect);\n        this.configuration.websocketProvider.off(\"disconnect\", this.forwardDisconnect);\n        this.configuration.websocketProvider.off(\"destroy\", this.configuration.onDestroy);\n        this.configuration.websocketProvider.off(\"destroy\", this.forwardDestroy);\n        this.configuration.websocketProvider.detach(this);\n        this._isAttached = false;\n    }\n    attach() {\n        if (this._isAttached)\n            return;\n        this.configuration.websocketProvider.on(\"connect\", this.configuration.onConnect);\n        this.configuration.websocketProvider.on(\"connect\", this.forwardConnect);\n        this.configuration.websocketProvider.on(\"status\", this.configuration.onStatus);\n        this.configuration.websocketProvider.on(\"status\", this.forwardStatus);\n        this.configuration.websocketProvider.on(\"open\", this.boundOnOpen);\n        this.configuration.websocketProvider.on(\"close\", this.boundOnClose);\n        this.configuration.websocketProvider.on(\"close\", this.configuration.onClose);\n        this.configuration.websocketProvider.on(\"close\", this.forwardClose);\n        this.configuration.websocketProvider.on(\"disconnect\", this.configuration.onDisconnect);\n        this.configuration.websocketProvider.on(\"disconnect\", this.forwardDisconnect);\n        this.configuration.websocketProvider.on(\"destroy\", this.configuration.onDestroy);\n        this.configuration.websocketProvider.on(\"destroy\", this.forwardDestroy);\n        this.configuration.websocketProvider.attach(this);\n        this._isAttached = true;\n    }\n    permissionDeniedHandler(reason) {\n        this.emit(\"authenticationFailed\", { reason });\n        this.isAuthenticated = false;\n    }\n    authenticatedHandler(scope) {\n        this.isAuthenticated = true;\n        this.authorizedScope = scope;\n        this.emit(\"authenticated\", { scope });\n    }\n    setAwarenessField(key, value) {\n        if (!this.awareness) {\n            throw new AwarenessError(`Cannot set awareness field \"${key}\" to ${JSON.stringify(value)}. You have disabled Awareness for this provider by explicitly passing awareness: null in the provider configuration.`);\n        }\n        this.awareness.setLocalStateField(key, value);\n    }\n}\n\n\n//# sourceMappingURL=hocuspocus-provider.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AaG9jdXNwb2N1cy9wcm92aWRlci9kaXN0L2hvY3VzcG9jdXMtcHJvdmlkZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWlIO0FBQ3hGO0FBQ2lCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0Isd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGFBQWE7O0FBRWhEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2RkFBNkYsOEJBQThCOztBQUUzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUVBQW1CO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9DQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEVBQXNCO0FBQzlDLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QiwwRUFBc0I7QUFDOUMsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhCQUE4QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsOEJBQThCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsOEJBQThCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixNQUFNO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtDQUErQztBQUNsRjtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdDQUFnQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaURBQWlEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsSUFBSSxPQUFPLHNCQUFzQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTs7QUFFeUc7QUFDekciLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnlhbmdveWFsL3JlYWwtdGltZS10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQGhvY3VzcG9jdXMvcHJvdmlkZXIvZGlzdC9ob2N1c3BvY3VzLXByb3ZpZGVyLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXc1JlYWR5U3RhdGVzLCByZWFkQXV0aE1lc3NhZ2UsIHdyaXRlQXV0aGVudGljYXRpb24sIGF3YXJlbmVzc1N0YXRlc1RvQXJyYXkgfSBmcm9tICdAaG9jdXNwb2N1cy9jb21tb24nO1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnO1xuaW1wb3J0IHsgcmV0cnkgfSBmcm9tICdAbGlmZW9taWMvYXR0ZW1wdCc7XG5cbi8qKlxuICogQ29tbW9uIE1hdGggZXhwcmVzc2lvbnMuXG4gKlxuICogQG1vZHVsZSBtYXRoXG4gKi9cblxuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzbWFsbGVyIGVsZW1lbnQgb2YgYSBhbmQgYlxuICovXG5jb25zdCBtaW4gPSAoYSwgYikgPT4gYSA8IGIgPyBhIDogYjtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYmlnZ2VyIGVsZW1lbnQgb2YgYSBhbmQgYlxuICovXG5jb25zdCBtYXggPSAoYSwgYikgPT4gYSA+IGIgPyBhIDogYjtcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbmNvbnN0IEJJVDcgPSA2NDtcbmNvbnN0IEJJVDggPSAxMjg7XG5jb25zdCBCSVRTNiA9IDYzO1xuY29uc3QgQklUUzcgPSAxMjc7XG5cbi8qKlxuICogVXRpbGl0eSBoZWxwZXJzIGZvciB3b3JraW5nIHdpdGggbnVtYmVycy5cbiAqXG4gKiBAbW9kdWxlIG51bWJlclxuICovXG5cblxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBzZXRzLlxuICpcbiAqIEBtb2R1bGUgc2V0XG4gKi9cblxuY29uc3QgY3JlYXRlJDIgPSAoKSA9PiBuZXcgU2V0KCk7XG5cbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIEFycmF5cy5cbiAqXG4gKiBAbW9kdWxlIGFycmF5XG4gKi9cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgc29tZXRoaW5nIGFycmF5LWxpa2UgdG8gYW4gYWN0dWFsIEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXJyYXlMaWtlPFQ+fEl0ZXJhYmxlPFQ+fSBhcnJheWxpa2VcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmNvbnN0IGZyb20gPSBBcnJheS5mcm9tO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IF9lbmNvZGVVdGY4UG9seWZpbGwgPSBzdHIgPT4ge1xuICBjb25zdCBlbmNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xuICBjb25zdCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aDtcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufTtcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IHV0ZjhUZXh0RW5jb2RlciA9IC8qKiBAdHlwZSB7VGV4dEVuY29kZXJ9ICovICh0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHRFbmNvZGVyKCkgOiBudWxsKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBfZW5jb2RlVXRmOE5hdGl2ZSA9IHN0ciA9PiB1dGY4VGV4dEVuY29kZXIuZW5jb2RlKHN0cik7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IGVuY29kZVV0ZjggPSB1dGY4VGV4dEVuY29kZXIgPyBfZW5jb2RlVXRmOE5hdGl2ZSA6IF9lbmNvZGVVdGY4UG9seWZpbGw7XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5sZXQgdXRmOFRleHREZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBmYXRhbDogdHJ1ZSwgaWdub3JlQk9NOiB0cnVlIH0pO1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmlmICh1dGY4VGV4dERlY29kZXIgJiYgdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEpIHtcbiAgLy8gU2FmYXJpIGRvZXNuJ3QgaGFuZGxlIEJPTSBjb3JyZWN0bHkuXG4gIC8vIFRoaXMgZml4ZXMgYSBidWcgaW4gU2FmYXJpIDEzLjAuNSB3aGVyZSBpdCBwcm9kdWNlcyBhIEJPTSB0aGUgZmlyc3QgdGltZSBpdCBpcyBjYWxsZWQuXG4gIC8vIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxIG9uIHRoZSBmaXJzdCBjYWxsIGFuZFxuICAvLyB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSBvbiB0aGUgc2Vjb25kIGNhbGxcbiAgLy8gQW5vdGhlciBpc3N1ZSBpcyB0aGF0IGZyb20gdGhlbiBvbiBubyBCT00gY2hhcnMgYXJlIHJlY29nbml6ZWQgYW55bW9yZVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB1dGY4VGV4dERlY29kZXIgPSBudWxsO1xufVxuXG4vKipcbiAqIEVmZmljaWVudCBzY2hlbWEtbGVzcyBiaW5hcnkgZW5jb2Rpbmcgd2l0aCBzdXBwb3J0IGZvciB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogVXNlIFtsaWIwL2VuY29kaW5nXSB3aXRoIFtsaWIwL2RlY29kaW5nXS4gRXZlcnkgZW5jb2RpbmcgZnVuY3Rpb24gaGFzIGEgY29ycmVzcG9uZGluZyBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBFbmNvZGVzIG51bWJlcnMgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciAobGVhc3QgdG8gbW9zdCBzaWduaWZpY2FudCBieXRlIG9yZGVyKVxuICogYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBHb2xhbmcncyBiaW5hcnkgZW5jb2RpbmcgKGh0dHBzOi8vZ29sYW5nLm9yZy9wa2cvZW5jb2RpbmcvYmluYXJ5LylcbiAqIHdoaWNoIGlzIGFsc28gdXNlZCBpbiBQcm90b2NvbCBCdWZmZXJzLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBlbmNvZGluZyBzdGVwXG4gKiBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gKiBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMjU2KVxuICogZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgJ0hlbGxvIHdvcmxkIScpXG4gKiBjb25zdCBidWYgPSBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWNvZGluZyBzdGVwXG4gKiBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpXG4gKiBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKSAvLyA9PiAyNTZcbiAqIGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikgLy8gPT4gJ0hlbGxvIHdvcmxkISdcbiAqIGRlY29kaW5nLmhhc0NvbnRlbnQoZGVjb2RlcikgLy8gPT4gZmFsc2UgLSBhbGwgZGF0YSBpcyByZWFkXG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIGVuY29kaW5nXG4gKi9cblxuXG4vKipcbiAqIEEgQmluYXJ5RW5jb2RlciBoYW5kbGVzIHRoZSBlbmNvZGluZyB0byBhbiBVaW50OEFycmF5LlxuICovXG5jbGFzcyBFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuY3BvcyA9IDA7XG4gICAgdGhpcy5jYnVmID0gbmV3IFVpbnQ4QXJyYXkoMTAwKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VWludDhBcnJheT59XG4gICAgICovXG4gICAgdGhpcy5idWZzID0gW107XG4gIH1cbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge0VuY29kZXJ9XG4gKi9cbmNvbnN0IGNyZWF0ZUVuY29kZXIgPSAoKSA9PiBuZXcgRW5jb2RlcigpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgZW5jb2RlZCBkYXRhLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmNvbnN0IGxlbmd0aCQxID0gZW5jb2RlciA9PiB7XG4gIGxldCBsZW4gPSBlbmNvZGVyLmNwb3M7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGVuICs9IGVuY29kZXIuYnVmc1tpXS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGxlblxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdG8gVWludDhBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHJldHVybiB7VWludDhBcnJheX0gVGhlIGNyZWF0ZWQgQXJyYXlCdWZmZXIuXG4gKi9cbmNvbnN0IHRvVWludDhBcnJheSA9IGVuY29kZXIgPT4ge1xuICBjb25zdCB1aW50OGFyciA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCQxKGVuY29kZXIpKTtcbiAgbGV0IGN1clBvcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZCA9IGVuY29kZXIuYnVmc1tpXTtcbiAgICB1aW50OGFyci5zZXQoZCwgY3VyUG9zKTtcbiAgICBjdXJQb3MgKz0gZC5sZW5ndGg7XG4gIH1cbiAgdWludDhhcnIuc2V0KG5ldyBVaW50OEFycmF5KGVuY29kZXIuY2J1Zi5idWZmZXIsIDAsIGVuY29kZXIuY3BvcyksIGN1clBvcyk7XG4gIHJldHVybiB1aW50OGFyclxufTtcblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSB0byB0aGUgZW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgYnl0ZSB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IHdyaXRlID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBjb25zdCBidWZmZXJMZW4gPSBlbmNvZGVyLmNidWYubGVuZ3RoO1xuICBpZiAoZW5jb2Rlci5jcG9zID09PSBidWZmZXJMZW4pIHtcbiAgICBlbmNvZGVyLmJ1ZnMucHVzaChlbmNvZGVyLmNidWYpO1xuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbiAqIDIpO1xuICAgIGVuY29kZXIuY3BvcyA9IDA7XG4gIH1cbiAgZW5jb2Rlci5jYnVmW2VuY29kZXIuY3BvcysrXSA9IG51bTtcbn07XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggdW5zaWduZWQgaW50ZWdlci4gTWF4IGVuY29kYWJsZSBpbnRlZ2VyIGlzIDJeNTMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IHdyaXRlVmFyVWludCA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgd2hpbGUgKG51bSA+IEJJVFM3KSB7XG4gICAgd3JpdGUoZW5jb2RlciwgQklUOCB8IChCSVRTNyAmIG51bSkpO1xuICAgIG51bSA9IGZsb29yKG51bSAvIDEyOCk7IC8vIHNoaWZ0ID4+PiA3XG4gIH1cbiAgd3JpdGUoZW5jb2RlciwgQklUUzcgJiBudW0pO1xufTtcblxuLyoqXG4gKiBBIGNhY2hlIHRvIHN0b3JlIHN0cmluZ3MgdGVtcG9yYXJpbHlcbiAqL1xuY29uc3QgX3N0ckJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDMwMDAwKTtcbmNvbnN0IF9tYXhTdHJCU2l6ZSA9IF9zdHJCdWZmZXIubGVuZ3RoIC8gMztcblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCBzdHJpbmcuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IF93cml0ZVZhclN0cmluZ05hdGl2ZSA9IChlbmNvZGVyLCBzdHIpID0+IHtcbiAgaWYgKHN0ci5sZW5ndGggPCBfbWF4U3RyQlNpemUpIHtcbiAgICAvLyBXZSBjYW4gZW5jb2RlIHRoZSBzdHJpbmcgaW50byB0aGUgZXhpc3RpbmcgYnVmZmVyXG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICBjb25zdCB3cml0dGVuID0gdXRmOFRleHRFbmNvZGVyLmVuY29kZUludG8oc3RyLCBfc3RyQnVmZmVyKS53cml0dGVuIHx8IDA7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIHdyaXR0ZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JpdHRlbjsgaSsrKSB7XG4gICAgICB3cml0ZShlbmNvZGVyLCBfc3RyQnVmZmVyW2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGVuY29kZVV0Zjgoc3RyKSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCBfd3JpdGVWYXJTdHJpbmdQb2x5ZmlsbCA9IChlbmNvZGVyLCBzdHIpID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbiAgY29uc3QgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGg7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbmNvZGVkU3RyaW5nLmNvZGVQb2ludEF0KGkpKSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3Qgd3JpdGVWYXJTdHJpbmcgPSAodXRmOFRleHRFbmNvZGVyICYmIC8qKiBAdHlwZSB7YW55fSAqLyAodXRmOFRleHRFbmNvZGVyKS5lbmNvZGVJbnRvKSA/IF93cml0ZVZhclN0cmluZ05hdGl2ZSA6IF93cml0ZVZhclN0cmluZ1BvbHlmaWxsO1xuXG4vKipcbiAqIEFwcGVuZCBmaXhlZC1sZW5ndGggVWludDhBcnJheSB0byB0aGUgZW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKi9cbmNvbnN0IHdyaXRlVWludDhBcnJheSA9IChlbmNvZGVyLCB1aW50OEFycmF5KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGg7XG4gIGNvbnN0IGNwb3MgPSBlbmNvZGVyLmNwb3M7XG4gIGNvbnN0IGxlZnRDb3B5TGVuID0gbWluKGJ1ZmZlckxlbiAtIGNwb3MsIHVpbnQ4QXJyYXkubGVuZ3RoKTtcbiAgY29uc3QgcmlnaHRDb3B5TGVuID0gdWludDhBcnJheS5sZW5ndGggLSBsZWZ0Q29weUxlbjtcbiAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KDAsIGxlZnRDb3B5TGVuKSwgY3Bvcyk7XG4gIGVuY29kZXIuY3BvcyArPSBsZWZ0Q29weUxlbjtcbiAgaWYgKHJpZ2h0Q29weUxlbiA+IDApIHtcbiAgICAvLyBTdGlsbCBzb21ldGhpbmcgdG8gd3JpdGUsIHdyaXRlIHJpZ2h0IGhhbGYuLlxuICAgIC8vIEFwcGVuZCBuZXcgYnVmZmVyXG4gICAgZW5jb2Rlci5idWZzLnB1c2goZW5jb2Rlci5jYnVmKTtcbiAgICAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgc2l6ZSBvZiByZW1haW5pbmcgYnVmZmVyXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkobWF4KGJ1ZmZlckxlbiAqIDIsIHJpZ2h0Q29weUxlbikpO1xuICAgIC8vIGNvcHkgYXJyYXlcbiAgICBlbmNvZGVyLmNidWYuc2V0KHVpbnQ4QXJyYXkuc3ViYXJyYXkobGVmdENvcHlMZW4pKTtcbiAgICBlbmNvZGVyLmNwb3MgPSByaWdodENvcHlMZW47XG4gIH1cbn07XG5cbi8qKlxuICogQXBwZW5kIGFuIFVpbnQ4QXJyYXkgdG8gRW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKi9cbmNvbnN0IHdyaXRlVmFyVWludDhBcnJheSA9IChlbmNvZGVyLCB1aW50OEFycmF5KSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCB1aW50OEFycmF5LmJ5dGVMZW5ndGgpO1xuICB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdWludDhBcnJheSk7XG59O1xuXG4vKipcbiAqIEVycm9yIGhlbHBlcnMuXG4gKlxuICogQG1vZHVsZSBlcnJvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge0Vycm9yfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgY3JlYXRlJDEgPSBzID0+IG5ldyBFcnJvcihzKTtcblxuLyoqXG4gKiBFZmZpY2llbnQgc2NoZW1hLWxlc3MgYmluYXJ5IGRlY29kaW5nIHdpdGggc3VwcG9ydCBmb3IgdmFyaWFibGUgbGVuZ3RoIGVuY29kaW5nLlxuICpcbiAqIFVzZSBbbGliMC9kZWNvZGluZ10gd2l0aCBbbGliMC9lbmNvZGluZ10uIEV2ZXJ5IGVuY29kaW5nIGZ1bmN0aW9uIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjb2RpbmcgZnVuY3Rpb24uXG4gKlxuICogRW5jb2RlcyBudW1iZXJzIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgKGxlYXN0IHRvIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBvcmRlcilcbiAqIGFuZCBpcyBjb21wYXRpYmxlIHdpdGggR29sYW5nJ3MgYmluYXJ5IGVuY29kaW5nIChodHRwczovL2dvbGFuZy5vcmcvcGtnL2VuY29kaW5nL2JpbmFyeS8pXG4gKiB3aGljaCBpcyBhbHNvIHVzZWQgaW4gUHJvdG9jb2wgQnVmZmVycy5cbiAqXG4gKiBgYGBqc1xuICogLy8gZW5jb2Rpbmcgc3RlcFxuICogY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICogZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDI1NilcbiAqIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsICdIZWxsbyB3b3JsZCEnKVxuICogY29uc3QgYnVmID0gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVjb2Rpbmcgc3RlcFxuICogY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICogZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gPT4gMjU2XG4gKiBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpIC8vID0+ICdIZWxsbyB3b3JsZCEnXG4gKiBkZWNvZGluZy5oYXNDb250ZW50KGRlY29kZXIpIC8vID0+IGZhbHNlIC0gYWxsIGRhdGEgaXMgcmVhZFxuICogYGBgXG4gKlxuICogQG1vZHVsZSBkZWNvZGluZ1xuICovXG5cblxuY29uc3QgZXJyb3JVbmV4cGVjdGVkRW5kT2ZBcnJheSA9IGNyZWF0ZSQxKCdVbmV4cGVjdGVkIGVuZCBvZiBhcnJheScpO1xuY29uc3QgZXJyb3JJbnRlZ2VyT3V0T2ZSYW5nZSA9IGNyZWF0ZSQxKCdJbnRlZ2VyIG91dCBvZiBSYW5nZScpO1xuXG4vKipcbiAqIEEgRGVjb2RlciBoYW5kbGVzIHRoZSBkZWNvZGluZyBvZiBhbiBVaW50OEFycmF5LlxuICovXG5jbGFzcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheSBCaW5hcnkgZGF0YSB0byBkZWNvZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgLyoqXG4gICAgICogRGVjb2RpbmcgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5hcnIgPSB1aW50OEFycmF5O1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZGVjb2RpbmcgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMDtcbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKiBAcmV0dXJuIHtEZWNvZGVyfVxuICovXG5jb25zdCBjcmVhdGVEZWNvZGVyID0gdWludDhBcnJheSA9PiBuZXcgRGVjb2Rlcih1aW50OEFycmF5KTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gVWludDhBcnJheSB2aWV3IG9mIHRoZSBuZXh0IGBsZW5gIGJ5dGVzIGFuZCBhZHZhbmNlIHRoZSBwb3NpdGlvbiBieSBgbGVuYC5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVGhlIGxlbmd0aCBvZiBieXRlcyB0byByZWFkXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCByZWFkVWludDhBcnJheSA9IChkZWNvZGVyLCBsZW4pID0+IHtcbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGRlY29kZXIuYXJyLmJ1ZmZlciwgZGVjb2Rlci5wb3MgKyBkZWNvZGVyLmFyci5ieXRlT2Zmc2V0LCBsZW4pO1xuICBkZWNvZGVyLnBvcyArPSBsZW47XG4gIHJldHVybiB2aWV3XG59O1xuXG4vKipcbiAqIFJlYWQgdmFyaWFibGUgbGVuZ3RoIFVpbnQ4QXJyYXkuXG4gKlxuICogSW1wb3J0YW50OiBUaGUgVWludDhBcnJheSBzdGlsbCBwb2ludHMgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIE1ha2Ugc3VyZSB0byBkaXNjYXJkIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBwcmV2ZW50IGFueSBtZW1vcnkgbGVha3MuXG4gKiAgICAgICAgICAgIFVzZSBgYnVmZmVyLmNvcHlVaW50OEFycmF5YCB0byBjb3B5IHRoZSByZXN1bHQgaW50byBhIG5ldyBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCByZWFkVmFyVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgcmVhZFZhclVpbnQoZGVjb2RlcikpO1xuXG4vKipcbiAqIFJlYWQgb25lIGJ5dGUgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAqL1xuY29uc3QgcmVhZFVpbnQ4ID0gZGVjb2RlciA9PiBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcblxuLyoqXG4gKiBSZWFkIHVuc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0bGVuZ3RoXG4gKiAgKiBudW1iZXJzIDwgMl4xNCBpcyBzdG9yZWQgaW4gdHdvIGJ5bGVuZ3RoXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5sZW5ndGhcbiAqL1xuY29uc3QgcmVhZFZhclVpbnQgPSBkZWNvZGVyID0+IHtcbiAgbGV0IG51bSA9IDA7XG4gIGxldCBtdWx0ID0gMTtcbiAgY29uc3QgbGVuID0gZGVjb2Rlci5hcnIubGVuZ3RoO1xuICB3aGlsZSAoZGVjb2Rlci5wb3MgPCBsZW4pIHtcbiAgICBjb25zdCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK107XG4gICAgLy8gbnVtID0gbnVtIHwgKChyICYgYmluYXJ5LkJJVFM3KSA8PCBsZW4pXG4gICAgbnVtID0gbnVtICsgKHIgJiBCSVRTNykgKiBtdWx0OyAvLyBzaGlmdCAkciA8PCAoNyojaXRlcmF0aW9ucykgYW5kIGFkZCBpdCB0byBudW1cbiAgICBtdWx0ICo9IDEyODsgLy8gbmV4dCBpdGVyYXRpb24sIHNoaWZ0IDcgXCJtb3JlXCIgdG8gdGhlIGxlZnRcbiAgICBpZiAociA8IEJJVDgpIHtcbiAgICAgIHJldHVybiBudW1cbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKG51bSA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IGVycm9ySW50ZWdlck91dE9mUmFuZ2VcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgfVxuICB0aHJvdyBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5XG59O1xuXG4vKipcbiAqIFJlYWQgc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0bGVuZ3RoXG4gKiAgKiBudW1iZXJzIDwgMl4xNCBpcyBzdG9yZWQgaW4gdHdvIGJ5bGVuZ3RoXG4gKiBAdG9kbyBUaGlzIHNob3VsZCBwcm9iYWJseSBjcmVhdGUgdGhlIGludmVyc2Ugfm51bSBpZiBudW1iZXIgaXMgbmVnYXRpdmUgLSBidXQgdGhpcyB3b3VsZCBiZSBhIGJyZWFraW5nIGNoYW5nZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLmxlbmd0aFxuICovXG5jb25zdCByZWFkVmFySW50ID0gZGVjb2RlciA9PiB7XG4gIGxldCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK107XG4gIGxldCBudW0gPSByICYgQklUUzY7XG4gIGxldCBtdWx0ID0gNjQ7XG4gIGNvbnN0IHNpZ24gPSAociAmIEJJVDcpID4gMCA/IC0xIDogMTtcbiAgaWYgKChyICYgQklUOCkgPT09IDApIHtcbiAgICAvLyBkb24ndCBjb250aW51ZSByZWFkaW5nXG4gICAgcmV0dXJuIHNpZ24gKiBudW1cbiAgfVxuICBjb25zdCBsZW4gPSBkZWNvZGVyLmFyci5sZW5ndGg7XG4gIHdoaWxlIChkZWNvZGVyLnBvcyA8IGxlbikge1xuICAgIHIgPSBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcbiAgICAvLyBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbilcbiAgICBudW0gPSBudW0gKyAociAmIEJJVFM3KSAqIG11bHQ7XG4gICAgbXVsdCAqPSAxMjg7XG4gICAgaWYgKHIgPCBCSVQ4KSB7XG4gICAgICByZXR1cm4gc2lnbiAqIG51bVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAobnVtID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgdGhyb3cgZXJyb3JJbnRlZ2VyT3V0T2ZSYW5nZVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICB9XG4gIHRocm93IGVycm9yVW5leHBlY3RlZEVuZE9mQXJyYXlcbn07XG5cbi8qKlxuICogV2UgZG9uJ3QgdGVzdCB0aGlzIGZ1bmN0aW9uIGFueW1vcmUgYXMgd2UgdXNlIG5hdGl2ZSBkZWNvZGluZy9lbmNvZGluZyBieSBkZWZhdWx0IG5vdy5cbiAqIEJldHRlciBub3QgbW9kaWZ5IHRoaXMgYW55bW9yZS4uXG4gKlxuICogVHJhbnNmb3JtaW5nIHV0ZjggdG8gYSBzdHJpbmcgaXMgcHJldHR5IGV4cGVuc2l2ZS4gVGhlIGNvZGUgcGVyZm9ybXMgMTB4IGJldHRlclxuICogd2hlbiBTdHJpbmcuZnJvbUNvZGVQb2ludCBpcyBmZWQgd2l0aCBhbGwgY2hhcmFjdGVycyBhcyBhcmd1bWVudHMuXG4gKiBCdXQgbW9zdCBlbnZpcm9ubWVudHMgaGF2ZSBhIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyBwZXIgZnVuY3Rpb25zLlxuICogRm9yIGVmZmllbmN5IHJlYXNvbnMgd2UgYXBwbHkgYSBtYXhpbXVtIG9mIDEwMDAwIGNoYXJhY3RlcnMgYXQgb25jZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVhZCBTdHJpbmcuXG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgX3JlYWRWYXJTdHJpbmdQb2x5ZmlsbCA9IGRlY29kZXIgPT4ge1xuICBsZXQgcmVtYWluaW5nTGVuID0gcmVhZFZhclVpbnQoZGVjb2Rlcik7XG4gIGlmIChyZW1haW5pbmdMZW4gPT09IDApIHtcbiAgICByZXR1cm4gJydcbiAgfSBlbHNlIHtcbiAgICBsZXQgZW5jb2RlZFN0cmluZyA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHJlYWRVaW50OChkZWNvZGVyKSk7IC8vIHJlbWVtYmVyIHRvIGRlY3JlYXNlIHJlbWFpbmluZ0xlblxuICAgIGlmICgtLXJlbWFpbmluZ0xlbiA8IDEwMCkgeyAvLyBkbyBub3QgY3JlYXRlIGEgVWludDhBcnJheSBmb3Igc21hbGwgc3RyaW5nc1xuICAgICAgd2hpbGUgKHJlbWFpbmluZ0xlbi0tKSB7XG4gICAgICAgIGVuY29kZWRTdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQocmVhZFVpbnQ4KGRlY29kZXIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHJlbWFpbmluZ0xlbiA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dExlbiA9IHJlbWFpbmluZ0xlbiA8IDEwMDAwID8gcmVtYWluaW5nTGVuIDogMTAwMDA7XG4gICAgICAgIC8vIHRoaXMgaXMgZGFuZ2Vyb3VzLCB3ZSBjcmVhdGUgYSBmcmVzaCBhcnJheSB2aWV3IGZyb20gdGhlIGV4aXN0aW5nIGJ1ZmZlclxuICAgICAgICBjb25zdCBieXRlcyA9IGRlY29kZXIuYXJyLnN1YmFycmF5KGRlY29kZXIucG9zLCBkZWNvZGVyLnBvcyArIG5leHRMZW4pO1xuICAgICAgICBkZWNvZGVyLnBvcyArPSBuZXh0TGVuO1xuICAgICAgICAvLyBTdGFydGluZyB3aXRoIEVTNS4xIHdlIGNhbiBzdXBwbHkgYSBnZW5lcmljIGFycmF5LWxpa2Ugb2JqZWN0IGFzIGFyZ3VtZW50c1xuICAgICAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIC8qKiBAdHlwZSB7YW55fSAqLyAoYnl0ZXMpKTtcbiAgICAgICAgcmVtYWluaW5nTGVuIC09IG5leHRMZW47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGVuY29kZWRTdHJpbmcpKVxuICB9XG59O1xuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVhZCBTdHJpbmdcbiAqL1xuY29uc3QgX3JlYWRWYXJTdHJpbmdOYXRpdmUgPSBkZWNvZGVyID0+XG4gIC8qKiBAdHlwZSBhbnkgKi8gKHV0ZjhUZXh0RGVjb2RlcikuZGVjb2RlKHJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcblxuLyoqXG4gKiBSZWFkIHN0cmluZyBvZiB2YXJpYWJsZSBsZW5ndGhcbiAqICogdmFyVWludCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZ1xuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZWFkIFN0cmluZ1xuICpcbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IHJlYWRWYXJTdHJpbmcgPSB1dGY4VGV4dERlY29kZXIgPyBfcmVhZFZhclN0cmluZ05hdGl2ZSA6IF9yZWFkVmFyU3RyaW5nUG9seWZpbGw7XG5cbi8qKlxuICogTG9vayBhaGVhZCBhbmQgcmVhZCB2YXJTdHJpbmcgd2l0aG91dCBpbmNyZW1lbnRpbmcgcG9zaXRpb25cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCBwZWVrVmFyU3RyaW5nID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHBvcyA9IGRlY29kZXIucG9zO1xuICBjb25zdCBzID0gcmVhZFZhclN0cmluZyhkZWNvZGVyKTtcbiAgZGVjb2Rlci5wb3MgPSBwb3M7XG4gIHJldHVybiBzXG59O1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCB0aW1lLlxuICpcbiAqIEBtb2R1bGUgdGltZVxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gY3VycmVudCB1bml4IHRpbWUuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBnZXRVbml4VGltZSA9IERhdGUubm93O1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBrZXktdmFsdWUgc3RvcmVzLlxuICpcbiAqIEBtb2R1bGUgbWFwXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IE1hcCBpbnN0YW5jZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge01hcDxhbnksIGFueT59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZSA9ICgpID0+IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBHZXQgbWFwIHByb3BlcnR5LiBDcmVhdGUgVCBpZiBwcm9wZXJ0eSBpcyB1bmRlZmluZWQgYW5kIHNldCBUIG9uIG1hcC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbGlzdGVuZXJzID0gbWFwLnNldElmVW5kZWZpbmVkKGV2ZW50cywgJ2V2ZW50TmFtZScsIHNldC5jcmVhdGUpXG4gKiBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKVxuICogYGBgXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUge01hcDxhbnksIGFueT59IE1BUFxuICogQHRlbXBsYXRlIHtNQVAgZXh0ZW5kcyBNYXA8YW55LGluZmVyIFY+ID8gZnVuY3Rpb24oKTpWIDogdW5rbm93bn0gQ0ZcbiAqIEBwYXJhbSB7TUFQfSBtYXBcbiAqIEBwYXJhbSB7TUFQIGV4dGVuZHMgTWFwPGluZmVyIEssYW55PiA/IEsgOiB1bmtub3dufSBrZXlcbiAqIEBwYXJhbSB7Q0Z9IGNyZWF0ZVRcbiAqIEByZXR1cm4ge1JldHVyblR5cGU8Q0Y+fVxuICovXG5jb25zdCBzZXRJZlVuZGVmaW5lZCA9IChtYXAsIGtleSwgY3JlYXRlVCkgPT4ge1xuICBsZXQgc2V0ID0gbWFwLmdldChrZXkpO1xuICBpZiAoc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXAuc2V0KGtleSwgc2V0ID0gY3JlYXRlVCgpKTtcbiAgfVxuICByZXR1cm4gc2V0XG59O1xuXG4vKipcbiAqIE9ic2VydmFibGUgY2xhc3MgcHJvdG90eXBlLlxuICpcbiAqIEBtb2R1bGUgb2JzZXJ2YWJsZVxuICovXG5cblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG4vKipcbiAqIEhhbmRsZXMgbmFtZWQgZXZlbnRzLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKiBAdGVtcGxhdGUgTlxuICovXG5jbGFzcyBPYnNlcnZhYmxlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIFNvbWUgZGVzYy5cbiAgICAgKiBAdHlwZSB7TWFwPE4sIGFueT59XG4gICAgICovXG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gY3JlYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9uIChuYW1lLCBmKSB7XG4gICAgc2V0SWZVbmRlZmluZWQodGhpcy5fb2JzZXJ2ZXJzLCBuYW1lLCBjcmVhdGUkMikuYWRkKGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvbmNlIChuYW1lLCBmKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG4gICAgICovXG4gICAgY29uc3QgX2YgPSAoLi4uYXJncykgPT4ge1xuICAgICAgdGhpcy5vZmYobmFtZSwgX2YpO1xuICAgICAgZiguLi5hcmdzKTtcbiAgICB9O1xuICAgIHRoaXMub24obmFtZSwgX2YpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvZmYgKG5hbWUsIGYpIHtcbiAgICBjb25zdCBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpO1xuICAgIGlmIChvYnNlcnZlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShmKTtcbiAgICAgIGlmIChvYnNlcnZlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgbmFtZWQgZXZlbnQuIEFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycyB0aGF0IGxpc3RlbiB0byB0aGVcbiAgICogc3BlY2lmaWVkIG5hbWUgd2lsbCByZWNlaXZlIHRoZSBldmVudC5cbiAgICpcbiAgICogQHRvZG8gVGhpcyBzaG91bGQgY2F0Y2ggZXhjZXB0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge059IG5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncyBUaGUgYXJndW1lbnRzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgZW1pdCAobmFtZSwgYXJncykge1xuICAgIC8vIGNvcHkgYWxsIGxpc3RlbmVycyB0byBhbiBhcnJheSBmaXJzdCB0byBtYWtlIHN1cmUgdGhhdCBubyBldmVudCBpcyBlbWl0dGVkIHRvIGxpc3RlbmVycyB0aGF0IGFyZSBzdWJzY3JpYmVkIHdoaWxlIHRoZSBldmVudCBoYW5kbGVyIGlzIGNhbGxlZC5cbiAgICByZXR1cm4gZnJvbSgodGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKSB8fCBjcmVhdGUoKSkudmFsdWVzKCkpLmZvckVhY2goZiA9PiBmKC4uLmFyZ3MpKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gY3JlYXRlKCk7XG4gIH1cbn1cbi8qIGM4IGlnbm9yZSBlbmQgKi9cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIEVjbWFTY3JpcHQgb2JqZWN0cy5cbiAqXG4gKiBAbW9kdWxlIG9iamVjdFxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKi9cbmNvbnN0IGtleXMgPSBPYmplY3Qua2V5cztcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2Ugb2JqZWN0LnNpemUgaW5zdGVhZFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBsZW5ndGggPSBvYmogPT4ga2V5cyhvYmopLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxscyBgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHthbnl9IG9ialxuICogQHBhcmFtIHtzdHJpbmd8c3ltYm9sfSBrZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGhhc1Byb3BlcnR5ID0gKG9iaiwga2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuXG4vKipcbiAqIENvbW1vbiBmdW5jdGlvbnMgYW5kIGZ1bmN0aW9uIGNhbGwgaGVscGVycy5cbiAqXG4gKiBAbW9kdWxlIGZ1bmN0aW9uXG4gKi9cblxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHBhcmFtIHtUfSBhXG4gKiBAcGFyYW0ge1R9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVxdWFsaXR5U3RyaWN0ID0gKGEsIGIpID0+IGEgPT09IGI7XG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXF1YWxpdHlEZWVwID0gKGEsIGIpID0+IHtcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICByZXR1cm4gZXF1YWxpdHlTdHJpY3QoYSwgYilcbiAgfVxuICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBzd2l0Y2ggKGEuY29uc3RydWN0b3IpIHtcbiAgICBjYXNlIEFycmF5QnVmZmVyOlxuICAgICAgYSA9IG5ldyBVaW50OEFycmF5KGEpO1xuICAgICAgYiA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIGNhc2UgVWludDhBcnJheToge1xuICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgU2V0OiB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGEpIHtcbiAgICAgICAgaWYgKCFiLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBNYXA6IHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGEua2V5cygpKSB7XG4gICAgICAgIGlmICghYi5oYXMoa2V5KSB8fCAhZXF1YWxpdHlEZWVwKGEuZ2V0KGtleSksIGIuZ2V0KGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgT2JqZWN0OlxuICAgICAgaWYgKGxlbmd0aChhKSAhPT0gbGVuZ3RoKGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoIWhhc1Byb3BlcnR5KGEsIGtleSkgfHwgIWVxdWFsaXR5RGVlcChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlIEFycmF5OlxuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWVxdWFsaXR5RGVlcChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLyoqXG4gKiBAbW9kdWxlIGF3YXJlbmVzcy1wcm90b2NvbFxuICovXG5cblxuY29uc3Qgb3V0ZGF0ZWRUaW1lb3V0ID0gMzAwMDA7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YUNsaWVudFN0YXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gTWV0YUNsaWVudFN0YXRlLmNsb2NrXG4gKiBAcHJvcGVydHkge251bWJlcn0gTWV0YUNsaWVudFN0YXRlLmxhc3RVcGRhdGVkIHVuaXggdGltZXN0YW1wXG4gKi9cblxuLyoqXG4gKiBUaGUgQXdhcmVuZXNzIGNsYXNzIGltcGxlbWVudHMgYSBzaW1wbGUgc2hhcmVkIHN0YXRlIHByb3RvY29sIHRoYXQgY2FuIGJlIHVzZWQgZm9yIG5vbi1wZXJzaXN0ZW50IGRhdGEgbGlrZSBhd2FyZW5lc3MgaW5mb3JtYXRpb25cbiAqIChjdXJzb3IsIHVzZXJuYW1lLCBzdGF0dXMsIC4uKS4gRWFjaCBjbGllbnQgY2FuIHVwZGF0ZSBpdHMgb3duIGxvY2FsIHN0YXRlIGFuZCBsaXN0ZW4gdG8gc3RhdGUgY2hhbmdlcyBvZlxuICogcmVtb3RlIGNsaWVudHMuIEV2ZXJ5IGNsaWVudCBtYXkgc2V0IGEgc3RhdGUgb2YgYSByZW1vdGUgcGVlciB0byBgbnVsbGAgdG8gbWFyayB0aGUgY2xpZW50IGFzIG9mZmxpbmUuXG4gKlxuICogRWFjaCBjbGllbnQgaXMgaWRlbnRpZmllZCBieSBhIHVuaXF1ZSBjbGllbnQgaWQgKHNvbWV0aGluZyB3ZSBib3Jyb3cgZnJvbSBgZG9jLmNsaWVudElEYCkuIEEgY2xpZW50IGNhbiBvdmVycmlkZVxuICogaXRzIG93biBzdGF0ZSBieSBwcm9wYWdhdGluZyBhIG1lc3NhZ2Ugd2l0aCBhbiBpbmNyZWFzaW5nIHRpbWVzdGFtcCAoYGNsb2NrYCkuIElmIHN1Y2ggYSBtZXNzYWdlIGlzIHJlY2VpdmVkLCBpdCBpc1xuICogYXBwbGllZCBpZiB0aGUga25vd24gc3RhdGUgb2YgdGhhdCBjbGllbnQgaXMgb2xkZXIgdGhhbiB0aGUgbmV3IHN0YXRlIChgY2xvY2sgPCBuZXdDbG9ja2ApLiBJZiBhIGNsaWVudCB0aGlua3MgdGhhdFxuICogYSByZW1vdGUgY2xpZW50IGlzIG9mZmxpbmUsIGl0IG1heSBwcm9wYWdhdGUgYSBtZXNzYWdlIHdpdGhcbiAqIGB7IGNsb2NrOiBjdXJyZW50Q2xpZW50Q2xvY2ssIHN0YXRlOiBudWxsLCBjbGllbnQ6IHJlbW90ZUNsaWVudCB9YC4gSWYgc3VjaCBhXG4gKiBtZXNzYWdlIGlzIHJlY2VpdmVkLCBhbmQgdGhlIGtub3duIGNsb2NrIG9mIHRoYXQgY2xpZW50IGVxdWFscyB0aGUgcmVjZWl2ZWQgY2xvY2ssIGl0IHdpbGwgb3ZlcnJpZGUgdGhlIHN0YXRlIHdpdGggYG51bGxgLlxuICpcbiAqIEJlZm9yZSBhIGNsaWVudCBkaXNjb25uZWN0cywgaXQgc2hvdWxkIHByb3BhZ2F0ZSBhIGBudWxsYCBzdGF0ZSB3aXRoIGFuIHVwZGF0ZWQgY2xvY2suXG4gKlxuICogQXdhcmVuZXNzIHN0YXRlcyBtdXN0IGJlIHVwZGF0ZWQgZXZlcnkgMzAgc2Vjb25kcy4gT3RoZXJ3aXNlIHRoZSBBd2FyZW5lc3MgaW5zdGFuY2Ugd2lsbCBkZWxldGUgdGhlIGNsaWVudCBzdGF0ZS5cbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2YWJsZTxzdHJpbmc+fVxuICovXG5jbGFzcyBBd2FyZW5lc3MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudElEID0gZG9jLmNsaWVudElEO1xuICAgIC8qKlxuICAgICAqIE1hcHMgZnJvbSBjbGllbnQgaWQgdG8gY2xpZW50IHN0YXRlXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsIE9iamVjdDxzdHJpbmcsIGFueT4+fVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBNZXRhQ2xpZW50U3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMubWV0YSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9jaGVja0ludGVydmFsID0gLyoqIEB0eXBlIHthbnl9ICovIChzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSBnZXRVbml4VGltZSgpO1xuICAgICAgaWYgKHRoaXMuZ2V0TG9jYWxTdGF0ZSgpICE9PSBudWxsICYmIChvdXRkYXRlZFRpbWVvdXQgLyAyIDw9IG5vdyAtIC8qKiBAdHlwZSB7e2xhc3RVcGRhdGVkOm51bWJlcn19ICovICh0aGlzLm1ldGEuZ2V0KHRoaXMuY2xpZW50SUQpKS5sYXN0VXBkYXRlZCkpIHtcbiAgICAgICAgLy8gcmVuZXcgbG9jYWwgY2xvY2tcbiAgICAgICAgdGhpcy5zZXRMb2NhbFN0YXRlKHRoaXMuZ2V0TG9jYWxTdGF0ZSgpKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHJlbW92ZSA9IFtdO1xuICAgICAgdGhpcy5tZXRhLmZvckVhY2goKG1ldGEsIGNsaWVudGlkKSA9PiB7XG4gICAgICAgIGlmIChjbGllbnRpZCAhPT0gdGhpcy5jbGllbnRJRCAmJiBvdXRkYXRlZFRpbWVvdXQgPD0gbm93IC0gbWV0YS5sYXN0VXBkYXRlZCAmJiB0aGlzLnN0YXRlcy5oYXMoY2xpZW50aWQpKSB7XG4gICAgICAgICAgcmVtb3ZlLnB1c2goY2xpZW50aWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgICByZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcywgcmVtb3ZlLCAndGltZW91dCcpO1xuICAgICAgfVxuICAgIH0sIGZsb29yKG91dGRhdGVkVGltZW91dCAvIDEwKSkpO1xuICAgIGRvYy5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0TG9jYWxTdGF0ZSh7fSk7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knLCBbdGhpc10pO1xuICAgIHRoaXMuc2V0TG9jYWxTdGF0ZShudWxsKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja0ludGVydmFsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT58bnVsbH1cbiAgICovXG4gIGdldExvY2FsU3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlcy5nZXQodGhpcy5jbGllbnRJRCkgfHwgbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fG51bGx9IHN0YXRlXG4gICAqL1xuICBzZXRMb2NhbFN0YXRlIChzdGF0ZSkge1xuICAgIGNvbnN0IGNsaWVudElEID0gdGhpcy5jbGllbnRJRDtcbiAgICBjb25zdCBjdXJyTG9jYWxNZXRhID0gdGhpcy5tZXRhLmdldChjbGllbnRJRCk7XG4gICAgY29uc3QgY2xvY2sgPSBjdXJyTG9jYWxNZXRhID09PSB1bmRlZmluZWQgPyAwIDogY3VyckxvY2FsTWV0YS5jbG9jayArIDE7XG4gICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5zdGF0ZXMuZ2V0KGNsaWVudElEKTtcbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RhdGVzLmRlbGV0ZShjbGllbnRJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGVzLnNldChjbGllbnRJRCwgc3RhdGUpO1xuICAgIH1cbiAgICB0aGlzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICBjbG9jayxcbiAgICAgIGxhc3RVcGRhdGVkOiBnZXRVbml4VGltZSgpXG4gICAgfSk7XG4gICAgY29uc3QgYWRkZWQgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVkID0gW107XG4gICAgY29uc3QgZmlsdGVyZWRVcGRhdGVkID0gW107XG4gICAgY29uc3QgcmVtb3ZlZCA9IFtdO1xuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKTtcbiAgICB9IGVsc2UgaWYgKHByZXZTdGF0ZSA9PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBhZGRlZC5wdXNoKGNsaWVudElEKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlZC5wdXNoKGNsaWVudElEKTtcbiAgICAgIGlmICghZXF1YWxpdHlEZWVwKHByZXZTdGF0ZSwgc3RhdGUpKSB7XG4gICAgICAgIGZpbHRlcmVkVXBkYXRlZC5wdXNoKGNsaWVudElEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgZmlsdGVyZWRVcGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIFt7IGFkZGVkLCB1cGRhdGVkOiBmaWx0ZXJlZFVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIFt7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH0sICdsb2NhbCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqL1xuICBzZXRMb2NhbFN0YXRlRmllbGQgKGZpZWxkLCB2YWx1ZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRMb2NhbFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnNldExvY2FsU3RhdGUoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW2ZpZWxkXTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtNYXA8bnVtYmVyLE9iamVjdDxzdHJpbmcsYW55Pj59XG4gICAqL1xuICBnZXRTdGF0ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1xuICB9XG59XG5cbi8qKlxuICogTWFyayAocmVtb3RlKSBjbGllbnRzIGFzIGluYWN0aXZlIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBwZWVycy5cbiAqIFRoaXMgY2hhbmdlIHdpbGwgYmUgcHJvcGFnYXRlZCB0byByZW1vdGUgY2xpZW50cy5cbiAqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsaWVudHNcbiAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAqL1xuY29uc3QgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzID0gKGF3YXJlbmVzcywgY2xpZW50cywgb3JpZ2luKSA9PiB7XG4gIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGllbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBjbGllbnRzW2ldO1xuICAgIGlmIChhd2FyZW5lc3Muc3RhdGVzLmhhcyhjbGllbnRJRCkpIHtcbiAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKTtcbiAgICAgIGlmIChjbGllbnRJRCA9PT0gYXdhcmVuZXNzLmNsaWVudElEKSB7XG4gICAgICAgIGNvbnN0IGN1ck1ldGEgPSAvKiogQHR5cGUge01ldGFDbGllbnRTdGF0ZX0gKi8gKGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRCkpO1xuICAgICAgICBhd2FyZW5lc3MubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgICAgICBjbG9jazogY3VyTWV0YS5jbG9jayArIDEsXG4gICAgICAgICAgbGFzdFVwZGF0ZWQ6IGdldFVuaXhUaW1lKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpO1xuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ2NoYW5nZScsIFt7IGFkZGVkOiBbXSwgdXBkYXRlZDogW10sIHJlbW92ZWQgfSwgb3JpZ2luXSk7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ3VwZGF0ZScsIFt7IGFkZGVkOiBbXSwgdXBkYXRlZDogW10sIHJlbW92ZWQgfSwgb3JpZ2luXSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbGllbnRzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVBd2FyZW5lc3NVcGRhdGUgPSAoYXdhcmVuZXNzLCBjbGllbnRzLCBzdGF0ZXMgPSBhd2FyZW5lc3Muc3RhdGVzKSA9PiB7XG4gIGNvbnN0IGxlbiA9IGNsaWVudHMubGVuZ3RoO1xuICBjb25zdCBlbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpO1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gY2xpZW50c1tpXTtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YXRlcy5nZXQoY2xpZW50SUQpIHx8IG51bGw7XG4gICAgY29uc3QgY2xvY2sgPSAvKiogQHR5cGUge01ldGFDbGllbnRTdGF0ZX0gKi8gKGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRCkpLmNsb2NrO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBjbGllbnRJRCk7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGNsb2NrKTtcbiAgICB3cml0ZVZhclN0cmluZyhlbmNvZGVyLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICB9XG4gIHJldHVybiB0b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBvcmlnaW4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbWl0dGVkIGNoYW5nZSBldmVudFxuICovXG5jb25zdCBhcHBseUF3YXJlbmVzc1VwZGF0ZSA9IChhd2FyZW5lc3MsIHVwZGF0ZSwgb3JpZ2luKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVEZWNvZGVyKHVwZGF0ZSk7XG4gIGNvbnN0IHRpbWVzdGFtcCA9IGdldFVuaXhUaW1lKCk7XG4gIGNvbnN0IGFkZGVkID0gW107XG4gIGNvbnN0IHVwZGF0ZWQgPSBbXTtcbiAgY29uc3QgZmlsdGVyZWRVcGRhdGVkID0gW107XG4gIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgY29uc3QgbGVuID0gcmVhZFZhclVpbnQoZGVjb2Rlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IHJlYWRWYXJVaW50KGRlY29kZXIpO1xuICAgIGxldCBjbG9jayA9IHJlYWRWYXJVaW50KGRlY29kZXIpO1xuICAgIGNvbnN0IHN0YXRlID0gSlNPTi5wYXJzZShyZWFkVmFyU3RyaW5nKGRlY29kZXIpKTtcbiAgICBjb25zdCBjbGllbnRNZXRhID0gYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKTtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSBhd2FyZW5lc3Muc3RhdGVzLmdldChjbGllbnRJRCk7XG4gICAgY29uc3QgY3VyckNsb2NrID0gY2xpZW50TWV0YSA9PT0gdW5kZWZpbmVkID8gMCA6IGNsaWVudE1ldGEuY2xvY2s7XG4gICAgaWYgKGN1cnJDbG9jayA8IGNsb2NrIHx8IChjdXJyQ2xvY2sgPT09IGNsb2NrICYmIHN0YXRlID09PSBudWxsICYmIGF3YXJlbmVzcy5zdGF0ZXMuaGFzKGNsaWVudElEKSkpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBuZXZlciBsZXQgYSByZW1vdGUgY2xpZW50IHJlbW92ZSB0aGlzIGxvY2FsIHN0YXRlXG4gICAgICAgIGlmIChjbGllbnRJRCA9PT0gYXdhcmVuZXNzLmNsaWVudElEICYmIGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIHJlbW90ZSBjbGllbnQgcmVtb3ZlZCB0aGUgbG9jYWwgc3RhdGUuIERvIG5vdCByZW1vdGUgc3RhdGUuIEJyb2FkY2FzdCBhIG1lc3NhZ2UgaW5kaWNhdGluZ1xuICAgICAgICAgIC8vIHRoYXQgdGhpcyBjbGllbnQgc3RpbGwgZXhpc3RzIGJ5IGluY3JlYXNpbmcgdGhlIGNsb2NrXG4gICAgICAgICAgY2xvY2srKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FyZW5lc3Muc3RhdGVzLmRlbGV0ZShjbGllbnRJRCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuc2V0KGNsaWVudElELCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBhd2FyZW5lc3MubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgICAgY2xvY2ssXG4gICAgICAgIGxhc3RVcGRhdGVkOiB0aW1lc3RhbXBcbiAgICAgIH0pO1xuICAgICAgaWYgKGNsaWVudE1ldGEgPT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBhZGRlZC5wdXNoKGNsaWVudElEKTtcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50TWV0YSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlID09PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZWQucHVzaChjbGllbnRJRCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghZXF1YWxpdHlEZWVwKHN0YXRlLCBwcmV2U3RhdGUpKSB7XG4gICAgICAgICAgZmlsdGVyZWRVcGRhdGVkLnB1c2goY2xpZW50SUQpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWQucHVzaChjbGllbnRJRCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IGZpbHRlcmVkVXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCdjaGFuZ2UnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQ6IGZpbHRlcmVkVXBkYXRlZCwgcmVtb3ZlZFxuICAgIH0sIG9yaWdpbl0pO1xuICB9XG4gIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IHVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgndXBkYXRlJywgW3tcbiAgICAgIGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkXG4gICAgfSwgb3JpZ2luXSk7XG4gIH1cbn07XG5cbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWZ1bmN0aW9uLXR5cGVcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZnVuY3Rpb24tdHlwZVxuICAgIG9uKGV2ZW50LCBmbikge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1mdW5jdGlvbi10eXBlXG4gICAgb2ZmKGV2ZW50LCBmbikge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoKGNhbGxiYWNrKSA9PiBjYWxsYmFjayAhPT0gZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICAgIH1cbn1cblxuY2xhc3MgSW5jb21pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IGNyZWF0ZUVuY29kZXIoKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gY3JlYXRlRGVjb2RlcihuZXcgVWludDhBcnJheSh0aGlzLmRhdGEpKTtcbiAgICB9XG4gICAgcGVla1ZhclN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHBlZWtWYXJTdHJpbmcodGhpcy5kZWNvZGVyKTtcbiAgICB9XG4gICAgcmVhZFZhclVpbnQoKSB7XG4gICAgICAgIHJldHVybiByZWFkVmFyVWludCh0aGlzLmRlY29kZXIpO1xuICAgIH1cbiAgICByZWFkVmFyU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gcmVhZFZhclN0cmluZyh0aGlzLmRlY29kZXIpO1xuICAgIH1cbiAgICByZWFkVmFyVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRWYXJVaW50OEFycmF5KHRoaXMuZGVjb2Rlcik7XG4gICAgfVxuICAgIHdyaXRlVmFyVWludCh0eXBlKSB7XG4gICAgICAgIHJldHVybiB3cml0ZVZhclVpbnQodGhpcy5lbmNvZGVyLCB0eXBlKTtcbiAgICB9XG4gICAgd3JpdGVWYXJTdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB3cml0ZVZhclN0cmluZyh0aGlzLmVuY29kZXIsIHN0cmluZyk7XG4gICAgfVxuICAgIHdyaXRlVmFyVWludDhBcnJheShkYXRhKSB7XG4gICAgICAgIHJldHVybiB3cml0ZVZhclVpbnQ4QXJyYXkodGhpcy5lbmNvZGVyLCBkYXRhKTtcbiAgICB9XG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoJDEodGhpcy5lbmNvZGVyKTtcbiAgICB9XG59XG5cbnZhciBNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoTWVzc2FnZVR5cGUpIHtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlN5bmNcIl0gPSAwXSA9IFwiU3luY1wiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQXdhcmVuZXNzXCJdID0gMV0gPSBcIkF3YXJlbmVzc1wiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQXV0aFwiXSA9IDJdID0gXCJBdXRoXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJRdWVyeUF3YXJlbmVzc1wiXSA9IDNdID0gXCJRdWVyeUF3YXJlbmVzc1wiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU3RhdGVsZXNzXCJdID0gNV0gPSBcIlN0YXRlbGVzc1wiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQ0xPU0VcIl0gPSA3XSA9IFwiQ0xPU0VcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlN5bmNTdGF0dXNcIl0gPSA4XSA9IFwiU3luY1N0YXR1c1wiO1xufSkoTWVzc2FnZVR5cGUgfHwgKE1lc3NhZ2VUeXBlID0ge30pKTtcbnZhciBXZWJTb2NrZXRTdGF0dXM7XG4oZnVuY3Rpb24gKFdlYlNvY2tldFN0YXR1cykge1xuICAgIFdlYlNvY2tldFN0YXR1c1tcIkNvbm5lY3RpbmdcIl0gPSBcImNvbm5lY3RpbmdcIjtcbiAgICBXZWJTb2NrZXRTdGF0dXNbXCJDb25uZWN0ZWRcIl0gPSBcImNvbm5lY3RlZFwiO1xuICAgIFdlYlNvY2tldFN0YXR1c1tcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG59KShXZWJTb2NrZXRTdGF0dXMgfHwgKFdlYlNvY2tldFN0YXR1cyA9IHt9KSk7XG5cbmNsYXNzIE91dGdvaW5nTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IGNyZWF0ZUVuY29kZXIoKTtcbiAgICB9XG4gICAgZ2V0KGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MuZW5jb2RlcjtcbiAgICB9XG4gICAgdG9VaW50OEFycmF5KCkge1xuICAgICAgICByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMuZW5jb2Rlcik7XG4gICAgfVxufVxuXG5jbGFzcyBDbG9zZU1lc3NhZ2UgZXh0ZW5kcyBPdXRnb2luZ01lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSBNZXNzYWdlVHlwZS5DTE9TRTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiQXNrIHRoZSBzZXJ2ZXIgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb25cIjtcbiAgICB9XG4gICAgZ2V0KGFyZ3MpIHtcbiAgICAgICAgd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50TmFtZSk7XG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLmVuY29kZXIsIHRoaXMudHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZXI7XG4gICAgfVxufVxuXG5jbGFzcyBIb2N1c3BvY3VzUHJvdmlkZXJXZWJzb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0ge1xuICAgICAgICAgICAgdXJsOiBcIlwiLFxuICAgICAgICAgICAgYXV0b0Nvbm5lY3Q6IHRydWUsXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBkb2N1bWVudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgV2ViU29ja2V0UG9seWZpbGw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGRlcGVuZCBvbiBhd2FyZW5lc3Mub3V0ZGF0ZWRUaW1lXG4gICAgICAgICAgICBtZXNzYWdlUmVjb25uZWN0VGltZW91dDogMzAwMDAsXG4gICAgICAgICAgICAvLyAxIHNlY29uZFxuICAgICAgICAgICAgZGVsYXk6IDEwMDAsXG4gICAgICAgICAgICAvLyBpbnN0YW50XG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IDAsXG4gICAgICAgICAgICAvLyBkb3VibGUgdGhlIGRlbGF5IGVhY2ggdGltZVxuICAgICAgICAgICAgZmFjdG9yOiAyLFxuICAgICAgICAgICAgLy8gdW5saW1pdGVkIHJldHJpZXNcbiAgICAgICAgICAgIG1heEF0dGVtcHRzOiAwLFxuICAgICAgICAgICAgLy8gd2FpdCBhdCBsZWFzdCAxIHNlY29uZFxuICAgICAgICAgICAgbWluRGVsYXk6IDEwMDAsXG4gICAgICAgICAgICAvLyBhdCBsZWFzdCBldmVyeSAzMCBzZWNvbmRzXG4gICAgICAgICAgICBtYXhEZWxheTogMzAwMDAsXG4gICAgICAgICAgICAvLyByYW5kb21pemVcbiAgICAgICAgICAgIGppdHRlcjogdHJ1ZSxcbiAgICAgICAgICAgIC8vIHJldHJ5IGZvcmV2ZXJcbiAgICAgICAgICAgIHRpbWVvdXQ6IDAsXG4gICAgICAgICAgICBvbk9wZW46ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkNvbm5lY3Q6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbk1lc3NhZ2U6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbk91dGdvaW5nTWVzc2FnZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uU3RhdHVzOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25EaXNjb25uZWN0OiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uRGVzdHJveTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQXdhcmVuZXNzVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25Bd2FyZW5lc3NDaGFuZ2U6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBoYW5kbGVUaW1lb3V0OiBudWxsLFxuICAgICAgICAgICAgcHJvdmlkZXJNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXQgPSBudWxsO1xuICAgICAgICB0aGlzLndlYlNvY2tldEhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gV2ViU29ja2V0U3RhdHVzLkRpc2Nvbm5lY3RlZDtcbiAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkID0gMDtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gMDtcbiAgICAgICAgdGhpcy5pbnRlcnZhbHMgPSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uQ2hlY2tlcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uQXR0ZW1wdCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRPbk9wZW5QYXlsb2FkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsb3NlVHJpZXMgPSAwO1xuICAgICAgICB0aGlzLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5XZWJTb2NrZXRQb2x5ZmlsbCA9IGNvbmZpZ3VyYXRpb24uV2ViU29ja2V0UG9seWZpbGxcbiAgICAgICAgICAgID8gY29uZmlndXJhdGlvbi5XZWJTb2NrZXRQb2x5ZmlsbFxuICAgICAgICAgICAgOiBXZWJTb2NrZXQ7XG4gICAgICAgIHRoaXMub24oXCJvcGVuXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbk9wZW4pO1xuICAgICAgICB0aGlzLm9uKFwib3BlblwiLCB0aGlzLm9uT3Blbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vbihcImNvbm5lY3RcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uQ29ubmVjdCk7XG4gICAgICAgIHRoaXMub24oXCJtZXNzYWdlXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbk1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm9uKFwib3V0Z29pbmdNZXNzYWdlXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbk91dGdvaW5nTWVzc2FnZSk7XG4gICAgICAgIHRoaXMub24oXCJzdGF0dXNcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uU3RhdHVzKTtcbiAgICAgICAgdGhpcy5vbihcImRpc2Nvbm5lY3RcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uRGlzY29ubmVjdCk7XG4gICAgICAgIHRoaXMub24oXCJjbG9zZVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25DbG9zZSk7XG4gICAgICAgIHRoaXMub24oXCJkZXN0cm95XCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkRlc3Ryb3kpO1xuICAgICAgICB0aGlzLm9uKFwiYXdhcmVuZXNzVXBkYXRlXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkF3YXJlbmVzc1VwZGF0ZSk7XG4gICAgICAgIHRoaXMub24oXCJhd2FyZW5lc3NDaGFuZ2VcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uQXdhcmVuZXNzQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5vbihcImNsb3NlXCIsIHRoaXMub25DbG9zZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vbihcIm1lc3NhZ2VcIiwgdGhpcy5vbk1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzLmNvbm5lY3Rpb25DaGVja2VyID0gc2V0SW50ZXJ2YWwodGhpcy5jaGVja0Nvbm5lY3Rpb24uYmluZCh0aGlzKSwgdGhpcy5jb25maWd1cmF0aW9uLm1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0IC8gMTApO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRDb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbk9wZW4oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBXZWJTb2NrZXRTdGF0dXMuQ29ubmVjdGVkO1xuICAgICAgICB0aGlzLmVtaXQoXCJzdGF0dXNcIiwgeyBzdGF0dXM6IFdlYlNvY2tldFN0YXR1cy5Db25uZWN0ZWQgfSk7XG4gICAgICAgIHRoaXMuY2FuY2VsV2Vic29ja2V0UmV0cnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRPbk9wZW5QYXlsb2FkID0gZXZlbnQ7XG4gICAgfVxuICAgIGF0dGFjaChwcm92aWRlcikge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucHJvdmlkZXJNYXAuc2V0KHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24ubmFtZSwgcHJvdmlkZXIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFdlYlNvY2tldFN0YXR1cy5EaXNjb25uZWN0ZWQgJiYgdGhpcy5zaG91bGRDb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNlaXZlZE9uT3BlblBheWxvYWQgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBXZWJTb2NrZXRTdGF0dXMuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBwcm92aWRlci5vbk9wZW4odGhpcy5yZWNlaXZlZE9uT3BlblBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRldGFjaChwcm92aWRlcikge1xuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVyTWFwLmhhcyhwcm92aWRlci5jb25maWd1cmF0aW9uLm5hbWUpKSB7XG4gICAgICAgICAgICBwcm92aWRlci5zZW5kKENsb3NlTWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50TmFtZTogcHJvdmlkZXIuY29uZmlndXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucHJvdmlkZXJNYXAuZGVsZXRlKHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24ubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uID0ge30pIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0geyAuLi50aGlzLmNvbmZpZ3VyYXRpb24sIC4uLmNvbmZpZ3VyYXRpb24gfTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZ3VyYXRpb24uYXV0b0Nvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyBjYW5jZWwgYW55IHByZXZpb3VzbHkgaW5pdGlhdGVkIGNvbm5lY3Rpb24gcmV0cnllciBpbnN0YW5jZXNcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsV2Vic29ja2V0UmV0cnkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsV2Vic29ja2V0UmV0cnkoKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsV2Vic29ja2V0UmV0cnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWNlaXZlZE9uT3BlblBheWxvYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGFib3J0YWJsZVJldHJ5ID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNhbmNlbEF0dGVtcHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5UHJvbWlzZSA9IHJldHJ5KHRoaXMuY3JlYXRlV2ViU29ja2V0Q29ubmVjdGlvbi5iaW5kKHRoaXMpLCB7XG4gICAgICAgICAgICAgICAgZGVsYXk6IHRoaXMuY29uZmlndXJhdGlvbi5kZWxheSxcbiAgICAgICAgICAgICAgICBpbml0aWFsRGVsYXk6IHRoaXMuY29uZmlndXJhdGlvbi5pbml0aWFsRGVsYXksXG4gICAgICAgICAgICAgICAgZmFjdG9yOiB0aGlzLmNvbmZpZ3VyYXRpb24uZmFjdG9yLFxuICAgICAgICAgICAgICAgIG1heEF0dGVtcHRzOiB0aGlzLmNvbmZpZ3VyYXRpb24ubWF4QXR0ZW1wdHMsXG4gICAgICAgICAgICAgICAgbWluRGVsYXk6IHRoaXMuY29uZmlndXJhdGlvbi5taW5EZWxheSxcbiAgICAgICAgICAgICAgICBtYXhEZWxheTogdGhpcy5jb25maWd1cmF0aW9uLm1heERlbGF5LFxuICAgICAgICAgICAgICAgIGppdHRlcjogdGhpcy5jb25maWd1cmF0aW9uLmppdHRlcixcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLmNvbmZpZ3VyYXRpb24udGltZW91dCxcbiAgICAgICAgICAgICAgICBoYW5kbGVUaW1lb3V0OiB0aGlzLmNvbmZpZ3VyYXRpb24uaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgICBiZWZvcmVBdHRlbXB0OiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkQ29ubmVjdCB8fCBjYW5jZWxBdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYWJvcnRlZCB0aGUgY29ubmVjdGlvbiBhdHRlbXB0IHRoZW4gZG9u4oCZdCB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIC8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL2xpZmVvbWljL2F0dGVtcHQvYmxvYi9tYXN0ZXIvc3JjL2luZGV4LnRzI0wxMzZcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSAhPT0gXCJBVFRFTVBUX0FCT1JURURcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmV0cnlQcm9taXNlLFxuICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQXR0ZW1wdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgcmV0cnlQcm9taXNlLCBjYW5jZWxGdW5jIH0gPSBhYm9ydGFibGVSZXRyeSgpO1xuICAgICAgICB0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5ID0gY2FuY2VsRnVuYztcbiAgICAgICAgcmV0dXJuIHJldHJ5UHJvbWlzZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZnVuY3Rpb24tdHlwZVxuICAgIGF0dGFjaFdlYlNvY2tldExpc3RlbmVycyh3cywgcmVqZWN0KSB7XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpZmllciB9ID0gd3M7XG4gICAgICAgIGNvbnN0IG9uTWVzc2FnZUhhbmRsZXIgPSAocGF5bG9hZCkgPT4gdGhpcy5lbWl0KFwibWVzc2FnZVwiLCBwYXlsb2FkKTtcbiAgICAgICAgY29uc3Qgb25DbG9zZUhhbmRsZXIgPSAocGF5bG9hZCkgPT4gdGhpcy5lbWl0KFwiY2xvc2VcIiwgeyBldmVudDogcGF5bG9hZCB9KTtcbiAgICAgICAgY29uc3Qgb25PcGVuSGFuZGxlciA9IChwYXlsb2FkKSA9PiB0aGlzLmVtaXQoXCJvcGVuXCIsIHBheWxvYWQpO1xuICAgICAgICBjb25zdCBvbkVycm9ySGFuZGxlciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndlYlNvY2tldEhhbmRsZXJzW2lkZW50aWZpZXJdID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogb25NZXNzYWdlSGFuZGxlcixcbiAgICAgICAgICAgIGNsb3NlOiBvbkNsb3NlSGFuZGxlcixcbiAgICAgICAgICAgIG9wZW46IG9uT3BlbkhhbmRsZXIsXG4gICAgICAgICAgICBlcnJvcjogb25FcnJvckhhbmRsZXIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy53ZWJTb2NrZXRIYW5kbGVyc1t3cy5pZGVudGlmaWVyXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaGFuZGxlcnMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYW51cFdlYlNvY2tldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLndlYlNvY2tldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpZmllciB9ID0gdGhpcy53ZWJTb2NrZXQ7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy53ZWJTb2NrZXRIYW5kbGVyc1tpZGVudGlmaWVyXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaGFuZGxlcnMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMud2ViU29ja2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy53ZWJTb2NrZXRIYW5kbGVyc1tpZGVudGlmaWVyXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud2ViU29ja2V0LmNsb3NlKCk7XG4gICAgICAgIHRoaXMud2ViU29ja2V0ID0gbnVsbDtcbiAgICB9XG4gICAgY3JlYXRlV2ViU29ja2V0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLndlYlNvY2tldCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwV2ViU29ja2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5pZGVudGlmaWVyICs9IDE7XG4gICAgICAgICAgICAvLyBJbml0IHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgICAgICAgICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5jb25maWd1cmF0aW9uLldlYlNvY2tldFBvbHlmaWxsKHRoaXMudXJsKTtcbiAgICAgICAgICAgIHdzLmJpbmFyeVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgICAgICB3cy5pZGVudGlmaWVyID0gdGhpcy5pZGVudGlmaWVyO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hXZWJTb2NrZXRMaXN0ZW5lcnMod3MsIHJlamVjdCk7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldCA9IHdzO1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHN0YXR1c1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBXZWJTb2NrZXRTdGF0dXMuQ29ubmVjdGluZztcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInN0YXR1c1wiLCB7IHN0YXR1czogV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RpbmcgfSk7XG4gICAgICAgICAgICAvLyBTdG9yZSByZXNvbHZlL3JlamVjdCBmb3IgbGF0ZXIgdXNlXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0ID0ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uTWVzc2FnZShldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbm5lY3Rpb25BdHRlbXB0KCk7XG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZCA9IGdldFVuaXhUaW1lKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgSW5jb21pbmdNZXNzYWdlKGV2ZW50LmRhdGEpO1xuICAgICAgICBjb25zdCBkb2N1bWVudE5hbWUgPSBtZXNzYWdlLnBlZWtWYXJTdHJpbmcoKTtcbiAgICAgICAgKF9hID0gdGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVyTWFwLmdldChkb2N1bWVudE5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25NZXNzYWdlKGV2ZW50KTtcbiAgICB9XG4gICAgcmVzb2x2ZUNvbm5lY3Rpb25BdHRlbXB0KCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uQXR0ZW1wdCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQXR0ZW1wdC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RlZDtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInN0YXR1c1wiLCB7IHN0YXR1czogV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RlZCB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIik7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5mb3JFYWNoKChtZXNzYWdlKSA9PiB0aGlzLnNlbmQobWVzc2FnZSkpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29ubmVjdGlvbkF0dGVtcHQoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkF0dGVtcHQgPSBudWxsO1xuICAgIH1cbiAgICByZWplY3RDb25uZWN0aW9uQXR0ZW1wdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVqZWN0KCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkF0dGVtcHQgPSBudWxsO1xuICAgIH1cbiAgICBjaGVja0Nvbm5lY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gRG9u4oCZdCBjaGVjayB0aGUgY29ubmVjdGlvbiB3aGVuIGl04oCZcyBub3QgZXZlbiBlc3RhYmxpc2hlZFxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFdlYlNvY2tldFN0YXR1cy5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb27igJl0IGNsb3NlIHRoZSBjb25uZWN0aW9uIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBmaXJzdCBtZXNzYWdlXG4gICAgICAgIGlmICghdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9u4oCZdCBjbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIGEgbWVzc2FnZSB3YXMgcmVjZWl2ZWQgcmVjZW50bHlcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5tZXNzYWdlUmVjb25uZWN0VGltZW91dCA+PVxuICAgICAgICAgICAgZ2V0VW5peFRpbWUoKSAtIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG1lc3NhZ2UgcmVjZWl2ZWQgaW4gYSBsb25nIHRpbWUsIG5vdCBldmVuIHlvdXIgb3duXG4gICAgICAgIC8vIEF3YXJlbmVzcyB1cGRhdGVzLCB3aGljaCBhcmUgdXBkYXRlZCBldmVyeSAxNSBzZWNvbmRzXG4gICAgICAgIC8vIGlmIGF3YXJlbmVzcyBpcyBlbmFibGVkLlxuICAgICAgICB0aGlzLmNsb3NlVHJpZXMgKz0gMTtcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI0Nzk0M1xuICAgICAgICBpZiAodGhpcy5jbG9zZVRyaWVzID4gMikge1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKHtcbiAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiA0NDA4LFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiZm9yY2VkXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jbG9zZVRyaWVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMud2ViU29ja2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFVSTCBuZXZlciBlbmRzIHdpdGggL1xuICAgIGdldCBzZXJ2ZXJVcmwoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNvbmZpZ3VyYXRpb24udXJsW3RoaXMuY29uZmlndXJhdGlvbi51cmwubGVuZ3RoIC0gMV0gPT09IFwiL1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnVybC5zbGljZSgwLCB0aGlzLmNvbmZpZ3VyYXRpb24udXJsLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24udXJsO1xuICAgIH1cbiAgICBnZXQgdXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJVcmw7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy53ZWJTb2NrZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLndlYlNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGUpID09PSBXc1JlYWR5U3RhdGVzLk9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0LnNlbmQobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQ2xvc2UoeyBldmVudCB9KSB7XG4gICAgICAgIHRoaXMuY2xvc2VUcmllcyA9IDA7XG4gICAgICAgIHRoaXMuY2xlYW51cFdlYlNvY2tldCgpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uQXR0ZW1wdCkge1xuICAgICAgICAgICAgLy8gVGhhdCBjb25uZWN0aW9uIGF0dGVtcHQgZmFpbGVkLlxuICAgICAgICAgICAgdGhpcy5yZWplY3RDb25uZWN0aW9uQXR0ZW1wdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExldOKAmXMgdXBkYXRlIHRoZSBjb25uZWN0aW9uIHN0YXR1cy5cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBXZWJTb2NrZXRTdGF0dXMuRGlzY29ubmVjdGVkO1xuICAgICAgICB0aGlzLmVtaXQoXCJzdGF0dXNcIiwgeyBzdGF0dXM6IFdlYlNvY2tldFN0YXR1cy5EaXNjb25uZWN0ZWQgfSk7XG4gICAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIiwgeyBldmVudCB9KTtcbiAgICAgICAgLy8gdHJpZ2dlciBjb25uZWN0IGlmIG5vIHJldHJ5IGlzIHJ1bm5pbmcgYW5kIHdlIHdhbnQgdG8gaGF2ZSBhIGNvbm5lY3Rpb25cbiAgICAgICAgaWYgKCF0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5ICYmIHRoaXMuc2hvdWxkQ29ubmVjdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZ3VyYXRpb24uZGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIik7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbHMuY29ubmVjdGlvbkNoZWNrZXIpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBzdGlsbCBhIGNvbm5lY3Rpb24gYXR0ZW1wdCBvdXRzdGFuZGluZyB0aGVuIHdlIHNob3VsZCBzdG9wXG4gICAgICAgIC8vIGl0IGJlZm9yZSBjYWxsaW5nIGRpc2Nvbm5lY3QsIG90aGVyd2lzZSBpdCB3aWxsIGJlIHJlamVjdGVkIGluIHRoZSBvbkNsb3NlXG4gICAgICAgIC8vIGhhbmRsZXIgYW5kIHRyaWdnZXIgYSByZXRyeVxuICAgICAgICB0aGlzLnN0b3BDb25uZWN0aW9uQXR0ZW1wdCgpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5jbGVhbnVwV2ViU29ja2V0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBtb2R1bGUgc3luYy1wcm90b2NvbFxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7TWFwPG51bWJlciwgbnVtYmVyPn0gU3RhdGVNYXBcbiAqL1xuXG4vKipcbiAqIENvcmUgWWpzIGRlZmluZXMgdHdvIG1lc3NhZ2UgdHlwZXM6XG4gKiDigKIgWWpzU3luY1N0ZXAxOiBJbmNsdWRlcyB0aGUgU3RhdGUgU2V0IG9mIHRoZSBzZW5kaW5nIGNsaWVudC4gV2hlbiByZWNlaXZlZCwgdGhlIGNsaWVudCBzaG91bGQgcmVwbHkgd2l0aCBZanNTeW5jU3RlcDIuXG4gKiDigKIgWWpzU3luY1N0ZXAyOiBJbmNsdWRlcyBhbGwgbWlzc2luZyBzdHJ1Y3RzIGFuZCB0aGUgY29tcGxldGUgZGVsZXRlIHNldC4gV2hlbiByZWNlaXZlZCwgdGhlIGNsaWVudCBpcyBhc3N1cmVkIHRoYXQgaXRcbiAqICAgcmVjZWl2ZWQgYWxsIGluZm9ybWF0aW9uIGZyb20gdGhlIHJlbW90ZSBjbGllbnQuXG4gKlxuICogSW4gYSBwZWVyLXRvLXBlZXIgbmV0d29yaywgeW91IG1heSB3YW50IHRvIGludHJvZHVjZSBhIFN5bmNEb25lIG1lc3NhZ2UgdHlwZS4gQm90aCBwYXJ0aWVzIHNob3VsZCBpbml0aWF0ZSB0aGUgY29ubmVjdGlvblxuICogd2l0aCBTeW5jU3RlcDEuIFdoZW4gYSBjbGllbnQgcmVjZWl2ZWQgU3luY1N0ZXAyLCBpdCBzaG91bGQgcmVwbHkgd2l0aCBTeW5jRG9uZS4gV2hlbiB0aGUgbG9jYWwgY2xpZW50IHJlY2VpdmVkIGJvdGhcbiAqIFN5bmNTdGVwMiBhbmQgU3luY0RvbmUsIGl0IGlzIGFzc3VyZWQgdGhhdCBpdCBpcyBzeW5jZWQgdG8gdGhlIHJlbW90ZSBjbGllbnQuXG4gKlxuICogSW4gYSBjbGllbnQtc2VydmVyIG1vZGVsLCB5b3Ugd2FudCB0byBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseTogVGhlIGNsaWVudCBzaG91bGQgaW5pdGlhdGUgdGhlIGNvbm5lY3Rpb24gd2l0aCBTeW5jU3RlcDEuXG4gKiBXaGVuIHRoZSBzZXJ2ZXIgcmVjZWl2ZXMgU3luY1N0ZXAxLCBpdCBzaG91bGQgcmVwbHkgd2l0aCBTeW5jU3RlcDIgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgU3luY1N0ZXAxLiBUaGUgY2xpZW50IHJlcGxpZXNcbiAqIHdpdGggU3luY1N0ZXAyIHdoZW4gaXQgcmVjZWl2ZXMgU3luY1N0ZXAxLiBPcHRpb25hbGx5IHRoZSBzZXJ2ZXIgbWF5IHNlbmQgYSBTeW5jRG9uZSBhZnRlciBpdCByZWNlaXZlZCBTeW5jU3RlcDIsIHNvIHRoZVxuICogY2xpZW50IGtub3dzIHRoYXQgdGhlIHN5bmMgaXMgZmluaXNoZWQuICBUaGVyZSBhcmUgdHdvIHJlYXNvbnMgZm9yIHRoaXMgbW9yZSBlbGFib3JhdGVkIHN5bmMgbW9kZWw6IDEuIFRoaXMgcHJvdG9jb2wgY2FuXG4gKiBlYXNpbHkgYmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mIGh0dHAgYW5kIHdlYnNvY2tldHMuIDIuIFRoZSBzZXJ2ZXIgc2hvdWxkIG9ubHkgcmVwbHkgdG8gcmVxdWVzdHMsIGFuZCBub3QgaW5pdGlhdGUgdGhlbS5cbiAqIFRoZXJlZm9yZSBpdCBpcyBuZWNlc3NhcnkgdGhhdCB0aGUgY2xpZW50IGluaXRpYXRlcyB0aGUgc3luYy5cbiAqXG4gKiBDb25zdHJ1Y3Rpb24gb2YgYSBtZXNzYWdlOlxuICogW21lc3NhZ2VUeXBlIDogdmFyVWludCwgbWVzc2FnZSBkZWZpbml0aW9uLi5dXG4gKlxuICogTm90ZTogQSBtZXNzYWdlIGRvZXMgbm90IGluY2x1ZGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb20gbmFtZS4gVGhpcyBtdXN0IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHVwcGVyIGxheWVyIHByb3RvY29sIVxuICpcbiAqIHN0cmluZ2lmeVttZXNzYWdlVHlwZV0gc3RyaW5naWZpZXMgYSBtZXNzYWdlIGRlZmluaXRpb24gKG1lc3NhZ2VUeXBlIGlzIGFscmVhZHkgcmVhZCBmcm9tIHRoZSBidWZmZmVyKVxuICovXG5cbmNvbnN0IG1lc3NhZ2VZanNTeW5jU3RlcDEgPSAwO1xuY29uc3QgbWVzc2FnZVlqc1N5bmNTdGVwMiA9IDE7XG5jb25zdCBtZXNzYWdlWWpzVXBkYXRlID0gMjtcblxuLyoqXG4gKiBDcmVhdGUgYSBzeW5jIHN0ZXAgMSBtZXNzYWdlIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBzaGFyZWQgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqL1xuY29uc3Qgd3JpdGVTeW5jU3RlcDEgPSAoZW5jb2RlciwgZG9jKSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzU3luY1N0ZXAxKTtcbiAgY29uc3Qgc3YgPSBZLmVuY29kZVN0YXRlVmVjdG9yKGRvYyk7XG4gIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBzdik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtlbmNvZGVkU3RhdGVWZWN0b3JdXG4gKi9cbmNvbnN0IHdyaXRlU3luY1N0ZXAyID0gKGVuY29kZXIsIGRvYywgZW5jb2RlZFN0YXRlVmVjdG9yKSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzU3luY1N0ZXAyKTtcbiAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIFkuZW5jb2RlU3RhdGVBc1VwZGF0ZShkb2MsIGVuY29kZWRTdGF0ZVZlY3RvcikpO1xufTtcblxuLyoqXG4gKiBSZWFkIFN5bmNTdGVwMSBtZXNzYWdlIGFuZCByZXBseSB3aXRoIFN5bmNTdGVwMi5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXIgVGhlIHJlcGx5IHRvIHRoZSByZWNlaXZlZCBtZXNzYWdlXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXIgVGhlIHJlY2VpdmVkIG1lc3NhZ2VcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICovXG5jb25zdCByZWFkU3luY1N0ZXAxID0gKGRlY29kZXIsIGVuY29kZXIsIGRvYykgPT5cbiAgd3JpdGVTeW5jU3RlcDIoZW5jb2RlciwgZG9jLCByZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgU3RydWN0cyBhbmQgdGhlbiBEZWxldGVTdG9yZSB0byBhIHkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5jb25zdCByZWFkU3luY1N0ZXAyID0gKGRlY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHtcbiAgdHJ5IHtcbiAgICBZLmFwcGx5VXBkYXRlKGRvYywgcmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIHRyYW5zYWN0aW9uT3JpZ2luKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBUaGlzIGNhdGNoZXMgZXJyb3JzIHRoYXQgYXJlIHRocm93biBieSBldmVudCBoYW5kbGVyc1xuICAgIGNvbnNvbGUuZXJyb3IoJ0NhdWdodCBlcnJvciB3aGlsZSBoYW5kbGluZyBhIFlqcyB1cGRhdGUnLCBlcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICovXG5jb25zdCB3cml0ZVVwZGF0ZSA9IChlbmNvZGVyLCB1cGRhdGUpID0+IHtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VZanNVcGRhdGUpO1xuICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdXBkYXRlKTtcbn07XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgU3RydWN0cyBhbmQgdGhlbiBEZWxldGVTdG9yZSB0byBhIHkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5jb25zdCByZWFkVXBkYXRlID0gcmVhZFN5bmNTdGVwMjtcblxuLyoqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXIgQSBtZXNzYWdlIHJlY2VpdmVkIGZyb20gYW5vdGhlciBjbGllbnRcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlciBUaGUgcmVwbHkgbWVzc2FnZS4gRG9lcyBub3QgbmVlZCB0byBiZSBzZW50IGlmIGVtcHR5LlxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuY29uc3QgcmVhZFN5bmNNZXNzYWdlID0gKGRlY29kZXIsIGVuY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHtcbiAgY29uc3QgbWVzc2FnZVR5cGUgPSByZWFkVmFyVWludChkZWNvZGVyKTtcbiAgc3dpdGNoIChtZXNzYWdlVHlwZSkge1xuICAgIGNhc2UgbWVzc2FnZVlqc1N5bmNTdGVwMTpcbiAgICAgIHJlYWRTeW5jU3RlcDEoZGVjb2RlciwgZW5jb2RlciwgZG9jKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlWWpzU3luY1N0ZXAyOlxuICAgICAgcmVhZFN5bmNTdGVwMihkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlWWpzVXBkYXRlOlxuICAgICAgcmVhZFVwZGF0ZShkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIHR5cGUnKVxuICB9XG4gIHJldHVybiBtZXNzYWdlVHlwZVxufTtcblxuY2xhc3MgTWVzc2FnZVJlY2VpdmVyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIGFwcGx5KHByb3ZpZGVyLCBlbWl0U3luY2VkKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UucmVhZFZhclVpbnQoKTtcbiAgICAgICAgY29uc3QgZW1wdHlNZXNzYWdlTGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgoKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlN5bmM6XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVN5bmNNZXNzYWdlKHByb3ZpZGVyLCBlbWl0U3luY2VkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQXdhcmVuZXNzOlxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlBd2FyZW5lc3NNZXNzYWdlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQXV0aDpcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5QXV0aE1lc3NhZ2UocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5RdWVyeUF3YXJlbmVzczpcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UXVlcnlBd2FyZW5lc3NNZXNzYWdlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU3RhdGVsZXNzOlxuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlY2VpdmVTdGF0ZWxlc3MocmVhZFZhclN0cmluZyhtZXNzYWdlLmRlY29kZXIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU3luY1N0YXR1czpcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5U3luY1N0YXR1c01lc3NhZ2UocHJvdmlkZXIsIHJlYWRWYXJJbnQobWVzc2FnZS5kZWNvZGVyKSA9PT0gMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNMT1NFOlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAxMDAwLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlYWRWYXJTdHJpbmcobWVzc2FnZS5kZWNvZGVyKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIud2ViU29ja2V0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNsb3NlXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIuY29uZmlndXJhdGlvbi5vbkNsb3NlKHsgZXZlbnQgfSk7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIuZm9yd2FyZENsb3NlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW7igJl0IGFwcGx5IG1lc3NhZ2Ugb2YgdW5rbm93biB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVwbHlcbiAgICAgICAgaWYgKG1lc3NhZ2UubGVuZ3RoKCkgPiBlbXB0eU1lc3NhZ2VMZW5ndGggKyAxKSB7XG4gICAgICAgICAgICAvLyBsZW5ndGggb2YgZG9jdW1lbnROYW1lIChjb25zaWRlcmVkIGluIGVtcHR5TWVzc2FnZUxlbmd0aCBwbHVzIGxlbmd0aCBvZiB5anMgc3luYyB0eXBlLCBzZXQgaW4gYXBwbHlTeW5jTWVzc2FnZSlcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHByb3ZpZGVyLnNlbmQoT3V0Z29pbmdNZXNzYWdlLCB7IGVuY29kZXI6IG1lc3NhZ2UuZW5jb2RlciB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseVN5bmNNZXNzYWdlKHByb3ZpZGVyLCBlbWl0U3luY2VkKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgbWVzc2FnZS53cml0ZVZhclVpbnQoTWVzc2FnZVR5cGUuU3luYyk7XG4gICAgICAgIC8vIEFwcGx5IHVwZGF0ZVxuICAgICAgICBjb25zdCBzeW5jTWVzc2FnZVR5cGUgPSByZWFkU3luY01lc3NhZ2UobWVzc2FnZS5kZWNvZGVyLCBtZXNzYWdlLmVuY29kZXIsIHByb3ZpZGVyLmRvY3VtZW50LCBwcm92aWRlcik7XG4gICAgICAgIC8vIFN5bmNlZCBvbmNlIHdlIHJlY2VpdmUgU3RlcDJcbiAgICAgICAgaWYgKGVtaXRTeW5jZWQgJiYgc3luY01lc3NhZ2VUeXBlID09PSBtZXNzYWdlWWpzU3luY1N0ZXAyKSB7XG4gICAgICAgICAgICBwcm92aWRlci5zeW5jZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5U3luY1N0YXR1c01lc3NhZ2UocHJvdmlkZXIsIGFwcGxpZWQpIHtcbiAgICAgICAgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmRlY3JlbWVudFVuc3luY2VkQ2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5QXdhcmVuZXNzTWVzc2FnZShwcm92aWRlcikge1xuICAgICAgICBpZiAoIXByb3ZpZGVyLmF3YXJlbmVzcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSB0aGlzO1xuICAgICAgICBhcHBseUF3YXJlbmVzc1VwZGF0ZShwcm92aWRlci5hd2FyZW5lc3MsIG1lc3NhZ2UucmVhZFZhclVpbnQ4QXJyYXkoKSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICBhcHBseUF1dGhNZXNzYWdlKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgcmVhZEF1dGhNZXNzYWdlKG1lc3NhZ2UuZGVjb2RlciwgcHJvdmlkZXIuc2VuZFRva2VuLmJpbmQocHJvdmlkZXIpLCBwcm92aWRlci5wZXJtaXNzaW9uRGVuaWVkSGFuZGxlci5iaW5kKHByb3ZpZGVyKSwgcHJvdmlkZXIuYXV0aGVudGljYXRlZEhhbmRsZXIuYmluZChwcm92aWRlcikpO1xuICAgIH1cbiAgICBhcHBseVF1ZXJ5QXdhcmVuZXNzTWVzc2FnZShwcm92aWRlcikge1xuICAgICAgICBpZiAoIXByb3ZpZGVyLmF3YXJlbmVzcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSB0aGlzO1xuICAgICAgICBtZXNzYWdlLndyaXRlVmFyVWludChNZXNzYWdlVHlwZS5Bd2FyZW5lc3MpO1xuICAgICAgICBtZXNzYWdlLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVBd2FyZW5lc3NVcGRhdGUocHJvdmlkZXIuYXdhcmVuZXNzLCBBcnJheS5mcm9tKHByb3ZpZGVyLmF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5rZXlzKCkpKSk7XG4gICAgfVxufVxuXG5jbGFzcyBNZXNzYWdlU2VuZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihNZXNzYWdlLCBhcmdzID0ge30pIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbmV3IE1lc3NhZ2UoKTtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gdGhpcy5tZXNzYWdlLmdldChhcmdzKTtcbiAgICB9XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMuZW5jb2Rlcik7XG4gICAgfVxuICAgIHNlbmQod2ViU29ja2V0KSB7XG4gICAgICAgIHdlYlNvY2tldCA9PT0gbnVsbCB8fCB3ZWJTb2NrZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdlYlNvY2tldC5zZW5kKHRoaXMuY3JlYXRlKCkpO1xuICAgIH1cbn1cblxuY2xhc3MgQXV0aGVudGljYXRpb25NZXNzYWdlIGV4dGVuZHMgT3V0Z29pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gTWVzc2FnZVR5cGUuQXV0aDtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiQXV0aGVudGljYXRpb25cIjtcbiAgICB9XG4gICAgZ2V0KGFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzLnRva2VuID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXV0aGVudGljYXRpb24gbWVzc2FnZSByZXF1aXJlcyBgdG9rZW5gIGFzIGFuIGFyZ3VtZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZVZhclN0cmluZyh0aGlzLmVuY29kZXIsIGFyZ3MuZG9jdW1lbnROYW1lKTtcbiAgICAgICAgd3JpdGVWYXJVaW50KHRoaXMuZW5jb2RlciwgdGhpcy50eXBlKTtcbiAgICAgICAgd3JpdGVBdXRoZW50aWNhdGlvbih0aGlzLmVuY29kZXIsIGFyZ3MudG9rZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyO1xuICAgIH1cbn1cblxuY2xhc3MgQXdhcmVuZXNzTWVzc2FnZSBleHRlbmRzIE91dGdvaW5nTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IE1lc3NhZ2VUeXBlLkF3YXJlbmVzcztcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiQXdhcmVuZXNzIHN0YXRlcyB1cGRhdGVcIjtcbiAgICB9XG4gICAgZ2V0KGFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzLmF3YXJlbmVzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGF3YXJlbmVzcyBtZXNzYWdlIHJlcXVpcmVzIGF3YXJlbmVzcyBhcyBhbiBhcmd1bWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ3MuY2xpZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGF3YXJlbmVzcyBtZXNzYWdlIHJlcXVpcmVzIGNsaWVudHMgYXMgYW4gYXJndW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50TmFtZSk7XG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLmVuY29kZXIsIHRoaXMudHlwZSk7XG4gICAgICAgIGxldCBhd2FyZW5lc3NVcGRhdGU7XG4gICAgICAgIGlmIChhcmdzLnN0YXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhd2FyZW5lc3NVcGRhdGUgPSBlbmNvZGVBd2FyZW5lc3NVcGRhdGUoYXJncy5hd2FyZW5lc3MsIGFyZ3MuY2xpZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FyZW5lc3NVcGRhdGUgPSBlbmNvZGVBd2FyZW5lc3NVcGRhdGUoYXJncy5hd2FyZW5lc3MsIGFyZ3MuY2xpZW50cywgYXJncy5zdGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlVmFyVWludDhBcnJheSh0aGlzLmVuY29kZXIsIGF3YXJlbmVzc1VwZGF0ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZXI7XG4gICAgfVxufVxuXG5jbGFzcyBTdGF0ZWxlc3NNZXNzYWdlIGV4dGVuZHMgT3V0Z29pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gTWVzc2FnZVR5cGUuU3RhdGVsZXNzO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJBIHN0YXRlbGVzcyBtZXNzYWdlXCI7XG4gICAgfVxuICAgIGdldChhcmdzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50TmFtZSk7XG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLmVuY29kZXIsIHRoaXMudHlwZSk7XG4gICAgICAgIHdyaXRlVmFyU3RyaW5nKHRoaXMuZW5jb2RlciwgKF9hID0gYXJncy5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlcjtcbiAgICB9XG59XG5cbmNsYXNzIFN5bmNTdGVwT25lTWVzc2FnZSBleHRlbmRzIE91dGdvaW5nTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IE1lc3NhZ2VUeXBlLlN5bmM7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIkZpcnN0IHN5bmMgc3RlcFwiO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3MuZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzeW5jIHN0ZXAgb25lIG1lc3NhZ2UgcmVxdWlyZXMgZG9jdW1lbnQgYXMgYW4gYXJndW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50TmFtZSk7XG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLmVuY29kZXIsIHRoaXMudHlwZSk7XG4gICAgICAgIHdyaXRlU3luY1N0ZXAxKHRoaXMuZW5jb2RlciwgYXJncy5kb2N1bWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZXI7XG4gICAgfVxufVxuXG5jbGFzcyBVcGRhdGVNZXNzYWdlIGV4dGVuZHMgT3V0Z29pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gTWVzc2FnZVR5cGUuU3luYztcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiQSBkb2N1bWVudCB1cGRhdGVcIjtcbiAgICB9XG4gICAgZ2V0KGFyZ3MpIHtcbiAgICAgICAgd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50TmFtZSk7XG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLmVuY29kZXIsIHRoaXMudHlwZSk7XG4gICAgICAgIHdyaXRlVXBkYXRlKHRoaXMuZW5jb2RlciwgYXJncy51cGRhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyO1xuICAgIH1cbn1cblxuY2xhc3MgQXdhcmVuZXNzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29kZSA9IDEwMDE7XG4gICAgfVxufVxuY2xhc3MgSG9jdXNwb2N1c1Byb3ZpZGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZG9jdW1lbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGF3YXJlbmVzczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICBmb3JjZVN5bmNJbnRlcnZhbDogZmFsc2UsXG4gICAgICAgICAgICBvbkF1dGhlbnRpY2F0ZWQ6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkF1dGhlbnRpY2F0aW9uRmFpbGVkOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25PcGVuOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25Db25uZWN0OiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25NZXNzYWdlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25PdXRnb2luZ01lc3NhZ2U6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvblN5bmNlZDogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uU3RhdHVzOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25EaXNjb25uZWN0OiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uRGVzdHJveTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQXdhcmVuZXNzVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25Bd2FyZW5lc3NDaGFuZ2U6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvblN0YXRlbGVzczogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uVW5zeW5jZWRDaGFuZ2VzOiAoKSA9PiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzU3luY2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudW5zeW5jZWRDaGFuZ2VzID0gMDtcbiAgICAgICAgdGhpcy5pc0F1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRob3JpemVkU2NvcGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLm1hbmFnZVNvY2tldCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzID0ge1xuICAgICAgICAgICAgZm9yY2VTeW5jOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJvdW5kRG9jdW1lbnRVcGRhdGVIYW5kbGVyID0gdGhpcy5kb2N1bWVudFVwZGF0ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ib3VuZEF3YXJlbmVzc1VwZGF0ZUhhbmRsZXIgPSB0aGlzLmF3YXJlbmVzc1VwZGF0ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ib3VuZFBhZ2VIaWRlID0gdGhpcy5wYWdlSGlkZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJvdW5kT25PcGVuID0gdGhpcy5vbk9wZW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ib3VuZE9uQ2xvc2UgPSB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkQ29ubmVjdCA9ICgpID0+IHRoaXMuZW1pdChcImNvbm5lY3RcIik7XG4gICAgICAgIHRoaXMuZm9yd2FyZFN0YXR1cyA9IChlKSA9PiB0aGlzLmVtaXQoXCJzdGF0dXNcIiwgZSk7XG4gICAgICAgIHRoaXMuZm9yd2FyZENsb3NlID0gKGUpID0+IHRoaXMuZW1pdChcImNsb3NlXCIsIGUpO1xuICAgICAgICB0aGlzLmZvcndhcmREaXNjb25uZWN0ID0gKGUpID0+IHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIiwgZSk7XG4gICAgICAgIHRoaXMuZm9yd2FyZERlc3Ryb3kgPSAoKSA9PiB0aGlzLmVtaXQoXCJkZXN0cm95XCIpO1xuICAgICAgICB0aGlzLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5kb2N1bWVudCA9IGNvbmZpZ3VyYXRpb24uZG9jdW1lbnRcbiAgICAgICAgICAgID8gY29uZmlndXJhdGlvbi5kb2N1bWVudFxuICAgICAgICAgICAgOiBuZXcgWS5Eb2MoKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmF3YXJlbmVzcyA9XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uLmF3YXJlbmVzcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBjb25maWd1cmF0aW9uLmF3YXJlbmVzc1xuICAgICAgICAgICAgICAgIDogbmV3IEF3YXJlbmVzcyh0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5vbihcIm9wZW5cIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uT3Blbik7XG4gICAgICAgIHRoaXMub24oXCJtZXNzYWdlXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbk1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm9uKFwib3V0Z29pbmdNZXNzYWdlXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbk91dGdvaW5nTWVzc2FnZSk7XG4gICAgICAgIHRoaXMub24oXCJzeW5jZWRcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uU3luY2VkKTtcbiAgICAgICAgdGhpcy5vbihcImRlc3Ryb3lcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uRGVzdHJveSk7XG4gICAgICAgIHRoaXMub24oXCJhd2FyZW5lc3NVcGRhdGVcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uQXdhcmVuZXNzVXBkYXRlKTtcbiAgICAgICAgdGhpcy5vbihcImF3YXJlbmVzc0NoYW5nZVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25Bd2FyZW5lc3NDaGFuZ2UpO1xuICAgICAgICB0aGlzLm9uKFwic3RhdGVsZXNzXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vblN0YXRlbGVzcyk7XG4gICAgICAgIHRoaXMub24oXCJ1bnN5bmNlZENoYW5nZXNcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uVW5zeW5jZWRDaGFuZ2VzKTtcbiAgICAgICAgdGhpcy5vbihcImF1dGhlbnRpY2F0ZWRcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uQXV0aGVudGljYXRlZCk7XG4gICAgICAgIHRoaXMub24oXCJhdXRoZW50aWNhdGlvbkZhaWxlZFwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25BdXRoZW50aWNhdGlvbkZhaWxlZCk7XG4gICAgICAgIChfYSA9IHRoaXMuYXdhcmVuZXNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub24oXCJ1cGRhdGVcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiYXdhcmVuZXNzVXBkYXRlXCIsIHtcbiAgICAgICAgICAgICAgICBzdGF0ZXM6IGF3YXJlbmVzc1N0YXRlc1RvQXJyYXkodGhpcy5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAoX2IgPSB0aGlzLmF3YXJlbmVzcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9uKFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImF3YXJlbmVzc0NoYW5nZVwiLCB7XG4gICAgICAgICAgICAgICAgc3RhdGVzOiBhd2FyZW5lc3NTdGF0ZXNUb0FycmF5KHRoaXMuYXdhcmVuZXNzLmdldFN0YXRlcygpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5vbihcInVwZGF0ZVwiLCB0aGlzLmJvdW5kRG9jdW1lbnRVcGRhdGVIYW5kbGVyKTtcbiAgICAgICAgKF9jID0gdGhpcy5hd2FyZW5lc3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5vbihcInVwZGF0ZVwiLCB0aGlzLmJvdW5kQXdhcmVuZXNzVXBkYXRlSGFuZGxlcik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpO1xuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLmZvcmNlU3luY0ludGVydmFsICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5jb25maWd1cmF0aW9uLmZvcmNlU3luY0ludGVydmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLmludGVydmFscy5mb3JjZVN5bmMgPSBzZXRJbnRlcnZhbCh0aGlzLmZvcmNlU3luYy5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZ3VyYXRpb24uZm9yY2VTeW5jSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hbmFnZVNvY2tldCkge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24gPSB7fSkge1xuICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHdlYnNvY2tldFByb3ZpZGVyQ29uZmlnID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlU29ja2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlciA9IG5ldyBIb2N1c3BvY3VzUHJvdmlkZXJXZWJzb2NrZXQoe1xuICAgICAgICAgICAgICAgIHVybDogd2Vic29ja2V0UHJvdmlkZXJDb25maWcudXJsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0geyAuLi50aGlzLmNvbmZpZ3VyYXRpb24sIC4uLmNvbmZpZ3VyYXRpb24gfTtcbiAgICB9XG4gICAgZ2V0IGRvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmRvY3VtZW50O1xuICAgIH1cbiAgICBnZXQgaXNBdHRhY2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQXR0YWNoZWQ7XG4gICAgfVxuICAgIGdldCBhd2FyZW5lc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uYXdhcmVuZXNzO1xuICAgIH1cbiAgICBnZXQgaGFzVW5zeW5jZWRDaGFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bnN5bmNlZENoYW5nZXMgPiAwO1xuICAgIH1cbiAgICByZXNldFVuc3luY2VkQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy51bnN5bmNlZENoYW5nZXMgPSAxO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1bnN5bmNlZENoYW5nZXNcIiwgeyBudW1iZXI6IHRoaXMudW5zeW5jZWRDaGFuZ2VzIH0pO1xuICAgIH1cbiAgICBpbmNyZW1lbnRVbnN5bmNlZENoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMudW5zeW5jZWRDaGFuZ2VzICs9IDE7XG4gICAgICAgIHRoaXMuZW1pdChcInVuc3luY2VkQ2hhbmdlc1wiLCB7IG51bWJlcjogdGhpcy51bnN5bmNlZENoYW5nZXMgfSk7XG4gICAgfVxuICAgIGRlY3JlbWVudFVuc3luY2VkQ2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zeW5jZWRDaGFuZ2VzID4gMCkge1xuICAgICAgICAgICAgdGhpcy51bnN5bmNlZENoYW5nZXMgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51bnN5bmNlZENoYW5nZXMgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3luY2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJ1bnN5bmNlZENoYW5nZXNcIiwgeyBudW1iZXI6IHRoaXMudW5zeW5jZWRDaGFuZ2VzIH0pO1xuICAgIH1cbiAgICBmb3JjZVN5bmMoKSB7XG4gICAgICAgIHRoaXMucmVzZXRVbnN5bmNlZENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5zZW5kKFN5bmNTdGVwT25lTWVzc2FnZSwge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IHRoaXMuZG9jdW1lbnQsXG4gICAgICAgICAgICBkb2N1bWVudE5hbWU6IHRoaXMuY29uZmlndXJhdGlvbi5uYW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFnZUhpZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmF3YXJlbmVzcykge1xuICAgICAgICAgICAgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHRoaXMuYXdhcmVuZXNzLCBbdGhpcy5kb2N1bWVudC5jbGllbnRJRF0sIFwicGFnZSBoaWRlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICEoXCJhZGRFdmVudExpc3RlbmVyXCIgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgdGhpcy5ib3VuZFBhZ2VIaWRlKTtcbiAgICB9XG4gICAgc2VuZFN0YXRlbGVzcyhwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuc2VuZChTdGF0ZWxlc3NNZXNzYWdlLCB7XG4gICAgICAgICAgICBkb2N1bWVudE5hbWU6IHRoaXMuY29uZmlndXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUb2tlbigpIHtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdG9rZW4gPSBhd2FpdCB0aGlzLmdldFRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25EZW5pZWRIYW5kbGVyKGBGYWlsZWQgdG8gZ2V0IHRva2VuIGR1cmluZyBzZW5kVG9rZW4oKTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmQoQXV0aGVudGljYXRpb25NZXNzYWdlLCB7XG4gICAgICAgICAgICB0b2tlbjogdG9rZW4gIT09IG51bGwgJiYgdG9rZW4gIT09IHZvaWQgMCA/IHRva2VuIDogXCJcIixcbiAgICAgICAgICAgIGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb2N1bWVudFVwZGF0ZUhhbmRsZXIodXBkYXRlLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5jcmVtZW50VW5zeW5jZWRDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuc2VuZChVcGRhdGVNZXNzYWdlLCB7IHVwZGF0ZSwgZG9jdW1lbnROYW1lOiB0aGlzLmNvbmZpZ3VyYXRpb24ubmFtZSB9KTtcbiAgICB9XG4gICAgYXdhcmVuZXNzVXBkYXRlSGFuZGxlcih7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH0sIG9yaWdpbikge1xuICAgICAgICBjb25zdCBjaGFuZ2VkQ2xpZW50cyA9IGFkZGVkLmNvbmNhdCh1cGRhdGVkKS5jb25jYXQocmVtb3ZlZCk7XG4gICAgICAgIHRoaXMuc2VuZChBd2FyZW5lc3NNZXNzYWdlLCB7XG4gICAgICAgICAgICBhd2FyZW5lc3M6IHRoaXMuYXdhcmVuZXNzLFxuICAgICAgICAgICAgY2xpZW50czogY2hhbmdlZENsaWVudHMsXG4gICAgICAgICAgICBkb2N1bWVudE5hbWU6IHRoaXMuY29uZmlndXJhdGlvbi5uYW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgYSBmaXJzdCBoYW5kc2hha2Ugd2l0aCB0aGUgc2VydmVyIGhhcyBiZWVuIGVzdGFibGlzaGVkXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IG1lYW4gYWxsIHVwZGF0ZXMgZnJvbSB0aGUgY2xpZW50IGhhdmUgYmVlbiBwZXJzaXN0ZWQgdG8gdGhlIGJhY2tlbmQuIEZvciB0aGlzLFxuICAgICAqIHVzZSBgaGFzVW5zeW5jZWRDaGFuZ2VzYC5cbiAgICAgKi9cbiAgICBnZXQgc3luY2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1N5bmNlZDtcbiAgICB9XG4gICAgc2V0IHN5bmNlZChzdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5pc1N5bmNlZCA9PT0gc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3luY2VkID0gc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwic3luY2VkXCIsIHsgc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVjZWl2ZVN0YXRlbGVzcyhwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuZW1pdChcInN0YXRlbGVzc1wiLCB7IHBheWxvYWQgfSk7XG4gICAgfVxuICAgIC8vIG5vdCBuZWVkZWQsIGJ1dCBwcm92aWRlcyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggZS5nLiBsZXhpY2FsL3lqc1xuICAgIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hbmFnZVNvY2tldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKFwiSG9jdXNwb2N1c1Byb3ZpZGVyOjpjb25uZWN0KCkgaXMgZGVwcmVjYXRlZCBhbmQgZG9lcyBub3QgZG8gYW55dGhpbmcuIFBsZWFzZSBjb25uZWN0L2Rpc2Nvbm5lY3Qgb24gdGhlIHdlYnNvY2tldFByb3ZpZGVyLCBvciBhdHRhY2gvZGVhdHRhY2ggcHJvdmlkZXJzLlwiKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlU29ja2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oXCJIb2N1c3BvY3VzUHJvdmlkZXI6OmRpc2Nvbm5lY3QoKSBpcyBkZXByZWNhdGVkIGFuZCBkb2VzIG5vdCBkbyBhbnl0aGluZy4gUGxlYXNlIGNvbm5lY3QvZGlzY29ubmVjdCBvbiB0aGUgd2Vic29ja2V0UHJvdmlkZXIsIG9yIGF0dGFjaC9kZWF0dGFjaCBwcm92aWRlcnMuXCIpO1xuICAgIH1cbiAgICBhc3luYyBvbk9wZW4oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5pc0F1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KFwib3BlblwiLCB7IGV2ZW50IH0pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRUb2tlbigpO1xuICAgICAgICB0aGlzLnN0YXJ0U3luYygpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUb2tlbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZ3VyYXRpb24udG9rZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmNvbmZpZ3VyYXRpb24udG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnRva2VuO1xuICAgIH1cbiAgICBzdGFydFN5bmMoKSB7XG4gICAgICAgIHRoaXMucmVzZXRVbnN5bmNlZENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5zZW5kKFN5bmNTdGVwT25lTWVzc2FnZSwge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IHRoaXMuZG9jdW1lbnQsXG4gICAgICAgICAgICBkb2N1bWVudE5hbWU6IHRoaXMuY29uZmlndXJhdGlvbi5uYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuYXdhcmVuZXNzICYmIHRoaXMuYXdhcmVuZXNzLmdldExvY2FsU3RhdGUoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kKEF3YXJlbmVzc01lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBhd2FyZW5lc3M6IHRoaXMuYXdhcmVuZXNzLFxuICAgICAgICAgICAgICAgIGNsaWVudHM6IFt0aGlzLmRvY3VtZW50LmNsaWVudElEXSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudE5hbWU6IHRoaXMuY29uZmlndXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZChtZXNzYWdlLCBhcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNBdHRhY2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWVzc2FnZVNlbmRlciA9IG5ldyBNZXNzYWdlU2VuZGVyKG1lc3NhZ2UsIGFyZ3MpO1xuICAgICAgICB0aGlzLmVtaXQoXCJvdXRnb2luZ01lc3NhZ2VcIiwgeyBtZXNzYWdlOiBtZXNzYWdlU2VuZGVyLm1lc3NhZ2UgfSk7XG4gICAgICAgIG1lc3NhZ2VTZW5kZXIuc2VuZCh0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIpO1xuICAgIH1cbiAgICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50TmFtZSA9IG1lc3NhZ2UucmVhZFZhclN0cmluZygpO1xuICAgICAgICBtZXNzYWdlLndyaXRlVmFyU3RyaW5nKGRvY3VtZW50TmFtZSk7XG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgeyBldmVudCwgbWVzc2FnZTogbmV3IEluY29taW5nTWVzc2FnZShldmVudC5kYXRhKSB9KTtcbiAgICAgICAgbmV3IE1lc3NhZ2VSZWNlaXZlcihtZXNzYWdlKS5hcHBseSh0aGlzLCB0cnVlKTtcbiAgICB9XG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5pc0F1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gdXBkYXRlIGF3YXJlbmVzcyAoYWxsIHVzZXJzIGV4Y2VwdCBsb2NhbCBsZWZ0KVxuICAgICAgICBpZiAodGhpcy5hd2FyZW5lc3MpIHtcbiAgICAgICAgICAgIHJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLmF3YXJlbmVzcywgQXJyYXkuZnJvbSh0aGlzLmF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5rZXlzKCkpLmZpbHRlcigoY2xpZW50KSA9PiBjbGllbnQgIT09IHRoaXMuZG9jdW1lbnQuY2xpZW50SUQpLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIpO1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbHMuZm9yY2VTeW5jKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxzLmZvcmNlU3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXdhcmVuZXNzKSB7XG4gICAgICAgICAgICByZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcy5hd2FyZW5lc3MsIFt0aGlzLmRvY3VtZW50LmNsaWVudElEXSwgXCJwcm92aWRlciBkZXN0cm95XCIpO1xuICAgICAgICAgICAgdGhpcy5hd2FyZW5lc3Mub2ZmKFwidXBkYXRlXCIsIHRoaXMuYm91bmRBd2FyZW5lc3NVcGRhdGVIYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMuYXdhcmVuZXNzLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvY3VtZW50Lm9mZihcInVwZGF0ZVwiLCB0aGlzLmJvdW5kRG9jdW1lbnRVcGRhdGVIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlU29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICEoXCJyZW1vdmVFdmVudExpc3RlbmVyXCIgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgdGhpcy5ib3VuZFBhZ2VIaWRlKTtcbiAgICB9XG4gICAgZGV0YWNoKCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub2ZmKFwiY29ubmVjdFwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25Db25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZihcImNvbm5lY3RcIiwgdGhpcy5mb3J3YXJkQ29ubmVjdCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoXCJzdGF0dXNcIiwgdGhpcy5mb3J3YXJkU3RhdHVzKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZihcInN0YXR1c1wiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25TdGF0dXMpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub2ZmKFwib3BlblwiLCB0aGlzLmJvdW5kT25PcGVuKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZihcImNsb3NlXCIsIHRoaXMuYm91bmRPbkNsb3NlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZihcImNsb3NlXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkNsb3NlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZihcImNsb3NlXCIsIHRoaXMuZm9yd2FyZENsb3NlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZihcImRpc2Nvbm5lY3RcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uRGlzY29ubmVjdCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoXCJkaXNjb25uZWN0XCIsIHRoaXMuZm9yd2FyZERpc2Nvbm5lY3QpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub2ZmKFwiZGVzdHJveVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25EZXN0cm95KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZihcImRlc3Ryb3lcIiwgdGhpcy5mb3J3YXJkRGVzdHJveSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5kZXRhY2godGhpcyk7XG4gICAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYXR0YWNoKCkge1xuICAgICAgICBpZiAodGhpcy5faXNBdHRhY2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKFwiY29ubmVjdFwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25Db25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKFwiY29ubmVjdFwiLCB0aGlzLmZvcndhcmRDb25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKFwic3RhdHVzXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vblN0YXR1cyk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vbihcInN0YXR1c1wiLCB0aGlzLmZvcndhcmRTdGF0dXMpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oXCJvcGVuXCIsIHRoaXMuYm91bmRPbk9wZW4pO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oXCJjbG9zZVwiLCB0aGlzLmJvdW5kT25DbG9zZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vbihcImNsb3NlXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkNsb3NlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKFwiY2xvc2VcIiwgdGhpcy5mb3J3YXJkQ2xvc2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oXCJkaXNjb25uZWN0XCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkRpc2Nvbm5lY3QpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oXCJkaXNjb25uZWN0XCIsIHRoaXMuZm9yd2FyZERpc2Nvbm5lY3QpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oXCJkZXN0cm95XCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkRlc3Ryb3kpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oXCJkZXN0cm95XCIsIHRoaXMuZm9yd2FyZERlc3Ryb3kpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIuYXR0YWNoKHRoaXMpO1xuICAgICAgICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcGVybWlzc2lvbkRlbmllZEhhbmRsZXIocmVhc29uKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImF1dGhlbnRpY2F0aW9uRmFpbGVkXCIsIHsgcmVhc29uIH0pO1xuICAgICAgICB0aGlzLmlzQXV0aGVudGljYXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBhdXRoZW50aWNhdGVkSGFuZGxlcihzY29wZSkge1xuICAgICAgICB0aGlzLmlzQXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXV0aG9yaXplZFNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuZW1pdChcImF1dGhlbnRpY2F0ZWRcIiwgeyBzY29wZSB9KTtcbiAgICB9XG4gICAgc2V0QXdhcmVuZXNzRmllbGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYXdhcmVuZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXdhcmVuZXNzRXJyb3IoYENhbm5vdCBzZXQgYXdhcmVuZXNzIGZpZWxkIFwiJHtrZXl9XCIgdG8gJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LiBZb3UgaGF2ZSBkaXNhYmxlZCBBd2FyZW5lc3MgZm9yIHRoaXMgcHJvdmlkZXIgYnkgZXhwbGljaXRseSBwYXNzaW5nIGF3YXJlbmVzczogbnVsbCBpbiB0aGUgcHJvdmlkZXIgY29uZmlndXJhdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoa2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBd2FyZW5lc3NFcnJvciwgSG9jdXNwb2N1c1Byb3ZpZGVyLCBIb2N1c3BvY3VzUHJvdmlkZXJXZWJzb2NrZXQsIE1lc3NhZ2VUeXBlLCBXZWJTb2NrZXRTdGF0dXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvY3VzcG9jdXMtcHJvdmlkZXIuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lifeomic/attempt/dist/es6/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lifeomic/attempt/dist/es6/src/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultCalculateDelay: () => (/* binding */ defaultCalculateDelay),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\nfunction applyDefaults(options) {\n    if (!options) {\n        options = {};\n    }\n    return {\n        delay: (options.delay === undefined) ? 200 : options.delay,\n        initialDelay: (options.initialDelay === undefined) ? 0 : options.initialDelay,\n        minDelay: (options.minDelay === undefined) ? 0 : options.minDelay,\n        maxDelay: (options.maxDelay === undefined) ? 0 : options.maxDelay,\n        factor: (options.factor === undefined) ? 0 : options.factor,\n        maxAttempts: (options.maxAttempts === undefined) ? 3 : options.maxAttempts,\n        timeout: (options.timeout === undefined) ? 0 : options.timeout,\n        jitter: (options.jitter === true),\n        initialJitter: (options.initialJitter === true),\n        handleError: (options.handleError === undefined) ? null : options.handleError,\n        handleTimeout: (options.handleTimeout === undefined) ? null : options.handleTimeout,\n        beforeAttempt: (options.beforeAttempt === undefined) ? null : options.beforeAttempt,\n        calculateDelay: (options.calculateDelay === undefined) ? null : options.calculateDelay\n    };\n}\nasync function sleep(delay) {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n}\nfunction defaultCalculateDelay(context, options) {\n    let delay = options.delay;\n    if (delay === 0) {\n        // no delay between attempts\n        return 0;\n    }\n    if (options.factor) {\n        delay *= Math.pow(options.factor, context.attemptNum - 1);\n        if (options.maxDelay !== 0) {\n            delay = Math.min(delay, options.maxDelay);\n        }\n    }\n    if (options.jitter) {\n        // Jitter will result in a random value between `minDelay` and\n        // calculated delay for a given attempt.\n        // See https://www.awsarchitectureblog.com/2015/03/backoff.html\n        // We're using the \"full jitter\" strategy.\n        const min = Math.ceil(options.minDelay);\n        const max = Math.floor(delay);\n        delay = Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return Math.round(delay);\n}\nasync function retry(attemptFunc, attemptOptions) {\n    const options = applyDefaults(attemptOptions);\n    for (const prop of [\n        'delay',\n        'initialDelay',\n        'minDelay',\n        'maxDelay',\n        'maxAttempts',\n        'timeout'\n    ]) {\n        const value = options[prop];\n        if (!Number.isInteger(value) || (value < 0)) {\n            throw new Error(`Value for ${prop} must be an integer greater than or equal to 0`);\n        }\n    }\n    if ((options.factor.constructor !== Number) || (options.factor < 0)) {\n        throw new Error(`Value for factor must be a number greater than or equal to 0`);\n    }\n    if (options.delay < options.minDelay) {\n        throw new Error(`delay cannot be less than minDelay (delay: ${options.delay}, minDelay: ${options.minDelay}`);\n    }\n    const context = {\n        attemptNum: 0,\n        attemptsRemaining: options.maxAttempts ? options.maxAttempts : -1,\n        aborted: false,\n        abort() {\n            context.aborted = true;\n        }\n    };\n    const calculateDelay = options.calculateDelay || defaultCalculateDelay;\n    async function makeAttempt() {\n        if (options.beforeAttempt) {\n            options.beforeAttempt(context, options);\n        }\n        if (context.aborted) {\n            const err = new Error(`Attempt aborted`);\n            err.code = 'ATTEMPT_ABORTED';\n            throw err;\n        }\n        const onError = async (err) => {\n            if (options.handleError) {\n                await options.handleError(err, context, options);\n            }\n            if (context.aborted || (context.attemptsRemaining === 0)) {\n                throw err;\n            }\n            // We are about to try again so increment attempt number\n            context.attemptNum++;\n            const delay = calculateDelay(context, options);\n            if (delay) {\n                await sleep(delay);\n            }\n            return makeAttempt();\n        };\n        if (context.attemptsRemaining > 0) {\n            context.attemptsRemaining--;\n        }\n        if (options.timeout) {\n            return new Promise((resolve, reject) => {\n                const timer = setTimeout(() => {\n                    if (options.handleTimeout) {\n                        // If calling handleTimeout throws an error that is not wrapped in a promise\n                        // we want to catch the error and reject.\n                        try {\n                            resolve(options.handleTimeout(context, options));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                    }\n                    else {\n                        const err = new Error(`Retry timeout (attemptNum: ${context.attemptNum}, timeout: ${options.timeout})`);\n                        err.code = 'ATTEMPT_TIMEOUT';\n                        reject(err);\n                    }\n                }, options.timeout);\n                attemptFunc(context, options).then((result) => {\n                    clearTimeout(timer);\n                    resolve(result);\n                }).catch((err) => {\n                    clearTimeout(timer);\n                    // Calling resolve with a Promise that rejects here will result\n                    // in an unhandled rejection. Calling `reject` with errors\n                    // does not result in an unhandled rejection\n                    onError(err).then(resolve).catch(reject);\n                });\n            });\n        }\n        else {\n            // No timeout provided so wait indefinitely for the returned promise\n            // to be resolved.\n            return attemptFunc(context, options).catch(onError);\n        }\n    }\n    const initialDelay = options.calculateDelay\n        ? options.calculateDelay(context, options)\n        : options.initialDelay;\n    if (initialDelay) {\n        await sleep(initialDelay);\n    }\n    if (context.attemptNum < 1 && options.initialJitter) {\n        const delay = calculateDelay(context, options);\n        if (delay) {\n            await sleep(delay);\n        }\n    }\n    return makeAttempt();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGlmZW9taWMvYXR0ZW1wdC9kaXN0L2VzNi9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsY0FBYyxjQUFjLGlCQUFpQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsbUJBQW1CLGFBQWEsZ0JBQWdCO0FBQzVIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXJ5YW5nb3lhbC9yZWFsLXRpbWUtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0BsaWZlb21pYy9hdHRlbXB0L2Rpc3QvZXM2L3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhcHBseURlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheTogKG9wdGlvbnMuZGVsYXkgPT09IHVuZGVmaW5lZCkgPyAyMDAgOiBvcHRpb25zLmRlbGF5LFxuICAgICAgICBpbml0aWFsRGVsYXk6IChvcHRpb25zLmluaXRpYWxEZWxheSA9PT0gdW5kZWZpbmVkKSA/IDAgOiBvcHRpb25zLmluaXRpYWxEZWxheSxcbiAgICAgICAgbWluRGVsYXk6IChvcHRpb25zLm1pbkRlbGF5ID09PSB1bmRlZmluZWQpID8gMCA6IG9wdGlvbnMubWluRGVsYXksXG4gICAgICAgIG1heERlbGF5OiAob3B0aW9ucy5tYXhEZWxheSA9PT0gdW5kZWZpbmVkKSA/IDAgOiBvcHRpb25zLm1heERlbGF5LFxuICAgICAgICBmYWN0b3I6IChvcHRpb25zLmZhY3RvciA9PT0gdW5kZWZpbmVkKSA/IDAgOiBvcHRpb25zLmZhY3RvcixcbiAgICAgICAgbWF4QXR0ZW1wdHM6IChvcHRpb25zLm1heEF0dGVtcHRzID09PSB1bmRlZmluZWQpID8gMyA6IG9wdGlvbnMubWF4QXR0ZW1wdHMsXG4gICAgICAgIHRpbWVvdXQ6IChvcHRpb25zLnRpbWVvdXQgPT09IHVuZGVmaW5lZCkgPyAwIDogb3B0aW9ucy50aW1lb3V0LFxuICAgICAgICBqaXR0ZXI6IChvcHRpb25zLmppdHRlciA9PT0gdHJ1ZSksXG4gICAgICAgIGluaXRpYWxKaXR0ZXI6IChvcHRpb25zLmluaXRpYWxKaXR0ZXIgPT09IHRydWUpLFxuICAgICAgICBoYW5kbGVFcnJvcjogKG9wdGlvbnMuaGFuZGxlRXJyb3IgPT09IHVuZGVmaW5lZCkgPyBudWxsIDogb3B0aW9ucy5oYW5kbGVFcnJvcixcbiAgICAgICAgaGFuZGxlVGltZW91dDogKG9wdGlvbnMuaGFuZGxlVGltZW91dCA9PT0gdW5kZWZpbmVkKSA/IG51bGwgOiBvcHRpb25zLmhhbmRsZVRpbWVvdXQsXG4gICAgICAgIGJlZm9yZUF0dGVtcHQ6IChvcHRpb25zLmJlZm9yZUF0dGVtcHQgPT09IHVuZGVmaW5lZCkgPyBudWxsIDogb3B0aW9ucy5iZWZvcmVBdHRlbXB0LFxuICAgICAgICBjYWxjdWxhdGVEZWxheTogKG9wdGlvbnMuY2FsY3VsYXRlRGVsYXkgPT09IHVuZGVmaW5lZCkgPyBudWxsIDogb3B0aW9ucy5jYWxjdWxhdGVEZWxheVxuICAgIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2xlZXAoZGVsYXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0Q2FsY3VsYXRlRGVsYXkoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGxldCBkZWxheSA9IG9wdGlvbnMuZGVsYXk7XG4gICAgaWYgKGRlbGF5ID09PSAwKSB7XG4gICAgICAgIC8vIG5vIGRlbGF5IGJldHdlZW4gYXR0ZW1wdHNcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZhY3Rvcikge1xuICAgICAgICBkZWxheSAqPSBNYXRoLnBvdyhvcHRpb25zLmZhY3RvciwgY29udGV4dC5hdHRlbXB0TnVtIC0gMSk7XG4gICAgICAgIGlmIChvcHRpb25zLm1heERlbGF5ICE9PSAwKSB7XG4gICAgICAgICAgICBkZWxheSA9IE1hdGgubWluKGRlbGF5LCBvcHRpb25zLm1heERlbGF5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5qaXR0ZXIpIHtcbiAgICAgICAgLy8gSml0dGVyIHdpbGwgcmVzdWx0IGluIGEgcmFuZG9tIHZhbHVlIGJldHdlZW4gYG1pbkRlbGF5YCBhbmRcbiAgICAgICAgLy8gY2FsY3VsYXRlZCBkZWxheSBmb3IgYSBnaXZlbiBhdHRlbXB0LlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly93d3cuYXdzYXJjaGl0ZWN0dXJlYmxvZy5jb20vMjAxNS8wMy9iYWNrb2ZmLmh0bWxcbiAgICAgICAgLy8gV2UncmUgdXNpbmcgdGhlIFwiZnVsbCBqaXR0ZXJcIiBzdHJhdGVneS5cbiAgICAgICAgY29uc3QgbWluID0gTWF0aC5jZWlsKG9wdGlvbnMubWluRGVsYXkpO1xuICAgICAgICBjb25zdCBtYXggPSBNYXRoLmZsb29yKGRlbGF5KTtcbiAgICAgICAgZGVsYXkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5yb3VuZChkZWxheSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV0cnkoYXR0ZW1wdEZ1bmMsIGF0dGVtcHRPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdHMoYXR0ZW1wdE9wdGlvbnMpO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBbXG4gICAgICAgICdkZWxheScsXG4gICAgICAgICdpbml0aWFsRGVsYXknLFxuICAgICAgICAnbWluRGVsYXknLFxuICAgICAgICAnbWF4RGVsYXknLFxuICAgICAgICAnbWF4QXR0ZW1wdHMnLFxuICAgICAgICAndGltZW91dCdcbiAgICBdKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1twcm9wXTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCAodmFsdWUgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBmb3IgJHtwcm9wfSBtdXN0IGJlIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDBgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKG9wdGlvbnMuZmFjdG9yLmNvbnN0cnVjdG9yICE9PSBOdW1iZXIpIHx8IChvcHRpb25zLmZhY3RvciA8IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgZm9yIGZhY3RvciBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwYCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRlbGF5IDwgb3B0aW9ucy5taW5EZWxheSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRlbGF5IGNhbm5vdCBiZSBsZXNzIHRoYW4gbWluRGVsYXkgKGRlbGF5OiAke29wdGlvbnMuZGVsYXl9LCBtaW5EZWxheTogJHtvcHRpb25zLm1pbkRlbGF5fWApO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBhdHRlbXB0TnVtOiAwLFxuICAgICAgICBhdHRlbXB0c1JlbWFpbmluZzogb3B0aW9ucy5tYXhBdHRlbXB0cyA/IG9wdGlvbnMubWF4QXR0ZW1wdHMgOiAtMSxcbiAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgY29udGV4dC5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2FsY3VsYXRlRGVsYXkgPSBvcHRpb25zLmNhbGN1bGF0ZURlbGF5IHx8IGRlZmF1bHRDYWxjdWxhdGVEZWxheTtcbiAgICBhc3luYyBmdW5jdGlvbiBtYWtlQXR0ZW1wdCgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYmVmb3JlQXR0ZW1wdCkge1xuICAgICAgICAgICAgb3B0aW9ucy5iZWZvcmVBdHRlbXB0KGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgQXR0ZW1wdCBhYm9ydGVkYCk7XG4gICAgICAgICAgICBlcnIuY29kZSA9ICdBVFRFTVBUX0FCT1JURUQnO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSBhc3luYyAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVFcnJvcikge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9wdGlvbnMuaGFuZGxlRXJyb3IoZXJyLCBjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZXh0LmFib3J0ZWQgfHwgKGNvbnRleHQuYXR0ZW1wdHNSZW1haW5pbmcgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgYXJlIGFib3V0IHRvIHRyeSBhZ2FpbiBzbyBpbmNyZW1lbnQgYXR0ZW1wdCBudW1iZXJcbiAgICAgICAgICAgIGNvbnRleHQuYXR0ZW1wdE51bSsrO1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBjYWxjdWxhdGVEZWxheShjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlQXR0ZW1wdCgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY29udGV4dC5hdHRlbXB0c1JlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQuYXR0ZW1wdHNSZW1haW5pbmctLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhhbmRsZVRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGNhbGxpbmcgaGFuZGxlVGltZW91dCB0aHJvd3MgYW4gZXJyb3IgdGhhdCBpcyBub3Qgd3JhcHBlZCBpbiBhIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gY2F0Y2ggdGhlIGVycm9yIGFuZCByZWplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3B0aW9ucy5oYW5kbGVUaW1lb3V0KGNvbnRleHQsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBSZXRyeSB0aW1lb3V0IChhdHRlbXB0TnVtOiAke2NvbnRleHQuYXR0ZW1wdE51bX0sIHRpbWVvdXQ6ICR7b3B0aW9ucy50aW1lb3V0fSlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gJ0FUVEVNUFRfVElNRU9VVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdEZ1bmMoY29udGV4dCwgb3B0aW9ucykudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGxpbmcgcmVzb2x2ZSB3aXRoIGEgUHJvbWlzZSB0aGF0IHJlamVjdHMgaGVyZSB3aWxsIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uLiBDYWxsaW5nIGByZWplY3RgIHdpdGggZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IHJlc3VsdCBpbiBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIHRpbWVvdXQgcHJvdmlkZWQgc28gd2FpdCBpbmRlZmluaXRlbHkgZm9yIHRoZSByZXR1cm5lZCBwcm9taXNlXG4gICAgICAgICAgICAvLyB0byBiZSByZXNvbHZlZC5cbiAgICAgICAgICAgIHJldHVybiBhdHRlbXB0RnVuYyhjb250ZXh0LCBvcHRpb25zKS5jYXRjaChvbkVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbml0aWFsRGVsYXkgPSBvcHRpb25zLmNhbGN1bGF0ZURlbGF5XG4gICAgICAgID8gb3B0aW9ucy5jYWxjdWxhdGVEZWxheShjb250ZXh0LCBvcHRpb25zKVxuICAgICAgICA6IG9wdGlvbnMuaW5pdGlhbERlbGF5O1xuICAgIGlmIChpbml0aWFsRGVsYXkpIHtcbiAgICAgICAgYXdhaXQgc2xlZXAoaW5pdGlhbERlbGF5KTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuYXR0ZW1wdE51bSA8IDEgJiYgb3B0aW9ucy5pbml0aWFsSml0dGVyKSB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gY2FsY3VsYXRlRGVsYXkoY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoZGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYWtlQXR0ZW1wdCgpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lifeomic/attempt/dist/es6/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsiL1VzZXJzL2FyeWFuZ295YWwvcmVhbC10aW1lLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbic7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/documents/[documentId]/editor.tsx":
/*!***************************************************!*\
  !*** ./src/app/documents/[documentId]/editor.tsx ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ Editor)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _tiptap_react__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @tiptap/react */ \"(app-pages-browser)/./node_modules/@tiptap/react/dist/index.js\");\n/* harmony import */ var _tiptap_starter_kit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/starter-kit */ \"(app-pages-browser)/./node_modules/@tiptap/starter-kit/dist/index.js\");\n/* harmony import */ var _tiptap_extension_task_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-task-list */ \"(app-pages-browser)/./node_modules/@tiptap/extension-task-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_task_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-task-item */ \"(app-pages-browser)/./node_modules/@tiptap/extension-task-item/dist/index.js\");\n/* harmony import */ var _tiptap_extension_table__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-table */ \"(app-pages-browser)/./node_modules/@tiptap/extension-table/dist/index.js\");\n/* harmony import */ var _tiptap_extension_table_cell__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-table-cell */ \"(app-pages-browser)/./node_modules/@tiptap/extension-table-cell/dist/index.js\");\n/* harmony import */ var _tiptap_extension_font_family__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-font-family */ \"(app-pages-browser)/./node_modules/@tiptap/extension-font-family/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text_style__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-text-style */ \"(app-pages-browser)/./node_modules/@tiptap/extension-text-style/dist/index.js\");\n/* harmony import */ var _tiptap_extension_table_header__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-table-header */ \"(app-pages-browser)/./node_modules/@tiptap/extension-table-header/dist/index.js\");\n/* harmony import */ var _tiptap_extension_table_row__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-table-row */ \"(app-pages-browser)/./node_modules/@tiptap/extension-table-row/dist/index.js\");\n/* harmony import */ var _tiptap_extension_image__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-image */ \"(app-pages-browser)/./node_modules/@tiptap/extension-image/dist/index.js\");\n/* harmony import */ var tiptap_extension_resize_image__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! tiptap-extension-resize-image */ \"(app-pages-browser)/./node_modules/tiptap-extension-resize-image/esm/index.js\");\n/* harmony import */ var _tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-underline */ \"(app-pages-browser)/./node_modules/@tiptap/extension-underline/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-strike */ \"(app-pages-browser)/./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text_align__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-text-align */ \"(app-pages-browser)/./node_modules/@tiptap/extension-text-align/dist/index.js\");\n/* harmony import */ var _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extension-horizontal-rule */ \"(app-pages-browser)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\");\n/* harmony import */ var _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/extension-link */ \"(app-pages-browser)/./node_modules/@tiptap/extension-link/dist/index.js\");\n/* harmony import */ var _tiptap_extension_color__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tiptap/extension-color */ \"(app-pages-browser)/./node_modules/@tiptap/extension-color/dist/index.js\");\n/* harmony import */ var _tiptap_extension_highlight__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tiptap/extension-highlight */ \"(app-pages-browser)/./node_modules/@tiptap/extension-highlight/dist/index.js\");\n/* harmony import */ var _store_use_editor_store__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @/store/use-editor-store */ \"(app-pages-browser)/./src/store/use-editor-store.ts\");\n/* harmony import */ var _extensions_line_height__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @/extensions/line-height */ \"(app-pages-browser)/./src/extensions/line-height.ts\");\n/* harmony import */ var _extensions_font_size__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @/extensions/font-size */ \"(app-pages-browser)/./src/extensions/font-size.ts\");\n/* harmony import */ var _tiptap_extension_collaboration__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @tiptap/extension-collaboration */ \"(app-pages-browser)/./node_modules/@tiptap/extension-collaboration/dist/index.js\");\n/* harmony import */ var _tiptap_extension_collaboration_cursor__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @tiptap/extension-collaboration-cursor */ \"(app-pages-browser)/./node_modules/@tiptap/extension-collaboration-cursor/dist/index.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! yjs */ \"(app-pages-browser)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _hocuspocus_provider__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @hocuspocus/provider */ \"(app-pages-browser)/./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_25__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* __next_internal_client_entry_do_not_use__ Editor auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst Editor = ()=>{\n    _s();\n    const params = (0,next_navigation__WEBPACK_IMPORTED_MODULE_26__.useParams)();\n    const documentId = params === null || params === void 0 ? void 0 : params.documentId;\n    const [provider, setProvider] = (0,react__WEBPACK_IMPORTED_MODULE_25__.useState)(null);\n    const { setEditor } = (0,_store_use_editor_store__WEBPACK_IMPORTED_MODULE_19__.useEditorStore)();\n    // Initialize Yjs document and Hocuspocus provider\n    (0,react__WEBPACK_IMPORTED_MODULE_25__.useEffect)({\n        \"Editor.useEffect\": ()=>{\n            if (!documentId) return;\n            const yDoc = new yjs__WEBPACK_IMPORTED_MODULE_27__.Doc();\n            const yProvider = new _hocuspocus_provider__WEBPACK_IMPORTED_MODULE_24__.HocuspocusProvider({\n                url: 'ws://localhost:1234',\n                name: documentId,\n                document: yDoc\n            });\n            setProvider(yProvider);\n            return ({\n                \"Editor.useEffect\": ()=>{\n                    yProvider === null || yProvider === void 0 ? void 0 : yProvider.destroy();\n                    yDoc === null || yDoc === void 0 ? void 0 : yDoc.destroy();\n                }\n            })[\"Editor.useEffect\"];\n        }\n    }[\"Editor.useEffect\"], [\n        documentId\n    ]);\n    const editor = (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_28__.useEditor)({\n        immediatelyRender: false,\n        onCreate (param) {\n            let { editor } = param;\n            setEditor(editor);\n        },\n        onDestroy () {\n            setEditor(null);\n        },\n        onUpdate (param) {\n            let { editor } = param;\n            setEditor(editor);\n        },\n        onSelectionUpdate (param) {\n            let { editor } = param;\n            setEditor(editor);\n        },\n        onTransaction (param) {\n            let { editor } = param;\n            setEditor(editor);\n        },\n        onFocus (param) {\n            let { editor } = param;\n            setEditor(editor);\n        },\n        onBlur (param) {\n            let { editor } = param;\n            setEditor(editor);\n        },\n        onContentError (param) {\n            let { editor } = param;\n            setEditor(editor);\n        },\n        editorProps: {\n            attributes: {\n                style: \"padding-left:56px; padding-right:56px;\",\n                class: \"tiptap focus:outline-none print:border-0 bg-white border border-[#C7C7C7] flex flex-col min-h-[1054px] w-[816px] pt-10 pr-14 pb-10 cursor-text\"\n            }\n        },\n        extensions: [\n            _tiptap_starter_kit__WEBPACK_IMPORTED_MODULE_1__[\"default\"].configure({\n                // Disable history extension as Yjs handles undo/redo\n                history: false\n            }),\n            _tiptap_extension_task_item__WEBPACK_IMPORTED_MODULE_3__[\"default\"].configure({\n                nested: true\n            }),\n            _tiptap_extension_font_family__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n            _tiptap_extension_text_style__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n            _tiptap_extension_task_list__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n            _tiptap_extension_table__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n            _tiptap_extension_table_cell__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n            _tiptap_extension_table_header__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n            _tiptap_extension_table_row__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n            _tiptap_extension_image__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\n            tiptap_extension_resize_image__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n            _tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\n            _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\n            _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_16__[\"default\"].configure({\n                openOnClick: false,\n                autolink: true,\n                defaultProtocol: \"https\"\n            }),\n            _tiptap_extension_color__WEBPACK_IMPORTED_MODULE_17__.Color,\n            _tiptap_extension_highlight__WEBPACK_IMPORTED_MODULE_18__[\"default\"].configure({\n                multicolor: true\n            }),\n            _tiptap_extension_text_align__WEBPACK_IMPORTED_MODULE_14__[\"default\"].configure({\n                types: [\n                    'heading',\n                    'paragraph'\n                ]\n            }),\n            _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_15__[\"default\"],\n            _extensions_line_height__WEBPACK_IMPORTED_MODULE_20__.LineHeightExtension.configure({\n                types: [\n                    \"heading\",\n                    \"paragraph\"\n                ],\n                defaultLineHeight: \"normal\"\n            }),\n            _extensions_font_size__WEBPACK_IMPORTED_MODULE_21__.FontSizeExtension,\n            // Collaboration extensions\n            ...provider ? [\n                _tiptap_extension_collaboration__WEBPACK_IMPORTED_MODULE_22__[\"default\"].configure({\n                    document: provider.document\n                }),\n                _tiptap_extension_collaboration_cursor__WEBPACK_IMPORTED_MODULE_23__[\"default\"].configure({\n                    provider: provider,\n                    user: {\n                        name: \"User \".concat(Math.floor(Math.random() * 1000)),\n                        color: \"#\".concat(Math.floor(Math.random() * 16777215).toString(16))\n                    }\n                })\n            ] : []\n        ],\n        content: \"\\n      hello everyone\\n      \"\n    }, [\n        provider\n    ]);\n    if (!editor) return null;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"h-screen flex flex-col overflow-hidden\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n            className: \"size-full overflow-x-auto bg-[#F9FBFD] px-4 print:p-0 print:bg-white print:overflow-visible]\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"min-w-max justify-center w-[816px] py-4 print:py-0 mx-auto print:w-full print:min-w-0\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tiptap_react__WEBPACK_IMPORTED_MODULE_28__.EditorContent, {\n                    editor: editor\n                }, void 0, false, {\n                    fileName: \"/Users/aryangoyal/real-time-text-editor/src/app/documents/[documentId]/editor.tsx\",\n                    lineNumber: 151,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/aryangoyal/real-time-text-editor/src/app/documents/[documentId]/editor.tsx\",\n                lineNumber: 150,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/aryangoyal/real-time-text-editor/src/app/documents/[documentId]/editor.tsx\",\n            lineNumber: 149,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/aryangoyal/real-time-text-editor/src/app/documents/[documentId]/editor.tsx\",\n        lineNumber: 147,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Editor, \"ncRm0omjYBJNIUfHYPiKLDvsobI=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_26__.useParams,\n        _store_use_editor_store__WEBPACK_IMPORTED_MODULE_19__.useEditorStore,\n        _tiptap_react__WEBPACK_IMPORTED_MODULE_28__.useEditor\n    ];\n});\n_c = Editor;\nvar _c;\n$RefreshReg$(_c, \"Editor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZG9jdW1lbnRzL1tkb2N1bWVudElkXS9lZGl0b3IudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUV5RDtBQUNaO0FBQ007QUFDQTtBQUNQO0FBQ1M7QUFDRTtBQUNGO0FBQ0k7QUFDTjtBQUNQO0FBQ1k7QUFDSjtBQUNOO0FBQ087QUFDVTtBQUNyQjtBQUNNO0FBQ0k7QUFDTTtBQUNLO0FBQ0o7QUFDQztBQUNhO0FBQ2hEO0FBQ2lDO0FBQ2Q7QUFDQTtBQUVyQyxNQUFNOEIsU0FBUzs7SUFDcEIsTUFBTUMsU0FBU0YsMkRBQVNBO0lBQ3hCLE1BQU1HLGFBQWFELG1CQUFBQSw2QkFBQUEsT0FBUUMsVUFBVTtJQUNyQyxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR04sZ0RBQVFBLENBQTRCO0lBRXBFLE1BQU0sRUFBRU8sU0FBUyxFQUFFLEdBQUdmLHdFQUFjQTtJQUVwQyxrREFBa0Q7SUFDbERPLGlEQUFTQTs0QkFBQztZQUNSLElBQUksQ0FBQ0ssWUFBWTtZQUVqQixNQUFNSSxPQUFPLElBQUlYLHFDQUFLO1lBQ3RCLE1BQU1hLFlBQVksSUFBSVoscUVBQWtCQSxDQUFDO2dCQUN2Q2EsS0FBSztnQkFDTEMsTUFBTVI7Z0JBQ05TLFVBQVVMO1lBQ1o7WUFFQUYsWUFBWUk7WUFFWjtvQ0FBTztvQkFDTEEsc0JBQUFBLGdDQUFBQSxVQUFXSSxPQUFPO29CQUNsQk4saUJBQUFBLDJCQUFBQSxLQUFNTSxPQUFPO2dCQUNmOztRQUNGOzJCQUFHO1FBQUNWO0tBQVc7SUFFZixNQUFNVyxTQUFTM0MseURBQVNBLENBQUM7UUFDdkI0QyxtQkFBbUI7UUFDbkJDLFVBQVMsS0FBVTtnQkFBVixFQUFFRixNQUFNLEVBQUUsR0FBVjtZQUNQUixVQUFVUTtRQUNaO1FBQ0FHO1lBQ0VYLFVBQVU7UUFDWjtRQUNBWSxVQUFTLEtBQVU7Z0JBQVYsRUFBRUosTUFBTSxFQUFFLEdBQVY7WUFDUFIsVUFBVVE7UUFDWjtRQUNBSyxtQkFBa0IsS0FBVTtnQkFBVixFQUFFTCxNQUFNLEVBQUUsR0FBVjtZQUNoQlIsVUFBVVE7UUFDWjtRQUNBTSxlQUFjLEtBQVU7Z0JBQVYsRUFBRU4sTUFBTSxFQUFFLEdBQVY7WUFDWlIsVUFBVVE7UUFDWjtRQUNBTyxTQUFRLEtBQVU7Z0JBQVYsRUFBRVAsTUFBTSxFQUFFLEdBQVY7WUFDTlIsVUFBVVE7UUFDWjtRQUNBUSxRQUFPLEtBQVU7Z0JBQVYsRUFBRVIsTUFBTSxFQUFFLEdBQVY7WUFDTFIsVUFBVVE7UUFDWjtRQUNBUyxnQkFBZSxLQUFVO2dCQUFWLEVBQUVULE1BQU0sRUFBRSxHQUFWO1lBQ2JSLFVBQVVRO1FBQ1o7UUFDQVUsYUFBYTtZQUNYQyxZQUFZO2dCQUVWQyxPQUFPO2dCQUNQQyxPQUFPO1lBQ1Q7UUFDRjtRQUNBQyxZQUFZO1lBQ1Z2RCwyREFBVUEsQ0FBQ3dELFNBQVMsQ0FBQztnQkFDbkIscURBQXFEO2dCQUNyREMsU0FBUztZQUNYO1lBQ0F2RCxtRUFBUUEsQ0FBQ3NELFNBQVMsQ0FBQztnQkFBRUUsUUFBUTtZQUFLO1lBQ2xDckQscUVBQVVBO1lBQ1ZDLG9FQUFTQTtZQUNUTCxtRUFBUUE7WUFDUkUsK0RBQUtBO1lBQ0xDLG9FQUFTQTtZQUNURyxzRUFBV0E7WUFDWEMsbUVBQVFBO1lBQ1JDLGdFQUFLQTtZQUNMQyxzRUFBV0E7WUFDWEMsb0VBQVNBO1lBQ1RDLGlFQUFNQTtZQUNORywrREFBSUEsQ0FBQ3lDLFNBQVMsQ0FBQztnQkFDYkcsYUFBYTtnQkFDYkMsVUFBVTtnQkFDVkMsaUJBQWlCO1lBQ25CO1lBQ0E3QywyREFBS0E7WUFDTEMsb0VBQVNBLENBQUN1QyxTQUFTLENBQUM7Z0JBQUVNLFlBQVk7WUFBSztZQUV2Q2pELHFFQUFTQSxDQUFDMkMsU0FBUyxDQUFDO2dCQUFFTyxPQUFPO29CQUFDO29CQUFXO2lCQUFZO1lBQUM7WUFDdERqRCwwRUFBY0E7WUFDZEsseUVBQW1CQSxDQUFDcUMsU0FBUyxDQUFDO2dCQUM1Qk8sT0FBTztvQkFBQztvQkFBVztpQkFBWTtnQkFDL0JDLG1CQUFtQjtZQUNyQjtZQUNBNUMscUVBQWlCQTtZQUNqQiwyQkFBMkI7ZUFDdkJXLFdBQVc7Z0JBQ2JWLHdFQUFhQSxDQUFDbUMsU0FBUyxDQUFDO29CQUN0QmpCLFVBQVVSLFNBQVNRLFFBQVE7Z0JBQzdCO2dCQUNBakIsK0VBQW1CQSxDQUFDa0MsU0FBUyxDQUFDO29CQUM1QnpCLFVBQVVBO29CQUNWa0MsTUFBTTt3QkFDSjNCLE1BQU0sUUFBeUMsT0FBakM0QixLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBSzt3QkFDekNDLE9BQU8sSUFBc0QsT0FBbERILEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLLFVBQVVFLFFBQVEsQ0FBQztvQkFDM0Q7Z0JBQ0Y7YUFDRCxHQUFHLEVBQUU7U0FDUDtRQUNEQyxTQUNHO0lBSUwsR0FBRztRQUFDeEM7S0FBUztJQUViLElBQUksQ0FBQ1UsUUFBUSxPQUFPO0lBRXBCLHFCQUNFLDhEQUFDK0I7UUFBSUMsV0FBVTtrQkFFYiw0RUFBQ0M7WUFBS0QsV0FBVTtzQkFDZCw0RUFBQ0Q7Z0JBQUlDLFdBQVU7MEJBQ2IsNEVBQUMxRSx5REFBYUE7b0JBQUMwQyxRQUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS2pDLEVBQUU7R0E1SFdiOztRQUNJRCx1REFBU0E7UUFJRlQsb0VBQWNBO1FBcUJyQnBCLHFEQUFTQTs7O0tBMUJiOEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnlhbmdveWFsL3JlYWwtdGltZS10ZXh0LWVkaXRvci9zcmMvYXBwL2RvY3VtZW50cy9bZG9jdW1lbnRJZF0vZWRpdG9yLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVkaXRvciwgRWRpdG9yQ29udGVudCB9IGZyb20gJ0B0aXB0YXAvcmVhY3QnO1xuaW1wb3J0IFN0YXJ0ZXJLaXQgZnJvbSAnQHRpcHRhcC9zdGFydGVyLWtpdCc7XG5pbXBvcnQgVGFza2xpc3QgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tdGFzay1saXN0JztcbmltcG9ydCBUYXNraXRlbSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi10YXNrLWl0ZW0nO1xuaW1wb3J0IFRhYmxlIGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXRhYmxlJztcbmltcG9ydCBUYWJsZUNlbGwgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tdGFibGUtY2VsbCc7XG5pbXBvcnQgRm9udEZhbWlseSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1mb250LWZhbWlseSc7XG5pbXBvcnQgVGV4dFN0eWxlIGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXRleHQtc3R5bGUnO1xuaW1wb3J0IFRhYmxlSGVhZGVyIGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXRhYmxlLWhlYWRlcic7XG5pbXBvcnQgVGFibGVSb3cgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tdGFibGUtcm93JztcbmltcG9ydCBJbWFnZSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1pbWFnZSc7XG5pbXBvcnQgSW1hZ2VSZXNpemUgZnJvbSAndGlwdGFwLWV4dGVuc2lvbi1yZXNpemUtaW1hZ2UnO1xuaW1wb3J0IFVuZGVybGluZSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi11bmRlcmxpbmUnO1xuaW1wb3J0IFN0cmlrZSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1zdHJpa2UnO1xuaW1wb3J0IFRleHRBbGlnbiBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi10ZXh0LWFsaWduJztcbmltcG9ydCBIb3Jpem9udGFsUnVsZSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1ob3Jpem9udGFsLXJ1bGUnO1xuaW1wb3J0IExpbmsgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tbGluayc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWNvbG9yJztcbmltcG9ydCBIaWdobGlnaHQgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taGlnaGxpZ2h0JztcbmltcG9ydCB7IHVzZUVkaXRvclN0b3JlIH0gZnJvbSAnQC9zdG9yZS91c2UtZWRpdG9yLXN0b3JlJztcbmltcG9ydCB7IExpbmVIZWlnaHRFeHRlbnNpb24gfSBmcm9tICdAL2V4dGVuc2lvbnMvbGluZS1oZWlnaHQnO1xuaW1wb3J0IHsgRm9udFNpemVFeHRlbnNpb24gfSBmcm9tICdAL2V4dGVuc2lvbnMvZm9udC1zaXplJztcbmltcG9ydCBDb2xsYWJvcmF0aW9uIGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWNvbGxhYm9yYXRpb24nO1xuaW1wb3J0IENvbGxhYm9yYXRpb25DdXJzb3IgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvbi1jdXJzb3InO1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnO1xuaW1wb3J0IHsgSG9jdXNwb2N1c1Byb3ZpZGVyIH0gZnJvbSAnQGhvY3VzcG9jdXMvcHJvdmlkZXInO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVBhcmFtcyB9IGZyb20gJ25leHQvbmF2aWdhdGlvbic7XG5cbmV4cG9ydCBjb25zdCBFZGl0b3IgPSAoKSA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHVzZVBhcmFtcygpO1xuICBjb25zdCBkb2N1bWVudElkID0gcGFyYW1zPy5kb2N1bWVudElkIGFzIHN0cmluZztcbiAgY29uc3QgW3Byb3ZpZGVyLCBzZXRQcm92aWRlcl0gPSB1c2VTdGF0ZTxIb2N1c3BvY3VzUHJvdmlkZXIgfCBudWxsPihudWxsKTtcblxuICBjb25zdCB7IHNldEVkaXRvciB9ID0gdXNlRWRpdG9yU3RvcmUoKTtcblxuICAvLyBJbml0aWFsaXplIFlqcyBkb2N1bWVudCBhbmQgSG9jdXNwb2N1cyBwcm92aWRlclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZG9jdW1lbnRJZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgeURvYyA9IG5ldyBZLkRvYygpO1xuICAgIGNvbnN0IHlQcm92aWRlciA9IG5ldyBIb2N1c3BvY3VzUHJvdmlkZXIoe1xuICAgICAgdXJsOiAnd3M6Ly9sb2NhbGhvc3Q6MTIzNCcsXG4gICAgICBuYW1lOiBkb2N1bWVudElkLFxuICAgICAgZG9jdW1lbnQ6IHlEb2MsXG4gICAgfSk7XG5cbiAgICBzZXRQcm92aWRlcih5UHJvdmlkZXIpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHlQcm92aWRlcj8uZGVzdHJveSgpO1xuICAgICAgeURvYz8uZGVzdHJveSgpO1xuICAgIH07XG4gIH0sIFtkb2N1bWVudElkXSk7XG5cbiAgY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKHtcbiAgICBpbW1lZGlhdGVseVJlbmRlcjogZmFsc2UsXG4gICAgb25DcmVhdGUoeyBlZGl0b3IgfSkge1xuICAgICAgc2V0RWRpdG9yKGVkaXRvcik7XG4gICAgfSxcbiAgICBvbkRlc3Ryb3koKSB7XG4gICAgICBzZXRFZGl0b3IobnVsbCk7XG4gICAgfSxcbiAgICBvblVwZGF0ZSh7IGVkaXRvciB9KSB7XG4gICAgICBzZXRFZGl0b3IoZWRpdG9yKTtcbiAgICB9LFxuICAgIG9uU2VsZWN0aW9uVXBkYXRlKHsgZWRpdG9yIH0pIHtcbiAgICAgIHNldEVkaXRvcihlZGl0b3IpO1xuICAgIH0sXG4gICAgb25UcmFuc2FjdGlvbih7IGVkaXRvciB9KSB7XG4gICAgICBzZXRFZGl0b3IoZWRpdG9yKTtcbiAgICB9LFxuICAgIG9uRm9jdXMoeyBlZGl0b3IgfSkge1xuICAgICAgc2V0RWRpdG9yKGVkaXRvcik7XG4gICAgfSxcbiAgICBvbkJsdXIoeyBlZGl0b3IgfSkge1xuICAgICAgc2V0RWRpdG9yKGVkaXRvcik7XG4gICAgfSxcbiAgICBvbkNvbnRlbnRFcnJvcih7IGVkaXRvciB9KSB7XG4gICAgICBzZXRFZGl0b3IoZWRpdG9yKTtcbiAgICB9LFxuICAgIGVkaXRvclByb3BzOiB7XG4gICAgICBhdHRyaWJ1dGVzOiB7XG5cbiAgICAgICAgc3R5bGU6IFwicGFkZGluZy1sZWZ0OjU2cHg7IHBhZGRpbmctcmlnaHQ6NTZweDtcIixcbiAgICAgICAgY2xhc3M6IFwidGlwdGFwIGZvY3VzOm91dGxpbmUtbm9uZSBwcmludDpib3JkZXItMCBiZy13aGl0ZSBib3JkZXIgYm9yZGVyLVsjQzdDN0M3XSBmbGV4IGZsZXgtY29sIG1pbi1oLVsxMDU0cHhdIHctWzgxNnB4XSBwdC0xMCBwci0xNCBwYi0xMCBjdXJzb3ItdGV4dFwiLFxuICAgICAgfSxcbiAgICB9LFxuICAgIGV4dGVuc2lvbnM6IFtcbiAgICAgIFN0YXJ0ZXJLaXQuY29uZmlndXJlKHtcbiAgICAgICAgLy8gRGlzYWJsZSBoaXN0b3J5IGV4dGVuc2lvbiBhcyBZanMgaGFuZGxlcyB1bmRvL3JlZG9cbiAgICAgICAgaGlzdG9yeTogZmFsc2UsXG4gICAgICB9KSxcbiAgICAgIFRhc2tpdGVtLmNvbmZpZ3VyZSh7IG5lc3RlZDogdHJ1ZSB9KSxcbiAgICAgIEZvbnRGYW1pbHksXG4gICAgICBUZXh0U3R5bGUsXG4gICAgICBUYXNrbGlzdCxcbiAgICAgIFRhYmxlLFxuICAgICAgVGFibGVDZWxsLFxuICAgICAgVGFibGVIZWFkZXIsXG4gICAgICBUYWJsZVJvdyxcbiAgICAgIEltYWdlLFxuICAgICAgSW1hZ2VSZXNpemUsXG4gICAgICBVbmRlcmxpbmUsXG4gICAgICBTdHJpa2UsXG4gICAgICBMaW5rLmNvbmZpZ3VyZSh7XG4gICAgICAgIG9wZW5PbkNsaWNrOiBmYWxzZSxcbiAgICAgICAgYXV0b2xpbms6IHRydWUsXG4gICAgICAgIGRlZmF1bHRQcm90b2NvbDogXCJodHRwc1wiLFxuICAgICAgfSksXG4gICAgICBDb2xvcixcbiAgICAgIEhpZ2hsaWdodC5jb25maWd1cmUoeyBtdWx0aWNvbG9yOiB0cnVlIH0pLFxuXG4gICAgICBUZXh0QWxpZ24uY29uZmlndXJlKHsgdHlwZXM6IFsnaGVhZGluZycsICdwYXJhZ3JhcGgnXSB9KSxcbiAgICAgIEhvcml6b250YWxSdWxlLFxuICAgICAgTGluZUhlaWdodEV4dGVuc2lvbi5jb25maWd1cmUoe1xuICAgICAgICB0eXBlczogW1wiaGVhZGluZ1wiLCBcInBhcmFncmFwaFwiXSxcbiAgICAgICAgZGVmYXVsdExpbmVIZWlnaHQ6IFwibm9ybWFsXCIsXG4gICAgICB9KSxcbiAgICAgIEZvbnRTaXplRXh0ZW5zaW9uLFxuICAgICAgLy8gQ29sbGFib3JhdGlvbiBleHRlbnNpb25zXG4gICAgICAuLi4ocHJvdmlkZXIgPyBbXG4gICAgICAgIENvbGxhYm9yYXRpb24uY29uZmlndXJlKHtcbiAgICAgICAgICBkb2N1bWVudDogcHJvdmlkZXIuZG9jdW1lbnQsXG4gICAgICAgIH0pLFxuICAgICAgICBDb2xsYWJvcmF0aW9uQ3Vyc29yLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgcHJvdmlkZXI6IHByb3ZpZGVyLFxuICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgIG5hbWU6IGBVc2VyICR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCl9YCxcbiAgICAgICAgICAgIGNvbG9yOiBgIyR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTY3NzcyMTUpLnRvU3RyaW5nKDE2KX1gLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgXSA6IFtdKSxcbiAgICBdLFxuICAgIGNvbnRlbnQ6XG4gICAgICBgXG4gICAgICBoZWxsbyBldmVyeW9uZVxuICAgICAgYCxcblxuICB9LCBbcHJvdmlkZXJdKTtcblxuICBpZiAoIWVkaXRvcikgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImgtc2NyZWVuIGZsZXggZmxleC1jb2wgb3ZlcmZsb3ctaGlkZGVuXCI+XG4gICAgICB7LyogRWRpdG9yIEFyZWEgKi99XG4gICAgICA8bWFpbiBjbGFzc05hbWU9XCJzaXplLWZ1bGwgb3ZlcmZsb3cteC1hdXRvIGJnLVsjRjlGQkZEXSBweC00IHByaW50OnAtMCBwcmludDpiZy13aGl0ZSBwcmludDpvdmVyZmxvdy12aXNpYmxlXVwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nbWluLXctbWF4IGp1c3RpZnktY2VudGVyIHctWzgxNnB4XSBweS00IHByaW50OnB5LTAgbXgtYXV0byBwcmludDp3LWZ1bGwgcHJpbnQ6bWluLXctMCc+XG4gICAgICAgICAgPEVkaXRvckNvbnRlbnQgZWRpdG9yPXtlZGl0b3J9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9tYWluPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuIl0sIm5hbWVzIjpbInVzZUVkaXRvciIsIkVkaXRvckNvbnRlbnQiLCJTdGFydGVyS2l0IiwiVGFza2xpc3QiLCJUYXNraXRlbSIsIlRhYmxlIiwiVGFibGVDZWxsIiwiRm9udEZhbWlseSIsIlRleHRTdHlsZSIsIlRhYmxlSGVhZGVyIiwiVGFibGVSb3ciLCJJbWFnZSIsIkltYWdlUmVzaXplIiwiVW5kZXJsaW5lIiwiU3RyaWtlIiwiVGV4dEFsaWduIiwiSG9yaXpvbnRhbFJ1bGUiLCJMaW5rIiwiQ29sb3IiLCJIaWdobGlnaHQiLCJ1c2VFZGl0b3JTdG9yZSIsIkxpbmVIZWlnaHRFeHRlbnNpb24iLCJGb250U2l6ZUV4dGVuc2lvbiIsIkNvbGxhYm9yYXRpb24iLCJDb2xsYWJvcmF0aW9uQ3Vyc29yIiwiWSIsIkhvY3VzcG9jdXNQcm92aWRlciIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUGFyYW1zIiwiRWRpdG9yIiwicGFyYW1zIiwiZG9jdW1lbnRJZCIsInByb3ZpZGVyIiwic2V0UHJvdmlkZXIiLCJzZXRFZGl0b3IiLCJ5RG9jIiwiRG9jIiwieVByb3ZpZGVyIiwidXJsIiwibmFtZSIsImRvY3VtZW50IiwiZGVzdHJveSIsImVkaXRvciIsImltbWVkaWF0ZWx5UmVuZGVyIiwib25DcmVhdGUiLCJvbkRlc3Ryb3kiLCJvblVwZGF0ZSIsIm9uU2VsZWN0aW9uVXBkYXRlIiwib25UcmFuc2FjdGlvbiIsIm9uRm9jdXMiLCJvbkJsdXIiLCJvbkNvbnRlbnRFcnJvciIsImVkaXRvclByb3BzIiwiYXR0cmlidXRlcyIsInN0eWxlIiwiY2xhc3MiLCJleHRlbnNpb25zIiwiY29uZmlndXJlIiwiaGlzdG9yeSIsIm5lc3RlZCIsIm9wZW5PbkNsaWNrIiwiYXV0b2xpbmsiLCJkZWZhdWx0UHJvdG9jb2wiLCJtdWx0aWNvbG9yIiwidHlwZXMiLCJkZWZhdWx0TGluZUhlaWdodCIsInVzZXIiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJjb2xvciIsInRvU3RyaW5nIiwiY29udGVudCIsImRpdiIsImNsYXNzTmFtZSIsIm1haW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/documents/[documentId]/editor.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/documents/[documentId]/page.tsx":
/*!*************************************************!*\
  !*** ./src/app/documents/[documentId]/page.tsx ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor */ \"(app-pages-browser)/./src/app/documents/[documentId]/editor.tsx\");\n/* harmony import */ var _toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toolbar */ \"(app-pages-browser)/./src/app/documents/[documentId]/toolbar.tsx\");\n/* harmony import */ var _document_header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./document-header */ \"(app-pages-browser)/./src/app/documents/[documentId]/document-header.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\nconst DocumentIdPage = (param)=>{\n    let { params } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-[#FAFBFD]\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_document_header__WEBPACK_IMPORTED_MODULE_3__.DocumentHeader, {}, void 0, false, {\n                fileName: \"/Users/aryangoyal/real-time-text-editor/src/app/documents/[documentId]/page.tsx\",\n                lineNumber: 14,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_toolbar__WEBPACK_IMPORTED_MODULE_2__.Toolbar, {}, void 0, false, {\n                fileName: \"/Users/aryangoyal/real-time-text-editor/src/app/documents/[documentId]/page.tsx\",\n                lineNumber: 15,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_editor__WEBPACK_IMPORTED_MODULE_1__.Editor, {}, void 0, false, {\n                fileName: \"/Users/aryangoyal/real-time-text-editor/src/app/documents/[documentId]/page.tsx\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/aryangoyal/real-time-text-editor/src/app/documents/[documentId]/page.tsx\",\n        lineNumber: 13,\n        columnNumber: 5\n    }, undefined);\n};\n_c = DocumentIdPage;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DocumentIdPage);\nvar _c;\n$RefreshReg$(_c, \"DocumentIdPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZG9jdW1lbnRzL1tkb2N1bWVudElkXS9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFa0M7QUFDRTtBQUNlO0FBTW5ELE1BQU1HLGlCQUFpQjtRQUFDLEVBQUVDLE1BQU0sRUFBdUI7SUFDckQscUJBQ0UsOERBQUNDO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDSiw0REFBY0E7Ozs7OzBCQUNmLDhEQUFDRCw2Q0FBT0E7Ozs7OzBCQUNSLDhEQUFDRCwyQ0FBTUE7Ozs7Ozs7Ozs7O0FBR2I7S0FSTUc7QUFVTixpRUFBZUEsY0FBY0EsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2FyeWFuZ295YWwvcmVhbC10aW1lLXRleHQtZWRpdG9yL3NyYy9hcHAvZG9jdW1lbnRzL1tkb2N1bWVudElkXS9wYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gXCIuL2VkaXRvclwiO1xuaW1wb3J0IHsgVG9vbGJhciB9IGZyb20gXCIuL3Rvb2xiYXJcIjtcbmltcG9ydCB7IERvY3VtZW50SGVhZGVyIH0gZnJvbSBcIi4vZG9jdW1lbnQtaGVhZGVyXCI7XG5cbmludGVyZmFjZSBEb2N1bWVudElkUGFnZVByb3BzIHtcbiAgcGFyYW1zOiB7IGRvY3VtZW50SWQ6IHN0cmluZyB9O1xufVxuXG5jb25zdCBEb2N1bWVudElkUGFnZSA9ICh7IHBhcmFtcyB9OiBEb2N1bWVudElkUGFnZVByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gYmctWyNGQUZCRkRdXCI+XG4gICAgICA8RG9jdW1lbnRIZWFkZXIgLz5cbiAgICAgIDxUb29sYmFyIC8+XG4gICAgICA8RWRpdG9yIC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEb2N1bWVudElkUGFnZTtcbiJdLCJuYW1lcyI6WyJFZGl0b3IiLCJUb29sYmFyIiwiRG9jdW1lbnRIZWFkZXIiLCJEb2N1bWVudElkUGFnZSIsInBhcmFtcyIsImRpdiIsImNsYXNzTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/documents/[documentId]/page.tsx\n"));

/***/ })

});