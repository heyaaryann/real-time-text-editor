"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@liveblocks";
exports.ids = ["vendor-chunks/@liveblocks"];
exports.modules = {

/***/ "(ssr)/./node_modules/@liveblocks/core/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   DefaultMap: () => (/* binding */ DefaultMap),\n/* harmony export */   Deque: () => (/* binding */ Deque),\n/* harmony export */   DerivedSignal: () => (/* binding */ DerivedSignal),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   LiveblocksError: () => (/* binding */ LiveblocksError),\n/* harmony export */   MENTION_CHARACTER: () => (/* binding */ MENTION_CHARACTER),\n/* harmony export */   MutableSignal: () => (/* binding */ MutableSignal),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   Permission: () => (/* binding */ Permission),\n/* harmony export */   Promise_withResolvers: () => (/* binding */ Promise_withResolvers),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   Signal: () => (/* binding */ Signal),\n/* harmony export */   SortedList: () => (/* binding */ SortedList),\n/* harmony export */   TextEditorType: () => (/* binding */ TextEditorType),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   autoRetry: () => (/* binding */ autoRetry),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   checkBounds: () => (/* binding */ checkBounds),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   compactObject: () => (/* binding */ compactObject),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToGroupData: () => (/* binding */ convertToGroupData),\n/* harmony export */   convertToInboxNotificationData: () => (/* binding */ convertToInboxNotificationData),\n/* harmony export */   convertToSubscriptionData: () => (/* binding */ convertToSubscriptionData),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   convertToUserSubscriptionData: () => (/* binding */ convertToUserSubscriptionData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   createCommentAttachmentId: () => (/* binding */ createCommentAttachmentId),\n/* harmony export */   createCommentId: () => (/* binding */ createCommentId),\n/* harmony export */   createInboxNotificationId: () => (/* binding */ createInboxNotificationId),\n/* harmony export */   createManagedPool: () => (/* binding */ createManagedPool),\n/* harmony export */   createNotificationSettings: () => (/* binding */ createNotificationSettings),\n/* harmony export */   createThreadId: () => (/* binding */ createThreadId),\n/* harmony export */   defineAiTool: () => (/* binding */ defineAiTool),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   entries: () => (/* binding */ entries),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   findLastIndex: () => (/* binding */ findLastIndex),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   generateUrl: () => (/* binding */ generateUrl),\n/* harmony export */   getMentionsFromCommentBody: () => (/* binding */ getMentionsFromCommentBody),\n/* harmony export */   getSubscriptionKey: () => (/* binding */ getSubscriptionKey),\n/* harmony export */   html: () => (/* binding */ html),\n/* harmony export */   htmlSafe: () => (/* binding */ htmlSafe),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isCommentBodyLink: () => (/* binding */ isCommentBodyLink),\n/* harmony export */   isCommentBodyMention: () => (/* binding */ isCommentBodyMention),\n/* harmony export */   isCommentBodyText: () => (/* binding */ isCommentBodyText),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isNotificationChannelEnabled: () => (/* binding */ isNotificationChannelEnabled),\n/* harmony export */   isNumberOperator: () => (/* binding */ isNumberOperator),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   isStartsWithOperator: () => (/* binding */ isStartsWithOperator),\n/* harmony export */   isUrl: () => (/* binding */ isUrl),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeAbortController: () => (/* binding */ makeAbortController),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   mapValues: () => (/* binding */ mapValues),\n/* harmony export */   memoizeOnSuccess: () => (/* binding */ memoizeOnSuccess),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   objectToQuery: () => (/* binding */ objectToQuery),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   patchNotificationSettings: () => (/* binding */ patchNotificationSettings),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   resolveMentionsInCommentBody: () => (/* binding */ resolveMentionsInCommentBody),\n/* harmony export */   sanitizeUrl: () => (/* binding */ sanitizeUrl),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   shallow2: () => (/* binding */ shallow2),\n/* harmony export */   stableStringify: () => (/* binding */ stableStringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   urljoin: () => (/* binding */ urljoin),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   warnOnce: () => (/* binding */ warnOnce),\n/* harmony export */   warnOnceIf: () => (/* binding */ warnOnceIf),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"3.11.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _observers = /* @__PURE__ */ new Set();\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    const unsub = subscribe((event) => {\n      unsub();\n      return callback(event);\n    });\n    return unsub;\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notify(event) {\n    let called = false;\n    for (const callback of _observers) {\n      callback(event);\n      called = true;\n    }\n    return called;\n  }\n  function count() {\n    return _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify,\n    subscribe,\n    subscribeOnce,\n    count,\n    waitUntil,\n    dispose() {\n      _observers.clear();\n    },\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\nfunction makeBufferableEventSource() {\n  const eventSource2 = makeEventSource();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      eventSource2.notify(event);\n    }\n    _buffer = null;\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n      return false;\n    } else {\n      return eventSource2.notify(event);\n    }\n  }\n  return {\n    ...eventSource2,\n    notify: notifyOrBuffer,\n    pause,\n    unpause,\n    dispose() {\n      eventSource2.dispose();\n      if (_buffer !== null) {\n        _buffer.length = 0;\n      }\n    }\n  };\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction keys(obj) {\n  return Object.keys(obj);\n}\nfunction values(obj) {\n  return Object.values(obj);\n}\nfunction create(obj, descriptors) {\n  if (typeof descriptors !== \"undefined\") {\n    return Object.create(obj, descriptors);\n  }\n  return Object.create(obj);\n}\nfunction mapValues(obj, mapFn) {\n  const result = {};\n  for (const pair of Object.entries(obj)) {\n    const key = pair[0];\n    if (key === \"__proto__\") {\n      continue;\n    }\n    const value = pair[1];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\nfunction findLastIndex(arr, predicate) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// src/lib/signals.ts\nvar kSinks = Symbol(\"kSinks\");\nvar kTrigger = Symbol(\"kTrigger\");\nvar signalsToTrigger = null;\nvar trackedReads = null;\nfunction batch(callback) {\n  if (signalsToTrigger !== null) {\n    callback();\n    return;\n  }\n  signalsToTrigger = /* @__PURE__ */ new Set();\n  try {\n    callback();\n  } finally {\n    for (const signal of signalsToTrigger) {\n      signal[kTrigger]();\n    }\n    signalsToTrigger = null;\n  }\n}\nfunction enqueueTrigger(signal) {\n  if (!signalsToTrigger) raise(\"Expected to be in an active batch\");\n  signalsToTrigger.add(signal);\n}\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar AbstractSignal = class {\n  /** @internal */\n  equals;\n  #eventSource;\n  /** @internal */\n  [kSinks];\n  constructor(equals) {\n    this.equals = equals ?? Object.is;\n    this.#eventSource = makeEventSource();\n    this[kSinks] = /* @__PURE__ */ new Set();\n    this.get = this.get.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.subscribeOnce = this.subscribeOnce.bind(this);\n  }\n  dispose() {\n    this.#eventSource.dispose();\n    this.#eventSource = \"(disposed)\";\n    this.equals = \"(disposed)\";\n  }\n  get hasWatchers() {\n    if (this.#eventSource.count() > 0) return true;\n    for (const sink of this[kSinks]) {\n      if (sink.hasWatchers) {\n        return true;\n      }\n    }\n    return false;\n  }\n  [kTrigger]() {\n    this.#eventSource.notify();\n    for (const sink of this[kSinks]) {\n      enqueueTrigger(sink);\n    }\n  }\n  subscribe(callback) {\n    if (this.#eventSource.count() === 0) {\n      this.get();\n    }\n    return this.#eventSource.subscribe(callback);\n  }\n  subscribeOnce(callback) {\n    const unsub = this.subscribe(() => {\n      unsub();\n      return callback();\n    });\n    return unsub;\n  }\n  waitUntil() {\n    throw new Error(\"waitUntil not supported on Signals\");\n  }\n  markSinksDirty() {\n    for (const sink of this[kSinks]) {\n      sink.markDirty();\n    }\n  }\n  addSink(sink) {\n    this[kSinks].add(sink);\n  }\n  removeSink(sink) {\n    this[kSinks].delete(sink);\n  }\n  asReadonly() {\n    return this;\n  }\n};\nvar Signal = class extends AbstractSignal {\n  #value;\n  constructor(value, equals) {\n    super(equals);\n    this.#value = freeze(value);\n  }\n  dispose() {\n    super.dispose();\n    this.#value = \"(disposed)\";\n  }\n  get() {\n    trackedReads?.add(this);\n    return this.#value;\n  }\n  set(newValue) {\n    batch(() => {\n      if (typeof newValue === \"function\") {\n        newValue = newValue(this.#value);\n      }\n      if (!this.equals(this.#value, newValue)) {\n        this.#value = freeze(newValue);\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n};\nvar PatchableSignal = class extends Signal {\n  constructor(data) {\n    super(freeze(compactObject(data)));\n  }\n  set() {\n    throw new Error(\"Don't call .set() directly, use .patch()\");\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    super.set((old) => merge(old, patch));\n  }\n};\nvar INITIAL = Symbol();\nvar DerivedSignal = class _DerivedSignal extends AbstractSignal {\n  #prevValue;\n  #dirty;\n  // When true, the value in #value may not be up-to-date and needs re-checking\n  #sources;\n  #deps;\n  #transform;\n  // prettier-ignore\n  static from(...args) {\n    const last = args.pop();\n    if (typeof last !== \"function\")\n      raise(\"Invalid .from() call, last argument expected to be a function\");\n    if (typeof args[args.length - 1] === \"function\") {\n      const equals = last;\n      const transform = args.pop();\n      return new _DerivedSignal(args, transform, equals);\n    } else {\n      const transform = last;\n      return new _DerivedSignal(args, transform);\n    }\n  }\n  constructor(deps, transform, equals) {\n    super(equals);\n    this.#dirty = true;\n    this.#prevValue = INITIAL;\n    this.#deps = deps;\n    this.#sources = /* @__PURE__ */ new Set();\n    this.#transform = transform;\n  }\n  dispose() {\n    for (const src of this.#sources) {\n      src.removeSink(this);\n    }\n    this.#prevValue = \"(disposed)\";\n    this.#sources = \"(disposed)\";\n    this.#deps = \"(disposed)\";\n    this.#transform = \"(disposed)\";\n  }\n  get isDirty() {\n    return this.#dirty;\n  }\n  #recompute() {\n    const oldTrackedReads = trackedReads;\n    let derived;\n    trackedReads = /* @__PURE__ */ new Set();\n    try {\n      derived = this.#transform(...this.#deps.map((p) => p.get()));\n    } finally {\n      const oldSources = this.#sources;\n      this.#sources = /* @__PURE__ */ new Set();\n      for (const sig of trackedReads) {\n        this.#sources.add(sig);\n        oldSources.delete(sig);\n      }\n      for (const oldSource of oldSources) {\n        oldSource.removeSink(this);\n      }\n      for (const newSource of this.#sources) {\n        newSource.addSink(this);\n      }\n      trackedReads = oldTrackedReads;\n    }\n    this.#dirty = false;\n    if (!this.equals(this.#prevValue, derived)) {\n      this.#prevValue = derived;\n      return true;\n    }\n    return false;\n  }\n  markDirty() {\n    if (!this.#dirty) {\n      this.#dirty = true;\n      this.markSinksDirty();\n    }\n  }\n  get() {\n    if (this.#dirty) {\n      this.#recompute();\n    }\n    trackedReads?.add(this);\n    return this.#prevValue;\n  }\n  /**\n   * Called by the Signal system if one or more of the dependent signals have\n   * changed. In the case of a DerivedSignal, we'll only want to re-evaluate\n   * the actual value if it's being watched, or any of their sinks are being\n   * watched actively.\n   */\n  [kTrigger]() {\n    if (!this.hasWatchers) {\n      return;\n    }\n    const updated = this.#recompute();\n    if (updated) {\n      super[kTrigger]();\n    }\n  }\n};\nvar MutableSignal = class extends AbstractSignal {\n  #state;\n  constructor(initialState) {\n    super();\n    this.#state = initialState;\n  }\n  dispose() {\n    super.dispose();\n    this.#state = \"(disposed)\";\n  }\n  get() {\n    trackedReads?.add(this);\n    return this.#state;\n  }\n  /**\n   * Invokes a callback function that is allowed to mutate the given state\n   * value. Do not change the value outside of the callback.\n   *\n   * If the callback explicitly returns `false`, it's assumed that the state\n   * was not changed.\n   */\n  mutate(callback) {\n    batch(() => {\n      const result = callback ? callback(this.#state) : true;\n      if (result !== null && typeof result === \"object\" && \"then\" in result) {\n        raise(\"MutableSignal.mutate() does not support async callbacks\");\n      }\n      if (result !== false) {\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n};\n\n// src/lib/SortedList.ts\nfunction bisectRight(arr, x, lt) {\n  let lo = 0;\n  let hi = arr.length;\n  while (lo < hi) {\n    const mid = lo + (hi - lo >> 1);\n    if (lt(x, arr[mid])) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\nvar SortedList = class _SortedList {\n  #data;\n  #lt;\n  constructor(alreadySortedList, lt) {\n    this.#lt = lt;\n    this.#data = alreadySortedList;\n  }\n  static with(lt) {\n    return _SortedList.fromAlreadySorted([], lt);\n  }\n  static from(arr, lt) {\n    const sorted = new _SortedList([], lt);\n    for (const item of arr) {\n      sorted.add(item);\n    }\n    return sorted;\n  }\n  static fromAlreadySorted(alreadySorted, lt) {\n    return new _SortedList(alreadySorted, lt);\n  }\n  /**\n   * Clones the sorted list to a new instance.\n   */\n  clone() {\n    return new _SortedList(this.#data.slice(), this.#lt);\n  }\n  /**\n   * Adds a new item to the sorted list, such that it remains sorted.\n   */\n  add(value) {\n    const idx = bisectRight(this.#data, value, this.#lt);\n    this.#data.splice(idx, 0, value);\n  }\n  /**\n   * Removes all values from the sorted list, making it empty again.\n   * Returns whether the list was mutated or not.\n   */\n  clear() {\n    const hadData = this.#data.length > 0;\n    this.#data.length = 0;\n    return hadData;\n  }\n  /**\n   * Removes the first value matching the predicate.\n   * Returns whether the list was mutated or not.\n   */\n  removeBy(predicate, limit = Number.POSITIVE_INFINITY) {\n    let deleted = 0;\n    for (let i = 0; i < this.#data.length; i++) {\n      if (predicate(this.#data[i])) {\n        this.#data.splice(i, 1);\n        deleted++;\n        if (deleted >= limit) {\n          break;\n        } else {\n          i--;\n        }\n      }\n    }\n    return deleted > 0;\n  }\n  /**\n   * Removes the given value from the sorted list, if it exists. The given\n   * value must be `===` to one of the list items. Only the first entry will be\n   * removed if the element exists in the sorted list multiple times.\n   *\n   * Returns whether the list was mutated or not.\n   */\n  remove(value) {\n    const idx = this.#data.indexOf(value);\n    if (idx >= 0) {\n      this.#data.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n  at(index) {\n    return this.#data[index];\n  }\n  get length() {\n    return this.#data.length;\n  }\n  *filter(predicate) {\n    for (const item of this.#data) {\n      if (predicate(item)) {\n        yield item;\n      }\n    }\n  }\n  // XXXX If we keep this, add unit tests. Or remove it.\n  *findAllRight(predicate) {\n    for (let i = this.#data.length - 1; i >= 0; i--) {\n      const item = this.#data[i];\n      if (predicate(item, i)) {\n        yield item;\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this.#data[Symbol.iterator]();\n  }\n  *iterReversed() {\n    for (let i = this.#data.length - 1; i >= 0; i--) {\n      yield this.#data[i];\n    }\n  }\n  /** Finds the leftmost item that matches the predicate. */\n  find(predicate, start) {\n    const idx = this.findIndex(predicate, start);\n    return idx > -1 ? this.#data.at(idx) : void 0;\n  }\n  /** Finds the leftmost index that matches the predicate. */\n  findIndex(predicate, start = 0) {\n    for (let i = Math.max(0, start); i < this.#data.length; i++) {\n      if (predicate(this.#data[i], i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /** Finds the rightmost item that matches the predicate. */\n  findRight(predicate, start) {\n    const idx = this.findIndexRight(predicate, start);\n    return idx > -1 ? this.#data.at(idx) : void 0;\n  }\n  /** Finds the rightmost index that matches the predicate. */\n  findIndexRight(predicate, start = this.#data.length - 1) {\n    for (let i = Math.min(start, this.#data.length - 1); i >= 0; i--) {\n      if (predicate(this.#data[i], i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  get rawArray() {\n    return this.#data;\n  }\n};\n\n// src/AiChatDB.ts\nvar AiChatDB = class {\n  #byId;\n  // A map of chat id to chat details\n  #chats;\n  // Sorted list of non-deleted chats, most recent first\n  signal;\n  constructor() {\n    this.#byId = /* @__PURE__ */ new Map();\n    this.#chats = SortedList.from([], (c1, c2) => {\n      const d2 = c2.lastMessageAt ?? c2.createdAt;\n      const d1 = c1.lastMessageAt ?? c1.createdAt;\n      return d2 < d1 ? true : d2 === d1 ? c2.id < c1.id : false;\n    });\n    this.signal = new MutableSignal(this);\n  }\n  getEvenIfDeleted(chatId) {\n    this.signal.get();\n    return this.#byId.get(chatId);\n  }\n  markDeleted(chatId) {\n    const chat = this.#byId.get(chatId);\n    if (chat === void 0 || chat.deletedAt !== void 0) return;\n    this.upsert({\n      ...chat,\n      deletedAt: (/* @__PURE__ */ new Date()).toISOString()\n    });\n  }\n  upsert(chat) {\n    this.signal.mutate(() => {\n      const existingThread = this.#byId.get(chat.id);\n      if (existingThread !== void 0) {\n        if (existingThread.deletedAt !== void 0) return false;\n        this.#chats.remove(existingThread);\n        this.#byId.delete(existingThread.id);\n      }\n      if (chat.deletedAt === void 0) {\n        this.#chats.add(chat);\n      }\n      this.#byId.set(chat.id, chat);\n      return true;\n    });\n  }\n  findMany(query) {\n    return Array.from(\n      this.#chats.filter((chat) => {\n        if (query.metadata === void 0) return true;\n        for (const [key, value] of Object.entries(query.metadata)) {\n          if (value === null) {\n            if (key in chat.metadata) return false;\n          } else if (typeof value === \"string\") {\n            if (chat.metadata[key] !== value) return false;\n          } else {\n            const chatValue = chat.metadata[key];\n            if (!Array.isArray(chatValue) || !value.every((v) => chatValue.includes(v))) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })\n    );\n  }\n};\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToSubscriptionData(data) {\n  const createdAt = new Date(data.createdAt);\n  return {\n    ...data,\n    createdAt\n  };\n}\nfunction convertToUserSubscriptionData(data) {\n  const createdAt = new Date(data.createdAt);\n  return {\n    ...data,\n    createdAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToSubscriptionDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToGroupData(data) {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n  const members = data.members.map((member) => ({\n    ...member,\n    addedAt: new Date(member.addedAt)\n  }));\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    members\n  };\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/guards.ts\nfunction isDefined(value) {\n  return value !== null && value !== void 0;\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction isStartsWithOperator(blob) {\n  return isPlainObject(blob) && typeof blob.startsWith === \"string\";\n}\nfunction isNumberOperator(blob) {\n  return isPlainObject(blob) && (typeof blob.lt === \"number\" || typeof blob.gt === \"number\" || typeof blob.lte === \"number\" || typeof blob.gte === \"number\");\n}\n\n// src/lib/autoRetry.ts\nvar HttpError = class _HttpError extends Error {\n  response;\n  details;\n  constructor(message, response, details) {\n    super(message);\n    this.name = \"HttpError\";\n    this.response = response;\n    this.details = details;\n  }\n  static async fromResponse(response) {\n    let bodyAsText;\n    try {\n      bodyAsText = await response.text();\n    } catch {\n    }\n    const bodyAsJson = bodyAsText ? tryParseJson(bodyAsText) : void 0;\n    let bodyAsJsonObject;\n    if (isPlainObject(bodyAsJson)) {\n      bodyAsJsonObject = bodyAsJson;\n    }\n    let message = \"\";\n    message ||= typeof bodyAsJsonObject?.message === \"string\" ? bodyAsJsonObject.message : \"\";\n    message ||= typeof bodyAsJsonObject?.error === \"string\" ? bodyAsJsonObject.error : \"\";\n    if (bodyAsJson === void 0) {\n      message ||= bodyAsText || \"\";\n    }\n    message ||= response.statusText;\n    let path;\n    try {\n      path = new URL(response.url).pathname;\n    } catch {\n    }\n    message += path !== void 0 ? ` (got status ${response.status} from ${path})` : ` (got status ${response.status})`;\n    const details = bodyAsJsonObject;\n    return new _HttpError(message, response, details);\n  }\n  /**\n   * Convenience accessor for response.status.\n   */\n  get status() {\n    return this.response.status;\n  }\n};\nvar DONT_RETRY_4XX = (x) => x instanceof HttpError && x.status >= 400 && x.status < 500;\nasync function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n  let attempt = 0;\n  while (true) {\n    attempt++;\n    try {\n      return await promiseFn();\n    } catch (err) {\n      if (shouldStopRetrying(err)) {\n        throw err;\n      }\n      if (attempt >= maxTries) {\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n    warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/stringify.ts\nfunction replacer(_key, value) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value) ? Object.keys(value).sort().reduce((sorted, key) => {\n    sorted[key] = value[key];\n    return sorted;\n  }, {}) : value;\n}\nfunction stableStringify(value) {\n  return JSON.stringify(value, replacer);\n}\nfunction stringifyOrLog(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (err) {\n    console.error(`Could not stringify: ${err.message}`);\n    console.error(value);\n    throw err;\n  }\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  input;\n  resolve;\n  reject;\n  promise;\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  #queue = [];\n  #callback;\n  #size;\n  #delay;\n  #delayTimeoutId;\n  error = false;\n  constructor(callback, options) {\n    this.#callback = callback;\n    this.#size = options.size ?? DEFAULT_SIZE;\n    this.#delay = options.delay;\n  }\n  #clearDelayTimeout() {\n    if (this.#delayTimeoutId !== void 0) {\n      clearTimeout(this.#delayTimeoutId);\n      this.#delayTimeoutId = void 0;\n    }\n  }\n  #schedule() {\n    if (this.#queue.length === this.#size) {\n      void this.#flush();\n    } else if (this.#queue.length === 1) {\n      this.#clearDelayTimeout();\n      this.#delayTimeoutId = setTimeout(() => void this.#flush(), this.#delay);\n    }\n  }\n  async #flush() {\n    if (this.#queue.length === 0) {\n      return;\n    }\n    const calls = this.#queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.#callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.#queue.find(\n      (call2) => stableStringify(call2.input) === stableStringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.#queue.push(call);\n    this.#schedule();\n    return call.promise;\n  }\n  clear() {\n    this.#queue = [];\n    this.error = false;\n    this.#clearDelayTimeout();\n  }\n};\nfunction createBatchStore(batch2) {\n  const signal = new MutableSignal(/* @__PURE__ */ new Map());\n  function getCacheKey(args) {\n    return stableStringify(args);\n  }\n  function update(entryOrEntries) {\n    signal.mutate((cache) => {\n      if (Array.isArray(entryOrEntries)) {\n        for (const entry of entryOrEntries) {\n          cache.set(entry.key, entry.state);\n        }\n      } else {\n        cache.set(entryOrEntries.key, entryOrEntries.state);\n      }\n    });\n  }\n  function invalidate(inputs) {\n    signal.mutate((cache) => {\n      if (Array.isArray(inputs)) {\n        for (const input of inputs) {\n          cache.delete(getCacheKey(input));\n        }\n      } else {\n        cache.clear();\n      }\n    });\n  }\n  async function enqueue(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      update({ key: cacheKey, state: { isLoading: true } });\n      const result = await batch2.get(input);\n      update({ key: cacheKey, state: { isLoading: false, data: result } });\n    } catch (error3) {\n      update({\n        key: cacheKey,\n        state: { isLoading: false, error: error3 }\n      });\n    }\n  }\n  function setData(entries2) {\n    update(\n      entries2.map((entry) => ({\n        key: getCacheKey(entry[0]),\n        state: { isLoading: false, data: entry[1] }\n      }))\n    );\n  }\n  function getItemState(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey);\n  }\n  function getData(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey)?.data;\n  }\n  function _cacheKeys() {\n    const cache = signal.get();\n    return [...cache.keys()];\n  }\n  return {\n    subscribe: signal.subscribe,\n    enqueue,\n    setData,\n    getItemState,\n    getData,\n    invalidate,\n    batch: batch2,\n    _cacheKeys\n  };\n}\n\n// src/lib/chunk.ts\nfunction chunk(array, size) {\n  const chunks = [];\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n// src/lib/nanoid.ts\nvar nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(\n  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? \"_\" : \"-\",\n  \"\"\n);\n\n// src/lib/createIds.ts\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nvar INBOX_NOTIFICATION_ID_PREFIX = \"in\";\nfunction createOptimisticId(prefix) {\n  return `${prefix}_${nanoid()}`;\n}\nfunction createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction createCommentAttachmentId() {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\nfunction createInboxNotificationId() {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n\n// src/lib/DefaultMap.ts\nvar DefaultMap = class extends Map {\n  #defaultFn;\n  /**\n   * If the default function is not provided to the constructor, it has to be\n   * provided in each .getOrCreate() call individually.\n   */\n  constructor(defaultFn, entries2) {\n    super(entries2);\n    this.#defaultFn = defaultFn;\n  }\n  /**\n   * Gets the value at the given key, or creates it.\n   *\n   * Difference from normal Map: if the key does not exist, it will be created\n   * on the fly using the factory function, and that value will get returned\n   * instead of `undefined`.\n   */\n  getOrCreate(key, defaultFn) {\n    if (super.has(key)) {\n      return super.get(key);\n    } else {\n      const fn = defaultFn ?? this.#defaultFn ?? raise(\"DefaultMap used without a factory function\");\n      const value = fn(key);\n      this.set(key, value);\n      return value;\n    }\n  }\n};\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isPlainObject(value)) {\n      if (isStartsWithOperator(value) || isNumberOperator(value)) {\n        keyValuePairsWithOperator.push([key, value]);\n      } else {\n        indexedKeys.push([key, value]);\n      }\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isStartsWithOperator(nestedValue) || isNumberOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(({ key, operator, value }) => `${key}${operator}${quote(value)}`).join(\" \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n    if (\"lt\" in value && typeof value.lt === \"number\") {\n      filters.push({\n        key,\n        operator: \"<\",\n        value: value.lt\n      });\n    }\n    if (\"gt\" in value && typeof value.gt === \"number\") {\n      filters.push({\n        key,\n        operator: \">\",\n        value: value.gt\n      });\n    }\n    if (\"gte\" in value && typeof value.gte === \"number\") {\n      filters.push({\n        key,\n        operator: \">=\",\n        value: value.gte\n      });\n    }\n    if (\"lte\" in value && typeof value.lte === \"number\") {\n      filters.push({\n        key,\n        operator: \"<=\",\n        value: value.lte\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  return typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || value === null;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${quote(nestedKey)}]`;\n  }\n  return key;\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\nfunction quote(input) {\n  const result = JSON.stringify(input);\n  if (typeof input !== \"string\") {\n    return result;\n  }\n  if (result.includes(\"'\")) {\n    return result;\n  }\n  return `'${result.slice(1, -1).replace(/\\\\\"/g, '\"')}'`;\n}\n\n// src/lib/url.ts\nvar PLACEHOLDER_BASE_URL = \"https://localhost:9999\";\nvar ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nvar TRAILING_SLASH_URL_REGEX = /\\/(?:(?:\\?|#).*)?$/;\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url2 = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url2.toString();\n}\nfunction url(strings, ...values2) {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values2[i - 1] ?? \"\") + str\n  );\n}\nfunction sanitizeUrl(url2) {\n  if (url2.startsWith(\"www.\")) {\n    url2 = \"https://\" + url2;\n  }\n  if (url2 === \"#\") {\n    return url2;\n  }\n  try {\n    const isAbsolute = ABSOLUTE_URL_REGEX.test(url2);\n    const urlObject = new URL(\n      url2,\n      isAbsolute ? void 0 : PLACEHOLDER_BASE_URL\n    );\n    if (urlObject.protocol !== \"http:\" && urlObject.protocol !== \"https:\") {\n      return null;\n    }\n    const hasTrailingSlash = TRAILING_SLASH_URL_REGEX.test(url2);\n    const sanitizedUrl = (\n      // 1. Origin, only for absolute URLs\n      (isAbsolute ? urlObject.origin : \"\") + // 2. Pathname, with a trailing slash if the original URL had one\n      (urlObject.pathname === \"/\" ? (\n        // 2.a. Domain-only URLs, they always have their pathname set to \"/\"\n        hasTrailingSlash ? \"/\" : \"\"\n      ) : (\n        // 2.b. URLs with a path\n        hasTrailingSlash && !urlObject.pathname.endsWith(\"/\") ? urlObject.pathname + \"/\" : urlObject.pathname\n      )) + // 3. Search params\n      urlObject.search + // 4. Hash\n      urlObject.hash\n    );\n    return sanitizedUrl !== \"\" ? sanitizedUrl : null;\n  } catch {\n    return null;\n  }\n}\nfunction generateUrl(url2, params, hash) {\n  const isAbsolute = ABSOLUTE_URL_REGEX.test(url2);\n  const urlObject = new URL(url2, isAbsolute ? void 0 : PLACEHOLDER_BASE_URL);\n  if (params !== void 0) {\n    for (const [param, value] of Object.entries(params)) {\n      if (value) {\n        urlObject.searchParams.set(param, String(value));\n      }\n    }\n  }\n  if (!urlObject.hash && hash !== void 0) {\n    urlObject.hash = `#${hash}`;\n  }\n  return isAbsolute ? urlObject.href : urlObject.href.replace(PLACEHOLDER_BASE_URL, \"\");\n}\nfunction isUrl(string) {\n  try {\n    new URL(string);\n    return true;\n  } catch (_) {\n    return false;\n  }\n}\n\n// src/api-client.ts\nfunction createApiClient({\n  baseUrl,\n  authManager,\n  currentUserId,\n  fetchPolyfill\n}) {\n  const httpClient = new HttpClient(baseUrl, fetchPolyfill);\n  async function getThreadsSince(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/threads/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        since: options.since.toISOString()\n      },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: result.data.map(convertToThreadData),\n        deleted: result.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: result.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: result.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      subscriptions: {\n        updated: result.subscriptions.map(convertToSubscriptionData),\n        deleted: result.deletedSubscriptions.map(\n          convertToSubscriptionDeleteInfo\n        )\n      },\n      requestedAt: new Date(result.meta.requestedAt),\n      permissionHints: result.meta.permissionHints\n    };\n  }\n  async function getThreads(options) {\n    let query;\n    if (options.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    try {\n      const result = await httpClient.get(\n        url`/v2/c/rooms/${options.roomId}/threads`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\",\n          roomId: options.roomId\n        }),\n        {\n          cursor: options.cursor,\n          query,\n          limit: PAGE_SIZE\n        }\n      );\n      return {\n        threads: result.data.map(convertToThreadData),\n        inboxNotifications: result.inboxNotifications.map(\n          convertToInboxNotificationData\n        ),\n        subscriptions: result.subscriptions.map(convertToSubscriptionData),\n        nextCursor: result.meta.nextCursor,\n        requestedAt: new Date(result.meta.requestedAt),\n        permissionHints: result.meta.permissionHints\n      };\n    } catch (err) {\n      if (err instanceof HttpError && err.status === 404) {\n        return {\n          threads: [],\n          inboxNotifications: [],\n          subscriptions: [],\n          nextCursor: null,\n          //\n          // HACK\n          // requestedAt needs to be a *server* timestamp here. However, on\n          // this 404 error response, there is no such timestamp. So out of\n          // pure necessity we'll fall back to a local timestamp instead (and\n          // allow for a possible 6 hour clock difference between client and\n          // server).\n          //\n          requestedAt: new Date(Date.now() - 6 * 60 * 60 * 1e3),\n          permissionHints: {}\n        };\n      }\n      throw err;\n    }\n  }\n  async function searchComments(options, requestOptions) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/threads/comments/search`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        text: options.query.text,\n        query: objectToQuery({\n          threadMetadata: options.query.threadMetadata,\n          threadResolved: options.query.threadResolved,\n          hasAttachments: options.query.hasAttachments,\n          hasMentions: options.query.hasMentions\n        })\n      },\n      { signal: requestOptions?.signal }\n    );\n    return result;\n  }\n  async function createThread(options) {\n    const commentId = options.commentId ?? createCommentId();\n    const threadId = options.threadId ?? createThreadId();\n    const thread = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        id: threadId,\n        comment: {\n          id: commentId,\n          body: options.body,\n          attachmentIds: options.attachmentIds\n        },\n        metadata: options.metadata\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function deleteThread(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function getThread(options) {\n    const response = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/thread-with-notification/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0,\n        subscription: json.subscription ? convertToSubscriptionData(json.subscription) : void 0\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: void 0,\n        inboxNotification: void 0,\n        subscription: void 0\n      };\n    } else {\n      throw new Error(\n        `There was an error while getting thread ${options.threadId}.`\n      );\n    }\n  }\n  async function editThreadMetadata(options) {\n    return await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.metadata\n    );\n  }\n  async function createComment(options) {\n    const commentId = options.commentId ?? createCommentId();\n    const comment = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        id: commentId,\n        body: options.body,\n        attachmentIds: options.attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment(options) {\n    const comment = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        body: options.body,\n        attachmentIds: options.attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function addReaction(options) {\n    const reaction = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      { emoji: options.emoji }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function markThreadAsResolved(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-resolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function markThreadAsUnresolved(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-unresolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function subscribeToThread(options) {\n    const subscription = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/subscribe`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    return convertToSubscriptionData(subscription);\n  }\n  async function unsubscribeFromThread(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/unsubscribe`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function uploadAttachment(options) {\n    const roomId = options.roomId;\n    const abortSignal = options.signal;\n    const attachment = options.attachment;\n    const abortError = abortSignal ? new DOMException(\n      `Upload of attachment ${options.attachment.id} was aborted.`,\n      \"AbortError\"\n    ) : void 0;\n    if (abortSignal?.aborted) {\n      throw abortError;\n    }\n    const handleRetryError = (err) => {\n      if (abortSignal?.aborted) {\n        throw abortError;\n      }\n      if (err instanceof HttpError && err.status === 413) {\n        throw err;\n      }\n      return false;\n    };\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\n    const RETRY_ATTEMPTS = 10;\n    const RETRY_DELAYS = [\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3\n    ];\n    function splitFileIntoParts(file) {\n      const parts = [];\n      let start = 0;\n      while (start < file.size) {\n        const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n        parts.push({\n          partNumber: parts.length + 1,\n          part: file.slice(start, end)\n        });\n        start = end;\n      }\n      return parts;\n    }\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      return autoRetry(\n        async () => httpClient.putBlob(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          attachment.file,\n          { fileSize: attachment.size },\n          { signal: abortSignal }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      let uploadId;\n      const uploadedParts = [];\n      const createMultiPartUpload = await autoRetry(\n        async () => httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          void 0,\n          { signal: abortSignal },\n          { fileSize: attachment.size }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n        const parts = splitFileIntoParts(attachment.file);\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const batches = chunk(parts, 5);\n        for (const parts2 of batches) {\n          const uploadedPartsPromises = [];\n          for (const { part, partNumber } of parts2) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                async () => httpClient.putBlob(\n                  url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                  await authManager.getAuthValue({\n                    requestedScope: \"comments:read\",\n                    roomId\n                  }),\n                  part,\n                  void 0,\n                  { signal: abortSignal }\n                ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n          uploadedParts.push(...await Promise.all(uploadedPartsPromises));\n        }\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n        return httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { parts: sortedUploadedParts },\n          { signal: abortSignal }\n        );\n      } catch (error3) {\n        if (uploadId && error3?.name && (error3.name === \"AbortError\" || error3.name === \"TimeoutError\")) {\n          try {\n            await httpClient.rawDelete(\n              url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}`,\n              await authManager.getAuthValue({\n                requestedScope: \"comments:read\",\n                roomId\n              })\n            );\n          } catch (error4) {\n          }\n        }\n        throw error3;\n      }\n    }\n  }\n  const attachmentUrlsBatchStoresByRoom = new DefaultMap((roomId) => {\n    const batch2 = new Batch(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { attachmentIds }\n        );\n        return urls.map(\n          (url2) => url2 ?? new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch2);\n  });\n  function getOrCreateAttachmentUrlsStore(roomId) {\n    return attachmentUrlsBatchStoresByRoom.getOrCreate(roomId);\n  }\n  function getAttachmentUrl(options) {\n    const batch2 = getOrCreateAttachmentUrlsStore(options.roomId).batch;\n    return batch2.get(options.attachmentId);\n  }\n  async function uploadChatAttachment(options) {\n    const { chatId, attachment, signal } = options;\n    const userId = currentUserId.get();\n    if (userId === void 0) {\n      throw new Error(\"Attachment upload requires an authenticated user.\");\n    }\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\n    if (options.attachment.file.size <= ATTACHMENT_PART_SIZE) {\n      await httpClient.putBlob(\n        url`/v2/c/chats/${chatId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.file.name)}`,\n        await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n        attachment.file,\n        { fileSize: attachment.file.size },\n        { signal }\n      );\n    } else {\n      const multipartUpload = await httpClient.post(\n        url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.file.name)}`,\n        await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n        void 0,\n        { signal },\n        { fileSize: attachment.file.size }\n      );\n      try {\n        const uploadedParts = [];\n        const parts = [];\n        let start = 0;\n        while (start < attachment.file.size) {\n          const end = Math.min(\n            start + ATTACHMENT_PART_SIZE,\n            attachment.file.size\n          );\n          parts.push({\n            number: parts.length + 1,\n            part: attachment.file.slice(start, end)\n          });\n          start = end;\n        }\n        uploadedParts.push(\n          ...await Promise.all(\n            parts.map(async ({ number, part }) => {\n              return await httpClient.putBlob(\n                url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}/${String(number)}`,\n                await authManager.getAuthValue({\n                  requestedScope: \"comments:read\"\n                }),\n                part,\n                void 0,\n                { signal }\n              );\n            })\n          )\n        );\n        await httpClient.post(\n          url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}/complete`,\n          await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n          { parts: uploadedParts.sort((a, b) => a.number - b.number) },\n          { signal }\n        );\n      } catch (err) {\n        try {\n          await httpClient.delete(\n            url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}`,\n            await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n          );\n        } catch (err2) {\n        }\n        throw err;\n      }\n    }\n  }\n  const attachmentUrlsBatchStoresByChat = new DefaultMap((chatId) => {\n    const batch2 = new Batch(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post(\n          url`/v2/c/chats/${chatId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\"\n          }),\n          { attachmentIds }\n        );\n        return urls.map(\n          (url2) => url2 ?? new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch2);\n  });\n  function getOrCreateChatAttachmentUrlsStore(chatId) {\n    return attachmentUrlsBatchStoresByChat.getOrCreate(chatId);\n  }\n  function getChatAttachmentUrl(options) {\n    const batch2 = getOrCreateChatAttachmentUrlsStore(options.chatId).batch;\n    return batch2.get(options.attachmentId);\n  }\n  async function getSubscriptionSettings(options) {\n    return httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/subscription-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      void 0,\n      {\n        signal: options.signal\n      }\n    );\n  }\n  async function updateSubscriptionSettings(options) {\n    return httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/subscription-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.settings\n    );\n  }\n  const markAsReadBatchesByRoom = new DefaultMap(\n    (roomId) => new Batch(\n      async (batchedInboxNotificationIds) => {\n        const inboxNotificationIds = batchedInboxNotificationIds.flat();\n        await httpClient.post(\n          url`/v2/c/rooms/${roomId}/inbox-notifications/read`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { inboxNotificationIds }\n        );\n        return inboxNotificationIds;\n      },\n      { delay: 50 }\n    )\n  );\n  async function markRoomInboxNotificationAsRead(options) {\n    const batch2 = markAsReadBatchesByRoom.getOrCreate(options.roomId);\n    return batch2.get(options.inboxNotificationId);\n  }\n  async function createTextMention(options) {\n    if (options.mention.kind !== \"user\" && options.mention.kind !== \"group\") {\n      return assertNever(options.mention, \"Unexpected mention kind\");\n    }\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-mentions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        userId: options.mention.kind === \"user\" ? options.mention.id : void 0,\n        groupId: options.mention.kind === \"group\" ? options.mention.id : void 0,\n        userIds: options.mention.kind === \"group\" ? options.mention.userIds : void 0,\n        mentionId: options.mentionId\n      }\n    );\n  }\n  async function deleteTextMention(options) {\n    await httpClient.rawDelete(\n      url`/v2/c/rooms/${options.roomId}/text-mentions/${options.mentionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function getTextVersion(options) {\n    return httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/y-version/${options.versionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function createTextVersion(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/version`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function reportTextEditor(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        type: options.type,\n        rootKey: options.rootKey\n      }\n    );\n  }\n  async function executeContextualPrompt(options) {\n    const result = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/ai/contextual-prompt`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      }),\n      {\n        prompt: options.prompt,\n        context: {\n          beforeSelection: options.context.beforeSelection,\n          selection: options.context.selection,\n          afterSelection: options.context.afterSelection\n        },\n        previous: options.previous\n      },\n      { signal: options.signal }\n    );\n    if (!result || result.content.length === 0) {\n      throw new Error(\"No content returned from server\");\n    }\n    return result.content[0].text;\n  }\n  async function listTextVersions(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/versions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function listTextVersionsSince(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/versions/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function streamStorage(options) {\n    const result = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/storage`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      })\n    );\n    return await result.json();\n  }\n  async function sendMessagesOverHTTP(options) {\n    return httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/send-message`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      }),\n      {\n        nonce: options.nonce,\n        messages: options.messages\n      }\n    );\n  }\n  async function getInboxNotifications(options) {\n    const PAGE_SIZE = 50;\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        limit: PAGE_SIZE,\n        query\n      }\n    );\n    const groups = json.groups.map(convertToGroupData);\n    groupsStore.setData(groups.map((group) => [group.id, group]));\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      subscriptions: json.subscriptions.map(convertToSubscriptionData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getInboxNotificationsSince(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString(), query },\n      { signal: options.signal }\n    );\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      subscriptions: {\n        updated: json.subscriptions.map(convertToSubscriptionData),\n        deleted: json.deletedSubscriptions.map(convertToSubscriptionDeleteInfo)\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUnreadInboxNotificationsCount(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const { count } = await httpClient.get(\n      url`/v2/c/inbox-notifications/count`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { query },\n      { signal: options?.signal }\n    );\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds: \"all\"\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds\n      }\n    );\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications/${inboxNotificationId}`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n  async function getNotificationSettings(options) {\n    return httpClient.get(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      void 0,\n      { signal: options?.signal }\n    );\n  }\n  async function updateNotificationSettings(settings) {\n    return httpClient.post(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      settings\n    );\n  }\n  async function getUserThreads_experimental(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(\n      url`/v2/c/threads`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        query,\n        limit: PAGE_SIZE\n      }\n    );\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      subscriptions: json.subscriptions.map(convertToSubscriptionData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints\n    };\n  }\n  async function getUserThreadsSince_experimental(options) {\n    const json = await httpClient.get(\n      url`/v2/c/threads/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      subscriptions: {\n        updated: json.subscriptions.map(convertToSubscriptionData),\n        deleted: json.deletedSubscriptions.map(convertToSubscriptionDeleteInfo)\n      },\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints\n    };\n  }\n  const batchedGetGroups = new Batch(\n    async (batchedGroupIds) => {\n      const groupIds = batchedGroupIds.flat();\n      const { groups: plainGroups } = await httpClient.post(\n        url`/v2/c/groups/find`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\"\n        }),\n        { groupIds }\n      );\n      const groups = /* @__PURE__ */ new Map();\n      for (const group of plainGroups) {\n        groups.set(group.id, convertToGroupData(group));\n      }\n      return groupIds.map((groupId) => groups.get(groupId));\n    },\n    { delay: 50 }\n  );\n  const groupsStore = createBatchStore(batchedGetGroups);\n  function getGroup(groupId) {\n    return batchedGetGroups.get(groupId);\n  }\n  async function getUrlMetadata(_url) {\n    const { metadata } = await httpClient.get(\n      url`/v2/c/urls/metadata`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { url: _url }\n    );\n    return metadata;\n  }\n  return {\n    // Room threads\n    getThreads,\n    getThreadsSince,\n    searchComments,\n    createThread,\n    getThread,\n    deleteThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment,\n    addReaction,\n    removeReaction,\n    markThreadAsResolved,\n    markThreadAsUnresolved,\n    subscribeToThread,\n    unsubscribeFromThread,\n    markRoomInboxNotificationAsRead,\n    // Room subscription settings\n    getSubscriptionSettings,\n    updateSubscriptionSettings,\n    // Room text editor\n    createTextMention,\n    deleteTextMention,\n    getTextVersion,\n    createTextVersion,\n    reportTextEditor,\n    listTextVersions,\n    listTextVersionsSince,\n    // Room attachments\n    getAttachmentUrl,\n    uploadAttachment,\n    getOrCreateAttachmentUrlsStore,\n    // User attachments\n    uploadChatAttachment,\n    getOrCreateChatAttachmentUrlsStore,\n    getChatAttachmentUrl,\n    // Room storage\n    streamStorage,\n    sendMessagesOverHTTP,\n    // Notifications\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    getNotificationSettings,\n    updateNotificationSettings,\n    // User threads\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental,\n    // Groups\n    groupsStore,\n    getGroup,\n    // AI\n    executeContextualPrompt,\n    // URL metadata\n    getUrlMetadata\n  };\n}\nfunction getBearerTokenFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nvar HttpClient = class {\n  #baseUrl;\n  #fetchPolyfill;\n  constructor(baseUrl, fetchPolyfill) {\n    this.#baseUrl = baseUrl;\n    this.#fetchPolyfill = fetchPolyfill;\n  }\n  // ------------------------------------------------------------------\n  // Public methods\n  // ------------------------------------------------------------------\n  /**\n   * Constructs and makes the HTTP request, but does not handle the response.\n   *\n   * This is what .rawFetch() does:     This method!\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails\n   *   6. Throw HttpError if response is an error\n   */\n  async #rawFetch(endpoint, authValue, options, params) {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"This client can only be used to make /v2/c/* requests\");\n    }\n    const url2 = urljoin(this.#baseUrl, endpoint, params);\n    return await this.#fetchPolyfill(url2, {\n      ...options,\n      headers: {\n        // These headers are default, but can be overriden by custom headers\n        \"Content-Type\": \"application/json; charset=utf-8\",\n        // Possible header overrides\n        ...options?.headers,\n        // Cannot be overriden by custom headers\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\"\n      }\n    });\n  }\n  /**\n   * Constructs, makes the HTTP request, and handles the response by parsing\n   * JSON and/or throwing an HttpError if it failed.\n   *\n   * This is what .rawFetch() does:\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:    This method!\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails ()\n   *   6. Throw HttpError if response is an error\n   */\n  async #fetch(endpoint, authValue, options, params) {\n    const response = await this.#rawFetch(endpoint, authValue, options, params);\n    if (!response.ok) {\n      throw await HttpError.fromResponse(response);\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  /**\n   * Makes a GET request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .get() instead.\n   */\n  async rawGet(endpoint, authValue, params, options) {\n    return await this.#rawFetch(endpoint, authValue, options, params);\n  }\n  /**\n   * Makes a POST request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .post() instead.\n   */\n  async rawPost(endpoint, authValue, body) {\n    return await this.#rawFetch(endpoint, authValue, {\n      method: \"POST\",\n      body: stringifyOrLog(body)\n    });\n  }\n  /**\n   * Makes a DELETE request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .delete() instead.\n   */\n  async rawDelete(endpoint, authValue) {\n    return await this.#rawFetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a GET request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async get(endpoint, authValue, params, options) {\n    return await this.#fetch(endpoint, authValue, options, params);\n  }\n  /**\n   * Makes a POST request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async post(endpoint, authValue, body, options, params) {\n    return await this.#fetch(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"POST\",\n        body: stringifyOrLog(body)\n      },\n      params\n    );\n  }\n  /**\n   * Makes a DELETE request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async delete(endpoint, authValue) {\n    return await this.#fetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a PUT request for a Blob body, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async putBlob(endpoint, authValue, blob, params, options) {\n    return await this.#fetch(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/octet-stream\"\n        },\n        body: blob\n      },\n      params\n    );\n  }\n};\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  #curr;\n  constructor(initialContext) {\n    this.#curr = initialContext;\n  }\n  get current() {\n    return this.#curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.#curr,\n      patch(patch) {\n        if (allowed) {\n          self.#curr = Object.assign({}, self.#curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  id;\n  // Indicates whether this state machine is still being configured, has\n  // started, or has terminated\n  #runningState;\n  #currentContext;\n  #states;\n  #currentStateOrNull;\n  #allowedTransitions;\n  #eventHub;\n  events;\n  //\n  // The cleanup stack is a stack of (optional) callback functions that will\n  // be run when exiting the current state. If a state (or state group) does\n  // not have an exit handler, then the entry for that level may be\n  // `undefined`, but there will be an explicit entry in the stack for it.\n  //\n  // This will always be true:\n  //\n  //   cleanupStack.length == currentState.split('.').length + 1\n  //\n  // Each stack level represents a different state \"group\".\n  //\n  // For example, if you are in a state named `foo.bar.qux`, then the stack\n  // will contain the exit handler for `foo.bar.qux` (at the top), then\n  // `foo.bar.*`, then `foo.*`, and finally, `*`.\n  //\n  #cleanupStack;\n  #enterFns;\n  // Used to provide better error messages\n  #knownEventTypes;\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get #initialState() {\n    const result = this.#states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.#currentStateOrNull === null) {\n      if (this.#runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.#currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.#runningState = 1 /* STARTED */;\n    this.#currentStateOrNull = this.#initialState;\n    this.#enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.#runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.#exit(null);\n    this.#runningState = 2 /* STOPPED */;\n    this.#currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.#runningState = 0 /* NOT_STARTED_YET */;\n    this.#currentStateOrNull = null;\n    this.#states = /* @__PURE__ */ new Set();\n    this.#enterFns = /* @__PURE__ */ new Map();\n    this.#cleanupStack = [];\n    this.#knownEventTypes = /* @__PURE__ */ new Set();\n    this.#allowedTransitions = /* @__PURE__ */ new Map();\n    this.#currentContext = new SafeContext(initialContext);\n    this.#eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.#eventHub.didReceiveEvent.observable,\n      willTransition: this.#eventHub.willTransition.observable,\n      didIgnoreEvent: this.#eventHub.didIgnoreEvent.observable,\n      willExitState: this.#eventHub.willExitState.observable,\n      didEnterState: this.#eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.#currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.#states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.#enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.#enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  /**\n   * Defines a promise-based state. When the state is entered, the promise is\n   * created. When the promise resolves, the machine will transition to the\n   * provided `onOK` target state. When the promise rejects, the machine will\n   * transition to the `onError` target state.\n   *\n   * Optionally, a `maxTimeout` can be set. If the timeout happens before the\n   * promise is settled, then the machine will also transition to the `onError`\n   * target state.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param promiseFn       The callback to be invoked when the state is entered.\n   * @param onOK            The state to transition to when the promise resolves.\n   * @param onError         The state to transition to when the promise\n   *                        rejects, or when the timeout happens before the\n   *                        promise has been settled.\n   * @param maxTimeout      Optional timeout in milliseconds.\n   *\n   * When the promise callback function is invoked, it's provided with an\n   * AbortSignal (2nd argument).\n   * If a state transition happens while the promise is pending (for example,\n   * an event, or a timeout happens), then an abort signal will be used to\n   * indicate this. Implementers can use this abort signal to terminate the\n   * in-flight promise, or ignore its results, etc.\n   */\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      const timeoutId = maxTimeout ? setTimeout(() => {\n        const reason = new Error(\"Timed out\");\n        this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n      }, maxTimeout) : void 0;\n      let done = false;\n      void promiseFn(this.#currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        clearTimeout(timeoutId);\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  #getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.#states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.#states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.#states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.#getStatesMatching(nameOrPattern)) {\n      let map = this.#allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.#allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.#knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param after           Number of milliseconds after which to take the\n   *                        transition. If in the mean time, another transition\n   *                        is taken, the timer will get cancelled.\n   * @param target          The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.#currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.#transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  #getTargetFn(eventName) {\n    return this.#allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  #exit(levels) {\n    this.#eventHub.willExitState.notify(this.currentState);\n    this.#currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.#cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.#cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  #enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.#currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.#enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.#cleanupStack.push(cleanupFn);\n        } else {\n          this.#cleanupStack.push(null);\n        }\n      }\n    });\n    this.#eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.#knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.#runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.#getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.#transition(event, targetFn);\n    } else {\n      this.#eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  #transition(event, target) {\n    this.#eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.#currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.#eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.#states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.#eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.#exit(up);\n    }\n    this.#currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.#currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.#enter(down);\n    }\n  }\n};\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_UPDATED\"] = 408] = \"THREAD_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    // istanbul ignore next\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeBufferableEventSource();\n  onMessage.pause();\n  const onConnectionError = makeEventSource();\n  function fireErrorEvent(message, code) {\n    return () => {\n      onConnectionError.notify({ message, code });\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onConnectionError: onConnectionError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  #machine;\n  #cleanups;\n  events;\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.#machine = machine;\n    this.events = events;\n    this.#cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.#machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.#machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.#machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.#machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.#machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.#machine.stop();\n    let cleanup;\n    while (cleanup = this.#cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.#machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.#machine.send(event);\n  }\n};\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/lib/IncrementalJsonParser.ts\nvar EMPTY_OBJECT = Object.freeze({});\nvar NULL_KEYWORD_CHARS = Array.from(new Set(\"null\"));\nvar TRUE_KEYWORD_CHARS = Array.from(new Set(\"true\"));\nvar FALSE_KEYWORD_CHARS = Array.from(new Set(\"false\"));\nvar ALL_KEYWORD_CHARS = Array.from(new Set(\"nulltruefalse\"));\nfunction stripChar(str, chars) {\n  const lastChar = str[str.length - 1];\n  if (chars.includes(lastChar)) {\n    return str.slice(0, -1);\n  }\n  return str;\n}\nvar IncrementalJsonParser = class {\n  // Input\n  #sourceText = \"\";\n  // Output\n  #cachedJson;\n  /** How much we've already parsed */\n  #scanIndex = 0;\n  /** Whether the last char processed was a backslash */\n  #escaped = false;\n  /**\n   * Start position of the last unterminated string, -1 if we're not inside\n   * a string currently.\n   *\n   * Example: '{\"a\": \"foo'\n   *                 ^\n   */\n  #lastUnterminatedString = -1;\n  /**\n   * Start position of the last fully terminated string we've seen.\n   *\n   * Example: '{\"a\": \"foo'\n   *            ^\n   */\n  #lastTerminatedString = -1;\n  /** The bracket stack of expected closing chars. For input '{\"a\": [\"foo', the stack would be ['}', ']']. */\n  #stack = [];\n  constructor(text = \"\") {\n    this.append(text);\n  }\n  get source() {\n    return this.#sourceText;\n  }\n  get json() {\n    if (this.#cachedJson === void 0) {\n      this.#cachedJson = this.#parse();\n    }\n    return this.#cachedJson;\n  }\n  /** Whether we're currently inside an unterminated string, e.g. '{\"hello' */\n  get #inString() {\n    return this.#lastUnterminatedString >= 0;\n  }\n  append(delta) {\n    if (delta) {\n      if (this.#sourceText === \"\") {\n        delta = delta.trimStart();\n      }\n      this.#sourceText += delta;\n      this.#cachedJson = void 0;\n    }\n  }\n  #autocompleteTail(output) {\n    if (this.#inString) {\n      return \"\";\n    }\n    const lastChar = output.charAt(output.length - 1);\n    if (lastChar === \"\") return \"\";\n    if (lastChar === \"-\") {\n      return \"0\";\n    }\n    if (!ALL_KEYWORD_CHARS.includes(lastChar)) return \"\";\n    if (NULL_KEYWORD_CHARS.includes(lastChar)) {\n      if (output.endsWith(\"nul\")) return \"l\";\n      if (output.endsWith(\"nu\")) return \"ll\";\n      if (output.endsWith(\"n\")) return \"ull\";\n    }\n    if (TRUE_KEYWORD_CHARS.includes(lastChar)) {\n      if (output.endsWith(\"tru\")) return \"e\";\n      if (output.endsWith(\"tr\")) return \"ue\";\n      if (output.endsWith(\"t\")) return \"rue\";\n    }\n    if (FALSE_KEYWORD_CHARS.includes(lastChar)) {\n      if (output.endsWith(\"fals\")) return \"e\";\n      if (output.endsWith(\"fal\")) return \"se\";\n      if (output.endsWith(\"fa\")) return \"lse\";\n      if (output.endsWith(\"f\")) return \"alse\";\n    }\n    return \"\";\n  }\n  /**\n   * Updates the internal parsing state by processing any new content\n   * that has been appended since the last parse. This updates the state with\n   * facts only. Any interpretation is left to the #parse() method.\n   */\n  #catchup() {\n    const newContent = this.#sourceText.slice(this.#scanIndex);\n    for (let i = 0; i < newContent.length; i++) {\n      const ch = newContent[i];\n      const absolutePos = this.#scanIndex + i;\n      if (this.#inString) {\n        if (this.#escaped) {\n          this.#escaped = false;\n        } else if (ch === \"\\\\\") {\n          this.#escaped = true;\n        } else if (ch === '\"') {\n          this.#lastTerminatedString = this.#lastUnterminatedString;\n          this.#lastUnterminatedString = -1;\n        }\n      } else {\n        if (ch === '\"') {\n          this.#lastUnterminatedString = absolutePos;\n        } else if (ch === \"{\") {\n          this.#stack.push(\"}\");\n        } else if (ch === \"[\") {\n          this.#stack.push(\"]\");\n        } else if (ch === \"}\" && this.#stack.length > 0 && this.#stack[this.#stack.length - 1] === \"}\") {\n          this.#stack.pop();\n        } else if (ch === \"]\" && this.#stack.length > 0 && this.#stack[this.#stack.length - 1] === \"]\") {\n          this.#stack.pop();\n        }\n      }\n    }\n    this.#scanIndex = this.#sourceText.length;\n  }\n  #parse() {\n    this.#catchup();\n    let result = this.#sourceText;\n    if (result.charAt(0) !== \"{\") {\n      return EMPTY_OBJECT;\n    }\n    if (result.endsWith(\"}\")) {\n      const quickCheck = tryParseJson(result);\n      if (quickCheck) {\n        return quickCheck;\n      }\n    }\n    if (this.#inString) {\n      if (this.#escaped) {\n        result = result.slice(0, -1);\n      }\n      result += '\"';\n    }\n    result = result.trimEnd();\n    result = stripChar(result, \",.\");\n    result = result + this.#autocompleteTail(result);\n    const suffix = this.#stack.reduceRight((acc, ch) => acc + ch, \"\");\n    {\n      const attempt = tryParseJson(result + suffix);\n      if (attempt) {\n        return attempt;\n      }\n    }\n    if (this.#inString) {\n      result = result.slice(0, this.#lastUnterminatedString);\n    } else {\n      result = stripChar(result, \":\");\n      if (result.endsWith('\"')) {\n        result = result.slice(0, this.#lastTerminatedString);\n      }\n    }\n    result = stripChar(result, \",\");\n    result += suffix;\n    return tryParseJson(result) ?? EMPTY_OBJECT;\n  }\n};\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\nfunction shallow2(a, b) {\n  if (!isPlainObject(a) || !isPlainObject(b)) {\n    return shallow(a, b);\n  }\n  const keysA = Object.keys(a);\n  if (keysA.length !== Object.keys(b).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(b, key) && shallow(a[key], b[key])\n  );\n}\n\n// src/lib/TreePool.ts\nvar TreePool = class {\n  #_items;\n  #_childrenOf;\n  #_sorted;\n  #_primaryKey;\n  #_parentKeyFn;\n  #_lt;\n  constructor(primaryKey, parentKey, lt) {\n    this.#_primaryKey = primaryKey;\n    this.#_parentKeyFn = parentKey;\n    this.#_lt = lt;\n    this.#_items = /* @__PURE__ */ new Map();\n    this.#_childrenOf = new DefaultMap(() => /* @__PURE__ */ new Set());\n    this.#_sorted = SortedList.with(lt);\n  }\n  get(id) {\n    return this.#_items.get(id);\n  }\n  getOrThrow(id) {\n    return this.get(id) ?? raise(`Item with id ${id} not found`);\n  }\n  get sorted() {\n    return this.#_sorted;\n  }\n  getParentId(id) {\n    const item = this.getOrThrow(id);\n    return this.#_parentKeyFn(item);\n  }\n  getParent(id) {\n    const parentId = this.getParentId(id);\n    return parentId ? this.getOrThrow(parentId) : null;\n  }\n  getChildren(id) {\n    const childIds = this.#_childrenOf.get(id);\n    if (!childIds) return [];\n    return Array.from(childIds).map(\n      (id2) => this.#_items.get(id2)\n      // eslint-disable-line no-restricted-syntax\n    );\n  }\n  *walkUp(id, predicate) {\n    const includeSelf = true;\n    let nodeId = id;\n    do {\n      const item = this.getOrThrow(nodeId);\n      if (includeSelf || nodeId !== id) {\n        if (!predicate || predicate(item)) {\n          yield item;\n        }\n      }\n      nodeId = this.#_parentKeyFn(item);\n    } while (nodeId !== null);\n  }\n  // XXXX Generalize\n  *walkLeft(id, predicate) {\n    const self = this.getOrThrow(id);\n    const siblings = SortedList.from(this.getSiblings(id), this.#_lt);\n    for (const sibling of siblings.iterReversed()) {\n      if (this.#_lt(self, sibling)) continue;\n      if (!predicate || predicate(sibling)) {\n        yield sibling;\n      }\n    }\n  }\n  // XXXX Generalize\n  *walkRight(id, predicate) {\n    const self = this.getOrThrow(id);\n    const siblings = SortedList.from(this.getSiblings(id), this.#_lt);\n    for (const sibling of siblings) {\n      if (this.#_lt(sibling, self)) continue;\n      if (!predicate || predicate(sibling)) {\n        yield sibling;\n      }\n    }\n  }\n  // XXXX Generalize\n  *walkDown(id, predicate) {\n    const children = SortedList.from(this.getChildren(id), this.#_lt).rawArray;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      yield* this.walkDown(\n        this.#_primaryKey(child),\n        predicate\n        // \"depth-first\",\n        // true\n      );\n      if (!predicate || predicate(child)) {\n        yield child;\n      }\n    }\n  }\n  /** Returns all siblings, not including the item itself. */\n  getSiblings(id) {\n    const self = this.getOrThrow(id);\n    const parentId = this.getParentId(id);\n    return this.getChildren(parentId).filter((item) => item !== self);\n  }\n  [Symbol.iterator]() {\n    return this.#_sorted[Symbol.iterator]();\n  }\n  upsert(item) {\n    const pk = this.#_primaryKey(item);\n    const existing = this.#_items.get(pk);\n    if (existing) {\n      if (this.#_parentKeyFn(existing) !== this.#_parentKeyFn(item)) {\n        throw new Error(\n          \"Cannot upsert parent ID changes that change the tree structure. Remove the entry first, and recreate it\"\n        );\n      }\n      this.#_sorted.remove(existing);\n    }\n    this.#_items.set(pk, item);\n    this.#_sorted.add(item);\n    const parentId = this.#_parentKeyFn(item);\n    this.#_childrenOf.getOrCreate(parentId).add(pk);\n  }\n  remove(pk) {\n    const item = this.#_items.get(pk);\n    if (!item) return false;\n    const childIds = this.#_childrenOf.get(pk);\n    if (childIds) {\n      throw new Error(\n        `Cannot remove item '${pk}' while it still has children. Remove children first.`\n      );\n    }\n    const parentId = this.#_parentKeyFn(item);\n    const siblings = this.#_childrenOf.get(parentId);\n    if (siblings) {\n      siblings.delete(pk);\n      if (siblings.size === 0) {\n        this.#_childrenOf.delete(parentId);\n      }\n    }\n    this.#_sorted.remove(item);\n    this.#_childrenOf.delete(pk);\n    this.#_items.delete(pk);\n    return true;\n  }\n  clear() {\n    if (this.#_items.size === 0) return false;\n    this.#_childrenOf.clear();\n    this.#_items.clear();\n    this.#_sorted.clear();\n    return true;\n  }\n};\n\n// src/protocol/AuthToken.ts\nvar Permission = /* @__PURE__ */ ((Permission2) => {\n  Permission2[\"Read\"] = \"room:read\";\n  Permission2[\"Write\"] = \"room:write\";\n  Permission2[\"PresenceWrite\"] = \"room:presence:write\";\n  Permission2[\"CommentsWrite\"] = \"comments:write\";\n  Permission2[\"CommentsRead\"] = \"comments:read\";\n  return Permission2;\n})(Permission || {});\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/ai.ts\nvar DEFAULT_REQUEST_TIMEOUT = 4e3;\nfunction defineAiTool() {\n  return (def) => {\n    return def;\n  };\n}\nvar KnowledgeStack = class {\n  #_layers;\n  #stack;\n  //                 /                \\\n  //      knowledge key               \"layer\" key\n  //      (random, or optionally      (one entry per mounted component)\n  //       set by user)\n  #_cache;\n  constructor() {\n    this.#_layers = /* @__PURE__ */ new Set();\n    this.#stack = new DefaultMap(\n      () => /* @__PURE__ */ new Map()\n    );\n    this.#_cache = void 0;\n  }\n  // Typically a useId()\n  registerLayer(uniqueLayerId) {\n    const layerKey = uniqueLayerId;\n    if (this.#_layers.has(layerKey))\n      raise(`Layer '${layerKey}' already exists, provide a unique layer id`);\n    this.#_layers.add(layerKey);\n    return layerKey;\n  }\n  deregisterLayer(layerKey) {\n    this.#_layers.delete(layerKey);\n    let deleted = false;\n    for (const [key, knowledge] of this.#stack) {\n      if (knowledge.delete(layerKey)) {\n        deleted = true;\n      }\n      if (knowledge.size === 0)\n        this.#stack.delete(key);\n    }\n    if (deleted) {\n      this.invalidate();\n    }\n  }\n  get() {\n    return this.#_cache ??= this.#recompute();\n  }\n  invalidate() {\n    this.#_cache = void 0;\n  }\n  #recompute() {\n    return Array.from(this.#stack.values()).flatMap(\n      (layer) => (\n        // Return only the last item (returns [] when empty)\n        Array.from(layer.values()).slice(-1).filter(isDefined)\n      )\n    );\n  }\n  updateKnowledge(layerKey, key, data) {\n    if (!this.#_layers.has(layerKey)) raise(`Unknown layer key: ${layerKey}`);\n    this.#stack.getOrCreate(key).set(layerKey, data);\n    this.invalidate();\n  }\n};\nfunction createStore_forKnowledge() {\n  const knowledgeByChatId = new DefaultMap(\n    (_chatId) => new KnowledgeStack()\n  );\n  function getKnowledgeStack(chatId) {\n    return knowledgeByChatId.getOrCreate(chatId ?? kWILDCARD);\n  }\n  function getKnowledgeForChat(chatId) {\n    const globalKnowledge = knowledgeByChatId.getOrCreate(kWILDCARD).get();\n    const scopedKnowledge = knowledgeByChatId.get(chatId)?.get() ?? [];\n    return [...globalKnowledge, ...scopedKnowledge];\n  }\n  return {\n    getKnowledgeStack,\n    getKnowledgeForChat\n  };\n}\nfunction now() {\n  return (/* @__PURE__ */ new Date()).toISOString();\n}\nvar kWILDCARD = Symbol(\"*\");\nfunction createStore_forTools() {\n  const toolsByChatId\\u03A3 = new DefaultMap(\n    (_chatId) => {\n      return new DefaultMap((_name) => {\n        return new Signal(void 0);\n      });\n    }\n  );\n  const globalOrScopedTool\\u03A3 = new DefaultMap((nameAndChat) => {\n    const [name, chatId] = tryParseJson(nameAndChat);\n    return DerivedSignal.from(() => {\n      return (\n        // A tool that's registered and scoped to a specific chat ID...\n        (chatId !== void 0 ? toolsByChatId\\u03A3.getOrCreate(chatId).getOrCreate(name) : void 0)?.get() ?? // ...or a globally registered tool\n        toolsByChatId\\u03A3.getOrCreate(kWILDCARD).getOrCreate(name).get()\n      );\n    });\n  });\n  function getTool\\u03A3(name, chatId) {\n    const key = JSON.stringify(chatId !== void 0 ? [name, chatId] : [name]);\n    return globalOrScopedTool\\u03A3.getOrCreate(key);\n  }\n  function registerTool(name, tool, chatId) {\n    if (!tool.execute && !tool.render) {\n      throw new Error(\n        \"A tool definition must have an execute() function, a render() function, or both.\"\n      );\n    }\n    const key = chatId ?? kWILDCARD;\n    toolsByChatId\\u03A3.getOrCreate(key).getOrCreate(name).set(tool);\n    return () => unregisterTool(key, name);\n  }\n  function unregisterTool(chatId, name) {\n    const tools = toolsByChatId\\u03A3.get(chatId);\n    if (tools === void 0) return;\n    const tool = tools.get(name);\n    if (tool === void 0) return;\n    tool.set(void 0);\n  }\n  function getToolDescriptions(chatId) {\n    const globalTools\\u03A3 = toolsByChatId\\u03A3.get(kWILDCARD);\n    const scopedTools\\u03A3 = toolsByChatId\\u03A3.get(chatId);\n    return Array.from([\n      ...globalTools\\u03A3?.entries() ?? [],\n      ...scopedTools\\u03A3?.entries() ?? []\n    ]).flatMap(([name, tool\\u03A3]) => {\n      const tool = tool\\u03A3.get();\n      return tool && (tool.enabled ?? true) ? [{ name, description: tool.description, parameters: tool.parameters }] : [];\n    });\n  }\n  return {\n    getToolDescriptions,\n    getTool\\u03A3,\n    registerTool\n  };\n}\nfunction createStore_forChatMessages(toolsStore, setToolResultFn) {\n  const myMessages = /* @__PURE__ */ new Set();\n  const handledInvocations = /* @__PURE__ */ new Set();\n  const messagePoolByChatId\\u03A3 = new DefaultMap(\n    (_chatId) => new MutableSignal(\n      new TreePool(\n        (x) => x.id,\n        (x) => x.parentId,\n        (x, y) => x.createdAt < y.createdAt\n      )\n    )\n  );\n  const generatingMessages\\u03A3 = new MutableSignal(\n    /* @__PURE__ */ new Map()\n  );\n  function createOptimistically(chatId, role, parentId, third) {\n    const id = `ms_${nanoid()}`;\n    const createdAt = now();\n    if (role === \"user\") {\n      const content = third;\n      upsert({\n        id,\n        chatId,\n        role,\n        parentId,\n        createdAt,\n        content,\n        _optimistic: true\n      });\n    } else {\n      const copilotId = third;\n      upsert({\n        id,\n        chatId,\n        role,\n        parentId,\n        createdAt,\n        status: \"generating\",\n        contentSoFar: [],\n        copilotId,\n        _optimistic: true\n      });\n    }\n    return id;\n  }\n  function upsertMany(messages) {\n    batch(() => {\n      for (const message of messages) {\n        upsert(message);\n      }\n    });\n  }\n  function remove(chatId, messageId) {\n    const chatMsgs\\u03A3 = messagePoolByChatId\\u03A3.get(chatId);\n    if (!chatMsgs\\u03A3) return;\n    const existing = chatMsgs\\u03A3.get().get(messageId);\n    if (!existing || existing.deletedAt) return;\n    if (existing.role === \"assistant\" && existing.status !== \"completed\") {\n      upsert({ ...existing, deletedAt: now(), contentSoFar: [] });\n    } else {\n      upsert({ ...existing, deletedAt: now(), content: [] });\n    }\n  }\n  function removeByChatId(chatId) {\n    const chatMsgs\\u03A3 = messagePoolByChatId\\u03A3.get(chatId);\n    if (chatMsgs\\u03A3 === void 0) return;\n    chatMsgs\\u03A3.mutate((pool) => pool.clear());\n  }\n  function upsert(message) {\n    batch(() => {\n      const chatMsgs\\u03A3 = messagePoolByChatId\\u03A3.getOrCreate(message.chatId);\n      chatMsgs\\u03A3.mutate((pool) => pool.upsert(message));\n      if (message.role === \"assistant\" && message.status === \"generating\") {\n        generatingMessages\\u03A3.mutate((lut) => {\n          lut.set(message.id, structuredClone(message));\n        });\n      } else {\n        generatingMessages\\u03A3.mutate((lut) => {\n          lut.delete(message.id);\n        });\n      }\n      if (message.role === \"assistant\" && message.status === \"awaiting-tool\") {\n        if (myMessages.has(message.id)) {\n          for (const toolInvocation of message.contentSoFar.filter(\n            (part) => part.type === \"tool-invocation\" && part.stage === \"executing\"\n          )) {\n            if (!handledInvocations.has(toolInvocation.invocationId)) {\n              handledInvocations.add(toolInvocation.invocationId);\n            } else {\n              continue;\n            }\n            const executeFn = toolsStore.getTool\\u03A3(toolInvocation.name, message.chatId).get()?.execute;\n            if (executeFn) {\n              (async () => {\n                const result = await executeFn(toolInvocation.args, {\n                  name: toolInvocation.name,\n                  invocationId: toolInvocation.invocationId\n                });\n                return await setToolResultFn(\n                  message.chatId,\n                  message.id,\n                  toolInvocation.invocationId,\n                  result ?? { data: {} },\n                  { copilotId: message.copilotId }\n                  // TODO: Should we pass the other generation options (tools, knowledge) as well?\n                );\n              })().catch((err) => {\n                error2(\n                  `Error trying to respond to tool-call: ${String(err)} (in execute())`\n                );\n              });\n            }\n          }\n        }\n      } else {\n        if (message.role === \"assistant\" && message.status === \"generating\") {\n        } else {\n          myMessages.delete(message.id);\n        }\n      }\n    });\n  }\n  function addDelta(messageId, delta) {\n    generatingMessages\\u03A3.mutate((lut) => {\n      const message = lut.get(messageId);\n      if (message === void 0) return false;\n      patchContentWithDelta(message.contentSoFar, delta);\n      lut.set(messageId, message);\n      return true;\n    });\n  }\n  function* iterGeneratingMessages() {\n    for (const chatMsgs\\u03A3 of messagePoolByChatId\\u03A3.values()) {\n      for (const m of chatMsgs\\u03A3.get()) {\n        if (m.role === \"assistant\" && m.status === \"generating\" && !m._optimistic) {\n          yield m;\n        }\n      }\n    }\n  }\n  function failAllPending() {\n    batch(() => {\n      generatingMessages\\u03A3.mutate((lut) => {\n        let deleted = false;\n        for (const [k, v] of lut) {\n          if (!v._optimistic) {\n            lut.delete(k);\n            deleted = true;\n          }\n        }\n        return deleted;\n      });\n      upsertMany(\n        Array.from(iterGeneratingMessages()).map(\n          (message) => ({\n            ...message,\n            status: \"failed\",\n            errorReason: \"Lost connection\"\n          })\n        )\n      );\n    });\n  }\n  function getMessageById(messageId) {\n    for (const messages\\u03A3 of messagePoolByChatId\\u03A3.values()) {\n      const message = messages\\u03A3.get().get(messageId);\n      if (message) {\n        return message;\n      }\n    }\n    return void 0;\n  }\n  function first(iterable) {\n    const result = iterable.next();\n    return result.done ? void 0 : result.value;\n  }\n  function selectBranch(pool, preferredBranch) {\n    function isAlive(message2) {\n      if (!message2.deletedAt) {\n        return true;\n      }\n      for (const _ of pool.walkDown(message2.id, (m) => !m.deletedAt)) {\n        return true;\n      }\n      return false;\n    }\n    function selectSpine(leaf) {\n      const spine = [];\n      let lastVisitedMessage = null;\n      for (const message2 of pool.walkUp(leaf.id)) {\n        const prev = first(pool.walkLeft(message2.id, isAlive))?.id ?? null;\n        const next = first(pool.walkRight(message2.id, isAlive))?.id ?? null;\n        if (!message2.deletedAt || prev || next) {\n          const node = {\n            ...message2,\n            navigation: { parent: null, prev, next }\n          };\n          if (lastVisitedMessage !== null) {\n            lastVisitedMessage.navigation.parent = node.id;\n          }\n          lastVisitedMessage = node;\n          spine.push(node);\n        }\n      }\n      return spine.reverse();\n    }\n    function fallback() {\n      const latest = pool.sorted.findRight((m) => !m.deletedAt);\n      return latest ? selectSpine(latest) : [];\n    }\n    if (preferredBranch === null) {\n      return fallback();\n    }\n    const message = pool.get(preferredBranch);\n    if (!message) {\n      return fallback();\n    }\n    for (const current of pool.walkUp(message.id)) {\n      for (const desc of pool.walkDown(current.id, (m) => !m.deletedAt)) {\n        return selectSpine(desc);\n      }\n      if (!current.deletedAt) {\n        return selectSpine(current);\n      }\n    }\n    return fallback();\n  }\n  const immutableMessagesByBranch = new DefaultMap((chatId) => {\n    return new DefaultMap((branchId) => {\n      const messages\\u03A3 = DerivedSignal.from(() => {\n        const pool = messagePoolByChatId\\u03A3.getOrCreate(chatId).get();\n        return selectBranch(pool, branchId);\n      }, shallow2);\n      return DerivedSignal.from(() => {\n        const generatingMessages = generatingMessages\\u03A3.get();\n        return messages\\u03A3.get().map((message) => {\n          if (message.role !== \"assistant\" || message.status !== \"generating\") {\n            return message;\n          }\n          const generatingMessage = generatingMessages.get(message.id);\n          if (generatingMessage === void 0) return message;\n          return {\n            ...message,\n            contentSoFar: generatingMessage.contentSoFar\n          };\n        });\n      }, shallow);\n    });\n  });\n  function getChatMessagesForBranch\\u03A3(chatId, branch) {\n    return immutableMessagesByBranch.getOrCreate(chatId).getOrCreate(branch || null);\n  }\n  function getLastUsedCopilotId(chatId) {\n    const pool = messagePoolByChatId\\u03A3.getOrCreate(chatId).get();\n    const latest = pool.sorted.findRight(\n      (m) => m.role === \"assistant\" && !m.deletedAt\n    );\n    return latest?.copilotId;\n  }\n  return {\n    // Readers\n    getMessageById,\n    getChatMessagesForBranch\\u03A3,\n    getLastUsedCopilotId,\n    // Mutations\n    createOptimistically,\n    upsert,\n    upsertMany,\n    remove,\n    removeByChatId,\n    addDelta,\n    failAllPending,\n    markMine(messageId) {\n      myMessages.add(messageId);\n    },\n    /**\n     * Iterates over all my auto-executing messages.\n     *\n     * These are messages that match all these conditions:\n     * - The message is an assistant message\n     * - The message is owned by this client (\"mine\")\n     * - The message is currently in \"awaiting-tool\" status\n     * - The message has at least one tool invocation in \"executing\" stage\n     * - The tool invocation has an execute() function defined\n     */\n    *getAutoExecutingMessageIds() {\n      for (const messageId of myMessages) {\n        const message = getMessageById(messageId);\n        if (message?.role === \"assistant\" && message.status === \"awaiting-tool\") {\n          const isAutoExecuting = message.contentSoFar.some((part) => {\n            if (part.type === \"tool-invocation\" && part.stage === \"executing\") {\n              const tool = toolsStore.getTool\\u03A3(part.name, message.chatId).get();\n              return typeof tool?.execute === \"function\";\n            }\n            return false;\n          });\n          if (isAutoExecuting) {\n            yield message.id;\n          }\n        }\n      }\n    }\n  };\n}\nfunction createStore_forUserAiChats() {\n  const chatsDB = new AiChatDB();\n  function upsertMany(chats) {\n    batch(() => {\n      for (const chat of chats) {\n        chatsDB.upsert(chat);\n      }\n    });\n  }\n  function upsert(chat) {\n    chatsDB.upsert(chat);\n  }\n  function markDeleted(chatId) {\n    chatsDB.markDeleted(chatId);\n  }\n  function getChatById(chatId) {\n    return chatsDB.getEvenIfDeleted(chatId);\n  }\n  function findMany(query) {\n    return chatsDB.signal.get().findMany(query);\n  }\n  return {\n    getChatById,\n    findMany,\n    // Mutations\n    upsert,\n    upsertMany,\n    markDeleted\n  };\n}\nfunction createAi(config) {\n  const managedSocket = new ManagedSocket(\n    config.delegates,\n    config.enableDebugLogging,\n    false\n    // AI doesn't have actors (yet, but it will)\n  );\n  const chatsStore = createStore_forUserAiChats();\n  const toolsStore = createStore_forTools();\n  const knowledgeStore = createStore_forKnowledge();\n  const messagesStore = createStore_forChatMessages(toolsStore, setToolResult);\n  const context = {\n    staticSessionInfoSig: new Signal(null),\n    dynamicSessionInfoSig: new Signal(null),\n    pendingCmds: /* @__PURE__ */ new Map(),\n    chatsStore,\n    messagesStore,\n    toolsStore,\n    knowledgeStore\n  };\n  const status\\u03A3 = new Signal(\"initial\");\n  const DELTA_THROTTLE = 25;\n  let pendingDeltas = [];\n  let deltaBatchTimer = null;\n  function flushPendingDeltas() {\n    const currentQueue = pendingDeltas;\n    pendingDeltas = [];\n    if (deltaBatchTimer !== null) {\n      clearTimeout(deltaBatchTimer);\n      deltaBatchTimer = null;\n    }\n    batch(() => {\n      for (const { id, delta } of currentQueue) {\n        context.messagesStore.addDelta(id, delta);\n      }\n    });\n  }\n  function enqueueDelta(id, delta) {\n    pendingDeltas.push({ id, delta });\n    if (deltaBatchTimer === null) {\n      deltaBatchTimer = setTimeout(flushPendingDeltas, DELTA_THROTTLE);\n    }\n  }\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    status\\u03A3.set(newStatus);\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        _hasLostConnection = true;\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n  }\n  function onDidDisconnect() {\n    flushPendingDeltas();\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\")\n      return;\n    const msg = tryParseJson(event.data);\n    if (!msg)\n      return;\n    const cmdId = \"cmdId\" in msg ? msg.cmdId : msg.event === \"cmd-failed\" ? msg.failedCmdId : void 0;\n    const pendingCmd = context.pendingCmds.get(cmdId);\n    if (cmdId && !pendingCmd) {\n      warn(\"Ignoring unexpected command response. Already timed out, or not for us?\", msg);\n      return;\n    }\n    if (\"event\" in msg) {\n      if (msg.event === \"delta\") {\n        const { id, delta } = msg;\n        enqueueDelta(id, delta);\n      } else {\n        batch(() => {\n          flushPendingDeltas();\n          switch (msg.event) {\n            case \"cmd-failed\":\n              pendingCmd?.reject(new Error(msg.error));\n              break;\n            case \"settle\": {\n              context.messagesStore.upsert(msg.message);\n              break;\n            }\n            case \"warning\":\n              warn(msg.message);\n              break;\n            case \"error\":\n              error2(msg.error);\n              break;\n            case \"rebooted\":\n              context.messagesStore.failAllPending();\n              break;\n            case \"sync\":\n              for (const m of msg[\"-messages\"] ?? []) {\n                context.messagesStore.remove(m.chatId, m.id);\n              }\n              for (const chatId of msg[\"-chats\"] ?? []) {\n                context.chatsStore.markDeleted(chatId);\n                context.messagesStore.removeByChatId(chatId);\n              }\n              for (const chatId of msg.clear ?? []) {\n                context.messagesStore.removeByChatId(chatId);\n              }\n              if (msg.chats) {\n                context.chatsStore.upsertMany(msg.chats);\n              }\n              if (msg.messages) {\n                context.messagesStore.upsertMany(msg.messages);\n              }\n              break;\n            default:\n              return assertNever(msg, \"Unhandled case\");\n          }\n        });\n      }\n    } else {\n      switch (msg.cmd) {\n        case \"get-chats\":\n          context.chatsStore.upsertMany(msg.chats);\n          break;\n        case \"get-or-create-chat\":\n          context.chatsStore.upsert(msg.chat);\n          break;\n        case \"delete-chat\":\n          context.chatsStore.markDeleted(msg.chatId);\n          context.messagesStore.removeByChatId(msg.chatId);\n          break;\n        case \"get-message-tree\":\n          context.chatsStore.upsert(msg.chat);\n          context.messagesStore.upsertMany(msg.messages);\n          break;\n        case \"delete-message\":\n          context.messagesStore.remove(msg.chatId, msg.messageId);\n          break;\n        case \"clear-chat\":\n          context.messagesStore.removeByChatId(msg.chatId);\n          break;\n        case \"ask-in-chat\":\n          if (msg.sourceMessage) {\n            context.messagesStore.upsert(msg.sourceMessage);\n          }\n          context.messagesStore.upsert(msg.targetMessage);\n          break;\n        case \"abort-ai\":\n          break;\n        case \"set-tool-result\":\n          if (msg.ok) {\n            context.messagesStore.upsert(msg.message);\n          }\n          break;\n        default:\n          return assertNever(msg, \"Unhandled case\");\n      }\n    }\n    pendingCmd?.resolve(msg);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    if (true) {\n      error2(\n        `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n      );\n    }\n  });\n  function connectInitially() {\n    if (managedSocket.getStatus() === \"initial\") {\n      managedSocket.connect();\n    }\n  }\n  async function sendClientMsgWithResponse(msg) {\n    connectInitially();\n    if (managedSocket.getStatus() !== \"connected\") {\n      await managedSocket.events.didConnect.waitUntil();\n    }\n    const { promise, resolve, reject } = Promise_withResolvers();\n    const abortSignal = AbortSignal.timeout(DEFAULT_REQUEST_TIMEOUT);\n    abortSignal.addEventListener(\"abort\", () => reject(abortSignal.reason), {\n      once: true\n    });\n    const cmdId = nanoid(7);\n    context.pendingCmds.set(cmdId, { resolve, reject });\n    sendClientMsg({ ...msg, cmdId });\n    return promise.finally(() => {\n      context.pendingCmds.delete(cmdId);\n    }).catch((err) => {\n      error2(err.message);\n      throw err;\n    });\n  }\n  function sendClientMsg(msg) {\n    managedSocket.send(\n      JSON.stringify({\n        ...msg\n      })\n    );\n  }\n  function getChats(options = {}) {\n    return sendClientMsgWithResponse({\n      cmd: \"get-chats\",\n      cursor: options.cursor,\n      query: options.query\n    });\n  }\n  function getOrCreateChat(id, options) {\n    return sendClientMsgWithResponse({\n      cmd: \"get-or-create-chat\",\n      id,\n      options\n    });\n  }\n  function getMessageTree(chatId) {\n    return sendClientMsgWithResponse({\n      cmd: \"get-message-tree\",\n      chatId\n    });\n  }\n  async function setToolResult(chatId, messageId, invocationId, result, options) {\n    const knowledge = context.knowledgeStore.getKnowledgeForChat(chatId);\n    const tools = context.toolsStore.getToolDescriptions(chatId);\n    const resp = await sendClientMsgWithResponse({\n      cmd: \"set-tool-result\",\n      chatId,\n      messageId,\n      invocationId,\n      result,\n      generationOptions: {\n        copilotId: options?.copilotId,\n        stream: options?.stream,\n        timeout: options?.timeout,\n        // Knowledge and tools aren't coming from the options, but retrieved\n        // from the global context\n        knowledge: knowledge.length > 0 ? knowledge : void 0,\n        tools: tools.length > 0 ? tools : void 0\n      }\n    });\n    if (resp.ok) {\n      messagesStore.markMine(resp.message.id);\n    }\n  }\n  function handleBeforeUnload() {\n    for (const messageId of context.messagesStore.getAutoExecutingMessageIds()) {\n      sendClientMsgWithResponse({ cmd: \"abort-ai\", messageId }).catch(() => {\n      });\n    }\n  }\n  const win = typeof window !== \"undefined\" ? window : void 0;\n  win?.addEventListener(\"beforeunload\", handleBeforeUnload, { once: true });\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        context\n      },\n      connectInitially,\n      // reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      getChats,\n      getOrCreateChat,\n      deleteChat: (chatId) => {\n        return sendClientMsgWithResponse({ cmd: \"delete-chat\", chatId });\n      },\n      getMessageTree,\n      deleteMessage: (chatId, messageId) => sendClientMsgWithResponse({ cmd: \"delete-message\", chatId, messageId }),\n      clearChat: (chatId) => sendClientMsgWithResponse({ cmd: \"clear-chat\", chatId }),\n      askUserMessageInChat: async (chatId, userMessage, targetMessageId, options) => {\n        const knowledge = context.knowledgeStore.getKnowledgeForChat(chatId);\n        const requestKnowledge = options?.knowledge || [];\n        const combinedKnowledge = [...knowledge, ...requestKnowledge];\n        const tools = context.toolsStore.getToolDescriptions(chatId);\n        messagesStore.markMine(targetMessageId);\n        const resp = await sendClientMsgWithResponse({\n          cmd: \"ask-in-chat\",\n          chatId,\n          sourceMessage: userMessage,\n          targetMessageId,\n          generationOptions: {\n            copilotId: options?.copilotId,\n            stream: options?.stream,\n            timeout: options?.timeout,\n            // Combine global knowledge with request-specific knowledge\n            knowledge: combinedKnowledge.length > 0 ? combinedKnowledge : void 0,\n            tools: tools.length > 0 ? tools : void 0\n          }\n        });\n        return resp;\n      },\n      abort: (messageId) => sendClientMsgWithResponse({ cmd: \"abort-ai\", messageId }),\n      setToolResult,\n      getStatus: () => managedSocket.getStatus(),\n      signals: {\n        getChatMessagesForBranch\\u03A3: context.messagesStore.getChatMessagesForBranch\\u03A3,\n        getTool\\u03A3: context.toolsStore.getTool\\u03A3,\n        status\\u03A3\n      },\n      getChatById: context.chatsStore.getChatById,\n      queryChats: context.chatsStore.findMany,\n      getLastUsedCopilotId: context.messagesStore.getLastUsedCopilotId,\n      registerKnowledgeLayer: (uniqueLayerId, chatId) => {\n        const stack = context.knowledgeStore.getKnowledgeStack(chatId);\n        const layerKey = stack.registerLayer(uniqueLayerId);\n        const deregister = () => stack.deregisterLayer(layerKey);\n        return {\n          layerKey,\n          deregister\n        };\n      },\n      updateKnowledge: (layerKey, data, key, chatId) => {\n        context.knowledgeStore.getKnowledgeStack(chatId).updateKnowledge(layerKey, key ?? nanoid(), data);\n      },\n      registerTool: context.toolsStore.registerTool\n    },\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeCreateSocketDelegateForAi(baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url2 = new URL(baseUrl);\n    url2.protocol = url2.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url2.pathname = \"/ai/v7\";\n    if (authValue.type === \"secret\") {\n      url2.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      throw new Error(\"Public key not supported with AI Copilots\");\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url2.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url2.toString());\n  };\n}\nfunction replaceOrAppend(content, newItem, keyFn, now2) {\n  const existingIndex = findLastIndex(\n    content,\n    (item) => item.type === newItem.type && keyFn(item) === keyFn(newItem)\n  );\n  if (existingIndex > -1) {\n    content[existingIndex] = newItem;\n  } else {\n    closePart(content[content.length - 1], now2);\n    content.push(newItem);\n  }\n}\nfunction closePart(prevPart, endedAt) {\n  if (prevPart?.type === \"reasoning\") {\n    prevPart.endedAt ??= endedAt;\n  }\n}\nfunction patchContentWithDelta(content, delta) {\n  if (delta === null)\n    return;\n  const parts = content.filter(\n    (part) => part.type !== \"sources\"\n  );\n  const sources = content.filter((part) => part.type === \"sources\").flatMap((part) => part.sources);\n  const now2 = (/* @__PURE__ */ new Date()).toISOString();\n  const lastPart = parts[parts.length - 1];\n  switch (delta.type) {\n    case \"text-delta\":\n      if (lastPart?.type === \"text\") {\n        lastPart.text += delta.textDelta;\n      } else {\n        closePart(lastPart, now2);\n        parts.push({ type: \"text\", text: delta.textDelta });\n      }\n      break;\n    case \"reasoning-delta\":\n      if (lastPart?.type === \"reasoning\") {\n        lastPart.text += delta.textDelta;\n      } else {\n        closePart(lastPart, now2);\n        parts.push({\n          type: \"reasoning\",\n          text: delta.textDelta,\n          startedAt: now2\n        });\n      }\n      break;\n    case \"tool-stream\": {\n      const toolInvocation = createReceivingToolInvocation(\n        delta.invocationId,\n        delta.name\n      );\n      parts.push(toolInvocation);\n      break;\n    }\n    case \"tool-delta\": {\n      if (lastPart?.type === \"tool-invocation\" && lastPart.stage === \"receiving\") {\n        lastPart.__appendDelta?.(delta.delta);\n      }\n      break;\n    }\n    case \"tool-invocation\":\n      replaceOrAppend(parts, delta, (x) => x.invocationId, now2);\n      break;\n    case \"retrieval\":\n      replaceOrAppend(parts, delta, (x) => x.id, now2);\n      break;\n    case \"source\": {\n      sources.push(delta);\n      break;\n    }\n    default:\n      return assertNever(delta, \"Unhandled case\");\n  }\n  if (sources.length > 0) {\n    parts.push({\n      type: \"sources\",\n      sources\n    });\n  }\n  content.length = 0;\n  content.push(...parts);\n}\nfunction createReceivingToolInvocation(invocationId, name, partialArgsText = \"\") {\n  const parser = new IncrementalJsonParser(partialArgsText);\n  return {\n    type: \"tool-invocation\",\n    stage: \"receiving\",\n    invocationId,\n    name,\n    // --- Alternative implementation for FRONTEND only ------------------------\n    get partialArgsText() {\n      return parser.source;\n    },\n    // prettier-ignore\n    get partialArgs() {\n      return parser.json;\n    },\n    // prettier-ignore\n    __appendDelta(delta) {\n      parser.append(delta);\n    }\n    // prettier-ignore\n    // ------------------------------------------------------------------------\n  };\n}\n\n// src/auth-manager.ts\nvar NON_RETRY_STATUS_CODES = [\n  400,\n  401,\n  403,\n  404,\n  405,\n  410,\n  412,\n  414,\n  422,\n  431,\n  451\n];\nfunction createAuthManager(authOptions, onAuthenticate) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now2 = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now2) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      onAuthenticate?.(parsed.parsed);\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          onAuthenticate?.(parsed.parsed);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch, endpoint, body) {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: stringifyOrLog(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (NON_RETRY_STATUS_CODES.includes(res.status)) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${stringifyOrLog(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\nvar MENTION_CHARACTER = \"@\";\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      // When a devtool panel sends an explicit \"connect\" message back to this\n      // live running client (in response to the \"wake-up-devtools\" message,\n      // or when the devtool panel is opened for the first time), it means that it's okay to\n      // start emitting messages.\n      // Before this explicit acknowledgement, any call to sendToPanel() will\n      // be a no-op.\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        // Sent by the devtool panel when it wants to receive the sync stream\n        // for a room\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/warnings.ts\nvar _emittedWarnings = /* @__PURE__ */ new Set();\nfunction warnOnce(message, key = message) {\n  if (true) {\n    if (!_emittedWarnings.has(key)) {\n      _emittedWarnings.add(key);\n      warn(message);\n    }\n  }\n}\nfunction warnOnceIf(condition, message, key = message) {\n  if (typeof condition === \"function\" ? condition() : condition) {\n    warnOnce(message, key);\n  }\n}\n\n// src/protocol/NotificationSettings.ts\nvar kPlain = Symbol(\"notification-settings-plain\");\nfunction createNotificationSettings(plain) {\n  const channels = [\n    \"email\",\n    \"slack\",\n    \"teams\",\n    \"webPush\"\n  ];\n  const descriptors = {\n    [kPlain]: {\n      value: plain,\n      enumerable: false\n    }\n  };\n  for (const channel of channels) {\n    descriptors[channel] = {\n      enumerable: true,\n      /**\n       * In the TypeScript standard library definitions, the built-in interface for a property descriptor\n       * does not include a specialized type for the this context in the getter or setter functions.\n       * As a result, both the get and set methods implicitly have this: any.\n       * The reason is that property descriptors in JavaScript are used across various objects with\n       * no enforced shape for this. And so the standard library definitions have to remain as broad as possible\n       * to support any valid JavaScript usage (e.g `Object.defineProperty`).\n       *\n       * So we can safely tells that this getter is typed as `this: NotificationSettings` because we're\n       * creating a well known shaped object  `NotificationSettings`.\n       */\n      get() {\n        const value = this[kPlain][channel];\n        if (typeof value === \"undefined\") {\n          error2(\n            `In order to use the '${channel}' channel, please set up your project first. For more information: https://liveblocks.io/docs/errors/enable-a-notification-channel`\n          );\n          return null;\n        }\n        return value;\n      }\n    };\n  }\n  return create(null, descriptors);\n}\nfunction patchNotificationSettings(existing, patch) {\n  const outcoming = createNotificationSettings({\n    ...existing[kPlain]\n  });\n  for (const channel of keys(patch)) {\n    const updates = patch[channel];\n    if (updates !== void 0) {\n      const kindUpdates = Object.fromEntries(\n        entries(updates).filter(([, value]) => value !== void 0)\n      );\n      outcoming[kPlain][channel] = {\n        ...outcoming[kPlain][channel],\n        ...kindUpdates\n      };\n    }\n  }\n  return outcoming;\n}\nfunction isNotificationChannelEnabled(settings) {\n  return settings !== null ? values(settings).every((enabled) => enabled === true) : false;\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction createManagedPool(roomId, options) {\n  const {\n    getCurrentConnectionId,\n    onDispatch,\n    isStorageWritable = () => true\n  } = options;\n  let clock = 0;\n  let opClock = 0;\n  const nodes = /* @__PURE__ */ new Map();\n  return {\n    roomId,\n    nodes,\n    getNode: (id) => nodes.get(id),\n    addNode: (id, node) => void nodes.set(id, node),\n    deleteNode: (id) => void nodes.delete(id),\n    generateId: () => `${getCurrentConnectionId()}:${clock++}`,\n    generateOpId: () => `${getCurrentConnectionId()}:${opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      onDispatch?.(ops, reverse, storageUpdates);\n    },\n    assertStorageIsWritable: () => {\n      if (!isStorageWritable()) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n}\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  //                  ^^^^^^^^^^^^ TODO: Make this an interface\n  #pool;\n  #id;\n  #parent = NoParent;\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.#pool;\n  }\n  get roomId() {\n    return this.#pool ? this.#pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.#id;\n  }\n  /** @internal */\n  get parent() {\n    return this.#parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this.#parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this.#parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.#id || this.#pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.#id = id;\n    this.#pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.#pool && this.#id) {\n      this.#pool.deleteNode(this.#id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this.#parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this.#parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.#pool = void 0;\n  }\n  /** This caches the result of the last .toImmutable() call for this Live node. */\n  #cachedImmutable;\n  #cachedTreeNodeKey;\n  /** This caches the result of the last .toTreeNode() call for this Live node. */\n  #cachedTreeNode;\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this.#cachedImmutable !== void 0 || this.#cachedTreeNode !== void 0) {\n      this.#cachedImmutable = void 0;\n      this.#cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this.#cachedTreeNode === void 0 || this.#cachedTreeNodeKey !== key) {\n      this.#cachedTreeNodeKey = key;\n      this.#cachedTreeNode = this._toTreeNode(key);\n    }\n    return this.#cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this.#cachedImmutable === void 0) {\n      this.#cachedImmutable = this._toImmutable();\n    }\n    return this.#cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  #data;\n  constructor(data) {\n    super();\n    this.#data = data;\n  }\n  get data() {\n    return this.#data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this.#data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  // TODO: Naive array at first, find a better data structure. Maybe an Order statistics tree?\n  #items;\n  #implicitlyDeletedItems;\n  #unacknowledgedSets;\n  constructor(items) {\n    super();\n    this.#items = [];\n    this.#implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this.#unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this.#items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this.#items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this.#unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this.#items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this.#items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this.#items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this.#items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this.#items) {\n      item._detach();\n    }\n  }\n  #applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this.#items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this.#items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this.#implicitlyDeletedItems.add(itemWithSamePosition);\n        this.#items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this.#detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  #applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this.#detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this.#unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this.#unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this.#implicitlyDeletedItems.add(\n          this.#items[indexOfItemWithSamePosition]\n        );\n        const [prevNode] = this.#items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition, prevNode));\n      }\n      const prevIndex = this.#items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(existingItem);\n      if (newIndex !== prevIndex) {\n        delta.push(moveDelta(prevIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this.#implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this.#items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this.#items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this.#createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   */\n  #detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  #applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this.#shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  #applyInsertAck(op) {\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this.#items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this.#implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  #applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this.#items[existingItemIndex]?._parentPos;\n      const after2 = this.#items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  #applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this.#unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this.#items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this.#items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this.#detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this.#applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this.#applySetAck(op);\n      } else {\n        result = this.#applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this.#applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this.#applyInsertAck(op);\n      } else {\n        result = this.#applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this.#items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      const [previousNode] = this.#items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  #applySetChildKeyRemote(newKey, child) {\n    if (this.#implicitlyDeletedItems.has(child)) {\n      this.#implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this.#items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this.#items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  #applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this.#implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this.#implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this.#items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  #applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this.#items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    let actualNewKey = newKey;\n    if (existingItemIndex !== -1) {\n      actualNewKey = makePosition(\n        newKey,\n        this.#items[existingItemIndex + 1]?._parentPos\n      );\n    }\n    child._setParentLink(this, actualNewKey);\n    this._sortItems();\n    const newIndex = this.#items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this.#applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this.#applySetChildKeyAck(newKey, child);\n    } else {\n      return this.#applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this.#items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this.#items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length}`\n      );\n    }\n    const before2 = this.#items[index - 1] ? this.#items[index - 1]._parentPos : void 0;\n    const after2 = this.#items[index] ? this.#items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this.#items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this.#items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this.#items.length - 1 ? void 0 : this.#items[targetIndex + 1]._parentPos;\n      beforePosition = this.#items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this.#items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this.#items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this.#items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this.#items.length - 1}`\n      );\n    }\n    const item = this.#items[index];\n    item._detach();\n    const [prev] = this.#items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index, prev)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this.#items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0, item));\n        }\n      }\n      this.#items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this.#items) {\n        item._detach();\n      }\n      this.#items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length - 1}`\n      );\n    }\n    const existingItem = this.#items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this.#items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this.#unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this.#items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this.#items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this.#items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this.#items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this.#items);\n  }\n  #createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  #shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this.#items.length > index + 1 ? this.#items[index + 1]?._parentPos : void 0\n    );\n    this.#items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this.#items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this.#items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  #innerIterator;\n  constructor(items) {\n    this.#innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this.#innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index, deletedNode) {\n  return {\n    type: \"delete\",\n    index,\n    deletedItem: deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    type: \"move\",\n    index,\n    item: item instanceof LiveRegister ? item.data : item,\n    previousIndex\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  #map;\n  #unacknowledgedSet;\n  constructor(entries2) {\n    super();\n    this.#unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this.#map = new Map(mappedEntries);\n    } else {\n      this.#map = /* @__PURE__ */ new Map();\n    }\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this.#map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map.#map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.#unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.#unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.#unacknowledgedSet.delete(key);\n    }\n    const previousValue = this.#map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this.#map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this.#map.values()) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this.#map) {\n      if (value === child) {\n        this.#map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: {\n        [parentKey]: {\n          type: \"delete\",\n          deletedItem: liveNodeToLson(child)\n        }\n      }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this.#map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this.#map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this.#map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.#unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this.#map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this.#map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this.#map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this.#map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: {\n          [key]: {\n            type: \"delete\",\n            deletedItem: liveNodeToLson(item)\n          }\n        }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this.#map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this.#map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this.#map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this.#map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this.#map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this.#map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar MAX_LIVE_OBJECT_SIZE = 128 * 1024;\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  #map;\n  #propToLastUpdate;\n  /**\n   * Enable or disable detection of too large LiveObjects.\n   * When enabled, throws an error if LiveObject static data exceeds 128KB, which\n   * is the maximum value the server will be able to accept.\n   * By default, this behavior is disabled to avoid the runtime performance\n   * overhead on every LiveObject.set() or LiveObject.update() call.\n   *\n   * @experimental\n   */\n  static detectLargeObjects = false;\n  static #buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @private Do not use this API directly */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject.#buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this.#propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this.#map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj.#map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this.#propToLastUpdate.get(key) === opId) {\n        this.#propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this.#propToLastUpdate.set(key, nn(opId));\n    } else if (this.#propToLastUpdate.get(key) === void 0) {\n    } else if (this.#propToLastUpdate.get(key) === opId) {\n      this.#propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this.#map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this.#map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this.#map) {\n        if (value === child) {\n          this.#map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const value of this.#map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this.#applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this.#applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this.#map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  #applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this.#propToLastUpdate.set(key, nn(op.opId));\n      } else if (this.#propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this.#propToLastUpdate.get(key) === op.opId) {\n        this.#propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this.#map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  #applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    const oldValue = this.#map.get(key);\n    if (oldValue === void 0) {\n      return { modified: false };\n    }\n    if (!isLocal && this.#propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this.#map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [op.key]: { type: \"delete\", deletedItem: oldValue }\n        }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this.#map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this.#map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this.#map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this.#map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this.#map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: {\n        [key]: { type: \"delete\", deletedItem: oldValue }\n      }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (_LiveObject.detectLargeObjects) {\n      const data = {};\n      for (const [key, value] of this.#map) {\n        if (!isLiveNode(value)) {\n          data[key] = value;\n        }\n      }\n      for (const key of Object.keys(patch)) {\n        const value = patch[key];\n        if (value === void 0) continue;\n        if (!isLiveNode(value)) {\n          data[key] = value;\n        }\n      }\n      const jsonString = JSON.stringify(data);\n      const upperBoundSize = jsonString.length * 4;\n      if (upperBoundSize > MAX_LIVE_OBJECT_SIZE) {\n        const preciseSize = new TextEncoder().encode(jsonString).length;\n        if (preciseSize > MAX_LIVE_OBJECT_SIZE) {\n          throw new Error(\n            `LiveObject size exceeded limit: ${preciseSize} bytes > ${MAX_LIVE_OBJECT_SIZE} bytes. See https://liveblocks.io/docs/platform/limits#Liveblocks-Storage-limits`\n          );\n        }\n      }\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this.#map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this.#map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this.#propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this.#propToLastUpdate.set(key, opId);\n      }\n      this.#map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this.#map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this.#map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this.#map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || stringifyOrLog(crdt.data) !== stringifyOrLog(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/Deque.ts\nvar Deque = class {\n  #data;\n  #front;\n  #back;\n  #size;\n  constructor() {\n    this.#data = {};\n    this.#front = 0;\n    this.#back = 1;\n    this.#size = 0;\n  }\n  get length() {\n    return this.#size;\n  }\n  *[Symbol.iterator]() {\n    const size = this.#size;\n    const front = this.#front;\n    for (let i = 0; i < size; i++) {\n      yield this.#data[front + i];\n    }\n  }\n  push(value) {\n    const values2 = Array.isArray(value) ? value : [value];\n    if (this.#back > Number.MAX_SAFE_INTEGER - values2.length - 1)\n      raise(\"Deque full\");\n    for (const value2 of values2) {\n      this.#data[this.#back++ - 1] = value2;\n    }\n    this.#size += values2.length;\n  }\n  pop() {\n    if (this.#size < 1) return void 0;\n    this.#back--;\n    const value = this.#data[this.#back - 1];\n    delete this.#data[this.#back - 1];\n    this.#size--;\n    return value;\n  }\n  pushLeft(value) {\n    const values2 = Array.isArray(value) ? value : [value];\n    if (this.#front < Number.MIN_SAFE_INTEGER + values2.length)\n      raise(\"Deque full\");\n    for (let i = values2.length - 1; i >= 0; i--) {\n      this.#data[--this.#front] = values2[i];\n    }\n    this.#size += values2.length;\n  }\n  popLeft() {\n    if (this.#size < 1) return void 0;\n    const value = this.#data[this.#front];\n    delete this.#data[this.#front];\n    this.#front++;\n    this.#size--;\n    return value;\n  }\n};\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ManagedOthers.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar ManagedOthers = class {\n  // Track mutable state internally, but signal to the outside when the\n  // observable derived state changes only\n  #internal;\n  #userCache;\n  // The \"clean\" signal that is exposed to the outside world\n  signal;\n  constructor() {\n    this.#internal = new MutableSignal({\n      connections: /* @__PURE__ */ new Map(),\n      presences: /* @__PURE__ */ new Map()\n    });\n    this.signal = DerivedSignal.from(\n      this.#internal,\n      (_ignore) => compact(\n        Array.from(this.#internal.get().presences.keys()).map(\n          (connectionId) => this.getUser(Number(connectionId))\n        )\n      )\n    );\n    this.#userCache = /* @__PURE__ */ new Map();\n  }\n  // Shorthand for .signal.get()\n  get() {\n    return this.signal.get();\n  }\n  connectionIds() {\n    return this.#internal.get().connections.keys();\n  }\n  clearOthers() {\n    this.#internal.mutate((state) => {\n      state.connections.clear();\n      state.presences.clear();\n      this.#userCache.clear();\n    });\n  }\n  #_getUser(connectionId) {\n    const state = this.#internal.get();\n    const conn = state.connections.get(connectionId);\n    const presence = state.presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this.#userCache.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this.#_getUser(connectionId);\n    if (computedUser) {\n      this.#userCache.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  #invalidateUser(connectionId) {\n    this.#userCache.delete(connectionId);\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this.#internal.mutate((state) => {\n      state.connections.set(\n        connectionId,\n        freeze({\n          connectionId,\n          id: metaUserId,\n          info: metaUserInfo,\n          scopes\n        })\n      );\n      if (!state.presences.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this.#internal.mutate((state) => {\n      state.connections.delete(connectionId);\n      state.presences.delete(connectionId);\n      this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this.#internal.mutate((state) => {\n      state.presences.set(connectionId, freeze(compactObject(presence)));\n      if (!state.connections.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    this.#internal.mutate((state) => {\n      const oldPresence = state.presences.get(connectionId);\n      if (oldPresence === void 0) {\n        return false;\n      }\n      const newPresence = merge(oldPresence, patch);\n      if (oldPresence === newPresence) {\n        return false;\n      }\n      state.presences.set(connectionId, freeze(newPresence));\n      return this.#invalidateUser(connectionId);\n    });\n  }\n};\n\n// src/types/LiveblocksError.ts\nvar LiveblocksError = class _LiveblocksError extends Error {\n  context;\n  constructor(message, context, cause) {\n    super(message, { cause });\n    this.context = context;\n    this.name = \"LiveblocksError\";\n  }\n  /** Convenience accessor for error.context.roomId (if available) */\n  get roomId() {\n    return this.context.roomId;\n  }\n  /** @internal Use `context.code` instead, to enable type narrowing */\n  get code() {\n    return this.context.code;\n  }\n  /**\n   * Creates a LiveblocksError from a generic error, by attaching Liveblocks\n   * contextual information like room ID, thread ID, etc.\n   */\n  static from(context, cause) {\n    return new _LiveblocksError(\n      defaultMessageFromContext(context),\n      context,\n      cause\n    );\n  }\n};\nfunction defaultMessageFromContext(context) {\n  switch (context.type) {\n    case \"ROOM_CONNECTION_ERROR\": {\n      switch (context.code) {\n        case 4001:\n          return \"Not allowed to connect to the room\";\n        case 4005:\n          return \"Room is already full\";\n        case 4006:\n          return \"Kicked out of the room, because the room ID changed\";\n        default:\n          return \"Could not connect to the room\";\n      }\n    }\n    case \"AI_CONNECTION_ERROR\": {\n      switch (context.code) {\n        case 4001:\n          return \"Not allowed to connect to ai\";\n        default:\n          return \"Could not connect to the room\";\n      }\n    }\n    case \"CREATE_THREAD_ERROR\":\n      return \"Could not create new thread\";\n    case \"DELETE_THREAD_ERROR\":\n      return \"Could not delete thread\";\n    case \"EDIT_THREAD_METADATA_ERROR\":\n      return \"Could not edit thread metadata\";\n    case \"MARK_THREAD_AS_RESOLVED_ERROR\":\n      return \"Could not mark thread as resolved\";\n    case \"MARK_THREAD_AS_UNRESOLVED_ERROR\":\n      return \"Could not mark thread as unresolved\";\n    case \"SUBSCRIBE_TO_THREAD_ERROR\":\n      return \"Could not subscribe to thread\";\n    case \"UNSUBSCRIBE_FROM_THREAD_ERROR\":\n      return \"Could not unsubscribe from thread\";\n    case \"CREATE_COMMENT_ERROR\":\n      return \"Could not create new comment\";\n    case \"EDIT_COMMENT_ERROR\":\n      return \"Could not edit comment\";\n    case \"DELETE_COMMENT_ERROR\":\n      return \"Could not delete comment\";\n    case \"ADD_REACTION_ERROR\":\n      return \"Could not add reaction\";\n    case \"REMOVE_REACTION_ERROR\":\n      return \"Could not remove reaction\";\n    case \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\":\n      return \"Could not mark inbox notification as read\";\n    case \"DELETE_INBOX_NOTIFICATION_ERROR\":\n      return \"Could not delete inbox notification\";\n    case \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\":\n      return \"Could not mark all inbox notifications as read\";\n    case \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\":\n      return \"Could not delete all inbox notifications\";\n    case \"UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR\":\n      return \"Could not update room subscription settings\";\n    case \"UPDATE_NOTIFICATION_SETTINGS_ERROR\":\n      return \"Could not update notification settings\";\n    case \"LARGE_MESSAGE_ERROR\":\n      return \"Could not send large message\";\n    default:\n      return assertNever(context, \"Unhandled case\");\n  }\n}\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 512;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nfunction createRoom(options, config) {\n  const roomId = config.roomId;\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const httpClient = config.roomHttpClient;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfoSig: new Signal(null),\n    dynamicSessionInfoSig: new Signal(null),\n    myPresence: new PatchableSignal(initialPresence),\n    others: new ManagedOthers(),\n    initialStorage,\n    idFactory: null,\n    // The Yjs provider associated to this room\n    yjsProvider: void 0,\n    yjsProviderDidChange: makeEventSource(),\n    // Storage\n    pool: createManagedPool(roomId, {\n      getCurrentConnectionId,\n      onDispatch,\n      isStorageWritable\n    }),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map()\n  };\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    eventHub.status.notify(newStatus);\n    notifySelfChanged();\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        eventHub.lostConnection.notify(\"lost\");\n        _hasLostConnection = true;\n        context.others.clearOthers();\n        notify({ others: [{ type: \"reset\" }] });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          eventHub.lostConnection.notify(\"failed\");\n        } else {\n          eventHub.lostConnection.notify(\"restored\");\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.get() }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    const type = \"ROOM_CONNECTION_ERROR\";\n    const err = new LiveblocksError(message, { type, code, roomId });\n    const didNotify = config.errorEventSource.notify(err);\n    if (!didNotify) {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n        );\n      }\n    }\n  });\n  function onDispatch(ops, reverse, storageUpdates) {\n    if (context.activeBatch) {\n      for (const op of ops) {\n        context.activeBatch.ops.push(op);\n      }\n      for (const [key, value] of storageUpdates) {\n        context.activeBatch.updates.storageUpdates.set(\n          key,\n          mergeStorageUpdates(\n            context.activeBatch.updates.storageUpdates.get(key),\n            value\n          )\n        );\n      }\n      context.activeBatch.reverseOps.pushLeft(reverse);\n    } else {\n      addToUndoStack(reverse);\n      context.redoStack.length = 0;\n      dispatchOps(ops);\n      notify({ storageUpdates });\n    }\n  }\n  function isStorageWritable() {\n    const scopes = context.dynamicSessionInfoSig.get()?.scopes;\n    return scopes !== void 0 ? canWriteStorage(scopes) : true;\n  }\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource(),\n    roomWillDestroy: makeEventSource()\n  };\n  async function createTextMention(mentionId, mention) {\n    return httpClient.createTextMention({ roomId, mentionId, mention });\n  }\n  async function deleteTextMention(mentionId) {\n    return httpClient.deleteTextMention({ roomId, mentionId });\n  }\n  async function reportTextEditor(type, rootKey) {\n    await httpClient.reportTextEditor({ roomId, type, rootKey });\n  }\n  async function listTextVersions() {\n    return httpClient.listTextVersions({ roomId });\n  }\n  async function listTextVersionsSince(options2) {\n    return httpClient.listTextVersionsSince({\n      roomId,\n      since: options2.since,\n      signal: options2.signal\n    });\n  }\n  async function getTextVersion(versionId) {\n    return httpClient.getTextVersion({ roomId, versionId });\n  }\n  async function createTextVersion() {\n    return httpClient.createTextVersion({ roomId });\n  }\n  async function executeContextualPrompt(options2) {\n    return httpClient.executeContextualPrompt({\n      roomId,\n      ...options2\n    });\n  }\n  function* chunkOps(msg) {\n    const { ops, ...rest } = msg;\n    if (ops.length < 2) {\n      throw new Error(\"Cannot split ops into smaller chunks\");\n    }\n    const mid = Math.floor(ops.length / 2);\n    const firstHalf = ops.slice(0, mid);\n    const secondHalf = ops.slice(mid);\n    for (const halfOps of [firstHalf, secondHalf]) {\n      const half = { ops: halfOps, ...rest };\n      const text = stringifyOrLog([half]);\n      if (!isTooBigForWebSocket(text)) {\n        yield text;\n      } else {\n        yield* chunkOps(half);\n      }\n    }\n  }\n  function* chunkMessages(messages) {\n    if (messages.length < 2) {\n      if (messages[0].type === 201 /* UPDATE_STORAGE */) {\n        yield* chunkOps(messages[0]);\n        return;\n      } else {\n        throw new Error(\n          \"Cannot split into chunks smaller than the allowed message size\"\n        );\n      }\n    }\n    const mid = Math.floor(messages.length / 2);\n    const firstHalf = messages.slice(0, mid);\n    const secondHalf = messages.slice(mid);\n    for (const half of [firstHalf, secondHalf]) {\n      const text = stringifyOrLog(half);\n      if (!isTooBigForWebSocket(text)) {\n        yield text;\n      } else {\n        yield* chunkMessages(half);\n      }\n    }\n  }\n  function isTooBigForWebSocket(text) {\n    if (text.length * 4 < MAX_SOCKET_MESSAGE_SIZE) {\n      return false;\n    }\n    return new TextEncoder().encode(text).length >= MAX_SOCKET_MESSAGE_SIZE;\n  }\n  function sendMessages(messages) {\n    const strategy = config.largeMessageStrategy ?? \"default\";\n    const text = stringifyOrLog(messages);\n    if (!isTooBigForWebSocket(text)) {\n      return managedSocket.send(text);\n    }\n    switch (strategy) {\n      case \"default\": {\n        const type = \"LARGE_MESSAGE_ERROR\";\n        const err = new LiveblocksError(\"Message is too large for websockets\", {\n          type\n        });\n        const didNotify = config.errorEventSource.notify(err);\n        if (!didNotify) {\n          error2(\n            \"Message is too large for websockets.  Configure largeMessageStrategy option or useErrorListener to handle this.\"\n          );\n        }\n        return;\n      }\n      case \"split\": {\n        warn(\"Message is too large for websockets, splitting into smaller chunks\");\n        for (const chunk2 of chunkMessages(messages)) {\n          managedSocket.send(chunk2);\n        }\n        return;\n      }\n      // NOTE: This strategy is experimental as it will not work in all situations.\n      // It should only be used for broadcasting, presence updates, but isn't suitable\n      // for Storage or Yjs updates yet (because through this channel the server does\n      // not respond with acks or rejections, causing the client's reported status to\n      // be stuck in \"synchronizing\" forever).\n      case \"experimental-fallback-to-http\": {\n        warn(\"Message is too large for websockets, so sending over HTTP instead\");\n        const nonce = context.dynamicSessionInfoSig.get()?.nonce ?? raise(\"Session is not authorized to send message over HTTP\");\n        void httpClient.sendMessagesOverHTTP({ roomId, nonce, messages }).then((resp) => {\n          if (!resp.ok && resp.status === 403) {\n            managedSocket.reconnect();\n          }\n        }).catch((err) => {\n          error2(\n            `Failed to deliver message over HTTP: ${String(err)}`\n          );\n        });\n        return;\n      }\n    }\n  }\n  const self = DerivedSignal.from(\n    context.staticSessionInfoSig,\n    context.dynamicSessionInfoSig,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged() {\n    const currSelf = self.get();\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      eventHub.self.notify(currSelf);\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = DerivedSignal.from(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items);\n    } else {\n      context.root = LiveObject._fromItems(message.items, context.pool);\n    }\n    const canWrite = self.get()?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.pool.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates);\n  }\n  function _addToRealUndoStack(historyOps) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange();\n  }\n  function addToUndoStack(historyOps) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.pushLeft(historyOps);\n    } else {\n      _addToRealUndoStack(historyOps);\n    }\n  }\n  function notify(updates) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n      const others = context.others.get();\n      for (const event of othersUpdates) {\n        eventHub.others.notify({ ...event, others });\n      }\n    }\n    if (updates.presence ?? false) {\n      notifySelfChanged();\n      eventHub.myPresence.notify(context.myPresence.get());\n    }\n    if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n      const updates2 = Array.from(storageUpdates.values());\n      eventHub.storageBatch.notify(updates2);\n    }\n    notifyStorageStatus();\n  }\n  function getCurrentConnectionId() {\n    const info = context.dynamicSessionInfoSig.get();\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: new Deque(),\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: context.pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.get()[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.pushLeft(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.pushLeft(applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: Array.from(output.reverse),\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.pool.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.pool.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.pool.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.get()[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.pushLeft({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      if (options2?.addToHistory) {\n        addToUndoStack([{ type: \"presence\", data: oldValues }]);\n      }\n      notify({ presence: true });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message) {\n    context.dynamicSessionInfoSig.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged();\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange() {\n    eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.get(),\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const inOps = Array.from(offlineOps.values());\n    const result = applyOps(inOps, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    for (const message of messages) {\n      switch (message.type) {\n        case 101 /* USER_JOINED */: {\n          const userJoinedUpdate = onUserJoinedMessage(message);\n          if (userJoinedUpdate) {\n            updates.others.push(userJoinedUpdate);\n          }\n          break;\n        }\n        case 100 /* UPDATE_PRESENCE */: {\n          const othersPresenceUpdate = onUpdatePresenceMessage(message);\n          if (othersPresenceUpdate) {\n            updates.others.push(othersPresenceUpdate);\n          }\n          break;\n        }\n        case 103 /* BROADCASTED_EVENT */: {\n          const others = context.others.get();\n          eventHub.customEvent.notify({\n            connectionId: message.actor,\n            user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n            event: message.event\n          });\n          break;\n        }\n        case 102 /* USER_LEFT */: {\n          const event2 = onUserLeftMessage(message);\n          if (event2) {\n            updates.others.push(event2);\n          }\n          break;\n        }\n        case 300 /* UPDATE_YDOC */: {\n          eventHub.ydoc.notify(message);\n          break;\n        }\n        case 104 /* ROOM_STATE */: {\n          updates.others.push(onRoomStateMessage(message));\n          break;\n        }\n        case 200 /* INITIAL_STORAGE_STATE */: {\n          processInitialStorage(message);\n          break;\n        }\n        // Write event\n        case 201 /* UPDATE_STORAGE */: {\n          const applyResult = applyOps(message.ops, false);\n          for (const [key, value] of applyResult.updates.storageUpdates) {\n            updates.storageUpdates.set(\n              key,\n              mergeStorageUpdates(updates.storageUpdates.get(key), value)\n            );\n          }\n          break;\n        }\n        // Receiving a RejectedOps message in the client means that the server is no\n        // longer in sync with the client. Trying to synchronize the client again by\n        // rolling back particular Ops may be hard/impossible. It's fine to not try and\n        // accept the out-of-sync reality and throw an error.\n        case 299 /* REJECT_STORAGE_OP */: {\n          errorWithTitle(\n            \"Storage mutation rejection error\",\n            message.reason\n          );\n          if (true) {\n            throw new Error(\n              `Storage mutations rejected by server: ${message.reason}`\n            );\n          }\n          break;\n        }\n        case 400 /* THREAD_CREATED */:\n        case 407 /* THREAD_DELETED */:\n        case 401 /* THREAD_METADATA_UPDATED */:\n        case 408 /* THREAD_UPDATED */:\n        case 405 /* COMMENT_REACTION_ADDED */:\n        case 406 /* COMMENT_REACTION_REMOVED */:\n        case 402 /* COMMENT_CREATED */:\n        case 403 /* COMMENT_EDITED */:\n        case 404 /* COMMENT_DELETED */: {\n          eventHub.comments.notify(message);\n          break;\n        }\n        default:\n          break;\n      }\n    }\n    notify(updates);\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now2 = Date.now();\n    const elapsedMillis = now2 - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now2,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid, isV2) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid,\n      v2: isV2\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message);\n    applyAndSendOps(unacknowledgedOps);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) return;\n    const items = await httpClient.streamStorage({ roomId });\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid, isV2) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid && m.v2 === isV2;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid,\n        v2: isV2\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    notify(result.updates);\n    context.redoStack.push(result.reverse);\n    onHistoryChange();\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    notify(result.updates);\n    context.undoStack.push(result.reverse);\n    onHistoryChange();\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch2(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    context.activeBatch = {\n      ops: [],\n      updates: {\n        storageUpdates: /* @__PURE__ */ new Map(),\n        presence: false,\n        others: []\n      },\n      reverseOps: new Deque()\n    };\n    try {\n      returnValue = callback();\n    } finally {\n      const currentBatch = context.activeBatch;\n      context.activeBatch = null;\n      if (currentBatch.reverseOps.length > 0) {\n        addToUndoStack(Array.from(currentBatch.reverseOps));\n      }\n      if (currentBatch.ops.length > 0) {\n        context.redoStack.length = 0;\n      }\n      if (currentBatch.ops.length > 0) {\n        dispatchOps(currentBatch.ops);\n      }\n      notify(currentBatch.updates);\n      flushNowOrSoon();\n    }\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = new Deque();\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(Array.from(historyOps));\n    }\n  }\n  const syncSourceForStorage = config.createSyncSource();\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n    syncSourceForStorage.setSyncStatus(\n      storageStatus === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n  function isPresenceReady() {\n    return self.get() !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = DerivedSignal.from(\n    context.others.signal,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable,\n    roomWillDestroy: eventHub.roomWillDestroy.observable\n  };\n  async function getThreadsSince(options2) {\n    return httpClient.getThreadsSince({\n      roomId,\n      since: options2.since,\n      signal: options2.signal\n    });\n  }\n  async function getThreads(options2) {\n    return httpClient.getThreads({\n      roomId,\n      query: options2?.query,\n      cursor: options2?.cursor\n    });\n  }\n  async function getThread(threadId) {\n    return httpClient.getThread({ roomId, threadId });\n  }\n  async function createThread(options2) {\n    return httpClient.createThread({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      metadata: options2.metadata,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function deleteThread(threadId) {\n    return httpClient.deleteThread({ roomId, threadId });\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return httpClient.editThreadMetadata({ roomId, threadId, metadata });\n  }\n  async function markThreadAsResolved(threadId) {\n    return httpClient.markThreadAsResolved({ roomId, threadId });\n  }\n  async function markThreadAsUnresolved(threadId) {\n    return httpClient.markThreadAsUnresolved({\n      roomId,\n      threadId\n    });\n  }\n  async function subscribeToThread(threadId) {\n    return httpClient.subscribeToThread({ roomId, threadId });\n  }\n  async function unsubscribeFromThread(threadId) {\n    return httpClient.unsubscribeFromThread({ roomId, threadId });\n  }\n  async function createComment(options2) {\n    return httpClient.createComment({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function editComment(options2) {\n    return httpClient.editComment({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function deleteComment({\n    threadId,\n    commentId\n  }) {\n    return httpClient.deleteComment({ roomId, threadId, commentId });\n  }\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    return httpClient.addReaction({ roomId, threadId, commentId, emoji });\n  }\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    return await httpClient.removeReaction({\n      roomId,\n      threadId,\n      commentId,\n      emoji\n    });\n  }\n  function prepareAttachment(file) {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file\n    };\n  }\n  async function uploadAttachment(attachment, options2 = {}) {\n    return httpClient.uploadAttachment({\n      roomId,\n      attachment,\n      signal: options2.signal\n    });\n  }\n  function getAttachmentUrl(attachmentId) {\n    return httpClient.getAttachmentUrl({ roomId, attachmentId });\n  }\n  function getSubscriptionSettings(options2) {\n    return httpClient.getSubscriptionSettings({\n      roomId,\n      signal: options2?.signal\n    });\n  }\n  function updateSubscriptionSettings(settings) {\n    return httpClient.updateSubscriptionSettings({ roomId, settings });\n  }\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await httpClient.markRoomInboxNotificationAsRead({\n      roomId,\n      inboxNotificationId\n    });\n  }\n  const syncSourceForYjs = config.createSyncSource();\n  function yjsStatusDidChange(status) {\n    return syncSourceForYjs.setSyncStatus(\n      status === \"synchronizing\" || status === \"loading\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.pool.nodes.size;\n        },\n        // prettier-ignore\n        getYjsProvider() {\n          return context.yjsProvider;\n        },\n        setYjsProvider(newProvider) {\n          context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n          context.yjsProvider = newProvider;\n          newProvider?.on(\"status\", yjsStatusDidChange);\n          context.yjsProviderDidChange.notify();\n        },\n        yjsProviderDidChange: context.yjsProviderDidChange.observable,\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // List versions of the document since the specified date\n        listTextVersionsSince,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n        // execute a contextual prompt\n        executeContextualPrompt,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.get(),\n        getOthers_forDevTools: () => others_forDevTools.get(),\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        attachmentUrlsStore: httpClient.getOrCreateAttachmentUrlsStore(roomId)\n      },\n      id: roomId,\n      subscribe: makeClassicSubscribeFn(\n        roomId,\n        events,\n        config.errorEventSource\n      ),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        const { roomWillDestroy, ...eventsExceptDestroy } = eventHub;\n        for (const source of Object.values(eventsExceptDestroy)) {\n          source.dispose();\n        }\n        eventHub.roomWillDestroy.notify();\n        context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n        syncSourceForStorage.destroy();\n        syncSourceForYjs.destroy();\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n        roomWillDestroy.dispose();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch: batch2,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.get(),\n      // Presence\n      getPresence: () => context.myPresence.get(),\n      getOthers: () => context.others.get(),\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      subscribeToThread,\n      unsubscribeFromThread,\n      createComment,\n      editComment,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n      // Notifications\n      getNotificationSettings: getSubscriptionSettings,\n      getSubscriptionSettings,\n      updateNotificationSettings: updateSubscriptionSettings,\n      updateSubscriptionSettings,\n      markInboxNotificationAsRead\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(roomId, events, errorEvents) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\": {\n          return errorEvents.subscribe((err) => {\n            if (err.roomId === roomId) {\n              return callback(err);\n            }\n          });\n        }\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        case \"comments\":\n          return events.comments.subscribe(\n            callback\n          );\n        // istanbul ignore next\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\" || value === \"comments\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url2 = new URL(baseUrl);\n    url2.protocol = url2.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url2.pathname = \"/v7\";\n    url2.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url2.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url2.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url2.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url2.toString());\n  };\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nvar RESOLVE_GROUPS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay =  true && clientOptions.__DANGEROUSLY_disableThrottling ? 0 : getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const currentUserId = new Signal(void 0);\n  const authManager = createAuthManager(options, (token) => {\n    const userId = token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid;\n    currentUserId.set(() => userId);\n  });\n  const fetchPolyfill = clientOptions.polyfills?.fetch || /* istanbul ignore next */\n  globalThis.fetch?.bind(globalThis);\n  const httpClient = createApiClient({\n    baseUrl,\n    fetchPolyfill,\n    currentUserId,\n    authManager\n  });\n  const roomsById = /* @__PURE__ */ new Map();\n  const ai = createAi({\n    userId: currentUserId.get(),\n    lostConnectionTimeout,\n    backgroundKeepAliveTimeout: getBackgroundKeepAliveTimeout(\n      clientOptions.backgroundKeepAliveTimeout\n    ),\n    polyfills: clientOptions.polyfills,\n    delegates: {\n      createSocket: makeCreateSocketDelegateForAi(\n        baseUrl,\n        clientOptions.polyfills?.WebSocket\n      ),\n      authenticate: async () => {\n        const resp = await authManager.getAuthValue({\n          requestedScope: \"room:read\"\n        });\n        if (resp.type === \"public\") {\n          throw new StopRetrying(\n            \"Cannot use AI Copilots with a public API key\"\n          );\n        } else if (resp.token.parsed.k === \"sec-legacy\" /* SECRET_LEGACY */) {\n          throw new StopRetrying(\"AI Copilots requires an ID or Access token\");\n        }\n        return resp;\n      },\n      canZombie: () => false\n    }\n  });\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        baseUrl,\n        errorEventSource: liveblocksErrorSource,\n        largeMessageStrategy: clientOptions.largeMessageStrategy,\n        unstable_streamData: !!clientOptions.unstable_streamData,\n        roomHttpClient: httpClient,\n        createSyncSource\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    currentUserId.set(() => void 0);\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const resolveUsers = clientOptions.resolveUsers;\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnOnceIf(\n        !resolveUsers,\n        \"Set the resolveUsers option in createClient to specify user info.\"\n      );\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n  function invalidateResolvedUsers(userIds) {\n    usersStore.invalidate(userIds);\n  }\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnOnceIf(\n        !resolveRoomsInfo,\n        \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n      );\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n  function invalidateResolvedRoomsInfo(roomIds) {\n    roomsInfoStore.invalidate(roomIds);\n  }\n  const resolveGroupsInfo = clientOptions.resolveGroupsInfo;\n  const batchedResolveGroupsInfo = new Batch(\n    async (batchedGroupIds) => {\n      const groupIds = batchedGroupIds.flat();\n      const groupsInfo = await resolveGroupsInfo?.({ groupIds });\n      warnOnceIf(\n        !resolveGroupsInfo,\n        \"Set the resolveGroupsInfo option in createClient to specify group info.\"\n      );\n      return groupsInfo ?? groupIds.map(() => void 0);\n    },\n    { delay: RESOLVE_GROUPS_INFO_BATCH_DELAY }\n  );\n  const groupsInfoStore = createBatchStore(batchedResolveGroupsInfo);\n  function invalidateResolvedGroupsInfo(groupIds) {\n    groupsInfoStore.invalidate(groupIds);\n  }\n  const mentionSuggestionsCache = /* @__PURE__ */ new Map();\n  function invalidateResolvedMentionSuggestions() {\n    mentionSuggestionsCache.clear();\n  }\n  const syncStatusSources = [];\n  const syncStatusSignal = new Signal(\"synchronized\");\n  const liveblocksErrorSource = makeEventSource();\n  function getSyncStatus() {\n    const status = syncStatusSignal.get();\n    return status === \"synchronizing\" ? status : \"synchronized\";\n  }\n  function recompute() {\n    syncStatusSignal.set(\n      syncStatusSources.some((src) => src.get() === \"synchronizing\") ? \"synchronizing\" : syncStatusSources.some((src) => src.get() === \"has-local-changes\") ? \"has-local-changes\" : \"synchronized\"\n    );\n  }\n  function createSyncSource() {\n    const source = new Signal(\"synchronized\");\n    syncStatusSources.push(source);\n    const unsub = source.subscribe(() => recompute());\n    function setSyncStatus(status) {\n      source.set(status);\n    }\n    function destroy() {\n      unsub();\n      const index = syncStatusSources.findIndex((item) => item === source);\n      if (index > -1) {\n        const [ref] = syncStatusSources.splice(index, 1);\n        const wasStillPending = ref.get() !== \"synchronized\";\n        if (wasStillPending) {\n          recompute();\n        }\n      }\n    }\n    return { setSyncStatus, destroy };\n  }\n  {\n    const maybePreventClose = (e) => {\n      if (clientOptions.preventUnsavedChanges && syncStatusSignal.get() !== \"synchronized\") {\n        e.preventDefault();\n      }\n    };\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    win?.addEventListener(\"beforeunload\", maybePreventClose);\n  }\n  async function getNotificationSettings(options2) {\n    const plainSettings = await httpClient.getNotificationSettings(options2);\n    const settings = createNotificationSettings(plainSettings);\n    return settings;\n  }\n  async function updateNotificationSettings(settings) {\n    const plainSettings = await httpClient.updateNotificationSettings(settings);\n    const settingsObject = createNotificationSettings(plainSettings);\n    return settingsObject;\n  }\n  const client = Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      // Public inbox notifications API\n      getInboxNotifications: httpClient.getInboxNotifications,\n      getInboxNotificationsSince: httpClient.getInboxNotificationsSince,\n      getUnreadInboxNotificationsCount: httpClient.getUnreadInboxNotificationsCount,\n      markAllInboxNotificationsAsRead: httpClient.markAllInboxNotificationsAsRead,\n      markInboxNotificationAsRead: httpClient.markInboxNotificationAsRead,\n      deleteAllInboxNotifications: httpClient.deleteAllInboxNotifications,\n      deleteInboxNotification: httpClient.deleteInboxNotification,\n      // Public notification settings API\n      getNotificationSettings,\n      updateNotificationSettings,\n      // Advanced resolvers APIs\n      resolvers: {\n        invalidateUsers: invalidateResolvedUsers,\n        invalidateRoomsInfo: invalidateResolvedRoomsInfo,\n        invalidateGroupsInfo: invalidateResolvedGroupsInfo,\n        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions\n      },\n      getSyncStatus,\n      events: {\n        error: liveblocksErrorSource,\n        syncStatus: syncStatusSignal\n      },\n      // Internal\n      [kInternal]: {\n        currentUserId,\n        mentionSuggestionsCache,\n        ai,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        groupsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        httpClient,\n        // Type-level helper only, it's effectively only an identity-function at runtime\n        as: () => client,\n        createSyncSource,\n        emitError: (context, cause) => {\n          const error3 = LiveblocksError.from(context, cause);\n          const didNotify = liveblocksErrorSource.notify(error3);\n          if (!didNotify) {\n            error2(error3.message);\n          }\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n  return client;\n}\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"paragraph\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionsFromCommentBody(body, predicate) {\n  const mentionIds = /* @__PURE__ */ new Set();\n  const mentions = [];\n  traverseCommentBody(body, \"mention\", (mention) => {\n    if (\n      // If this mention isn't already in the list\n      !mentionIds.has(mention.id) && // And the provided predicate is true\n      (predicate ? predicate(mention) : true)\n    ) {\n      mentionIds.add(mention.id);\n      mentions.push(mention);\n    }\n  });\n  return mentions;\n}\nasync function resolveMentionsInCommentBody(body, resolveUsers, resolveGroupsInfo) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  const resolvedGroupsInfo = /* @__PURE__ */ new Map();\n  if (!resolveUsers && !resolveGroupsInfo) {\n    return {\n      users: resolvedUsers,\n      groups: resolvedGroupsInfo\n    };\n  }\n  const mentions = getMentionsFromCommentBody(body);\n  const userIds = mentions.filter((mention) => mention.kind === \"user\").map((mention) => mention.id);\n  const groupIds = mentions.filter((mention) => mention.kind === \"group\").map((mention) => mention.id);\n  const [users, groups] = await Promise.all([\n    resolveUsers && userIds.length > 0 ? resolveUsers({ userIds }) : void 0,\n    resolveGroupsInfo && groupIds.length > 0 ? resolveGroupsInfo({ groupIds }) : void 0\n  ]);\n  if (users) {\n    for (const [index, userId] of userIds.entries()) {\n      const user = users[index];\n      if (user) {\n        resolvedUsers.set(userId, user);\n      }\n    }\n  }\n  if (groups) {\n    for (const [index, groupId] of groupIds.entries()) {\n      const group = groups[index];\n      if (group) {\n        resolvedGroupsInfo.set(groupId, group);\n      }\n    }\n  }\n  return {\n    users: resolvedUsers,\n    groups: resolvedGroupsInfo\n  };\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  #strings;\n  #values;\n  constructor(strings, values2) {\n    this.#strings = strings;\n    this.#values = values2;\n  }\n  toString() {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this.#values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values2) {\n  return new HtmlSafeString(strings, values2);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  #strings;\n  #values;\n  constructor(strings, values2) {\n    this.#strings = strings;\n    this.#values = values2;\n  }\n  toString() {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this.#values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values2) {\n  return new MarkdownSafeString(strings, values2);\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.text ?? element.url,\n  mention: ({ element, user, group }) => {\n    return `@${user?.name ?? group?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return html`${children}`;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return html`${children}`;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ? html`${element.text}` : element.url}</a>`;\n  },\n  mention: ({ element, user, group }) => {\n    return html`<span data-mention>@${user?.name ? html`${user?.name}` : group?.name ? html`${group?.name}` : element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.text ?? element.url}](${href})`;\n  },\n  mention: ({ element, user, group }) => {\n    return markdown`@${user?.name ?? group?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const { users: resolvedUsers, groups: resolvedGroupsInfo } = await resolveMentionsInCommentBody(\n    body,\n    options?.resolveUsers,\n    options?.resolveGroupsInfo\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: inline.kind === \"user\" ? resolvedUsers.get(inline.id) : void 0,\n                  group: inline.kind === \"group\" ? resolvedGroupsInfo.get(inline.id) : void 0\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            const href = sanitizeUrl(inline.url);\n            if (href === null) {\n              return [\n                elements.text(\n                  {\n                    element: { text: inline.text ?? inline.url }\n                  },\n                  inlineIndex\n                )\n              ];\n            }\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/abortController.ts\nfunction makeAbortController(externalSignal) {\n  const ctl = new AbortController();\n  return {\n    signal: externalSignal ? AbortSignal.any([ctl.signal, externalSignal]) : ctl.signal,\n    abort: ctl.abort.bind(ctl)\n  };\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nvar BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];\nfunction makePoller(callback, intervalMs, options) {\n  const startTime = performance.now();\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const win = typeof window !== \"undefined\" ? window : void 0;\n  const maxStaleTimeMs = options?.maxStaleTimeMs ?? Number.POSITIVE_INFINITY;\n  const context = {\n    inForeground: doc?.visibilityState !== \"hidden\",\n    lastSuccessfulPollAt: startTime,\n    count: 0,\n    backoff: 0\n  };\n  function mayPoll() {\n    return context.count > 0 && context.inForeground;\n  }\n  const fsm = new FSM({}).addState(\"@idle\").addState(\"@enabled\").addState(\"@polling\");\n  fsm.addTransitions(\"@idle\", { START: \"@enabled\" });\n  fsm.addTransitions(\"@enabled\", { STOP: \"@idle\", POLL: \"@polling\" });\n  fsm.addTimedTransition(\n    \"@enabled\",\n    () => {\n      const lastPoll = context.lastSuccessfulPollAt;\n      const nextPoll = lastPoll + intervalMs;\n      return Math.max(0, nextPoll - performance.now()) + context.backoff;\n    },\n    \"@polling\"\n  );\n  fsm.onEnterAsync(\n    \"@polling\",\n    async (_ctx, signal) => {\n      await callback(signal);\n      if (!signal.aborted) {\n        context.lastSuccessfulPollAt = performance.now();\n      }\n    },\n    // When OK\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = 0;\n        }\n      };\n    },\n    // When error\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = BACKOFF_DELAYS2.find((delay) => delay > context.backoff) ?? BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1];\n        }\n      };\n    },\n    3e4\n    // Abort the poll if the callback takes more than 30 seconds to complete\n  );\n  function startOrStop() {\n    if (mayPoll()) {\n      fsm.send({ type: \"START\" });\n    } else {\n      fsm.send({ type: \"STOP\" });\n    }\n  }\n  function inc() {\n    context.count++;\n    startOrStop();\n  }\n  function dec() {\n    context.count--;\n    if (context.count < 0) {\n      context.count = 0;\n    }\n    startOrStop();\n  }\n  function pollNowIfStale() {\n    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {\n      fsm.send({ type: \"POLL\" });\n    }\n  }\n  function markAsStale() {\n    context.lastSuccessfulPollAt = performance.now() - maxStaleTimeMs - 1;\n  }\n  function setInForeground(inForeground) {\n    context.inForeground = inForeground;\n    startOrStop();\n    pollNowIfStale();\n  }\n  function onVisibilityChange() {\n    setInForeground(doc?.visibilityState !== \"hidden\");\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  win?.addEventListener(\"online\", onVisibilityChange);\n  win?.addEventListener(\"focus\", pollNowIfStale);\n  fsm.start();\n  return {\n    inc,\n    dec,\n    pollNowIfStale,\n    markAsStale,\n    // Internal API, used by unit tests only to simulate visibility events\n    setInForeground\n  };\n}\n\n// src/protocol/Subscriptions.ts\nfunction getSubscriptionKey(subscription, subjectId) {\n  if (typeof subscription === \"string\") {\n    return `${subscription}:${subjectId}`;\n  }\n  return `${subscription.kind}:${subscription.subjectId}`;\n}\n\n// src/types/Others.ts\nvar TextEditorType = /* @__PURE__ */ ((TextEditorType2) => {\n  TextEditorType2[\"Lexical\"] = \"lexical\";\n  TextEditorType2[\"TipTap\"] = \"tiptap\";\n  TextEditorType2[\"BlockNote\"] = \"blocknote\";\n  return TextEditorType2;\n})(TextEditorType || {});\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCLEdBQUcsVUFBVTtBQUN4RTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBLHFHQUFxRyxrQkFBa0I7QUFDdkg7QUFDQTtBQUNBLFdBQVcsU0FBUyxFQUFFLFVBQVU7QUFDaEMsV0FBVyxTQUFTLEVBQUUsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsd0JBQXdCO0FBQzNHO0FBQ0E7QUFDQSxhQUFhLFVBQVUsUUFBUSxZQUFZO0FBQzNDLGFBQWEsU0FBUyxRQUFRLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxNQUFxQztBQUNsRDtBQUNBLEVBQUUsQ0FBUTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1QkFBdUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDLHFCQUFxQixXQUFXLGdCQUFnQix1QkFBdUIsZ0JBQWdCO0FBQ3ZIO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBb0I7QUFDOUQ7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFpQztBQUN4RSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUNBQXVDO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkI7QUFDeEQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrRUFBa0U7QUFDbkgsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFpRDtBQUNoRSxNQUFNO0FBQ04sZUFBZSw0Q0FBNEM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxlQUFlO0FBQ3JFLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSwwREFBMEQsU0FBUyxTQUFTLEtBQUs7QUFDakY7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQsb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNEJBQTRCO0FBQzlELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNEJBQTRCO0FBQ3ZFLE9BQU87QUFDUDtBQUNBLHdFQUF3RSwwQ0FBMEM7QUFDbEgseURBQXlELDJCQUEyQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCx3REFBd0QsNEJBQTRCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1EQUFtRCw0RkFBNEY7QUFDL0k7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJLGNBQWM7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU0sbUNBQW1DLG1CQUFtQjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTSxtQ0FBbUMsdUJBQXVCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTSxtQ0FBbUMsdUJBQXVCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBcUMsR0FBRyxDQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1IsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CLCtCQUErQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwrQkFBK0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUI7O0FBRXRCO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSxHQUFHLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVcsZUFBZSxHQUFHO0FBQzlDLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxlQUFlO0FBQ3JFO0FBQ0EsK0NBQStDLG9CQUFvQjtBQUNuRTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBLDREQUE0RCxTQUFTLFNBQVMsS0FBSztBQUNuRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5QkFBeUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBEQUEwRCxJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0NBQXdDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25EO0FBQ0EsdURBQXVELGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxv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O0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQ0FBaUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQixZQUFZO0FBQ2xFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGdDQUFnQyxtQkFBbUI7QUFDbkQsbUNBQW1DLGlDQUFpQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEMsTUFBTTtBQUNOLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLEdBQUcsVUFBVTtBQUN4QztBQUNBLFlBQVksa0JBQWtCLEdBQUcsdUJBQXVCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCOztBQUV2QjtBQUNBO0FBMEdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnlhbmdveWFsL3JlYWwtdGltZS10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMy4xMS4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9kdXBlLWRldGVjdGlvbi50c1xudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9O1xudmFyIGNyb3NzTGlua2VkRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2Nyb3NzLWxpbmtlZFwiO1xudmFyIGR1cGVzRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2R1cGVzXCI7XG52YXIgU1BBQ0UgPSBcIiBcIjtcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtc2cpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlY3REdXBlcyhwa2dOYW1lLCBwa2dWZXJzaW9uLCBwa2dGb3JtYXQpIHtcbiAgY29uc3QgcGtnSWQgPSBTeW1ib2wuZm9yKHBrZ05hbWUpO1xuICBjb25zdCBwa2dCdWlsZEluZm8gPSBwa2dGb3JtYXQgPyBgJHtwa2dWZXJzaW9uIHx8IFwiZGV2XCJ9ICgke3BrZ0Zvcm1hdH0pYCA6IHBrZ1ZlcnNpb24gfHwgXCJkZXZcIjtcbiAgaWYgKCFnW3BrZ0lkXSkge1xuICAgIGdbcGtnSWRdID0gcGtnQnVpbGRJbmZvO1xuICB9IGVsc2UgaWYgKGdbcGtnSWRdID09PSBwa2dCdWlsZEluZm8pIHtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtc2cgPSBbXG4gICAgICBgTXVsdGlwbGUgY29waWVzIG9mIExpdmVibG9ja3MgYXJlIGJlaW5nIGxvYWRlZCBpbiB5b3VyIHByb2plY3QuIFRoaXMgd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2R1cGVzRG9jcyArIFNQQUNFfWAsXG4gICAgICBcIlwiLFxuICAgICAgXCJDb25mbGljdHM6XCIsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7Z1twa2dJZF19IChhbHJlYWR5IGxvYWRlZClgLFxuICAgICAgYC0gJHtwa2dOYW1lfSAke3BrZ0J1aWxkSW5mb30gKHRyeWluZyB0byBsb2FkIHRoaXMgbm93KWBcbiAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgZXJyb3IobXNnKTtcbiAgfVxuICBpZiAocGtnVmVyc2lvbiAmJiBQS0dfVkVSU0lPTiAmJiBwa2dWZXJzaW9uICE9PSBQS0dfVkVSU0lPTikge1xuICAgIGVycm9yKFxuICAgICAgW1xuICAgICAgICBgQ3Jvc3MtbGlua2VkIHZlcnNpb25zIG9mIExpdmVibG9ja3MgZm91bmQsIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzISBTZWUgJHtjcm9zc0xpbmtlZERvY3MgKyBTUEFDRX1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgICAgYC0gJHtQS0dfTkFNRX0gaXMgYXQgJHtQS0dfVkVSU0lPTn1gLFxuICAgICAgICBgLSAke3BrZ05hbWV9IGlzIGF0ICR7cGtnVmVyc2lvbn1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkFsd2F5cyB1cGdyYWRlIGFsbCBMaXZlYmxvY2tzIHBhY2thZ2VzIHRvIHRoZSBzYW1lIHZlcnNpb24gbnVtYmVyLlwiXG4gICAgICBdLmpvaW4oXCJcXG5cIilcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9saWIvRXZlbnRTb3VyY2UudHNcbmZ1bmN0aW9uIG1ha2VFdmVudFNvdXJjZSgpIHtcbiAgY29uc3QgX29ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgIF9vYnNlcnZlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gX29ic2VydmVycy5kZWxldGUoY2FsbGJhY2spO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZU9uY2UoY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bnN1YiA9IHN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgIHVuc3ViKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXZlbnQpO1xuICAgIH0pO1xuICAgIHJldHVybiB1bnN1YjtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWwocHJlZGljYXRlKSB7XG4gICAgbGV0IHVuc3ViO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICB1bnN1YiA9IHN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSA9PT0gdm9pZCAwIHx8IHByZWRpY2F0ZShldmVudCkpIHtcbiAgICAgICAgICByZXMoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHVuc3ViPy4oKSk7XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KGV2ZW50KSB7XG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgX29ic2VydmVycykge1xuICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxlZDtcbiAgfVxuICBmdW5jdGlvbiBjb3VudCgpIHtcbiAgICByZXR1cm4gX29ic2VydmVycy5zaXplO1xuICB9XG4gIHJldHVybiB7XG4gICAgLy8gUHJpdmF0ZS9pbnRlcm5hbCBjb250cm9sIG92ZXIgZXZlbnQgZW1pc3Npb25cbiAgICBub3RpZnksXG4gICAgc3Vic2NyaWJlLFxuICAgIHN1YnNjcmliZU9uY2UsXG4gICAgY291bnQsXG4gICAgd2FpdFVudGlsLFxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBfb2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgfSxcbiAgICAvLyBQdWJsaWNseSBleHBvc2FibGUgc3Vic2NyaXB0aW9uIEFQSVxuICAgIG9ic2VydmFibGU6IHtcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIHN1YnNjcmliZU9uY2UsXG4gICAgICB3YWl0VW50aWxcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtYWtlQnVmZmVyYWJsZUV2ZW50U291cmNlKCkge1xuICBjb25zdCBldmVudFNvdXJjZTIgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgbGV0IF9idWZmZXIgPSBudWxsO1xuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBfYnVmZmVyID0gW107XG4gIH1cbiAgZnVuY3Rpb24gdW5wYXVzZSgpIHtcbiAgICBpZiAoX2J1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIF9idWZmZXIpIHtcbiAgICAgIGV2ZW50U291cmNlMi5ub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgICBfYnVmZmVyID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnlPckJ1ZmZlcihldmVudCkge1xuICAgIGlmIChfYnVmZmVyICE9PSBudWxsKSB7XG4gICAgICBfYnVmZmVyLnB1c2goZXZlbnQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXZlbnRTb3VyY2UyLm5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZXZlbnRTb3VyY2UyLFxuICAgIG5vdGlmeTogbm90aWZ5T3JCdWZmZXIsXG4gICAgcGF1c2UsXG4gICAgdW5wYXVzZSxcbiAgICBkaXNwb3NlKCkge1xuICAgICAgZXZlbnRTb3VyY2UyLmRpc3Bvc2UoKTtcbiAgICAgIGlmIChfYnVmZmVyICE9PSBudWxsKSB7XG4gICAgICAgIF9idWZmZXIubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvZnJlZXplLnRzXG52YXIgZnJlZXplID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gKFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAoeCkgPT4geFxuKSA6IE9iamVjdC5mcmVlemU7XG5cbi8vIHNyYy9saWIvdXRpbHMudHNcbmZ1bmN0aW9uIHJhaXNlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGVudHJpZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopO1xufVxuZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG59XG5mdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKG9iaik7XG59XG5mdW5jdGlvbiBjcmVhdGUob2JqLCBkZXNjcmlwdG9ycykge1xuICBpZiAodHlwZW9mIGRlc2NyaXB0b3JzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUob2JqLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUob2JqKTtcbn1cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmosIG1hcEZuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGNvbnN0IGtleSA9IHBhaXJbMF07XG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcGFpclsxXTtcbiAgICByZXN1bHRba2V5XSA9IG1hcEZuKHZhbHVlLCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0cnlQYXJzZUpzb24ocmF3TWVzc2FnZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJhd01lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZGVlcENsb25lKHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBiNjRkZWNvZGUoYjY0dmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IGI2NHZhbHVlLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIGNvbnN0IGRlY29kZWRWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChcbiAgICAgIGF0b2IoZm9ybWF0dGVkVmFsdWUpLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBcIiVcIiArIChcIjAwXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICB9KS5qb2luKFwiXCIpXG4gICAgKTtcbiAgICByZXR1cm4gZGVjb2RlZFZhbHVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYXRvYihiNjR2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBhY3QoaXRlbXMpIHtcbiAgcmV0dXJuIGl0ZW1zLmZpbHRlcihcbiAgICAoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB2b2lkIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXBhY3RPYmplY3Qob2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHsgLi4ub2JqIH07XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgaWYgKG5ld09ialtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqO1xufVxuZnVuY3Rpb24gd2FpdChtaWxsaXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtaWxsaXMpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhUaW1lb3V0KHByb21pc2UsIG1pbGxpcywgZXJybXNnKSB7XG4gIGxldCB0aW1lcklEO1xuICBjb25zdCB0aW1lciQgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgdGltZXJJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJtc2cpKTtcbiAgICB9LCBtaWxsaXMpO1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZXIkXSkuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZXJJRCkpO1xufVxuZnVuY3Rpb24gbWVtb2l6ZU9uU3VjY2VzcyhmYWN0b3J5Rm4pIHtcbiAgbGV0IGNhY2hlZCA9IG51bGw7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKGNhY2hlZCA9PT0gbnVsbCkge1xuICAgICAgY2FjaGVkID0gZmFjdG9yeUZuKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjYWNoZWQgPSBudWxsO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyLCBwcmVkaWNhdGUpIHtcbiAgZm9yIChsZXQgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vLyBzcmMvbGliL3NpZ25hbHMudHNcbnZhciBrU2lua3MgPSBTeW1ib2woXCJrU2lua3NcIik7XG52YXIga1RyaWdnZXIgPSBTeW1ib2woXCJrVHJpZ2dlclwiKTtcbnZhciBzaWduYWxzVG9UcmlnZ2VyID0gbnVsbDtcbnZhciB0cmFja2VkUmVhZHMgPSBudWxsO1xuZnVuY3Rpb24gYmF0Y2goY2FsbGJhY2spIHtcbiAgaWYgKHNpZ25hbHNUb1RyaWdnZXIgIT09IG51bGwpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuICBzaWduYWxzVG9UcmlnZ2VyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgdHJ5IHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGZpbmFsbHkge1xuICAgIGZvciAoY29uc3Qgc2lnbmFsIG9mIHNpZ25hbHNUb1RyaWdnZXIpIHtcbiAgICAgIHNpZ25hbFtrVHJpZ2dlcl0oKTtcbiAgICB9XG4gICAgc2lnbmFsc1RvVHJpZ2dlciA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGVucXVldWVUcmlnZ2VyKHNpZ25hbCkge1xuICBpZiAoIXNpZ25hbHNUb1RyaWdnZXIpIHJhaXNlKFwiRXhwZWN0ZWQgdG8gYmUgaW4gYW4gYWN0aXZlIGJhdGNoXCIpO1xuICBzaWduYWxzVG9UcmlnZ2VyLmFkZChzaWduYWwpO1xufVxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBwYXRjaCkge1xuICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICBjb25zdCBuZXdWYWx1ZSA9IHsgLi4udGFyZ2V0IH07XG4gIE9iamVjdC5rZXlzKHBhdGNoKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaztcbiAgICBjb25zdCB2YWwgPSBwYXRjaFtrZXldO1xuICAgIGlmIChuZXdWYWx1ZVtrZXldICE9PSB2YWwpIHtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBkZWxldGUgbmV3VmFsdWVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdXBkYXRlZCA/IG5ld1ZhbHVlIDogdGFyZ2V0O1xufVxudmFyIEFic3RyYWN0U2lnbmFsID0gY2xhc3Mge1xuICAvKiogQGludGVybmFsICovXG4gIGVxdWFscztcbiAgI2V2ZW50U291cmNlO1xuICAvKiogQGludGVybmFsICovXG4gIFtrU2lua3NdO1xuICBjb25zdHJ1Y3RvcihlcXVhbHMpIHtcbiAgICB0aGlzLmVxdWFscyA9IGVxdWFscyA/PyBPYmplY3QuaXM7XG4gICAgdGhpcy4jZXZlbnRTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgICB0aGlzW2tTaW5rc10gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuZ2V0ID0gdGhpcy5nZXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN1YnNjcmliZSA9IHRoaXMuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdWJzY3JpYmVPbmNlID0gdGhpcy5zdWJzY3JpYmVPbmNlLmJpbmQodGhpcyk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLiNldmVudFNvdXJjZS5kaXNwb3NlKCk7XG4gICAgdGhpcy4jZXZlbnRTb3VyY2UgPSBcIihkaXNwb3NlZClcIjtcbiAgICB0aGlzLmVxdWFscyA9IFwiKGRpc3Bvc2VkKVwiO1xuICB9XG4gIGdldCBoYXNXYXRjaGVycygpIHtcbiAgICBpZiAodGhpcy4jZXZlbnRTb3VyY2UuY291bnQoKSA+IDApIHJldHVybiB0cnVlO1xuICAgIGZvciAoY29uc3Qgc2luayBvZiB0aGlzW2tTaW5rc10pIHtcbiAgICAgIGlmIChzaW5rLmhhc1dhdGNoZXJzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgW2tUcmlnZ2VyXSgpIHtcbiAgICB0aGlzLiNldmVudFNvdXJjZS5ub3RpZnkoKTtcbiAgICBmb3IgKGNvbnN0IHNpbmsgb2YgdGhpc1trU2lua3NdKSB7XG4gICAgICBlbnF1ZXVlVHJpZ2dlcihzaW5rKTtcbiAgICB9XG4gIH1cbiAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuI2V2ZW50U291cmNlLmNvdW50KCkgPT09IDApIHtcbiAgICAgIHRoaXMuZ2V0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNldmVudFNvdXJjZS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICB9XG4gIHN1YnNjcmliZU9uY2UoY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bnN1YiA9IHRoaXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHVuc3ViKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5zdWI7XG4gIH1cbiAgd2FpdFVudGlsKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIndhaXRVbnRpbCBub3Qgc3VwcG9ydGVkIG9uIFNpZ25hbHNcIik7XG4gIH1cbiAgbWFya1NpbmtzRGlydHkoKSB7XG4gICAgZm9yIChjb25zdCBzaW5rIG9mIHRoaXNba1NpbmtzXSkge1xuICAgICAgc2luay5tYXJrRGlydHkoKTtcbiAgICB9XG4gIH1cbiAgYWRkU2luayhzaW5rKSB7XG4gICAgdGhpc1trU2lua3NdLmFkZChzaW5rKTtcbiAgfVxuICByZW1vdmVTaW5rKHNpbmspIHtcbiAgICB0aGlzW2tTaW5rc10uZGVsZXRlKHNpbmspO1xuICB9XG4gIGFzUmVhZG9ubHkoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgU2lnbmFsID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFNpZ25hbCB7XG4gICN2YWx1ZTtcbiAgY29uc3RydWN0b3IodmFsdWUsIGVxdWFscykge1xuICAgIHN1cGVyKGVxdWFscyk7XG4gICAgdGhpcy4jdmFsdWUgPSBmcmVlemUodmFsdWUpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuI3ZhbHVlID0gXCIoZGlzcG9zZWQpXCI7XG4gIH1cbiAgZ2V0KCkge1xuICAgIHRyYWNrZWRSZWFkcz8uYWRkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLiN2YWx1ZTtcbiAgfVxuICBzZXQobmV3VmFsdWUpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG5ld1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZSh0aGlzLiN2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZXF1YWxzKHRoaXMuI3ZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSBmcmVlemUobmV3VmFsdWUpO1xuICAgICAgICB0aGlzLm1hcmtTaW5rc0RpcnR5KCk7XG4gICAgICAgIGVucXVldWVUcmlnZ2VyKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xudmFyIFBhdGNoYWJsZVNpZ25hbCA9IGNsYXNzIGV4dGVuZHMgU2lnbmFsIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGZyZWV6ZShjb21wYWN0T2JqZWN0KGRhdGEpKSk7XG4gIH1cbiAgc2V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkRvbid0IGNhbGwgLnNldCgpIGRpcmVjdGx5LCB1c2UgLnBhdGNoKClcIik7XG4gIH1cbiAgLyoqXG4gICAqIFBhdGNoZXMgdGhlIGN1cnJlbnQgb2JqZWN0LlxuICAgKi9cbiAgcGF0Y2gocGF0Y2gpIHtcbiAgICBzdXBlci5zZXQoKG9sZCkgPT4gbWVyZ2Uob2xkLCBwYXRjaCkpO1xuICB9XG59O1xudmFyIElOSVRJQUwgPSBTeW1ib2woKTtcbnZhciBEZXJpdmVkU2lnbmFsID0gY2xhc3MgX0Rlcml2ZWRTaWduYWwgZXh0ZW5kcyBBYnN0cmFjdFNpZ25hbCB7XG4gICNwcmV2VmFsdWU7XG4gICNkaXJ0eTtcbiAgLy8gV2hlbiB0cnVlLCB0aGUgdmFsdWUgaW4gI3ZhbHVlIG1heSBub3QgYmUgdXAtdG8tZGF0ZSBhbmQgbmVlZHMgcmUtY2hlY2tpbmdcbiAgI3NvdXJjZXM7XG4gICNkZXBzO1xuICAjdHJhbnNmb3JtO1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgc3RhdGljIGZyb20oLi4uYXJncykge1xuICAgIGNvbnN0IGxhc3QgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbGFzdCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmFpc2UoXCJJbnZhbGlkIC5mcm9tKCkgY2FsbCwgbGFzdCBhcmd1bWVudCBleHBlY3RlZCB0byBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGVxdWFscyA9IGxhc3Q7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBhcmdzLnBvcCgpO1xuICAgICAgcmV0dXJuIG5ldyBfRGVyaXZlZFNpZ25hbChhcmdzLCB0cmFuc2Zvcm0sIGVxdWFscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGxhc3Q7XG4gICAgICByZXR1cm4gbmV3IF9EZXJpdmVkU2lnbmFsKGFyZ3MsIHRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKGRlcHMsIHRyYW5zZm9ybSwgZXF1YWxzKSB7XG4gICAgc3VwZXIoZXF1YWxzKTtcbiAgICB0aGlzLiNkaXJ0eSA9IHRydWU7XG4gICAgdGhpcy4jcHJldlZhbHVlID0gSU5JVElBTDtcbiAgICB0aGlzLiNkZXBzID0gZGVwcztcbiAgICB0aGlzLiNzb3VyY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLiN0cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGNvbnN0IHNyYyBvZiB0aGlzLiNzb3VyY2VzKSB7XG4gICAgICBzcmMucmVtb3ZlU2luayh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy4jcHJldlZhbHVlID0gXCIoZGlzcG9zZWQpXCI7XG4gICAgdGhpcy4jc291cmNlcyA9IFwiKGRpc3Bvc2VkKVwiO1xuICAgIHRoaXMuI2RlcHMgPSBcIihkaXNwb3NlZClcIjtcbiAgICB0aGlzLiN0cmFuc2Zvcm0gPSBcIihkaXNwb3NlZClcIjtcbiAgfVxuICBnZXQgaXNEaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZGlydHk7XG4gIH1cbiAgI3JlY29tcHV0ZSgpIHtcbiAgICBjb25zdCBvbGRUcmFja2VkUmVhZHMgPSB0cmFja2VkUmVhZHM7XG4gICAgbGV0IGRlcml2ZWQ7XG4gICAgdHJhY2tlZFJlYWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0cnkge1xuICAgICAgZGVyaXZlZCA9IHRoaXMuI3RyYW5zZm9ybSguLi50aGlzLiNkZXBzLm1hcCgocCkgPT4gcC5nZXQoKSkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb25zdCBvbGRTb3VyY2VzID0gdGhpcy4jc291cmNlcztcbiAgICAgIHRoaXMuI3NvdXJjZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCBzaWcgb2YgdHJhY2tlZFJlYWRzKSB7XG4gICAgICAgIHRoaXMuI3NvdXJjZXMuYWRkKHNpZyk7XG4gICAgICAgIG9sZFNvdXJjZXMuZGVsZXRlKHNpZyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG9sZFNvdXJjZSBvZiBvbGRTb3VyY2VzKSB7XG4gICAgICAgIG9sZFNvdXJjZS5yZW1vdmVTaW5rKHRoaXMpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBuZXdTb3VyY2Ugb2YgdGhpcy4jc291cmNlcykge1xuICAgICAgICBuZXdTb3VyY2UuYWRkU2luayh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRyYWNrZWRSZWFkcyA9IG9sZFRyYWNrZWRSZWFkcztcbiAgICB9XG4gICAgdGhpcy4jZGlydHkgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZXF1YWxzKHRoaXMuI3ByZXZWYWx1ZSwgZGVyaXZlZCkpIHtcbiAgICAgIHRoaXMuI3ByZXZWYWx1ZSA9IGRlcml2ZWQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1hcmtEaXJ0eSgpIHtcbiAgICBpZiAoIXRoaXMuI2RpcnR5KSB7XG4gICAgICB0aGlzLiNkaXJ0eSA9IHRydWU7XG4gICAgICB0aGlzLm1hcmtTaW5rc0RpcnR5KCk7XG4gICAgfVxuICB9XG4gIGdldCgpIHtcbiAgICBpZiAodGhpcy4jZGlydHkpIHtcbiAgICAgIHRoaXMuI3JlY29tcHV0ZSgpO1xuICAgIH1cbiAgICB0cmFja2VkUmVhZHM/LmFkZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy4jcHJldlZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgYnkgdGhlIFNpZ25hbCBzeXN0ZW0gaWYgb25lIG9yIG1vcmUgb2YgdGhlIGRlcGVuZGVudCBzaWduYWxzIGhhdmVcbiAgICogY2hhbmdlZC4gSW4gdGhlIGNhc2Ugb2YgYSBEZXJpdmVkU2lnbmFsLCB3ZSdsbCBvbmx5IHdhbnQgdG8gcmUtZXZhbHVhdGVcbiAgICogdGhlIGFjdHVhbCB2YWx1ZSBpZiBpdCdzIGJlaW5nIHdhdGNoZWQsIG9yIGFueSBvZiB0aGVpciBzaW5rcyBhcmUgYmVpbmdcbiAgICogd2F0Y2hlZCBhY3RpdmVseS5cbiAgICovXG4gIFtrVHJpZ2dlcl0oKSB7XG4gICAgaWYgKCF0aGlzLmhhc1dhdGNoZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZWQgPSB0aGlzLiNyZWNvbXB1dGUoKTtcbiAgICBpZiAodXBkYXRlZCkge1xuICAgICAgc3VwZXJba1RyaWdnZXJdKCk7XG4gICAgfVxuICB9XG59O1xudmFyIE11dGFibGVTaWduYWwgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0U2lnbmFsIHtcbiAgI3N0YXRlO1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsU3RhdGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI3N0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuI3N0YXRlID0gXCIoZGlzcG9zZWQpXCI7XG4gIH1cbiAgZ2V0KCkge1xuICAgIHRyYWNrZWRSZWFkcz8uYWRkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLiNzdGF0ZTtcbiAgfVxuICAvKipcbiAgICogSW52b2tlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgYWxsb3dlZCB0byBtdXRhdGUgdGhlIGdpdmVuIHN0YXRlXG4gICAqIHZhbHVlLiBEbyBub3QgY2hhbmdlIHRoZSB2YWx1ZSBvdXRzaWRlIG9mIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogSWYgdGhlIGNhbGxiYWNrIGV4cGxpY2l0bHkgcmV0dXJucyBgZmFsc2VgLCBpdCdzIGFzc3VtZWQgdGhhdCB0aGUgc3RhdGVcbiAgICogd2FzIG5vdCBjaGFuZ2VkLlxuICAgKi9cbiAgbXV0YXRlKGNhbGxiYWNrKSB7XG4gICAgYmF0Y2goKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2sgPyBjYWxsYmFjayh0aGlzLiNzdGF0ZSkgOiB0cnVlO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIHJlc3VsdCkge1xuICAgICAgICByYWlzZShcIk11dGFibGVTaWduYWwubXV0YXRlKCkgZG9lcyBub3Qgc3VwcG9ydCBhc3luYyBjYWxsYmFja3NcIik7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLm1hcmtTaW5rc0RpcnR5KCk7XG4gICAgICAgIGVucXVldWVUcmlnZ2VyKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL1NvcnRlZExpc3QudHNcbmZ1bmN0aW9uIGJpc2VjdFJpZ2h0KGFyciwgeCwgbHQpIHtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IGhpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICBjb25zdCBtaWQgPSBsbyArIChoaSAtIGxvID4+IDEpO1xuICAgIGlmIChsdCh4LCBhcnJbbWlkXSkpIHtcbiAgICAgIGhpID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBsbyA9IG1pZCArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBsbztcbn1cbnZhciBTb3J0ZWRMaXN0ID0gY2xhc3MgX1NvcnRlZExpc3Qge1xuICAjZGF0YTtcbiAgI2x0O1xuICBjb25zdHJ1Y3RvcihhbHJlYWR5U29ydGVkTGlzdCwgbHQpIHtcbiAgICB0aGlzLiNsdCA9IGx0O1xuICAgIHRoaXMuI2RhdGEgPSBhbHJlYWR5U29ydGVkTGlzdDtcbiAgfVxuICBzdGF0aWMgd2l0aChsdCkge1xuICAgIHJldHVybiBfU29ydGVkTGlzdC5mcm9tQWxyZWFkeVNvcnRlZChbXSwgbHQpO1xuICB9XG4gIHN0YXRpYyBmcm9tKGFyciwgbHQpIHtcbiAgICBjb25zdCBzb3J0ZWQgPSBuZXcgX1NvcnRlZExpc3QoW10sIGx0KTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBzb3J0ZWQuYWRkKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gc29ydGVkO1xuICB9XG4gIHN0YXRpYyBmcm9tQWxyZWFkeVNvcnRlZChhbHJlYWR5U29ydGVkLCBsdCkge1xuICAgIHJldHVybiBuZXcgX1NvcnRlZExpc3QoYWxyZWFkeVNvcnRlZCwgbHQpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHNvcnRlZCBsaXN0IHRvIGEgbmV3IGluc3RhbmNlLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfU29ydGVkTGlzdCh0aGlzLiNkYXRhLnNsaWNlKCksIHRoaXMuI2x0KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRoZSBzb3J0ZWQgbGlzdCwgc3VjaCB0aGF0IGl0IHJlbWFpbnMgc29ydGVkLlxuICAgKi9cbiAgYWRkKHZhbHVlKSB7XG4gICAgY29uc3QgaWR4ID0gYmlzZWN0UmlnaHQodGhpcy4jZGF0YSwgdmFsdWUsIHRoaXMuI2x0KTtcbiAgICB0aGlzLiNkYXRhLnNwbGljZShpZHgsIDAsIHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgdmFsdWVzIGZyb20gdGhlIHNvcnRlZCBsaXN0LCBtYWtpbmcgaXQgZW1wdHkgYWdhaW4uXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgbGlzdCB3YXMgbXV0YXRlZCBvciBub3QuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBjb25zdCBoYWREYXRhID0gdGhpcy4jZGF0YS5sZW5ndGggPiAwO1xuICAgIHRoaXMuI2RhdGEubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gaGFkRGF0YTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZmlyc3QgdmFsdWUgbWF0Y2hpbmcgdGhlIHByZWRpY2F0ZS5cbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBsaXN0IHdhcyBtdXRhdGVkIG9yIG5vdC5cbiAgICovXG4gIHJlbW92ZUJ5KHByZWRpY2F0ZSwgbGltaXQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICBsZXQgZGVsZXRlZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLiNkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHRoaXMuI2RhdGFbaV0pKSB7XG4gICAgICAgIHRoaXMuI2RhdGEuc3BsaWNlKGksIDEpO1xuICAgICAgICBkZWxldGVkKys7XG4gICAgICAgIGlmIChkZWxldGVkID49IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWxldGVkID4gMDtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gdmFsdWUgZnJvbSB0aGUgc29ydGVkIGxpc3QsIGlmIGl0IGV4aXN0cy4gVGhlIGdpdmVuXG4gICAqIHZhbHVlIG11c3QgYmUgYD09PWAgdG8gb25lIG9mIHRoZSBsaXN0IGl0ZW1zLiBPbmx5IHRoZSBmaXJzdCBlbnRyeSB3aWxsIGJlXG4gICAqIHJlbW92ZWQgaWYgdGhlIGVsZW1lbnQgZXhpc3RzIGluIHRoZSBzb3J0ZWQgbGlzdCBtdWx0aXBsZSB0aW1lcy5cbiAgICpcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBsaXN0IHdhcyBtdXRhdGVkIG9yIG5vdC5cbiAgICovXG4gIHJlbW92ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuI2RhdGEuaW5kZXhPZih2YWx1ZSk7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLiNkYXRhLnNwbGljZShpZHgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhdChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhW2luZGV4XTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhLmxlbmd0aDtcbiAgfVxuICAqZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNkYXRhKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGl0ZW0pKSB7XG4gICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFhYWFggSWYgd2Uga2VlcCB0aGlzLCBhZGQgdW5pdCB0ZXN0cy4gT3IgcmVtb3ZlIGl0LlxuICAqZmluZEFsbFJpZ2h0KHByZWRpY2F0ZSkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLiNkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy4jZGF0YVtpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSwgaSkpIHtcbiAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGFbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gICppdGVyUmV2ZXJzZWQoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuI2RhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHlpZWxkIHRoaXMuI2RhdGFbaV07XG4gICAgfVxuICB9XG4gIC8qKiBGaW5kcyB0aGUgbGVmdG1vc3QgaXRlbSB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZS4gKi9cbiAgZmluZChwcmVkaWNhdGUsIHN0YXJ0KSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5maW5kSW5kZXgocHJlZGljYXRlLCBzdGFydCk7XG4gICAgcmV0dXJuIGlkeCA+IC0xID8gdGhpcy4jZGF0YS5hdChpZHgpIDogdm9pZCAwO1xuICB9XG4gIC8qKiBGaW5kcyB0aGUgbGVmdG1vc3QgaW5kZXggdGhhdCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUuICovXG4gIGZpbmRJbmRleChwcmVkaWNhdGUsIHN0YXJ0ID0gMCkge1xuICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBzdGFydCk7IGkgPCB0aGlzLiNkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHRoaXMuI2RhdGFbaV0sIGkpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLyoqIEZpbmRzIHRoZSByaWdodG1vc3QgaXRlbSB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZS4gKi9cbiAgZmluZFJpZ2h0KHByZWRpY2F0ZSwgc3RhcnQpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLmZpbmRJbmRleFJpZ2h0KHByZWRpY2F0ZSwgc3RhcnQpO1xuICAgIHJldHVybiBpZHggPiAtMSA/IHRoaXMuI2RhdGEuYXQoaWR4KSA6IHZvaWQgMDtcbiAgfVxuICAvKiogRmluZHMgdGhlIHJpZ2h0bW9zdCBpbmRleCB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZS4gKi9cbiAgZmluZEluZGV4UmlnaHQocHJlZGljYXRlLCBzdGFydCA9IHRoaXMuI2RhdGEubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IGkgPSBNYXRoLm1pbihzdGFydCwgdGhpcy4jZGF0YS5sZW5ndGggLSAxKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodGhpcy4jZGF0YVtpXSwgaSkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBnZXQgcmF3QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGE7XG4gIH1cbn07XG5cbi8vIHNyYy9BaUNoYXREQi50c1xudmFyIEFpQ2hhdERCID0gY2xhc3Mge1xuICAjYnlJZDtcbiAgLy8gQSBtYXAgb2YgY2hhdCBpZCB0byBjaGF0IGRldGFpbHNcbiAgI2NoYXRzO1xuICAvLyBTb3J0ZWQgbGlzdCBvZiBub24tZGVsZXRlZCBjaGF0cywgbW9zdCByZWNlbnQgZmlyc3RcbiAgc2lnbmFsO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLiNieUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLiNjaGF0cyA9IFNvcnRlZExpc3QuZnJvbShbXSwgKGMxLCBjMikgPT4ge1xuICAgICAgY29uc3QgZDIgPSBjMi5sYXN0TWVzc2FnZUF0ID8/IGMyLmNyZWF0ZWRBdDtcbiAgICAgIGNvbnN0IGQxID0gYzEubGFzdE1lc3NhZ2VBdCA/PyBjMS5jcmVhdGVkQXQ7XG4gICAgICByZXR1cm4gZDIgPCBkMSA/IHRydWUgOiBkMiA9PT0gZDEgPyBjMi5pZCA8IGMxLmlkIDogZmFsc2U7XG4gICAgfSk7XG4gICAgdGhpcy5zaWduYWwgPSBuZXcgTXV0YWJsZVNpZ25hbCh0aGlzKTtcbiAgfVxuICBnZXRFdmVuSWZEZWxldGVkKGNoYXRJZCkge1xuICAgIHRoaXMuc2lnbmFsLmdldCgpO1xuICAgIHJldHVybiB0aGlzLiNieUlkLmdldChjaGF0SWQpO1xuICB9XG4gIG1hcmtEZWxldGVkKGNoYXRJZCkge1xuICAgIGNvbnN0IGNoYXQgPSB0aGlzLiNieUlkLmdldChjaGF0SWQpO1xuICAgIGlmIChjaGF0ID09PSB2b2lkIDAgfHwgY2hhdC5kZWxldGVkQXQgIT09IHZvaWQgMCkgcmV0dXJuO1xuICAgIHRoaXMudXBzZXJ0KHtcbiAgICAgIC4uLmNoYXQsXG4gICAgICBkZWxldGVkQXQ6ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKVxuICAgIH0pO1xuICB9XG4gIHVwc2VydChjaGF0KSB7XG4gICAgdGhpcy5zaWduYWwubXV0YXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gdGhpcy4jYnlJZC5nZXQoY2hhdC5pZCk7XG4gICAgICBpZiAoZXhpc3RpbmdUaHJlYWQgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoZXhpc3RpbmdUaHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy4jY2hhdHMucmVtb3ZlKGV4aXN0aW5nVGhyZWFkKTtcbiAgICAgICAgdGhpcy4jYnlJZC5kZWxldGUoZXhpc3RpbmdUaHJlYWQuaWQpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXQuZGVsZXRlZEF0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy4jY2hhdHMuYWRkKGNoYXQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jYnlJZC5zZXQoY2hhdC5pZCwgY2hhdCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICBmaW5kTWFueShxdWVyeSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKFxuICAgICAgdGhpcy4jY2hhdHMuZmlsdGVyKChjaGF0KSA9PiB7XG4gICAgICAgIGlmIChxdWVyeS5tZXRhZGF0YSA9PT0gdm9pZCAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnkubWV0YWRhdGEpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIGNoYXQubWV0YWRhdGEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGNoYXQubWV0YWRhdGFba2V5XSAhPT0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2hhdFZhbHVlID0gY2hhdC5tZXRhZGF0YVtrZXldO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXRWYWx1ZSkgfHwgIXZhbHVlLmV2ZXJ5KCh2KSA9PiBjaGF0VmFsdWUuaW5jbHVkZXModikpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb252ZXJ0LXBsYWluLWRhdGEudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnREYXRhKGRhdGEpIHtcbiAgY29uc3QgZWRpdGVkQXQgPSBkYXRhLmVkaXRlZEF0ID8gbmV3IERhdGUoZGF0YS5lZGl0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgcmVhY3Rpb25zID0gZGF0YS5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gKHtcbiAgICAuLi5yZWFjdGlvbixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHJlYWN0aW9uLmNyZWF0ZWRBdClcbiAgfSkpO1xuICBpZiAoZGF0YS5ib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXQsXG4gICAgICBkZWxldGVkQXRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREYXRhKGRhdGEpIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gIGNvbnN0IGNvbW1lbnRzID0gZGF0YS5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpXG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQsXG4gICAgdXBkYXRlZEF0LFxuICAgIGNvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoZGF0YSkge1xuICBjb25zdCBub3RpZmllZEF0ID0gbmV3IERhdGUoZGF0YS5ub3RpZmllZEF0KTtcbiAgY29uc3QgcmVhZEF0ID0gZGF0YS5yZWFkQXQgPyBuZXcgRGF0ZShkYXRhLnJlYWRBdCkgOiBudWxsO1xuICBpZiAoXCJhY3Rpdml0aWVzXCIgaW4gZGF0YSkge1xuICAgIGNvbnN0IGFjdGl2aXRpZXMgPSBkYXRhLmFjdGl2aXRpZXMubWFwKChhY3Rpdml0eSkgPT4gKHtcbiAgICAgIC4uLmFjdGl2aXR5LFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShhY3Rpdml0eS5jcmVhdGVkQXQpXG4gICAgfSkpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgbm90aWZpZWRBdCxcbiAgICAgIHJlYWRBdCxcbiAgICAgIGFjdGl2aXRpZXNcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBub3RpZmllZEF0LFxuICAgIHJlYWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvU3Vic2NyaXB0aW9uRGF0YShkYXRhKSB7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvVXNlclN1YnNjcmlwdGlvbkRhdGEoZGF0YSkge1xuICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8oZGF0YSkge1xuICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBkZWxldGVkQXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGVsZXRlSW5mbyhkYXRhKSB7XG4gIGNvbnN0IGRlbGV0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuZGVsZXRlZEF0KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGRlbGV0ZWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvU3Vic2NyaXB0aW9uRGVsZXRlSW5mbyhkYXRhKSB7XG4gIGNvbnN0IGRlbGV0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuZGVsZXRlZEF0KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGRlbGV0ZWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvR3JvdXBEYXRhKGRhdGEpIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gIGNvbnN0IG1lbWJlcnMgPSBkYXRhLm1lbWJlcnMubWFwKChtZW1iZXIpID0+ICh7XG4gICAgLi4ubWVtYmVyLFxuICAgIGFkZGVkQXQ6IG5ldyBEYXRlKG1lbWJlci5hZGRlZEF0KVxuICB9KSk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQsXG4gICAgdXBkYXRlZEF0LFxuICAgIG1lbWJlcnNcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF92YWx1ZSwgZXJybXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgZXJybXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICBlcnIubmFtZSA9IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5uKHZhbHVlLCBlcnJtc2cgPSBcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG5vbi1udWxsYWJsZVwiKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwLCBlcnJtc2cpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9saWIvZmFuY3ktY29uc29sZS50c1xudmFyIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFuY3lfY29uc29sZV9leHBvcnRzLCB7XG4gIGVycm9yOiAoKSA9PiBlcnJvcjIsXG4gIGVycm9yV2l0aFRpdGxlOiAoKSA9PiBlcnJvcldpdGhUaXRsZSxcbiAgd2FybjogKCkgPT4gd2FybixcbiAgd2FybldpdGhUaXRsZTogKCkgPT4gd2FybldpdGhUaXRsZVxufSk7XG52YXIgYmFkZ2UgPSBcImJhY2tncm91bmQ6IzBlMGQxMjtib3JkZXItcmFkaXVzOjk5OTlweDtjb2xvcjojZmZmO3BhZGRpbmc6M3B4IDdweDtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjYwMDtcIjtcbnZhciBib2xkID0gXCJmb250LXdlaWdodDo2MDBcIjtcbmZ1bmN0aW9uIHdyYXAobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIChtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXCIlY0xpdmVibG9ja3NcIiwgYmFkZ2UsIG1lc3NhZ2UsIC4uLmFyZ3MpXG4gICk7XG59XG52YXIgd2FybiA9IHdyYXAoXCJ3YXJuXCIpO1xudmFyIGVycm9yMiA9IHdyYXAoXCJlcnJvclwiKTtcbmZ1bmN0aW9uIHdyYXBXaXRoVGl0bGUobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICh0aXRsZSwgbWVzc2FnZSwgLi4uYXJncykgPT4gY29uc29sZVttZXRob2RdKFxuICAgICAgYCVjTGl2ZWJsb2NrcyVjICR7dGl0bGV9YCxcbiAgICAgIGJhZGdlLFxuICAgICAgYm9sZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICAuLi5hcmdzXG4gICAgKVxuICApO1xufVxudmFyIHdhcm5XaXRoVGl0bGUgPSB3cmFwV2l0aFRpdGxlKFwid2FyblwiKTtcbnZhciBlcnJvcldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJlcnJvclwiKTtcblxuLy8gc3JjL2xpYi9ndWFyZHMudHNcbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYmxvYikge1xuICByZXR1cm4gYmxvYiAhPT0gbnVsbCAmJiB0eXBlb2YgYmxvYiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxvYikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBpc1N0YXJ0c1dpdGhPcGVyYXRvcihibG9iKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGJsb2IpICYmIHR5cGVvZiBibG9iLnN0YXJ0c1dpdGggPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc051bWJlck9wZXJhdG9yKGJsb2IpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoYmxvYikgJiYgKHR5cGVvZiBibG9iLmx0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBibG9iLmd0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBibG9iLmx0ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgYmxvYi5ndGUgPT09IFwibnVtYmVyXCIpO1xufVxuXG4vLyBzcmMvbGliL2F1dG9SZXRyeS50c1xudmFyIEh0dHBFcnJvciA9IGNsYXNzIF9IdHRwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHJlc3BvbnNlO1xuICBkZXRhaWxzO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZXNwb25zZSwgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiSHR0cEVycm9yXCI7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21SZXNwb25zZShyZXNwb25zZSkge1xuICAgIGxldCBib2R5QXNUZXh0O1xuICAgIHRyeSB7XG4gICAgICBib2R5QXNUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICBjb25zdCBib2R5QXNKc29uID0gYm9keUFzVGV4dCA/IHRyeVBhcnNlSnNvbihib2R5QXNUZXh0KSA6IHZvaWQgMDtcbiAgICBsZXQgYm9keUFzSnNvbk9iamVjdDtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChib2R5QXNKc29uKSkge1xuICAgICAgYm9keUFzSnNvbk9iamVjdCA9IGJvZHlBc0pzb247XG4gICAgfVxuICAgIGxldCBtZXNzYWdlID0gXCJcIjtcbiAgICBtZXNzYWdlIHx8PSB0eXBlb2YgYm9keUFzSnNvbk9iamVjdD8ubWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IGJvZHlBc0pzb25PYmplY3QubWVzc2FnZSA6IFwiXCI7XG4gICAgbWVzc2FnZSB8fD0gdHlwZW9mIGJvZHlBc0pzb25PYmplY3Q/LmVycm9yID09PSBcInN0cmluZ1wiID8gYm9keUFzSnNvbk9iamVjdC5lcnJvciA6IFwiXCI7XG4gICAgaWYgKGJvZHlBc0pzb24gPT09IHZvaWQgMCkge1xuICAgICAgbWVzc2FnZSB8fD0gYm9keUFzVGV4dCB8fCBcIlwiO1xuICAgIH1cbiAgICBtZXNzYWdlIHx8PSByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgIGxldCBwYXRoO1xuICAgIHRyeSB7XG4gICAgICBwYXRoID0gbmV3IFVSTChyZXNwb25zZS51cmwpLnBhdGhuYW1lO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICBtZXNzYWdlICs9IHBhdGggIT09IHZvaWQgMCA/IGAgKGdvdCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9IGZyb20gJHtwYXRofSlgIDogYCAoZ290IHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c30pYDtcbiAgICBjb25zdCBkZXRhaWxzID0gYm9keUFzSnNvbk9iamVjdDtcbiAgICByZXR1cm4gbmV3IF9IdHRwRXJyb3IobWVzc2FnZSwgcmVzcG9uc2UsIGRldGFpbHMpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBhY2Nlc3NvciBmb3IgcmVzcG9uc2Uuc3RhdHVzLlxuICAgKi9cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZS5zdGF0dXM7XG4gIH1cbn07XG52YXIgRE9OVF9SRVRSWV80WFggPSAoeCkgPT4geCBpbnN0YW5jZW9mIEh0dHBFcnJvciAmJiB4LnN0YXR1cyA+PSA0MDAgJiYgeC5zdGF0dXMgPCA1MDA7XG5hc3luYyBmdW5jdGlvbiBhdXRvUmV0cnkocHJvbWlzZUZuLCBtYXhUcmllcywgYmFja29mZiwgc2hvdWxkU3RvcFJldHJ5aW5nID0gRE9OVF9SRVRSWV80WFgpIHtcbiAgY29uc3QgZmFsbGJhY2tCYWNrb2ZmID0gYmFja29mZi5sZW5ndGggPiAwID8gYmFja29mZltiYWNrb2ZmLmxlbmd0aCAtIDFdIDogMDtcbiAgbGV0IGF0dGVtcHQgPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGF0dGVtcHQrKztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2VGbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHNob3VsZFN0b3BSZXRyeWluZyhlcnIpKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRlbXB0ID49IG1heFRyaWVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIGFmdGVyICR7bWF4VHJpZXN9IGF0dGVtcHRzOiAke1N0cmluZyhlcnIpfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWxheSA9IGJhY2tvZmZbYXR0ZW1wdCAtIDFdID8/IGZhbGxiYWNrQmFja29mZjtcbiAgICB3YXJuKFxuICAgICAgYEF0dGVtcHQgJHthdHRlbXB0fSB3YXMgdW5zdWNjZXNzZnVsLiBSZXRyeWluZyBpbiAke2RlbGF5fSBtaWxsaXNlY29uZHMuYFxuICAgICk7XG4gICAgYXdhaXQgd2FpdChkZWxheSk7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9jb250cm9sbGVkUHJvbWlzZS50c1xuZnVuY3Rpb24gY29udHJvbGxlZFByb21pc2UoKSB7XG4gIGxldCByZXNvbHZlO1xuICBsZXQgcmVqZWN0O1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICByZXR1cm4gW3Byb21pc2UsIHJlc29sdmUsIHJlamVjdF07XG59XG5mdW5jdGlvbiBQcm9taXNlX3dpdGhSZXNvbHZlcnMoKSB7XG4gIGNvbnN0IFtwcm9taXNlLCByZXNvbHZlLCByZWplY3RdID0gY29udHJvbGxlZFByb21pc2UoKTtcbiAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG59XG5cbi8vIHNyYy9saWIvc3RyaW5naWZ5LnRzXG5mdW5jdGlvbiByZXBsYWNlcihfa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSA/IE9iamVjdC5rZXlzKHZhbHVlKS5zb3J0KCkucmVkdWNlKChzb3J0ZWQsIGtleSkgPT4ge1xuICAgIHNvcnRlZFtrZXldID0gdmFsdWVba2V5XTtcbiAgICByZXR1cm4gc29ydGVkO1xuICB9LCB7fSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHN0YWJsZVN0cmluZ2lmeSh2YWx1ZSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeU9yTG9nKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IHN0cmluZ2lmeTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICBjb25zb2xlLmVycm9yKHZhbHVlKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9iYXRjaC50c1xudmFyIERFRkFVTFRfU0laRSA9IDUwO1xudmFyIEJhdGNoQ2FsbCA9IGNsYXNzIHtcbiAgaW5wdXQ7XG4gIHJlc29sdmU7XG4gIHJlamVjdDtcbiAgcHJvbWlzZTtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IFByb21pc2Vfd2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgfVxufTtcbnZhciBCYXRjaCA9IGNsYXNzIHtcbiAgI3F1ZXVlID0gW107XG4gICNjYWxsYmFjaztcbiAgI3NpemU7XG4gICNkZWxheTtcbiAgI2RlbGF5VGltZW91dElkO1xuICBlcnJvciA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHRoaXMuI2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy4jc2l6ZSA9IG9wdGlvbnMuc2l6ZSA/PyBERUZBVUxUX1NJWkU7XG4gICAgdGhpcy4jZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICB9XG4gICNjbGVhckRlbGF5VGltZW91dCgpIHtcbiAgICBpZiAodGhpcy4jZGVsYXlUaW1lb3V0SWQgIT09IHZvaWQgMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RlbGF5VGltZW91dElkKTtcbiAgICAgIHRoaXMuI2RlbGF5VGltZW91dElkID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICAjc2NoZWR1bGUoKSB7XG4gICAgaWYgKHRoaXMuI3F1ZXVlLmxlbmd0aCA9PT0gdGhpcy4jc2l6ZSkge1xuICAgICAgdm9pZCB0aGlzLiNmbHVzaCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLiNjbGVhckRlbGF5VGltZW91dCgpO1xuICAgICAgdGhpcy4jZGVsYXlUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHZvaWQgdGhpcy4jZmx1c2goKSwgdGhpcy4jZGVsYXkpO1xuICAgIH1cbiAgfVxuICBhc3luYyAjZmx1c2goKSB7XG4gICAgaWYgKHRoaXMuI3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYWxscyA9IHRoaXMuI3F1ZXVlLnNwbGljZSgwKTtcbiAgICBjb25zdCBpbnB1dHMgPSBjYWxscy5tYXAoKGNhbGwpID0+IGNhbGwuaW5wdXQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy4jY2FsbGJhY2soaW5wdXRzKTtcbiAgICAgIHRoaXMuZXJyb3IgPSBmYWxzZTtcbiAgICAgIGNhbGxzLmZvckVhY2goKGNhbGwsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHM/LltpbmRleF07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgIGNhbGwucmVqZWN0KG5ldyBFcnJvcihcIkNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5LlwiKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbHMubGVuZ3RoICE9PSByZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIGNhbGwucmVqZWN0KFxuICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQ2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBudW1iZXIgb2YgcHJvdmlkZWQgaXRlbXMuIEV4cGVjdGVkICR7Y2FsbHMubGVuZ3RofSwgYnV0IGdvdCAke3Jlc3VsdHMubGVuZ3RofS5gXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGNhbGwucmVqZWN0KHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgdGhpcy5lcnJvciA9IHRydWU7XG4gICAgICBjYWxscy5mb3JFYWNoKChjYWxsKSA9PiB7XG4gICAgICAgIGNhbGwucmVqZWN0KGVycm9yMyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0KGlucHV0KSB7XG4gICAgY29uc3QgZXhpc3RpbmdDYWxsID0gdGhpcy4jcXVldWUuZmluZChcbiAgICAgIChjYWxsMikgPT4gc3RhYmxlU3RyaW5naWZ5KGNhbGwyLmlucHV0KSA9PT0gc3RhYmxlU3RyaW5naWZ5KGlucHV0KVxuICAgICk7XG4gICAgaWYgKGV4aXN0aW5nQ2FsbCkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nQ2FsbC5wcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBjYWxsID0gbmV3IEJhdGNoQ2FsbChpbnB1dCk7XG4gICAgdGhpcy4jcXVldWUucHVzaChjYWxsKTtcbiAgICB0aGlzLiNzY2hlZHVsZSgpO1xuICAgIHJldHVybiBjYWxsLnByb21pc2U7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy4jcXVldWUgPSBbXTtcbiAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgdGhpcy4jY2xlYXJEZWxheVRpbWVvdXQoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2gyKSB7XG4gIGNvbnN0IHNpZ25hbCA9IG5ldyBNdXRhYmxlU2lnbmFsKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICBmdW5jdGlvbiBnZXRDYWNoZUtleShhcmdzKSB7XG4gICAgcmV0dXJuIHN0YWJsZVN0cmluZ2lmeShhcmdzKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUoZW50cnlPckVudHJpZXMpIHtcbiAgICBzaWduYWwubXV0YXRlKChjYWNoZSkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW50cnlPckVudHJpZXMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cnlPckVudHJpZXMpIHtcbiAgICAgICAgICBjYWNoZS5zZXQoZW50cnkua2V5LCBlbnRyeS5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlLnNldChlbnRyeU9yRW50cmllcy5rZXksIGVudHJ5T3JFbnRyaWVzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBpbnZhbGlkYXRlKGlucHV0cykge1xuICAgIHNpZ25hbC5tdXRhdGUoKGNhY2hlKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICAgICAgY2FjaGUuZGVsZXRlKGdldENhY2hlS2V5KGlucHV0KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZW5xdWV1ZShpbnB1dCkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoaW5wdXQpO1xuICAgIGNvbnN0IGNhY2hlID0gc2lnbmFsLmdldCgpO1xuICAgIGlmIChjYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB1cGRhdGUoeyBrZXk6IGNhY2hlS2V5LCBzdGF0ZTogeyBpc0xvYWRpbmc6IHRydWUgfSB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhdGNoMi5nZXQoaW5wdXQpO1xuICAgICAgdXBkYXRlKHsga2V5OiBjYWNoZUtleSwgc3RhdGU6IHsgaXNMb2FkaW5nOiBmYWxzZSwgZGF0YTogcmVzdWx0IH0gfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICBrZXk6IGNhY2hlS2V5LFxuICAgICAgICBzdGF0ZTogeyBpc0xvYWRpbmc6IGZhbHNlLCBlcnJvcjogZXJyb3IzIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXREYXRhKGVudHJpZXMyKSB7XG4gICAgdXBkYXRlKFxuICAgICAgZW50cmllczIubWFwKChlbnRyeSkgPT4gKHtcbiAgICAgICAga2V5OiBnZXRDYWNoZUtleShlbnRyeVswXSksXG4gICAgICAgIHN0YXRlOiB7IGlzTG9hZGluZzogZmFsc2UsIGRhdGE6IGVudHJ5WzFdIH1cbiAgICAgIH0pKVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SXRlbVN0YXRlKGlucHV0KSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShpbnB1dCk7XG4gICAgY29uc3QgY2FjaGUgPSBzaWduYWwuZ2V0KCk7XG4gICAgcmV0dXJuIGNhY2hlLmdldChjYWNoZUtleSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RGF0YShpbnB1dCkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoaW5wdXQpO1xuICAgIGNvbnN0IGNhY2hlID0gc2lnbmFsLmdldCgpO1xuICAgIHJldHVybiBjYWNoZS5nZXQoY2FjaGVLZXkpPy5kYXRhO1xuICB9XG4gIGZ1bmN0aW9uIF9jYWNoZUtleXMoKSB7XG4gICAgY29uc3QgY2FjaGUgPSBzaWduYWwuZ2V0KCk7XG4gICAgcmV0dXJuIFsuLi5jYWNoZS5rZXlzKCldO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3Vic2NyaWJlOiBzaWduYWwuc3Vic2NyaWJlLFxuICAgIGVucXVldWUsXG4gICAgc2V0RGF0YSxcbiAgICBnZXRJdGVtU3RhdGUsXG4gICAgZ2V0RGF0YSxcbiAgICBpbnZhbGlkYXRlLFxuICAgIGJhdGNoOiBiYXRjaDIsXG4gICAgX2NhY2hlS2V5c1xuICB9O1xufVxuXG4vLyBzcmMvbGliL2NodW5rLnRzXG5mdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSkge1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpICs9IHNpemUpIHtcbiAgICBjaHVua3MucHVzaChhcnJheS5zbGljZShpLCBpICsgc2l6ZSkpO1xuICB9XG4gIHJldHVybiBjaHVua3M7XG59XG5cbi8vIHNyYy9saWIvbmFub2lkLnRzXG52YXIgbmFub2lkID0gKHQgPSAyMSkgPT4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSh0KSkucmVkdWNlKFxuICAodDIsIGUpID0+IHQyICs9IChlICY9IDYzKSA8IDM2ID8gZS50b1N0cmluZygzNikgOiBlIDwgNjIgPyAoZSAtIDI2KS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKSA6IGUgPCA2MyA/IFwiX1wiIDogXCItXCIsXG4gIFwiXCJcbik7XG5cbi8vIHNyYy9saWIvY3JlYXRlSWRzLnRzXG52YXIgVEhSRUFEX0lEX1BSRUZJWCA9IFwidGhcIjtcbnZhciBDT01NRU5UX0lEX1BSRUZJWCA9IFwiY21cIjtcbnZhciBDT01NRU5UX0FUVEFDSE1FTlRfSURfUFJFRklYID0gXCJhdFwiO1xudmFyIElOQk9YX05PVElGSUNBVElPTl9JRF9QUkVGSVggPSBcImluXCI7XG5mdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljSWQocHJlZml4KSB7XG4gIHJldHVybiBgJHtwcmVmaXh9XyR7bmFub2lkKCl9YDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRocmVhZElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKFRIUkVBRF9JRF9QUkVGSVgpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKENPTU1FTlRfSURfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRBdHRhY2htZW50SWQoKSB7XG4gIHJldHVybiBjcmVhdGVPcHRpbWlzdGljSWQoQ09NTUVOVF9BVFRBQ0hNRU5UX0lEX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmJveE5vdGlmaWNhdGlvbklkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKElOQk9YX05PVElGSUNBVElPTl9JRF9QUkVGSVgpO1xufVxuXG4vLyBzcmMvbGliL0RlZmF1bHRNYXAudHNcbnZhciBEZWZhdWx0TWFwID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuICAjZGVmYXVsdEZuO1xuICAvKipcbiAgICogSWYgdGhlIGRlZmF1bHQgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciwgaXQgaGFzIHRvIGJlXG4gICAqIHByb3ZpZGVkIGluIGVhY2ggLmdldE9yQ3JlYXRlKCkgY2FsbCBpbmRpdmlkdWFsbHkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0Rm4sIGVudHJpZXMyKSB7XG4gICAgc3VwZXIoZW50cmllczIpO1xuICAgIHRoaXMuI2RlZmF1bHRGbiA9IGRlZmF1bHRGbjtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIGtleSwgb3IgY3JlYXRlcyBpdC5cbiAgICpcbiAgICogRGlmZmVyZW5jZSBmcm9tIG5vcm1hbCBNYXA6IGlmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZFxuICAgKiBvbiB0aGUgZmx5IHVzaW5nIHRoZSBmYWN0b3J5IGZ1bmN0aW9uLCBhbmQgdGhhdCB2YWx1ZSB3aWxsIGdldCByZXR1cm5lZFxuICAgKiBpbnN0ZWFkIG9mIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZ2V0T3JDcmVhdGUoa2V5LCBkZWZhdWx0Rm4pIHtcbiAgICBpZiAoc3VwZXIuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZm4gPSBkZWZhdWx0Rm4gPz8gdGhpcy4jZGVmYXVsdEZuID8/IHJhaXNlKFwiRGVmYXVsdE1hcCB1c2VkIHdpdGhvdXQgYSBmYWN0b3J5IGZ1bmN0aW9uXCIpO1xuICAgICAgY29uc3QgdmFsdWUgPSBmbihrZXkpO1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbGliL29iamVjdFRvUXVlcnkudHNcbnZhciBpZGVudGlmaWVyUmVnZXggPSAvXlthLXpBLVpfXVthLXpBLVowLTlfXSokLztcbmZ1bmN0aW9uIG9iamVjdFRvUXVlcnkob2JqKSB7XG4gIGxldCBmaWx0ZXJMaXN0ID0gW107XG4gIGNvbnN0IGVudHJpZXMyID0gT2JqZWN0LmVudHJpZXMob2JqKTtcbiAgY29uc3Qga2V5VmFsdWVQYWlycyA9IFtdO1xuICBjb25zdCBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gW107XG4gIGNvbnN0IGluZGV4ZWRLZXlzID0gW107XG4gIGVudHJpZXMyLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICghaWRlbnRpZmllclJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IG11c3Qgb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMsIF9cIik7XG4gICAgfVxuICAgIGlmIChpc1NpbXBsZVZhbHVlKHZhbHVlKSkge1xuICAgICAga2V5VmFsdWVQYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgaWYgKGlzU3RhcnRzV2l0aE9wZXJhdG9yKHZhbHVlKSB8fCBpc051bWJlck9wZXJhdG9yKHZhbHVlKSkge1xuICAgICAgICBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ZWRLZXlzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBmaWx0ZXJMaXN0ID0gW1xuICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyhrZXlWYWx1ZVBhaXJzKSxcbiAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3Ioa2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcilcbiAgXTtcbiAgaW5kZXhlZEtleXMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbmVzdGVkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgICBjb25zdCBuS2V5VmFsdWVQYWlycyA9IFtdO1xuICAgIGNvbnN0IG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gW107XG4gICAgbmVzdGVkRW50cmllcy5mb3JFYWNoKChbbmVzdGVkS2V5LCBuZXN0ZWRWYWx1ZV0pID0+IHtcbiAgICAgIGlmIChpc1N0cmluZ0VtcHR5KG5lc3RlZEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NpbXBsZVZhbHVlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgICBuS2V5VmFsdWVQYWlycy5wdXNoKFtmb3JtYXRGaWx0ZXJLZXkoa2V5LCBuZXN0ZWRLZXkpLCBuZXN0ZWRWYWx1ZV0pO1xuICAgICAgfSBlbHNlIGlmIChpc1N0YXJ0c1dpdGhPcGVyYXRvcihuZXN0ZWRWYWx1ZSkgfHwgaXNOdW1iZXJPcGVyYXRvcihuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgbktleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IucHVzaChbXG4gICAgICAgICAgZm9ybWF0RmlsdGVyS2V5KGtleSwgbmVzdGVkS2V5KSxcbiAgICAgICAgICBuZXN0ZWRWYWx1ZVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmaWx0ZXJMaXN0ID0gW1xuICAgICAgLi4uZmlsdGVyTGlzdCxcbiAgICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyhuS2V5VmFsdWVQYWlycyksXG4gICAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IobktleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IpXG4gICAgXTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJMaXN0Lm1hcCgoeyBrZXksIG9wZXJhdG9yLCB2YWx1ZSB9KSA9PiBgJHtrZXl9JHtvcGVyYXRvcn0ke3F1b3RlKHZhbHVlKX1gKS5qb2luKFwiIFwiKTtcbn1cbnZhciBnZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnMgPSAoa2V5VmFsdWVQYWlycykgPT4ge1xuICBjb25zdCBmaWx0ZXJzID0gW107XG4gIGtleVZhbHVlUGFpcnMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgZmlsdGVycy5wdXNoKHtcbiAgICAgIGtleSxcbiAgICAgIG9wZXJhdG9yOiBcIjpcIixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZmlsdGVycztcbn07XG52YXIgZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gKGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IpID0+IHtcbiAgY29uc3QgZmlsdGVycyA9IFtdO1xuICBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChcInN0YXJ0c1dpdGhcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuc3RhcnRzV2l0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZmlsdGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICBvcGVyYXRvcjogXCJeXCIsXG4gICAgICAgIHZhbHVlOiB2YWx1ZS5zdGFydHNXaXRoXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKFwibHRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgb3BlcmF0b3I6IFwiPFwiLFxuICAgICAgICB2YWx1ZTogdmFsdWUubHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoXCJndFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5ndCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZmlsdGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICBvcGVyYXRvcjogXCI+XCIsXG4gICAgICAgIHZhbHVlOiB2YWx1ZS5ndFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChcImd0ZVwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5ndGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgb3BlcmF0b3I6IFwiPj1cIixcbiAgICAgICAgdmFsdWU6IHZhbHVlLmd0ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChcImx0ZVwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5sdGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgb3BlcmF0b3I6IFwiPD1cIixcbiAgICAgICAgdmFsdWU6IHZhbHVlLmx0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZpbHRlcnM7XG59O1xudmFyIGlzU2ltcGxlVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PT0gbnVsbDtcbn07XG52YXIgZm9ybWF0RmlsdGVyS2V5ID0gKGtleSwgbmVzdGVkS2V5KSA9PiB7XG4gIGlmIChuZXN0ZWRLZXkpIHtcbiAgICByZXR1cm4gYCR7a2V5fVske3F1b3RlKG5lc3RlZEtleSl9XWA7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn07XG52YXIgaXNTdHJpbmdFbXB0eSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gIXZhbHVlIHx8IHZhbHVlLnRvU3RyaW5nKCkudHJpbSgpID09PSBcIlwiO1xufTtcbmZ1bmN0aW9uIHF1b3RlKGlucHV0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKHJlc3VsdC5pbmNsdWRlcyhcIidcIikpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiBgJyR7cmVzdWx0LnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJyl9J2A7XG59XG5cbi8vIHNyYy9saWIvdXJsLnRzXG52YXIgUExBQ0VIT0xERVJfQkFTRV9VUkwgPSBcImh0dHBzOi8vbG9jYWxob3N0Ojk5OTlcIjtcbnZhciBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi87XG52YXIgVFJBSUxJTkdfU0xBU0hfVVJMX1JFR0VYID0gL1xcLyg/Oig/OlxcP3wjKS4qKT8kLztcbmZ1bmN0aW9uIHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXJsam9pbihiYXNlVXJsLCBwYXRoLCBwYXJhbXMpIHtcbiAgY29uc3QgdXJsMiA9IG5ldyBVUkwocGF0aCwgYmFzZVVybCk7XG4gIGlmIChwYXJhbXMgIT09IHZvaWQgMCkge1xuICAgIHVybDIuc2VhcmNoID0gKHBhcmFtcyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IHBhcmFtcyA6IHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHVybDIudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHVybChzdHJpbmdzLCAuLi52YWx1ZXMyKSB7XG4gIHJldHVybiBzdHJpbmdzLnJlZHVjZShcbiAgICAocmVzdWx0LCBzdHIsIGkpID0+IHJlc3VsdCArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZXMyW2kgLSAxXSA/PyBcIlwiKSArIHN0clxuICApO1xufVxuZnVuY3Rpb24gc2FuaXRpemVVcmwodXJsMikge1xuICBpZiAodXJsMi5zdGFydHNXaXRoKFwid3d3LlwiKSkge1xuICAgIHVybDIgPSBcImh0dHBzOi8vXCIgKyB1cmwyO1xuICB9XG4gIGlmICh1cmwyID09PSBcIiNcIikge1xuICAgIHJldHVybiB1cmwyO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgaXNBYnNvbHV0ZSA9IEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KHVybDIpO1xuICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwoXG4gICAgICB1cmwyLFxuICAgICAgaXNBYnNvbHV0ZSA/IHZvaWQgMCA6IFBMQUNFSE9MREVSX0JBU0VfVVJMXG4gICAgKTtcbiAgICBpZiAodXJsT2JqZWN0LnByb3RvY29sICE9PSBcImh0dHA6XCIgJiYgdXJsT2JqZWN0LnByb3RvY29sICE9PSBcImh0dHBzOlwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaGFzVHJhaWxpbmdTbGFzaCA9IFRSQUlMSU5HX1NMQVNIX1VSTF9SRUdFWC50ZXN0KHVybDIpO1xuICAgIGNvbnN0IHNhbml0aXplZFVybCA9IChcbiAgICAgIC8vIDEuIE9yaWdpbiwgb25seSBmb3IgYWJzb2x1dGUgVVJMc1xuICAgICAgKGlzQWJzb2x1dGUgPyB1cmxPYmplY3Qub3JpZ2luIDogXCJcIikgKyAvLyAyLiBQYXRobmFtZSwgd2l0aCBhIHRyYWlsaW5nIHNsYXNoIGlmIHRoZSBvcmlnaW5hbCBVUkwgaGFkIG9uZVxuICAgICAgKHVybE9iamVjdC5wYXRobmFtZSA9PT0gXCIvXCIgPyAoXG4gICAgICAgIC8vIDIuYS4gRG9tYWluLW9ubHkgVVJMcywgdGhleSBhbHdheXMgaGF2ZSB0aGVpciBwYXRobmFtZSBzZXQgdG8gXCIvXCJcbiAgICAgICAgaGFzVHJhaWxpbmdTbGFzaCA/IFwiL1wiIDogXCJcIlxuICAgICAgKSA6IChcbiAgICAgICAgLy8gMi5iLiBVUkxzIHdpdGggYSBwYXRoXG4gICAgICAgIGhhc1RyYWlsaW5nU2xhc2ggJiYgIXVybE9iamVjdC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikgPyB1cmxPYmplY3QucGF0aG5hbWUgKyBcIi9cIiA6IHVybE9iamVjdC5wYXRobmFtZVxuICAgICAgKSkgKyAvLyAzLiBTZWFyY2ggcGFyYW1zXG4gICAgICB1cmxPYmplY3Quc2VhcmNoICsgLy8gNC4gSGFzaFxuICAgICAgdXJsT2JqZWN0Lmhhc2hcbiAgICApO1xuICAgIHJldHVybiBzYW5pdGl6ZWRVcmwgIT09IFwiXCIgPyBzYW5pdGl6ZWRVcmwgOiBudWxsO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2VuZXJhdGVVcmwodXJsMiwgcGFyYW1zLCBoYXNoKSB7XG4gIGNvbnN0IGlzQWJzb2x1dGUgPSBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh1cmwyKTtcbiAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwyLCBpc0Fic29sdXRlID8gdm9pZCAwIDogUExBQ0VIT0xERVJfQkFTRV9VUkwpO1xuICBpZiAocGFyYW1zICE9PSB2b2lkIDApIHtcbiAgICBmb3IgKGNvbnN0IFtwYXJhbSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmxPYmplY3Quc2VhcmNoUGFyYW1zLnNldChwYXJhbSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghdXJsT2JqZWN0Lmhhc2ggJiYgaGFzaCAhPT0gdm9pZCAwKSB7XG4gICAgdXJsT2JqZWN0Lmhhc2ggPSBgIyR7aGFzaH1gO1xuICB9XG4gIHJldHVybiBpc0Fic29sdXRlID8gdXJsT2JqZWN0LmhyZWYgOiB1cmxPYmplY3QuaHJlZi5yZXBsYWNlKFBMQUNFSE9MREVSX0JBU0VfVVJMLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzVXJsKHN0cmluZykge1xuICB0cnkge1xuICAgIG5ldyBVUkwoc3RyaW5nKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBzcmMvYXBpLWNsaWVudC50c1xuZnVuY3Rpb24gY3JlYXRlQXBpQ2xpZW50KHtcbiAgYmFzZVVybCxcbiAgYXV0aE1hbmFnZXIsXG4gIGN1cnJlbnRVc2VySWQsXG4gIGZldGNoUG9seWZpbGxcbn0pIHtcbiAgY29uc3QgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50KGJhc2VVcmwsIGZldGNoUG9seWZpbGwpO1xuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzU2luY2Uob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvZGVsdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgc2luY2U6IG9wdGlvbnMuc2luY2UudG9JU09TdHJpbmcoKVxuICAgICAgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGhyZWFkczoge1xuICAgICAgICB1cGRhdGVkOiByZXN1bHQuZGF0YS5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IHJlc3VsdC5kZWxldGVkVGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbylcbiAgICAgIH0sXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgdXBkYXRlZDogcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy5tYXAoY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKSxcbiAgICAgICAgZGVsZXRlZDogcmVzdWx0LmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGVsZXRlSW5mb1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgc3Vic2NyaXB0aW9uczoge1xuICAgICAgICB1cGRhdGVkOiByZXN1bHQuc3Vic2NyaXB0aW9ucy5tYXAoY29udmVydFRvU3Vic2NyaXB0aW9uRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IHJlc3VsdC5kZWxldGVkU3Vic2NyaXB0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvU3Vic2NyaXB0aW9uRGVsZXRlSW5mb1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0KSxcbiAgICAgIHBlcm1pc3Npb25IaW50czogcmVzdWx0Lm1ldGEucGVybWlzc2lvbkhpbnRzXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMpIHtcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKG9wdGlvbnMucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkc2AsXG4gICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgICAgfSksXG4gICAgICAgIHtcbiAgICAgICAgICBjdXJzb3I6IG9wdGlvbnMuY3Vyc29yLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIGxpbWl0OiBQQUdFX1NJWkVcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZHM6IHJlc3VsdC5kYXRhLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGFcbiAgICAgICAgKSxcbiAgICAgICAgc3Vic2NyaXB0aW9uczogcmVzdWx0LnN1YnNjcmlwdGlvbnMubWFwKGNvbnZlcnRUb1N1YnNjcmlwdGlvbkRhdGEpLFxuICAgICAgICBuZXh0Q3Vyc29yOiByZXN1bHQubWV0YS5uZXh0Q3Vyc29yLFxuICAgICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUocmVzdWx0Lm1ldGEucmVxdWVzdGVkQXQpLFxuICAgICAgICBwZXJtaXNzaW9uSGludHM6IHJlc3VsdC5tZXRhLnBlcm1pc3Npb25IaW50c1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBIdHRwRXJyb3IgJiYgZXJyLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGhyZWFkczogW10sXG4gICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBbXSxcbiAgICAgICAgICBzdWJzY3JpcHRpb25zOiBbXSxcbiAgICAgICAgICBuZXh0Q3Vyc29yOiBudWxsLFxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSEFDS1xuICAgICAgICAgIC8vIHJlcXVlc3RlZEF0IG5lZWRzIHRvIGJlIGEgKnNlcnZlciogdGltZXN0YW1wIGhlcmUuIEhvd2V2ZXIsIG9uXG4gICAgICAgICAgLy8gdGhpcyA0MDQgZXJyb3IgcmVzcG9uc2UsIHRoZXJlIGlzIG5vIHN1Y2ggdGltZXN0YW1wLiBTbyBvdXQgb2ZcbiAgICAgICAgICAvLyBwdXJlIG5lY2Vzc2l0eSB3ZSdsbCBmYWxsIGJhY2sgdG8gYSBsb2NhbCB0aW1lc3RhbXAgaW5zdGVhZCAoYW5kXG4gICAgICAgICAgLy8gYWxsb3cgZm9yIGEgcG9zc2libGUgNiBob3VyIGNsb2NrIGRpZmZlcmVuY2UgYmV0d2VlbiBjbGllbnQgYW5kXG4gICAgICAgICAgLy8gc2VydmVyKS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gNiAqIDYwICogNjAgKiAxZTMpLFxuICAgICAgICAgIHBlcm1pc3Npb25IaW50czoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc2VhcmNoQ29tbWVudHMob3B0aW9ucywgcmVxdWVzdE9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzL2NvbW1lbnRzL3NlYXJjaGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICB0ZXh0OiBvcHRpb25zLnF1ZXJ5LnRleHQsXG4gICAgICAgIHF1ZXJ5OiBvYmplY3RUb1F1ZXJ5KHtcbiAgICAgICAgICB0aHJlYWRNZXRhZGF0YTogb3B0aW9ucy5xdWVyeS50aHJlYWRNZXRhZGF0YSxcbiAgICAgICAgICB0aHJlYWRSZXNvbHZlZDogb3B0aW9ucy5xdWVyeS50aHJlYWRSZXNvbHZlZCxcbiAgICAgICAgICBoYXNBdHRhY2htZW50czogb3B0aW9ucy5xdWVyeS5oYXNBdHRhY2htZW50cyxcbiAgICAgICAgICBoYXNNZW50aW9uczogb3B0aW9ucy5xdWVyeS5oYXNNZW50aW9uc1xuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHsgc2lnbmFsOiByZXF1ZXN0T3B0aW9ucz8uc2lnbmFsIH1cbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGhyZWFkKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb21tZW50SWQgPSBvcHRpb25zLmNvbW1lbnRJZCA/PyBjcmVhdGVDb21tZW50SWQoKTtcbiAgICBjb25zdCB0aHJlYWRJZCA9IG9wdGlvbnMudGhyZWFkSWQgPz8gY3JlYXRlVGhyZWFkSWQoKTtcbiAgICBjb25zdCB0aHJlYWQgPSBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBpZDogdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgICAgICBhdHRhY2htZW50SWRzOiBvcHRpb25zLmF0dGFjaG1lbnRJZHNcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGFcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9UaHJlYWREYXRhKHRocmVhZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGhyZWFkKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LmRlbGV0ZShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQucmF3R2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZC13aXRoLW5vdGlmaWNhdGlvbi8ke29wdGlvbnMudGhyZWFkSWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZDogY29udmVydFRvVGhyZWFkRGF0YShqc29uLnRocmVhZCksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uOiBqc29uLmluYm94Tm90aWZpY2F0aW9uID8gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKGpzb24uaW5ib3hOb3RpZmljYXRpb24pIDogdm9pZCAwLFxuICAgICAgICBzdWJzY3JpcHRpb246IGpzb24uc3Vic2NyaXB0aW9uID8gY29udmVydFRvU3Vic2NyaXB0aW9uRGF0YShqc29uLnN1YnNjcmlwdGlvbikgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkOiB2b2lkIDAsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uOiB2b2lkIDAsXG4gICAgICAgIHN1YnNjcmlwdGlvbjogdm9pZCAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aHJlYWQgJHtvcHRpb25zLnRocmVhZElkfS5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlZGl0VGhyZWFkTWV0YWRhdGEob3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L21ldGFkYXRhYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICBvcHRpb25zLm1ldGFkYXRhXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21tZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb21tZW50SWQgPSBvcHRpb25zLmNvbW1lbnRJZCA/PyBjcmVhdGVDb21tZW50SWQoKTtcbiAgICBjb25zdCBjb21tZW50ID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfS9jb21tZW50c2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICBib2R5OiBvcHRpb25zLmJvZHksXG4gICAgICAgIGF0dGFjaG1lbnRJZHM6IG9wdGlvbnMuYXR0YWNobWVudElkc1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRDb21tZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb21tZW50ID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfS9jb21tZW50cy8ke29wdGlvbnMuY29tbWVudElkfWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBib2R5OiBvcHRpb25zLmJvZHksXG4gICAgICAgIGF0dGFjaG1lbnRJZHM6IG9wdGlvbnMuYXR0YWNobWVudElkc1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNvbW1lbnQob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQuZGVsZXRlKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfS9jb21tZW50cy8ke29wdGlvbnMuY29tbWVudElkfWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBhZGRSZWFjdGlvbihvcHRpb25zKSB7XG4gICAgY29uc3QgcmVhY3Rpb24gPSBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L2NvbW1lbnRzLyR7b3B0aW9ucy5jb21tZW50SWR9L3JlYWN0aW9uc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAgeyBlbW9qaTogb3B0aW9ucy5lbW9qaSB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbihyZWFjdGlvbik7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlUmVhY3Rpb24ob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQuZGVsZXRlKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfS9jb21tZW50cy8ke29wdGlvbnMuY29tbWVudElkfS9yZWFjdGlvbnMvJHtvcHRpb25zLmVtb2ppfWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrVGhyZWFkQXNSZXNvbHZlZChvcHRpb25zKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfS9tYXJrLWFzLXJlc29sdmVkYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtUaHJlYWRBc1VucmVzb2x2ZWQob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vbWFyay1hcy11bnJlc29sdmVkYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN1YnNjcmliZVRvVGhyZWFkKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L3N1YnNjcmliZWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvU3Vic2NyaXB0aW9uRGF0YShzdWJzY3JpcHRpb24pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVuc3Vic2NyaWJlRnJvbVRocmVhZChvcHRpb25zKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfS91bnN1YnNjcmliZWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1cGxvYWRBdHRhY2htZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCByb29tSWQgPSBvcHRpb25zLnJvb21JZDtcbiAgICBjb25zdCBhYm9ydFNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgIGNvbnN0IGF0dGFjaG1lbnQgPSBvcHRpb25zLmF0dGFjaG1lbnQ7XG4gICAgY29uc3QgYWJvcnRFcnJvciA9IGFib3J0U2lnbmFsID8gbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgIGBVcGxvYWQgb2YgYXR0YWNobWVudCAke29wdGlvbnMuYXR0YWNobWVudC5pZH0gd2FzIGFib3J0ZWQuYCxcbiAgICAgIFwiQWJvcnRFcnJvclwiXG4gICAgKSA6IHZvaWQgMDtcbiAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IGFib3J0RXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVJldHJ5RXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgYWJvcnRFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBIdHRwRXJyb3IgJiYgZXJyLnN0YXR1cyA9PT0gNDEzKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IEFUVEFDSE1FTlRfUEFSVF9TSVpFID0gNSAqIDEwMjQgKiAxMDI0O1xuICAgIGNvbnN0IFJFVFJZX0FUVEVNUFRTID0gMTA7XG4gICAgY29uc3QgUkVUUllfREVMQVlTID0gW1xuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzXG4gICAgXTtcbiAgICBmdW5jdGlvbiBzcGxpdEZpbGVJbnRvUGFydHMoZmlsZSkge1xuICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBmaWxlLnNpemUpIHtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBBVFRBQ0hNRU5UX1BBUlRfU0laRSwgZmlsZS5zaXplKTtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgcGFydE51bWJlcjogcGFydHMubGVuZ3RoICsgMSxcbiAgICAgICAgICBwYXJ0OiBmaWxlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgaWYgKGF0dGFjaG1lbnQuc2l6ZSA8PSBBVFRBQ0hNRU5UX1BBUlRfU0laRSkge1xuICAgICAgcmV0dXJuIGF1dG9SZXRyeShcbiAgICAgICAgYXN5bmMgKCkgPT4gaHR0cENsaWVudC5wdXRCbG9iKFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS91cGxvYWQvJHtlbmNvZGVVUklDb21wb25lbnQoYXR0YWNobWVudC5uYW1lKX1gLFxuICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICByb29tSWRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBhdHRhY2htZW50LmZpbGUsXG4gICAgICAgICAgeyBmaWxlU2l6ZTogYXR0YWNobWVudC5zaXplIH0sXG4gICAgICAgICAgeyBzaWduYWw6IGFib3J0U2lnbmFsIH1cbiAgICAgICAgKSxcbiAgICAgICAgUkVUUllfQVRURU1QVFMsXG4gICAgICAgIFJFVFJZX0RFTEFZUyxcbiAgICAgICAgaGFuZGxlUmV0cnlFcnJvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHVwbG9hZElkO1xuICAgICAgY29uc3QgdXBsb2FkZWRQYXJ0cyA9IFtdO1xuICAgICAgY29uc3QgY3JlYXRlTXVsdGlQYXJ0VXBsb2FkID0gYXdhaXQgYXV0b1JldHJ5KFxuICAgICAgICBhc3luYyAoKSA9PiBodHRwQ2xpZW50LnBvc3QoXG4gICAgICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7cm9vbUlkfS9hdHRhY2htZW50cy8ke2F0dGFjaG1lbnQuaWR9L211bHRpcGFydC8ke2VuY29kZVVSSUNvbXBvbmVudChhdHRhY2htZW50Lm5hbWUpfWAsXG4gICAgICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgICAgIHJvb21JZFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICB7IHNpZ25hbDogYWJvcnRTaWduYWwgfSxcbiAgICAgICAgICB7IGZpbGVTaXplOiBhdHRhY2htZW50LnNpemUgfVxuICAgICAgICApLFxuICAgICAgICBSRVRSWV9BVFRFTVBUUyxcbiAgICAgICAgUkVUUllfREVMQVlTLFxuICAgICAgICBoYW5kbGVSZXRyeUVycm9yXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdXBsb2FkSWQgPSBjcmVhdGVNdWx0aVBhcnRVcGxvYWQudXBsb2FkSWQ7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gc3BsaXRGaWxlSW50b1BhcnRzKGF0dGFjaG1lbnQuZmlsZSk7XG4gICAgICAgIGlmIChhYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgIHRocm93IGFib3J0RXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmF0Y2hlcyA9IGNodW5rKHBhcnRzLCA1KTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0czIgb2YgYmF0Y2hlcykge1xuICAgICAgICAgIGNvbnN0IHVwbG9hZGVkUGFydHNQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3QgeyBwYXJ0LCBwYXJ0TnVtYmVyIH0gb2YgcGFydHMyKSB7XG4gICAgICAgICAgICB1cGxvYWRlZFBhcnRzUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgYXV0b1JldHJ5KFxuICAgICAgICAgICAgICAgIGFzeW5jICgpID0+IGh0dHBDbGllbnQucHV0QmxvYihcbiAgICAgICAgICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS9tdWx0aXBhcnQvJHtjcmVhdGVNdWx0aVBhcnRVcGxvYWQudXBsb2FkSWR9LyR7U3RyaW5nKHBhcnROdW1iZXIpfWAsXG4gICAgICAgICAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICAgICAgICAgIHJvb21JZFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgeyBzaWduYWw6IGFib3J0U2lnbmFsIH1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJFVFJZX0FUVEVNUFRTLFxuICAgICAgICAgICAgICAgIFJFVFJZX0RFTEFZUyxcbiAgICAgICAgICAgICAgICBoYW5kbGVSZXRyeUVycm9yXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwbG9hZGVkUGFydHMucHVzaCguLi5hd2FpdCBQcm9taXNlLmFsbCh1cGxvYWRlZFBhcnRzUHJvbWlzZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBhYm9ydEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvcnRlZFVwbG9hZGVkUGFydHMgPSB1cGxvYWRlZFBhcnRzLnNvcnQoXG4gICAgICAgICAgKGEsIGIpID0+IGEucGFydE51bWJlciAtIGIucGFydE51bWJlclxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gaHR0cENsaWVudC5wb3N0KFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS9tdWx0aXBhcnQvJHt1cGxvYWRJZH0vY29tcGxldGVgLFxuICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICByb29tSWRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IHBhcnRzOiBzb3J0ZWRVcGxvYWRlZFBhcnRzIH0sXG4gICAgICAgICAgeyBzaWduYWw6IGFib3J0U2lnbmFsIH1cbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgICBpZiAodXBsb2FkSWQgJiYgZXJyb3IzPy5uYW1lICYmIChlcnJvcjMubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgZXJyb3IzLm5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGh0dHBDbGllbnQucmF3RGVsZXRlKFxuICAgICAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7dXBsb2FkSWR9YCxcbiAgICAgICAgICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICAgICAgcm9vbUlkXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yNCkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGF0dGFjaG1lbnRVcmxzQmF0Y2hTdG9yZXNCeVJvb20gPSBuZXcgRGVmYXVsdE1hcCgocm9vbUlkKSA9PiB7XG4gICAgY29uc3QgYmF0Y2gyID0gbmV3IEJhdGNoKFxuICAgICAgYXN5bmMgKGJhdGNoZWRBdHRhY2htZW50SWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGF0dGFjaG1lbnRJZHMgPSBiYXRjaGVkQXR0YWNobWVudElkcy5mbGF0KCk7XG4gICAgICAgIGNvbnN0IHsgdXJscyB9ID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvcHJlc2lnbmVkLXVybHNgLFxuICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICByb29tSWRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IGF0dGFjaG1lbnRJZHMgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdXJscy5tYXAoXG4gICAgICAgICAgKHVybDIpID0+IHVybDIgPz8gbmV3IEVycm9yKFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhpcyBhdHRhY2htZW50J3MgVVJMXCIpXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgeyBkZWxheTogNTAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2gyKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGdldE9yQ3JlYXRlQXR0YWNobWVudFVybHNTdG9yZShyb29tSWQpIHtcbiAgICByZXR1cm4gYXR0YWNobWVudFVybHNCYXRjaFN0b3Jlc0J5Um9vbS5nZXRPckNyZWF0ZShyb29tSWQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEF0dGFjaG1lbnRVcmwob3B0aW9ucykge1xuICAgIGNvbnN0IGJhdGNoMiA9IGdldE9yQ3JlYXRlQXR0YWNobWVudFVybHNTdG9yZShvcHRpb25zLnJvb21JZCkuYmF0Y2g7XG4gICAgcmV0dXJuIGJhdGNoMi5nZXQob3B0aW9ucy5hdHRhY2htZW50SWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZENoYXRBdHRhY2htZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoYXRJZCwgYXR0YWNobWVudCwgc2lnbmFsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHVzZXJJZCA9IGN1cnJlbnRVc2VySWQuZ2V0KCk7XG4gICAgaWYgKHVzZXJJZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRhY2htZW50IHVwbG9hZCByZXF1aXJlcyBhbiBhdXRoZW50aWNhdGVkIHVzZXIuXCIpO1xuICAgIH1cbiAgICBjb25zdCBBVFRBQ0hNRU5UX1BBUlRfU0laRSA9IDUgKiAxMDI0ICogMTAyNDtcbiAgICBpZiAob3B0aW9ucy5hdHRhY2htZW50LmZpbGUuc2l6ZSA8PSBBVFRBQ0hNRU5UX1BBUlRfU0laRSkge1xuICAgICAgYXdhaXQgaHR0cENsaWVudC5wdXRCbG9iKFxuICAgICAgICB1cmxgL3YyL2MvY2hhdHMvJHtjaGF0SWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vdXBsb2FkLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGF0dGFjaG1lbnQuZmlsZS5uYW1lKX1gLFxuICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICAgIGF0dGFjaG1lbnQuZmlsZSxcbiAgICAgICAgeyBmaWxlU2l6ZTogYXR0YWNobWVudC5maWxlLnNpemUgfSxcbiAgICAgICAgeyBzaWduYWwgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXVsdGlwYXJ0VXBsb2FkID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgICB1cmxgL3YyL2MvY2hhdHMvJHtjaGF0SWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7ZW5jb2RlVVJJQ29tcG9uZW50KGF0dGFjaG1lbnQuZmlsZS5uYW1lKX1gLFxuICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgeyBzaWduYWwgfSxcbiAgICAgICAgeyBmaWxlU2l6ZTogYXR0YWNobWVudC5maWxlLnNpemUgfVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVwbG9hZGVkUGFydHMgPSBbXTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgd2hpbGUgKHN0YXJ0IDwgYXR0YWNobWVudC5maWxlLnNpemUpIHtcbiAgICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIHN0YXJ0ICsgQVRUQUNITUVOVF9QQVJUX1NJWkUsXG4gICAgICAgICAgICBhdHRhY2htZW50LmZpbGUuc2l6ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICBudW1iZXI6IHBhcnRzLmxlbmd0aCArIDEsXG4gICAgICAgICAgICBwYXJ0OiBhdHRhY2htZW50LmZpbGUuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICB1cGxvYWRlZFBhcnRzLnB1c2goXG4gICAgICAgICAgLi4uYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBwYXJ0cy5tYXAoYXN5bmMgKHsgbnVtYmVyLCBwYXJ0IH0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGh0dHBDbGllbnQucHV0QmxvYihcbiAgICAgICAgICAgICAgICB1cmxgL3YyL2MvY2hhdHMvJHtjaGF0SWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7bXVsdGlwYXJ0VXBsb2FkLnVwbG9hZElkfS8ke1N0cmluZyhudW1iZXIpfWAsXG4gICAgICAgICAgICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgIHsgc2lnbmFsIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICAgICAgdXJsYC92Mi9jL2NoYXRzLyR7Y2hhdElkfS9hdHRhY2htZW50cy8ke2F0dGFjaG1lbnQuaWR9L211bHRpcGFydC8ke211bHRpcGFydFVwbG9hZC51cGxvYWRJZH0vY29tcGxldGVgLFxuICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KSxcbiAgICAgICAgICB7IHBhcnRzOiB1cGxvYWRlZFBhcnRzLnNvcnQoKGEsIGIpID0+IGEubnVtYmVyIC0gYi5udW1iZXIpIH0sXG4gICAgICAgICAgeyBzaWduYWwgfVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgaHR0cENsaWVudC5kZWxldGUoXG4gICAgICAgICAgICB1cmxgL3YyL2MvY2hhdHMvJHtjaGF0SWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7bXVsdGlwYXJ0VXBsb2FkLnVwbG9hZElkfWAsXG4gICAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBhdHRhY2htZW50VXJsc0JhdGNoU3RvcmVzQnlDaGF0ID0gbmV3IERlZmF1bHRNYXAoKGNoYXRJZCkgPT4ge1xuICAgIGNvbnN0IGJhdGNoMiA9IG5ldyBCYXRjaChcbiAgICAgIGFzeW5jIChiYXRjaGVkQXR0YWNobWVudElkcykgPT4ge1xuICAgICAgICBjb25zdCBhdHRhY2htZW50SWRzID0gYmF0Y2hlZEF0dGFjaG1lbnRJZHMuZmxhdCgpO1xuICAgICAgICBjb25zdCB7IHVybHMgfSA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgICAgICB1cmxgL3YyL2MvY2hhdHMvJHtjaGF0SWR9L2F0dGFjaG1lbnRzL3ByZXNpZ25lZC11cmxzYCxcbiAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyBhdHRhY2htZW50SWRzIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHVybHMubWFwKFxuICAgICAgICAgICh1cmwyKSA9PiB1cmwyID8/IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoaXMgYXR0YWNobWVudCdzIFVSTFwiKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHsgZGVsYXk6IDUwIH1cbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVCYXRjaFN0b3JlKGJhdGNoMik7XG4gIH0pO1xuICBmdW5jdGlvbiBnZXRPckNyZWF0ZUNoYXRBdHRhY2htZW50VXJsc1N0b3JlKGNoYXRJZCkge1xuICAgIHJldHVybiBhdHRhY2htZW50VXJsc0JhdGNoU3RvcmVzQnlDaGF0LmdldE9yQ3JlYXRlKGNoYXRJZCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2hhdEF0dGFjaG1lbnRVcmwob3B0aW9ucykge1xuICAgIGNvbnN0IGJhdGNoMiA9IGdldE9yQ3JlYXRlQ2hhdEF0dGFjaG1lbnRVcmxzU3RvcmUob3B0aW9ucy5jaGF0SWQpLmJhdGNoO1xuICAgIHJldHVybiBiYXRjaDIuZ2V0KG9wdGlvbnMuYXR0YWNobWVudElkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25TZXR0aW5ncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3N1YnNjcmlwdGlvbi1zZXR0aW5nc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAgdm9pZCAwLFxuICAgICAge1xuICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1cGRhdGVTdWJzY3JpcHRpb25TZXR0aW5ncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS9zdWJzY3JpcHRpb24tc2V0dGluZ3NgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIG9wdGlvbnMuc2V0dGluZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IG1hcmtBc1JlYWRCYXRjaGVzQnlSb29tID0gbmV3IERlZmF1bHRNYXAoXG4gICAgKHJvb21JZCkgPT4gbmV3IEJhdGNoKFxuICAgICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbklkcyA9IGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcy5mbGF0KCk7XG4gICAgICAgIGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZGAsXG4gICAgICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgICAgIHJvb21JZFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgaW5ib3hOb3RpZmljYXRpb25JZHMgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgICB9LFxuICAgICAgeyBkZWxheTogNTAgfVxuICAgIClcbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya1Jvb21JbmJveE5vdGlmaWNhdGlvbkFzUmVhZChvcHRpb25zKSB7XG4gICAgY29uc3QgYmF0Y2gyID0gbWFya0FzUmVhZEJhdGNoZXNCeVJvb20uZ2V0T3JDcmVhdGUob3B0aW9ucy5yb29tSWQpO1xuICAgIHJldHVybiBiYXRjaDIuZ2V0KG9wdGlvbnMuaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGV4dE1lbnRpb24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLm1lbnRpb24ua2luZCAhPT0gXCJ1c2VyXCIgJiYgb3B0aW9ucy5tZW50aW9uLmtpbmQgIT09IFwiZ3JvdXBcIikge1xuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKG9wdGlvbnMubWVudGlvbiwgXCJVbmV4cGVjdGVkIG1lbnRpb24ga2luZFwiKTtcbiAgICB9XG4gICAgYXdhaXQgaHR0cENsaWVudC5yYXdQb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RleHQtbWVudGlvbnNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgdXNlcklkOiBvcHRpb25zLm1lbnRpb24ua2luZCA9PT0gXCJ1c2VyXCIgPyBvcHRpb25zLm1lbnRpb24uaWQgOiB2b2lkIDAsXG4gICAgICAgIGdyb3VwSWQ6IG9wdGlvbnMubWVudGlvbi5raW5kID09PSBcImdyb3VwXCIgPyBvcHRpb25zLm1lbnRpb24uaWQgOiB2b2lkIDAsXG4gICAgICAgIHVzZXJJZHM6IG9wdGlvbnMubWVudGlvbi5raW5kID09PSBcImdyb3VwXCIgPyBvcHRpb25zLm1lbnRpb24udXNlcklkcyA6IHZvaWQgMCxcbiAgICAgICAgbWVudGlvbklkOiBvcHRpb25zLm1lbnRpb25JZFxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGV4dE1lbnRpb24ob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucmF3RGVsZXRlKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RleHQtbWVudGlvbnMvJHtvcHRpb25zLm1lbnRpb25JZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGV4dFZlcnNpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnJhd0dldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS95LXZlcnNpb24vJHtvcHRpb25zLnZlcnNpb25JZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGV4dFZlcnNpb24ob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucmF3UG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS92ZXJzaW9uYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlcG9ydFRleHRFZGl0b3Iob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucmF3UG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90ZXh0LW1ldGFkYXRhYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcbiAgICAgICAgcm9vdEtleTogb3B0aW9ucy5yb290S2V5XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBleGVjdXRlQ29udGV4dHVhbFByb21wdChvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L2FpL2NvbnRleHR1YWwtcHJvbXB0YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcInJvb206cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgcHJvbXB0OiBvcHRpb25zLnByb21wdCxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIGJlZm9yZVNlbGVjdGlvbjogb3B0aW9ucy5jb250ZXh0LmJlZm9yZVNlbGVjdGlvbixcbiAgICAgICAgICBzZWxlY3Rpb246IG9wdGlvbnMuY29udGV4dC5zZWxlY3Rpb24sXG4gICAgICAgICAgYWZ0ZXJTZWxlY3Rpb246IG9wdGlvbnMuY29udGV4dC5hZnRlclNlbGVjdGlvblxuICAgICAgICB9LFxuICAgICAgICBwcmV2aW91czogb3B0aW9ucy5wcmV2aW91c1xuICAgICAgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICBpZiAoIXJlc3VsdCB8fCByZXN1bHQuY29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNvbnRlbnQgcmV0dXJuZWQgZnJvbSBzZXJ2ZXJcIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuY29udGVudFswXS50ZXh0O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3ZlcnNpb25zYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uczogcmVzdWx0LnZlcnNpb25zLm1hcCgoeyBjcmVhdGVkQXQsIC4uLnZlcnNpb24gfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoY3JlYXRlZEF0KSxcbiAgICAgICAgICAuLi52ZXJzaW9uXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShyZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnNTaW5jZShvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdmVyc2lvbnMvZGVsdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHsgc2luY2U6IG9wdGlvbnMuc2luY2UudG9JU09TdHJpbmcoKSB9LFxuICAgICAgeyBzaWduYWw6IG9wdGlvbnMuc2lnbmFsIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uczogcmVzdWx0LnZlcnNpb25zLm1hcCgoeyBjcmVhdGVkQXQsIC4uLnZlcnNpb24gfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoY3JlYXRlZEF0KSxcbiAgICAgICAgICAuLi52ZXJzaW9uXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShyZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0b3JhZ2Uob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQucmF3R2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3N0b3JhZ2VgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwicm9vbTpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzZW5kTWVzc2FnZXNPdmVySFRUUChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQucmF3UG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS9zZW5kLW1lc3NhZ2VgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwicm9vbTpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBub25jZTogb3B0aW9ucy5ub25jZSxcbiAgICAgICAgbWVzc2FnZXM6IG9wdGlvbnMubWVzc2FnZXNcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEluYm94Tm90aWZpY2F0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChvcHRpb25zPy5xdWVyeSkge1xuICAgICAgcXVlcnkgPSBvYmplY3RUb1F1ZXJ5KG9wdGlvbnMucXVlcnkpO1xuICAgIH1cbiAgICBjb25zdCBqc29uID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9uc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7XG4gICAgICAgIGN1cnNvcjogb3B0aW9ucz8uY3Vyc29yLFxuICAgICAgICBsaW1pdDogUEFHRV9TSVpFLFxuICAgICAgICBxdWVyeVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgZ3JvdXBzID0ganNvbi5ncm91cHMubWFwKGNvbnZlcnRUb0dyb3VwRGF0YSk7XG4gICAgZ3JvdXBzU3RvcmUuc2V0RGF0YShncm91cHMubWFwKChncm91cCkgPT4gW2dyb3VwLmlkLCBncm91cF0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YVxuICAgICAgKSxcbiAgICAgIHRocmVhZHM6IGpzb24udGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICBzdWJzY3JpcHRpb25zOiBqc29uLnN1YnNjcmlwdGlvbnMubWFwKGNvbnZlcnRUb1N1YnNjcmlwdGlvbkRhdGEpLFxuICAgICAgbmV4dEN1cnNvcjoganNvbi5tZXRhLm5leHRDdXJzb3IsXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0SW5ib3hOb3RpZmljYXRpb25zU2luY2Uob3B0aW9ucykge1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAob3B0aW9ucz8ucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnMvZGVsdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAgeyBzaW5jZTogb3B0aW9ucy5zaW5jZS50b0lTT1N0cmluZygpLCBxdWVyeSB9LFxuICAgICAgeyBzaWduYWw6IG9wdGlvbnMuc2lnbmFsIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgdXBkYXRlZDoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB0aHJlYWRzOiB7XG4gICAgICAgIHVwZGF0ZWQ6IGpzb24udGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZFRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8pXG4gICAgICB9LFxuICAgICAgc3Vic2NyaXB0aW9uczoge1xuICAgICAgICB1cGRhdGVkOiBqc29uLnN1YnNjcmlwdGlvbnMubWFwKGNvbnZlcnRUb1N1YnNjcmlwdGlvbkRhdGEpLFxuICAgICAgICBkZWxldGVkOiBqc29uLmRlbGV0ZWRTdWJzY3JpcHRpb25zLm1hcChjb252ZXJ0VG9TdWJzY3JpcHRpb25EZWxldGVJbmZvKVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudChvcHRpb25zKSB7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChvcHRpb25zPy5xdWVyeSkge1xuICAgICAgcXVlcnkgPSBvYmplY3RUb1F1ZXJ5KG9wdGlvbnMucXVlcnkpO1xuICAgIH1cbiAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zL2NvdW50YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KSxcbiAgICAgIHsgcXVlcnkgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7XG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWRzOiBcImFsbFwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7XG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWRzXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBjb25zdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZCA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzKSA9PiB7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbklkcyA9IGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcy5mbGF0KCk7XG4gICAgICBhd2FpdCBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKTtcbiAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbklkcztcbiAgICB9LFxuICAgIHsgZGVsYXk6IDUwIH1cbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZC5nZXQoaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKCkge1xuICAgIGF3YWl0IGh0dHBDbGllbnQuZGVsZXRlKFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5kZWxldGUoXG4gICAgICB1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy8ke2luYm94Tm90aWZpY2F0aW9uSWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3Mob3B0aW9ucykge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9ub3RpZmljYXRpb24tc2V0dGluZ3NgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAgdm9pZCAwLFxuICAgICAgeyBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KSxcbiAgICAgIHNldHRpbmdzXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWwob3B0aW9ucykge1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAob3B0aW9ucz8ucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3RocmVhZHNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAge1xuICAgICAgICBjdXJzb3I6IG9wdGlvbnM/LmN1cnNvcixcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGxpbWl0OiBQQUdFX1NJWkVcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB0aHJlYWRzOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YVxuICAgICAgKSxcbiAgICAgIHN1YnNjcmlwdGlvbnM6IGpzb24uc3Vic2NyaXB0aW9ucy5tYXAoY29udmVydFRvU3Vic2NyaXB0aW9uRGF0YSksXG4gICAgICBuZXh0Q3Vyc29yOiBqc29uLm1ldGEubmV4dEN1cnNvcixcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpLFxuICAgICAgcGVybWlzc2lvbkhpbnRzOiBqc29uLm1ldGEucGVybWlzc2lvbkhpbnRzXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVc2VyVGhyZWFkc1NpbmNlX2V4cGVyaW1lbnRhbChvcHRpb25zKSB7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3RocmVhZHMvZGVsdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAgeyBzaW5jZTogb3B0aW9ucy5zaW5jZS50b0lTT1N0cmluZygpIH0sXG4gICAgICB7IHNpZ25hbDogb3B0aW9ucy5zaWduYWwgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgdXBkYXRlZDoganNvbi50aHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgICAgZGVsZXRlZDoganNvbi5kZWxldGVkVGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbylcbiAgICAgIH0sXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgdXBkYXRlZDoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpcHRpb25zOiB7XG4gICAgICAgIHVwZGF0ZWQ6IGpzb24uc3Vic2NyaXB0aW9ucy5tYXAoY29udmVydFRvU3Vic2NyaXB0aW9uRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZFN1YnNjcmlwdGlvbnMubWFwKGNvbnZlcnRUb1N1YnNjcmlwdGlvbkRlbGV0ZUluZm8pXG4gICAgICB9LFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdCksXG4gICAgICBwZXJtaXNzaW9uSGludHM6IGpzb24ubWV0YS5wZXJtaXNzaW9uSGludHNcbiAgICB9O1xuICB9XG4gIGNvbnN0IGJhdGNoZWRHZXRHcm91cHMgPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRHcm91cElkcykgPT4ge1xuICAgICAgY29uc3QgZ3JvdXBJZHMgPSBiYXRjaGVkR3JvdXBJZHMuZmxhdCgpO1xuICAgICAgY29uc3QgeyBncm91cHM6IHBsYWluR3JvdXBzIH0gPSBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICAgIHVybGAvdjIvYy9ncm91cHMvZmluZGAsXG4gICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiXG4gICAgICAgIH0pLFxuICAgICAgICB7IGdyb3VwSWRzIH1cbiAgICAgICk7XG4gICAgICBjb25zdCBncm91cHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCBncm91cCBvZiBwbGFpbkdyb3Vwcykge1xuICAgICAgICBncm91cHMuc2V0KGdyb3VwLmlkLCBjb252ZXJ0VG9Hcm91cERhdGEoZ3JvdXApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cElkcy5tYXAoKGdyb3VwSWQpID0+IGdyb3Vwcy5nZXQoZ3JvdXBJZCkpO1xuICAgIH0sXG4gICAgeyBkZWxheTogNTAgfVxuICApO1xuICBjb25zdCBncm91cHNTdG9yZSA9IGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2hlZEdldEdyb3Vwcyk7XG4gIGZ1bmN0aW9uIGdldEdyb3VwKGdyb3VwSWQpIHtcbiAgICByZXR1cm4gYmF0Y2hlZEdldEdyb3Vwcy5nZXQoZ3JvdXBJZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsTWV0YWRhdGEoX3VybCkge1xuICAgIGNvbnN0IHsgbWV0YWRhdGEgfSA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3VybHMvbWV0YWRhdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAgeyB1cmw6IF91cmwgfVxuICAgICk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9XG4gIHJldHVybiB7XG4gICAgLy8gUm9vbSB0aHJlYWRzXG4gICAgZ2V0VGhyZWFkcyxcbiAgICBnZXRUaHJlYWRzU2luY2UsXG4gICAgc2VhcmNoQ29tbWVudHMsXG4gICAgY3JlYXRlVGhyZWFkLFxuICAgIGdldFRocmVhZCxcbiAgICBkZWxldGVUaHJlYWQsXG4gICAgZWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIGNyZWF0ZUNvbW1lbnQsXG4gICAgZWRpdENvbW1lbnQsXG4gICAgZGVsZXRlQ29tbWVudCxcbiAgICBhZGRSZWFjdGlvbixcbiAgICByZW1vdmVSZWFjdGlvbixcbiAgICBtYXJrVGhyZWFkQXNSZXNvbHZlZCxcbiAgICBtYXJrVGhyZWFkQXNVbnJlc29sdmVkLFxuICAgIHN1YnNjcmliZVRvVGhyZWFkLFxuICAgIHVuc3Vic2NyaWJlRnJvbVRocmVhZCxcbiAgICBtYXJrUm9vbUluYm94Tm90aWZpY2F0aW9uQXNSZWFkLFxuICAgIC8vIFJvb20gc3Vic2NyaXB0aW9uIHNldHRpbmdzXG4gICAgZ2V0U3Vic2NyaXB0aW9uU2V0dGluZ3MsXG4gICAgdXBkYXRlU3Vic2NyaXB0aW9uU2V0dGluZ3MsXG4gICAgLy8gUm9vbSB0ZXh0IGVkaXRvclxuICAgIGNyZWF0ZVRleHRNZW50aW9uLFxuICAgIGRlbGV0ZVRleHRNZW50aW9uLFxuICAgIGdldFRleHRWZXJzaW9uLFxuICAgIGNyZWF0ZVRleHRWZXJzaW9uLFxuICAgIHJlcG9ydFRleHRFZGl0b3IsXG4gICAgbGlzdFRleHRWZXJzaW9ucyxcbiAgICBsaXN0VGV4dFZlcnNpb25zU2luY2UsXG4gICAgLy8gUm9vbSBhdHRhY2htZW50c1xuICAgIGdldEF0dGFjaG1lbnRVcmwsXG4gICAgdXBsb2FkQXR0YWNobWVudCxcbiAgICBnZXRPckNyZWF0ZUF0dGFjaG1lbnRVcmxzU3RvcmUsXG4gICAgLy8gVXNlciBhdHRhY2htZW50c1xuICAgIHVwbG9hZENoYXRBdHRhY2htZW50LFxuICAgIGdldE9yQ3JlYXRlQ2hhdEF0dGFjaG1lbnRVcmxzU3RvcmUsXG4gICAgZ2V0Q2hhdEF0dGFjaG1lbnRVcmwsXG4gICAgLy8gUm9vbSBzdG9yYWdlXG4gICAgc3RyZWFtU3RvcmFnZSxcbiAgICBzZW5kTWVzc2FnZXNPdmVySFRUUCxcbiAgICAvLyBOb3RpZmljYXRpb25zXG4gICAgZ2V0SW5ib3hOb3RpZmljYXRpb25zLFxuICAgIGdldEluYm94Tm90aWZpY2F0aW9uc1NpbmNlLFxuICAgIGdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICAgIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQsXG4gICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkLFxuICAgIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBkZWxldGVJbmJveE5vdGlmaWNhdGlvbixcbiAgICBnZXROb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAvLyBVc2VyIHRocmVhZHNcbiAgICBnZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWwsXG4gICAgZ2V0VXNlclRocmVhZHNTaW5jZV9leHBlcmltZW50YWwsXG4gICAgLy8gR3JvdXBzXG4gICAgZ3JvdXBzU3RvcmUsXG4gICAgZ2V0R3JvdXAsXG4gICAgLy8gQUlcbiAgICBleGVjdXRlQ29udGV4dHVhbFByb21wdCxcbiAgICAvLyBVUkwgbWV0YWRhdGFcbiAgICBnZXRVcmxNZXRhZGF0YVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QmVhcmVyVG9rZW5Gcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSkge1xuICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICByZXR1cm4gYXV0aFZhbHVlLnB1YmxpY0FwaUtleTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXV0aFZhbHVlLnRva2VuLnJhdztcbiAgfVxufVxudmFyIEh0dHBDbGllbnQgPSBjbGFzcyB7XG4gICNiYXNlVXJsO1xuICAjZmV0Y2hQb2x5ZmlsbDtcbiAgY29uc3RydWN0b3IoYmFzZVVybCwgZmV0Y2hQb2x5ZmlsbCkge1xuICAgIHRoaXMuI2Jhc2VVcmwgPSBiYXNlVXJsO1xuICAgIHRoaXMuI2ZldGNoUG9seWZpbGwgPSBmZXRjaFBvbHlmaWxsO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQdWJsaWMgbWV0aG9kc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYW5kIG1ha2VzIHRoZSBIVFRQIHJlcXVlc3QsIGJ1dCBkb2VzIG5vdCBoYW5kbGUgdGhlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBUaGlzIGlzIHdoYXQgLnJhd0ZldGNoKCkgZG9lczogICAg8J+RiCBUaGlzIG1ldGhvZCFcbiAgICogICAxLiBTZXQgQ29udGVudC1UeXBlIGhlYWRlclxuICAgKiAgIDIuIFNldCBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgKiAgIDMuIENhbGwgdGhlIGNhbGxiYWNrIHRvIG9idGFpbiB0aGUgYGF1dGhWYWx1ZWAgdG8gdXNlIGluIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgKlxuICAgKiBUaGlzIGlzIHdoYXQgLmZldGNoKCkgZG9lcyBPTiBUT1Agb2YgdGhhdDpcbiAgICogICA0LiBQYXJzZSByZXNwb25zZSBib2R5IGFzIEpzb25cbiAgICogICA1LiAuLi5idXQgc2lsZW50bHkgcmV0dXJuIGB7fWAgaWYgdGhhdCBwYXJzaW5nIGZhaWxzXG4gICAqICAgNi4gVGhyb3cgSHR0cEVycm9yIGlmIHJlc3BvbnNlIGlzIGFuIGVycm9yXG4gICAqL1xuICBhc3luYyAjcmF3RmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgaWYgKCFlbmRwb2ludC5zdGFydHNXaXRoKFwiL3YyL2MvXCIpKSB7XG4gICAgICByYWlzZShcIlRoaXMgY2xpZW50IGNhbiBvbmx5IGJlIHVzZWQgdG8gbWFrZSAvdjIvYy8qIHJlcXVlc3RzXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwyID0gdXJsam9pbih0aGlzLiNiYXNlVXJsLCBlbmRwb2ludCwgcGFyYW1zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmV0Y2hQb2x5ZmlsbCh1cmwyLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAvLyBUaGVzZSBoZWFkZXJzIGFyZSBkZWZhdWx0LCBidXQgY2FuIGJlIG92ZXJyaWRlbiBieSBjdXN0b20gaGVhZGVyc1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgLy8gUG9zc2libGUgaGVhZGVyIG92ZXJyaWRlc1xuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAvLyBDYW5ub3QgYmUgb3ZlcnJpZGVuIGJ5IGN1c3RvbSBoZWFkZXJzXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKX1gLFxuICAgICAgICBcIlgtTEItQ2xpZW50XCI6IFBLR19WRVJTSU9OIHx8IFwiZGV2XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cywgbWFrZXMgdGhlIEhUVFAgcmVxdWVzdCwgYW5kIGhhbmRsZXMgdGhlIHJlc3BvbnNlIGJ5IHBhcnNpbmdcbiAgICogSlNPTiBhbmQvb3IgdGhyb3dpbmcgYW4gSHR0cEVycm9yIGlmIGl0IGZhaWxlZC5cbiAgICpcbiAgICogVGhpcyBpcyB3aGF0IC5yYXdGZXRjaCgpIGRvZXM6XG4gICAqICAgMS4gU2V0IENvbnRlbnQtVHlwZSBoZWFkZXJcbiAgICogICAyLiBTZXQgQXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICogICAzLiBDYWxsIHRoZSBjYWxsYmFjayB0byBvYnRhaW4gdGhlIGBhdXRoVmFsdWVgIHRvIHVzZSBpbiB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICpcbiAgICogVGhpcyBpcyB3aGF0IC5mZXRjaCgpIGRvZXMgT04gVE9QIG9mIHRoYXQ6ICAg8J+RiCBUaGlzIG1ldGhvZCFcbiAgICogICA0LiBQYXJzZSByZXNwb25zZSBib2R5IGFzIEpzb25cbiAgICogICA1LiAuLi5idXQgc2lsZW50bHkgcmV0dXJuIGB7fWAgaWYgdGhhdCBwYXJzaW5nIGZhaWxzICjwn6SUKVxuICAgKiAgIDYuIFRocm93IEh0dHBFcnJvciBpZiByZXNwb25zZSBpcyBhbiBlcnJvclxuICAgKi9cbiAgYXN5bmMgI2ZldGNoKGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy4jcmF3RmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9ucywgcGFyYW1zKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBIdHRwRXJyb3IuZnJvbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIEdFVCByZXF1ZXN0IGFuZCByZXR1cm5zIHRoZSByYXcgcmVzcG9uc2UuXG4gICAqIFdvbid0IHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICogQGRlcHJlY2F0ZWQgSWRlYWxseSwgdXNlIC5nZXQoKSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgcmF3R2V0KGVuZHBvaW50LCBhdXRoVmFsdWUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNyYXdGZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zLCBwYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIFBPU1QgcmVxdWVzdCBhbmQgcmV0dXJucyB0aGUgcmF3IHJlc3BvbnNlLlxuICAgKiBXb24ndCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqIEBkZXByZWNhdGVkIElkZWFsbHksIHVzZSAucG9zdCgpIGluc3RlYWQuXG4gICAqL1xuICBhc3luYyByYXdQb3N0KGVuZHBvaW50LCBhdXRoVmFsdWUsIGJvZHkpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jcmF3RmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHN0cmluZ2lmeU9yTG9nKGJvZHkpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIGEgREVMRVRFIHJlcXVlc3QgYW5kIHJldHVybnMgdGhlIHJhdyByZXNwb25zZS5cbiAgICogV29uJ3QgdGhyb3cgaWYgdGhlIHJlcG9uc2UgaXMgYSBub24tMnh4LlxuICAgKiBAZGVwcmVjYXRlZCBJZGVhbGx5LCB1c2UgLmRlbGV0ZSgpIGluc3RlYWQuXG4gICAqL1xuICBhc3luYyByYXdEZWxldGUoZW5kcG9pbnQsIGF1dGhWYWx1ZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNyYXdGZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCB7IG1ldGhvZDogXCJERUxFVEVcIiB9KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBHRVQgcmVxdWVzdCwgYW5kIHJldHVybiB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogV2lsbCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqL1xuICBhc3luYyBnZXQoZW5kcG9pbnQsIGF1dGhWYWx1ZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZldGNoKGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMsIHBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIGEgUE9TVCByZXF1ZXN0LCBhbmQgcmV0dXJuIHRoZSBKU09OIHJlc3BvbnNlLlxuICAgKiBXaWxsIHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICovXG4gIGFzeW5jIHBvc3QoZW5kcG9pbnQsIGF1dGhWYWx1ZSwgYm9keSwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZldGNoKFxuICAgICAgZW5kcG9pbnQsXG4gICAgICBhdXRoVmFsdWUsXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IHN0cmluZ2lmeU9yTG9nKGJvZHkpXG4gICAgICB9LFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBERUxFVEUgcmVxdWVzdCwgYW5kIHJldHVybiB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogV2lsbCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqL1xuICBhc3luYyBkZWxldGUoZW5kcG9pbnQsIGF1dGhWYWx1ZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCB7IG1ldGhvZDogXCJERUxFVEVcIiB9KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBQVVQgcmVxdWVzdCBmb3IgYSBCbG9iIGJvZHksIGFuZCByZXR1cm4gdGhlIEpTT04gcmVzcG9uc2UuXG4gICAqIFdpbGwgdGhyb3cgaWYgdGhlIHJlcG9uc2UgaXMgYSBub24tMnh4LlxuICAgKi9cbiAgYXN5bmMgcHV0QmxvYihlbmRwb2ludCwgYXV0aFZhbHVlLCBibG9iLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmV0Y2goXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGF1dGhWYWx1ZSxcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBibG9iXG4gICAgICB9LFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9mc20udHNcbmZ1bmN0aW9uIGRpc3RhbmNlKHN0YXRlMSwgc3RhdGUyKSB7XG4gIGlmIChzdGF0ZTEgPT09IHN0YXRlMikge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgY29uc3QgY2h1bmtzMSA9IHN0YXRlMS5zcGxpdChcIi5cIik7XG4gIGNvbnN0IGNodW5rczIgPSBzdGF0ZTIuc3BsaXQoXCIuXCIpO1xuICBjb25zdCBtaW5MZW4gPSBNYXRoLm1pbihjaHVua3MxLmxlbmd0aCwgY2h1bmtzMi5sZW5ndGgpO1xuICBsZXQgc2hhcmVkID0gMDtcbiAgZm9yICg7IHNoYXJlZCA8IG1pbkxlbjsgc2hhcmVkKyspIHtcbiAgICBpZiAoY2h1bmtzMVtzaGFyZWRdICE9PSBjaHVua3MyW3NoYXJlZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCB1cCA9IGNodW5rczEubGVuZ3RoIC0gc2hhcmVkO1xuICBjb25zdCBkb3duID0gY2h1bmtzMi5sZW5ndGggLSBzaGFyZWQ7XG4gIHJldHVybiBbdXAsIGRvd25dO1xufVxuZnVuY3Rpb24gcGF0dGVybnModGFyZ2V0U3RhdGUsIGxldmVscykge1xuICBjb25zdCBwYXJ0cyA9IHRhcmdldFN0YXRlLnNwbGl0KFwiLlwiKTtcbiAgaWYgKGxldmVscyA8IDEgfHwgbGV2ZWxzID4gcGFydHMubGVuZ3RoICsgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIGxldmVsc1wiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKGxldmVscyA+IHBhcnRzLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKFwiKlwiKTtcbiAgfVxuICBmb3IgKGxldCBpID0gcGFydHMubGVuZ3RoIC0gbGV2ZWxzICsgMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xpY2UgPSBwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnB1c2goc2xpY2Uuam9pbihcIi5cIikgKyBcIi4qXCIpO1xuICAgIH1cbiAgfVxuICByZXN1bHQucHVzaCh0YXJnZXRTdGF0ZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgU2FmZUNvbnRleHQgPSBjbGFzcyB7XG4gICNjdXJyO1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgIHRoaXMuI2N1cnIgPSBpbml0aWFsQ29udGV4dDtcbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycjtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHBhdGNoaW5nIG9mIHRoZSBjb250ZXh0LCBieVxuICAgKiBjYWxsaW5nIGBjb250ZXh0LnBhdGNoKClgLiBQYXRjaGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHRoZSBkdXJhdGlvblxuICAgKiBvZiB0aGlzIHdpbmRvdy5cbiAgICovXG4gIGFsbG93UGF0Y2hpbmcoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgYWxsb3dlZCA9IHRydWU7XG4gICAgY29uc3QgcGF0Y2hhYmxlQ29udGV4dCA9IHtcbiAgICAgIC4uLnRoaXMuI2N1cnIsXG4gICAgICBwYXRjaChwYXRjaCkge1xuICAgICAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgICAgIHNlbGYuI2N1cnIgPSBPYmplY3QuYXNzaWduKHt9LCBzZWxmLiNjdXJyLCBwYXRjaCk7XG4gICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIE9iamVjdC5lbnRyaWVzKHBhdGNoKSkge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gcGFpcjtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwicGF0Y2hcIikge1xuICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vIGxvbmdlciBwYXRjaCBzdGFsZSBjb250ZXh0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjYWxsYmFjayhwYXRjaGFibGVDb250ZXh0KTtcbiAgICBhbGxvd2VkID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG59O1xudmFyIG5leHRJZCA9IDE7XG52YXIgRlNNID0gY2xhc3Mge1xuICBpZDtcbiAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBzdGF0ZSBtYWNoaW5lIGlzIHN0aWxsIGJlaW5nIGNvbmZpZ3VyZWQsIGhhc1xuICAvLyBzdGFydGVkLCBvciBoYXMgdGVybWluYXRlZFxuICAjcnVubmluZ1N0YXRlO1xuICAjY3VycmVudENvbnRleHQ7XG4gICNzdGF0ZXM7XG4gICNjdXJyZW50U3RhdGVPck51bGw7XG4gICNhbGxvd2VkVHJhbnNpdGlvbnM7XG4gICNldmVudEh1YjtcbiAgZXZlbnRzO1xuICAvL1xuICAvLyBUaGUgY2xlYW51cCBzdGFjayBpcyBhIHN0YWNrIG9mIChvcHRpb25hbCkgY2FsbGJhY2sgZnVuY3Rpb25zIHRoYXQgd2lsbFxuICAvLyBiZSBydW4gd2hlbiBleGl0aW5nIHRoZSBjdXJyZW50IHN0YXRlLiBJZiBhIHN0YXRlIChvciBzdGF0ZSBncm91cCkgZG9lc1xuICAvLyBub3QgaGF2ZSBhbiBleGl0IGhhbmRsZXIsIHRoZW4gdGhlIGVudHJ5IGZvciB0aGF0IGxldmVsIG1heSBiZVxuICAvLyBgdW5kZWZpbmVkYCwgYnV0IHRoZXJlIHdpbGwgYmUgYW4gZXhwbGljaXQgZW50cnkgaW4gdGhlIHN0YWNrIGZvciBpdC5cbiAgLy9cbiAgLy8gVGhpcyB3aWxsIGFsd2F5cyBiZSB0cnVlOlxuICAvL1xuICAvLyAgIGNsZWFudXBTdGFjay5sZW5ndGggPT0gY3VycmVudFN0YXRlLnNwbGl0KCcuJykubGVuZ3RoICsgMVxuICAvL1xuICAvLyBFYWNoIHN0YWNrIGxldmVsIHJlcHJlc2VudHMgYSBkaWZmZXJlbnQgc3RhdGUgXCJncm91cFwiLlxuICAvL1xuICAvLyBGb3IgZXhhbXBsZSwgaWYgeW91IGFyZSBpbiBhIHN0YXRlIG5hbWVkIGBmb28uYmFyLnF1eGAsIHRoZW4gdGhlIHN0YWNrXG4gIC8vIHdpbGwgY29udGFpbiB0aGUgZXhpdCBoYW5kbGVyIGZvciBgZm9vLmJhci5xdXhgIChhdCB0aGUgdG9wKSwgdGhlblxuICAvLyBgZm9vLmJhci4qYCwgdGhlbiBgZm9vLipgLCBhbmQgZmluYWxseSwgYCpgLlxuICAvL1xuICAjY2xlYW51cFN0YWNrO1xuICAjZW50ZXJGbnM7XG4gIC8vIFVzZWQgdG8gcHJvdmlkZSBiZXR0ZXIgZXJyb3IgbWVzc2FnZXNcbiAgI2tub3duRXZlbnRUeXBlcztcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluaXRpYWwgc3RhdGUsIHdoaWNoIGlzIGRlZmluZWQgYnkgdGhlIGZpcnN0IGNhbGwgbWFkZSB0b1xuICAgKiAuYWRkU3RhdGUoKS5cbiAgICovXG4gIGdldCAjaW5pdGlhbFN0YXRlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI3N0YXRlcy52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3RhdGVzIGRlZmluZWQgeWV0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfVxuICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIGlmICh0aGlzLiNjdXJyZW50U3RhdGVPck51bGwgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLiNydW5uaW5nU3RhdGUgPT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdGFydGVkIHlldFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RvcHBlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbDtcbiAgfVxuICAvKipcbiAgICogU3RhcnRzIHRoZSBtYWNoaW5lIGJ5IGVudGVyaW5nIHRoZSBpbml0aWFsIHN0YXRlLlxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuI3J1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlIG1hY2hpbmUgaGFzIGFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy4jcnVubmluZ1N0YXRlID0gMSAvKiBTVEFSVEVEICovO1xuICAgIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbCA9IHRoaXMuI2luaXRpYWxTdGF0ZTtcbiAgICB0aGlzLiNlbnRlcihudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIHN0YXRlIG1hY2hpbmUuIFN0b3BwaW5nIHRoZSBzdGF0ZSBtYWNoaW5lIHdpbGwgY2FsbCBleGl0XG4gICAqIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzdGF0ZSwgYnV0IG5vdCBlbnRlciBhIG5ldyBzdGF0ZS5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuI3J1bm5pbmdTdGF0ZSAhPT0gMSAvKiBTVEFSVEVEICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3RvcCBhIHN0YXRlIG1hY2hpbmUgdGhhdCBoYXNuJ3Qgc3RhcnRlZCB5ZXRcIik7XG4gICAgfVxuICAgIHRoaXMuI2V4aXQobnVsbCk7XG4gICAgdGhpcy4jcnVubmluZ1N0YXRlID0gMiAvKiBTVE9QUEVEICovO1xuICAgIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbCA9IG51bGw7XG4gIH1cbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLmlkID0gbmV4dElkKys7XG4gICAgdGhpcy4jcnVubmluZ1N0YXRlID0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi87XG4gICAgdGhpcy4jY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgICB0aGlzLiNzdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuI2VudGVyRm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLiNjbGVhbnVwU3RhY2sgPSBbXTtcbiAgICB0aGlzLiNrbm93bkV2ZW50VHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuI2FsbG93ZWRUcmFuc2l0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy4jY3VycmVudENvbnRleHQgPSBuZXcgU2FmZUNvbnRleHQoaW5pdGlhbENvbnRleHQpO1xuICAgIHRoaXMuI2V2ZW50SHViID0ge1xuICAgICAgZGlkUmVjZWl2ZUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIHdpbGxUcmFuc2l0aW9uOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIGRpZElnbm9yZUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIHdpbGxFeGl0U3RhdGU6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogbWFrZUV2ZW50U291cmNlKClcbiAgICB9O1xuICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgZGlkUmVjZWl2ZUV2ZW50OiB0aGlzLiNldmVudEh1Yi5kaWRSZWNlaXZlRXZlbnQub2JzZXJ2YWJsZSxcbiAgICAgIHdpbGxUcmFuc2l0aW9uOiB0aGlzLiNldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5vYnNlcnZhYmxlLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IHRoaXMuI2V2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsRXhpdFN0YXRlOiB0aGlzLiNldmVudEh1Yi53aWxsRXhpdFN0YXRlLm9ic2VydmFibGUsXG4gICAgICBkaWRFbnRlclN0YXRlOiB0aGlzLiNldmVudEh1Yi5kaWRFbnRlclN0YXRlLm9ic2VydmFibGVcbiAgICB9O1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50Q29udGV4dC5jdXJyZW50O1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgYW4gZXhwbGljaXQgZmluaXRlIHN0YXRlIGluIHRoZSBzdGF0ZSBtYWNoaW5lLlxuICAgKi9cbiAgYWRkU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzdGF0ZXMuYWRkKHN0YXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbkVudGVyKG5hbWVPclBhdHRlcm4sIGVudGVyRm4pIHtcbiAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jZW50ZXJGbnMuaGFzKG5hbWVPclBhdHRlcm4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIFRPRE8gV2UgX2N1cnJlbnRseV8gZG9uJ3Qgc3VwcG9ydCBtdWx0aXBsZSAub25FbnRlcnMoKSBmb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gc3RhdGUsIGJ1dCB0aGlzIGlzIG5vdCBhIGZ1bmRhbWVudGFsIGxpbWl0YXRpb24uIEp1c3Qgbm90XG4gICAgICAgIC8vIGltcGxlbWVudGVkIHlldC4gSWYgd2Ugd2FudGVkIHRvLCB3ZSBjb3VsZCBtYWtlIHRoaXMgYW4gYXJyYXkuXG4gICAgICAgIGBlbnRlci9leGl0IGZ1bmN0aW9uIGZvciAke25hbWVPclBhdHRlcm59IGFscmVhZHkgZXhpc3RzYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy4jZW50ZXJGbnMuc2V0KG5hbWVPclBhdHRlcm4sIGVudGVyRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgcHJvbWlzZS1iYXNlZCBzdGF0ZS4gV2hlbiB0aGUgc3RhdGUgaXMgZW50ZXJlZCwgdGhlIHByb21pc2UgaXNcbiAgICogY3JlYXRlZC4gV2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcywgdGhlIG1hY2hpbmUgd2lsbCB0cmFuc2l0aW9uIHRvIHRoZVxuICAgKiBwcm92aWRlZCBgb25PS2AgdGFyZ2V0IHN0YXRlLiBXaGVuIHRoZSBwcm9taXNlIHJlamVjdHMsIHRoZSBtYWNoaW5lIHdpbGxcbiAgICogdHJhbnNpdGlvbiB0byB0aGUgYG9uRXJyb3JgIHRhcmdldCBzdGF0ZS5cbiAgICpcbiAgICogT3B0aW9uYWxseSwgYSBgbWF4VGltZW91dGAgY2FuIGJlIHNldC4gSWYgdGhlIHRpbWVvdXQgaGFwcGVucyBiZWZvcmUgdGhlXG4gICAqIHByb21pc2UgaXMgc2V0dGxlZCwgdGhlbiB0aGUgbWFjaGluZSB3aWxsIGFsc28gdHJhbnNpdGlvbiB0byB0aGUgYG9uRXJyb3JgXG4gICAqIHRhcmdldCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuICBUaGUgc3RhdGUgbmFtZSwgb3Igc3RhdGUgZ3JvdXAgcGF0dGVybiBuYW1lLlxuICAgKiBAcGFyYW0gcHJvbWlzZUZuICAgICAgIFRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHN0YXRlIGlzIGVudGVyZWQuXG4gICAqIEBwYXJhbSBvbk9LICAgICAgICAgICAgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8gd2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcy5cbiAgICogQHBhcmFtIG9uRXJyb3IgICAgICAgICBUaGUgc3RhdGUgdG8gdHJhbnNpdGlvbiB0byB3aGVuIHRoZSBwcm9taXNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0cywgb3Igd2hlbiB0aGUgdGltZW91dCBoYXBwZW5zIGJlZm9yZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlIGhhcyBiZWVuIHNldHRsZWQuXG4gICAqIEBwYXJhbSBtYXhUaW1lb3V0ICAgICAgT3B0aW9uYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIFdoZW4gdGhlIHByb21pc2UgY2FsbGJhY2sgZnVuY3Rpb24gaXMgaW52b2tlZCwgaXQncyBwcm92aWRlZCB3aXRoIGFuXG4gICAqIEFib3J0U2lnbmFsICgybmQgYXJndW1lbnQpLlxuICAgKiBJZiBhIHN0YXRlIHRyYW5zaXRpb24gaGFwcGVucyB3aGlsZSB0aGUgcHJvbWlzZSBpcyBwZW5kaW5nIChmb3IgZXhhbXBsZSxcbiAgICogYW4gZXZlbnQsIG9yIGEgdGltZW91dCBoYXBwZW5zKSwgdGhlbiBhbiBhYm9ydCBzaWduYWwgd2lsbCBiZSB1c2VkIHRvXG4gICAqIGluZGljYXRlIHRoaXMuIEltcGxlbWVudGVycyBjYW4gdXNlIHRoaXMgYWJvcnQgc2lnbmFsIHRvIHRlcm1pbmF0ZSB0aGVcbiAgICogaW4tZmxpZ2h0IHByb21pc2UsIG9yIGlnbm9yZSBpdHMgcmVzdWx0cywgZXRjLlxuICAgKi9cbiAgb25FbnRlckFzeW5jKG5hbWVPclBhdHRlcm4sIHByb21pc2VGbiwgb25PSywgb25FcnJvciwgbWF4VGltZW91dCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIobmFtZU9yUGF0dGVybiwgKCkgPT4ge1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IG1heFRpbWVvdXQgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVhc29uID0gbmV3IEVycm9yKFwiVGltZWQgb3V0XCIpO1xuICAgICAgICB0aGlzLiN0cmFuc2l0aW9uKHsgdHlwZTogXCJBU1lOQ19FUlJPUlwiLCByZWFzb24gfSwgb25FcnJvcik7XG4gICAgICB9LCBtYXhUaW1lb3V0KSA6IHZvaWQgMDtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICB2b2lkIHByb21pc2VGbih0aGlzLiNjdXJyZW50Q29udGV4dC5jdXJyZW50LCBzaWduYWwpLnRoZW4oXG4gICAgICAgIC8vIE9uIE9LXG4gICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiN0cmFuc2l0aW9uKHsgdHlwZTogXCJBU1lOQ19PS1wiLCBkYXRhIH0sIG9uT0spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gT24gRXJyb3JcbiAgICAgICAgKHJlYXNvbikgPT4ge1xuICAgICAgICAgIGlmICghc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4jdHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfRVJST1JcIiwgcmVhc29uIH0sIG9uRXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICAjZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBpZiAobmFtZU9yUGF0dGVybiA9PT0gXCIqXCIpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy4jc3RhdGVzKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lT3JQYXR0ZXJuLmVuZHNXaXRoKFwiLipcIikpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IG5hbWVPclBhdHRlcm4uc2xpY2UoMCwgLTEpO1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLiNzdGF0ZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclBhdHRlcm47XG4gICAgICBpZiAodGhpcy4jc3RhdGVzLmhhcyhuYW1lKSkge1xuICAgICAgICBtYXRjaGVzLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGF0ZXMgbWF0Y2ggJHtKU09OLnN0cmluZ2lmeShuYW1lT3JQYXR0ZXJuKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cbiAgLyoqXG4gICAqIERlZmluZSBhbGwgYWxsb3dlZCBvdXRnb2luZyB0cmFuc2l0aW9ucyBmb3IgYSBzdGF0ZS5cbiAgICpcbiAgICogVGhlIHRhcmdldHMgZm9yIGVhY2ggZXZlbnQgY2FuIGJlIGRlZmluZWQgYXMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZVxuICAgKiBuZXh0IHN0YXRlIHRvIHRyYW5zaXRpb24gdG8uIFRoZXNlIGZ1bmN0aW9ucyBjYW4gbG9vayBhdCB0aGUgYGV2ZW50YCBvclxuICAgKiBgY29udGV4dGAgcGFyYW1zIHRvIGNvbmRpdGlvbmFsbHkgZGVjaWRlIHdoaWNoIG5leHQgc3RhdGUgdG8gdHJhbnNpdGlvblxuICAgKiB0by5cbiAgICpcbiAgICogSWYgeW91IHNldCBpdCB0byBgbnVsbGAsIHRoZW4gdGhlIHRyYW5zaXRpb24gd2lsbCBiZSBleHBsaWNpdGx5IGZvcmJpZGRlblxuICAgKiBhbmQgdGhyb3cgYW4gZXJyb3IuIElmIHlvdSBkb24ndCBkZWZpbmUgYSB0YXJnZXQgZm9yIGEgdHJhbnNpdGlvbiwgdGhlblxuICAgKiBzdWNoIGV2ZW50cyB3aWxsIGdldCBpZ25vcmVkLlxuICAgKi9cbiAgYWRkVHJhbnNpdGlvbnMobmFtZU9yUGF0dGVybiwgbWFwcGluZykge1xuICAgIGlmICh0aGlzLiNydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3JjU3RhdGUgb2YgdGhpcy4jZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLiNhbGxvd2VkVHJhbnNpdGlvbnMuZ2V0KHNyY1N0YXRlKTtcbiAgICAgIGlmIChtYXAgPT09IHZvaWQgMCkge1xuICAgICAgICBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNhbGxvd2VkVHJhbnNpdGlvbnMuc2V0KHNyY1N0YXRlLCBtYXApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbdHlwZSwgdGFyZ2V0X10gb2YgT2JqZWN0LmVudHJpZXMobWFwcGluZykpIHtcbiAgICAgICAgaWYgKG1hcC5oYXModHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVHJ5aW5nIHRvIHNldCB0cmFuc2l0aW9uIFwiJHt0eXBlfVwiIG9uIFwiJHtzcmNTdGF0ZX1cIiAodmlhIFwiJHtuYW1lT3JQYXR0ZXJufVwiKSwgYnV0IGEgdHJhbnNpdGlvbiBhbHJlYWR5IGV4aXN0cyB0aGVyZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRfO1xuICAgICAgICB0aGlzLiNrbm93bkV2ZW50VHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICAgICAgICBtYXAuc2V0KHR5cGUsIHRhcmdldEZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogTGlrZSBgLmFkZFRyYW5zaXRpb24oKWAsIGJ1dCB0YWtlcyBhbiAoYW5vbnltb3VzKSB0cmFuc2l0aW9uIHdoZW5ldmVyIHRoZVxuICAgKiB0aW1lciBmaXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuICBUaGUgc3RhdGUgbmFtZSwgb3Igc3RhdGUgZ3JvdXAgcGF0dGVybiBuYW1lLlxuICAgKiBAcGFyYW0gYWZ0ZXIgICAgICAgICAgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdG8gdGFrZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLiBJZiBpbiB0aGUgbWVhbiB0aW1lLCBhbm90aGVyIHRyYW5zaXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpcyB0YWtlbiwgdGhlIHRpbWVyIHdpbGwgZ2V0IGNhbmNlbGxlZC5cbiAgICogQHBhcmFtIHRhcmdldCAgICAgICAgICBUaGUgdGFyZ2V0IHN0YXRlIHRvIGdvIHRvLlxuICAgKi9cbiAgYWRkVGltZWRUcmFuc2l0aW9uKHN0YXRlT3JQYXR0ZXJuLCBhZnRlcjIsIHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIoc3RhdGVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IG1zID0gdHlwZW9mIGFmdGVyMiA9PT0gXCJmdW5jdGlvblwiID8gYWZ0ZXIyKHRoaXMuI2N1cnJlbnRDb250ZXh0LmN1cnJlbnQpIDogYWZ0ZXIyO1xuICAgICAgY29uc3QgdGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI3RyYW5zaXRpb24oeyB0eXBlOiBcIlRJTUVSXCIgfSwgdGFyZ2V0KTtcbiAgICAgIH0sIG1zKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICAjZ2V0VGFyZ2V0Rm4oZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbG93ZWRUcmFuc2l0aW9ucy5nZXQodGhpcy5jdXJyZW50U3RhdGUpPy5nZXQoZXZlbnROYW1lKTtcbiAgfVxuICAvKipcbiAgICogRXhpdHMgdGhlIGN1cnJlbnQgc3RhdGUsIGFuZCBleGVjdXRlcyBhbnkgbmVjZXNzYXJ5IGNsZWFudXAgZnVuY3Rpb25zLlxuICAgKiBDYWxsIHRoaXMgYmVmb3JlIGNoYW5naW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gbGV2ZWxzIERlZmluZXMgaG93IG1hbnkgXCJsZXZlbHNcIiBvZiBuZXN0aW5nIHdpbGwgYmVcbiAgICogZXhpdGVkLiBGb3IgZXhhbXBsZSwgaWYgeW91IHRyYW5zaXRpb24gZnJvbSBgZm9vLmJhci5xdXhgIHRvXG4gICAqIGBmb28uYmFyLmJhemAsIHRoZW4gdGhlIGxldmVsIGlzIDEuIEJ1dCBpZiB5b3UgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGBmb28uYmFyLnF1eGAgdG8gYGJsYS5ibGFgLCB0aGVuIHRoZSBsZXZlbCBpcyAzLlxuICAgKiBJZiBgbnVsbGAsIGl0IHdpbGwgZXhpdCBhbGwgbGV2ZWxzLlxuICAgKi9cbiAgI2V4aXQobGV2ZWxzKSB7XG4gICAgdGhpcy4jZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgIHRoaXMuI2N1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgIGxldmVscyA9IGxldmVscyA/PyB0aGlzLiNjbGVhbnVwU3RhY2subGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHM7IGkrKykge1xuICAgICAgICB0aGlzLiNjbGVhbnVwU3RhY2sucG9wKCk/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW50ZXJzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBvbkVudGVyIGhhbmRsZXJzLlxuICAgKiBDYWxsIHRoaXMgZGlyZWN0bHkgX2FmdGVyXyBzZXR0aW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKi9cbiAgI2VudGVyKGxldmVscykge1xuICAgIGNvbnN0IGVudGVyUGF0dGVybnMgPSBwYXR0ZXJucyhcbiAgICAgIHRoaXMuY3VycmVudFN0YXRlLFxuICAgICAgbGV2ZWxzID8/IHRoaXMuY3VycmVudFN0YXRlLnNwbGl0KFwiLlwiKS5sZW5ndGggKyAxXG4gICAgKTtcbiAgICB0aGlzLiNjdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgZW50ZXJQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBlbnRlckZuID0gdGhpcy4jZW50ZXJGbnMuZ2V0KHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSBlbnRlckZuPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYW51cEZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLiNjbGVhbnVwU3RhY2sucHVzaChjbGVhbnVwRm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI2NsZWFudXBTdGFjay5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgbWFjaGluZSwgd2hpY2ggbWF5IGNhdXNlIGFuIGludGVybmFsIHN0YXRlXG4gICAqIHRyYW5zaXRpb24gdG8gaGFwcGVuLiBXaGVuIHRoYXQgaGFwcGVucywgd2lsbCB0cmlnZ2VyIHNpZGUgZWZmZWN0cy5cbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2tub3duRXZlbnRUeXBlcy5oYXMoZXZlbnQudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBldmVudCAke0pTT04uc3RyaW5naWZ5KGV2ZW50LnR5cGUpfWApO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlID09PSAyIC8qIFNUT1BQRUQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Rm4gPSB0aGlzLiNnZXRUYXJnZXRGbihldmVudC50eXBlKTtcbiAgICBpZiAodGFyZ2V0Rm4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuI3RyYW5zaXRpb24oZXZlbnQsIHRhcmdldEZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgI3RyYW5zaXRpb24oZXZlbnQsIHRhcmdldCkge1xuICAgIHRoaXMuI2V2ZW50SHViLmRpZFJlY2VpdmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5jdXJyZW50U3RhdGU7XG4gICAgY29uc3QgdGFyZ2V0Rm4gPSB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgPyB0YXJnZXQgOiAoKSA9PiB0YXJnZXQ7XG4gICAgY29uc3QgbmV4dFRhcmdldCA9IHRhcmdldEZuKGV2ZW50LCB0aGlzLiNjdXJyZW50Q29udGV4dC5jdXJyZW50KTtcbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIGxldCBlZmZlY3RzID0gdm9pZCAwO1xuICAgIGlmIChuZXh0VGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICB0aGlzLiNldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5leHRUYXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQudGFyZ2V0O1xuICAgICAgZWZmZWN0cyA9IEFycmF5LmlzQXJyYXkobmV4dFRhcmdldC5lZmZlY3QpID8gbmV4dFRhcmdldC5lZmZlY3QgOiBbbmV4dFRhcmdldC5lZmZlY3RdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3N0YXRlcy5oYXMobmV4dFN0YXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5leHQgc3RhdGUgbmFtZTogJHtKU09OLnN0cmluZ2lmeShuZXh0U3RhdGUpfWApO1xuICAgIH1cbiAgICB0aGlzLiNldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5ub3RpZnkoeyBmcm9tOiBvbGRTdGF0ZSwgdG86IG5leHRTdGF0ZSB9KTtcbiAgICBjb25zdCBbdXAsIGRvd25dID0gZGlzdGFuY2UodGhpcy5jdXJyZW50U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgaWYgKHVwID4gMCkge1xuICAgICAgdGhpcy4jZXhpdCh1cCk7XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbCA9IG5leHRTdGF0ZTtcbiAgICBpZiAoZWZmZWN0cyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBlZmZlY3RzVG9SdW4gPSBlZmZlY3RzO1xuICAgICAgdGhpcy4jY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzVG9SdW4pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBlZmZlY3QocGF0Y2hhYmxlQ29udGV4dCwgZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRjaGFibGVDb250ZXh0LnBhdGNoKGVmZmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRvd24gPiAwKSB7XG4gICAgICB0aGlzLiNlbnRlcihkb3duKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJ2ZXJNc2cudHNcbnZhciBTZXJ2ZXJNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoU2VydmVyTXNnQ29kZTIpID0+IHtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVU0VSX0pPSU5FRFwiXSA9IDEwMV0gPSBcIlVTRVJfSk9JTkVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVNFUl9MRUZUXCJdID0gMTAyXSA9IFwiVVNFUl9MRUZUXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQlJPQURDQVNURURfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RFRF9FVkVOVFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlJPT01fU1RBVEVcIl0gPSAxMDRdID0gXCJST09NX1NUQVRFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiSU5JVElBTF9TVE9SQUdFX1NUQVRFXCJdID0gMjAwXSA9IFwiSU5JVElBTF9TVE9SQUdFX1NUQVRFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1NUT1JBR0VcIl0gPSAyMDFdID0gXCJVUERBVEVfU1RPUkFHRVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAwXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfQ1JFQVRFRFwiXSA9IDQwMF0gPSBcIlRIUkVBRF9DUkVBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX0RFTEVURURcIl0gPSA0MDddID0gXCJUSFJFQURfREVMRVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9NRVRBREFUQV9VUERBVEVEXCJdID0gNDAxXSA9IFwiVEhSRUFEX01FVEFEQVRBX1VQREFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfVVBEQVRFRFwiXSA9IDQwOF0gPSBcIlRIUkVBRF9VUERBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9DUkVBVEVEXCJdID0gNDAyXSA9IFwiQ09NTUVOVF9DUkVBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9FRElURURcIl0gPSA0MDNdID0gXCJDT01NRU5UX0VESVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfREVMRVRFRFwiXSA9IDQwNF0gPSBcIkNPTU1FTlRfREVMRVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfUkVBQ1RJT05fQURERURcIl0gPSA0MDVdID0gXCJDT01NRU5UX1JFQUNUSU9OX0FEREVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEXCJdID0gNDA2XSA9IFwiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiUkVKRUNUX1NUT1JBR0VfT1BcIl0gPSAyOTldID0gXCJSRUpFQ1RfU1RPUkFHRV9PUFwiO1xuICByZXR1cm4gU2VydmVyTXNnQ29kZTI7XG59KShTZXJ2ZXJNc2dDb2RlIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL0lXZWJTb2NrZXQudHNcbnZhciBXZWJzb2NrZXRDbG9zZUNvZGVzID0gLyogQF9fUFVSRV9fICovICgoV2Vic29ja2V0Q2xvc2VDb2RlczIpID0+IHtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9OT1JNQUxcIl0gPSAxZTNdID0gXCJDTE9TRV9OT1JNQUxcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9BQk5PUk1BTFwiXSA9IDEwMDZdID0gXCJDTE9TRV9BQk5PUk1BTFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlVORVhQRUNURURfQ09ORElUSU9OXCJdID0gMTAxMV0gPSBcIlVORVhQRUNURURfQ09ORElUSU9OXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVFJZX0FHQUlOX0xBVEVSXCJdID0gMTAxM10gPSBcIlRSWV9BR0FJTl9MQVRFUlwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIklOVkFMSURfTUVTU0FHRV9GT1JNQVRcIl0gPSA0ZTNdID0gXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTk9UX0FMTE9XRURcIl0gPSA0MDAxXSA9IFwiTk9UX0FMTE9XRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCJdID0gNDAwMl0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX1NFQ09ORFNcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNcIl0gPSA0MDAzXSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIl0gPSA0MDA0XSA9IFwiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNfUEVSX1JPT01cIl0gPSA0MDA1XSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiUk9PTV9JRF9VUERBVEVEXCJdID0gNDAwNl0gPSBcIlJPT01fSURfVVBEQVRFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIktJQ0tFRFwiXSA9IDQxMDBdID0gXCJLSUNLRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJUT0tFTl9FWFBJUkVEXCJdID0gNDEwOV0gPSBcIlRPS0VOX0VYUElSRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCJdID0gNDk5OV0gPSBcIkNMT1NFX1dJVEhPVVRfUkVUUllcIjtcbiAgcmV0dXJuIFdlYnNvY2tldENsb3NlQ29kZXMyO1xufSkoV2Vic29ja2V0Q2xvc2VDb2RlcyB8fCB7fSk7XG5mdW5jdGlvbiBzaG91bGREaXNjb25uZWN0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDQ5OTkgLyogQ0xPU0VfV0lUSE9VVF9SRVRSWSAqLyB8fCBjb2RlID49IDRlMyAmJiBjb2RlIDwgNDEwMDtcbn1cbmZ1bmN0aW9uIHNob3VsZFJlYXV0aChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQxMDAgJiYgY29kZSA8IDQyMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAxMyAvKiBUUllfQUdBSU5fTEFURVIgKi8gfHwgY29kZSA+PSA0MjAwICYmIGNvZGUgPCA0MzAwO1xufVxuXG4vLyBzcmMvY29ubmVjdGlvbi50c1xuZnVuY3Rpb24gaXNJZGxlKHN0YXR1cykge1xuICByZXR1cm4gc3RhdHVzID09PSBcImluaXRpYWxcIiB8fCBzdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCI7XG59XG5mdW5jdGlvbiB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSkge1xuICBjb25zdCBzdGF0ZSA9IG1hY2hpbmUuY3VycmVudFN0YXRlO1xuICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgY2FzZSBcIkBvay5jb25uZWN0ZWRcIjpcbiAgICBjYXNlIFwiQG9rLmF3YWl0aW5nLXBvbmdcIjpcbiAgICAgIHJldHVybiBcImNvbm5lY3RlZFwiO1xuICAgIGNhc2UgXCJAaWRsZS5pbml0aWFsXCI6XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgY2FzZSBcIkBhdXRoLmJ1c3lcIjpcbiAgICBjYXNlIFwiQGF1dGguYmFja29mZlwiOlxuICAgIGNhc2UgXCJAY29ubmVjdGluZy5idXN5XCI6XG4gICAgY2FzZSBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIjpcbiAgICBjYXNlIFwiQGlkbGUuem9tYmllXCI6XG4gICAgICByZXR1cm4gbWFjaGluZS5jb250ZXh0LnN1Y2Nlc3NDb3VudCA+IDAgPyBcInJlY29ubmVjdGluZ1wiIDogXCJjb25uZWN0aW5nXCI7XG4gICAgY2FzZSBcIkBpZGxlLmZhaWxlZFwiOlxuICAgICAgcmV0dXJuIFwiZGlzY29ubmVjdGVkXCI7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHN0YXRlLCBcIlVua25vd24gc3RhdGVcIik7XG4gIH1cbn1cbnZhciBCQUNLT0ZGX0RFTEFZUyA9IFsyNTAsIDUwMCwgMWUzLCAyZTMsIDRlMywgOGUzLCAxZTRdO1xudmFyIFJFU0VUX0RFTEFZID0gQkFDS09GRl9ERUxBWVNbMF0gLSAxO1xudmFyIEJBQ0tPRkZfREVMQVlTX1NMT1cgPSBbMmUzLCAzZTQsIDZlNCwgM2U1XTtcbnZhciBIRUFSVEJFQVRfSU5URVJWQUwgPSAzZTQ7XG52YXIgUE9OR19USU1FT1VUID0gMmUzO1xudmFyIEFVVEhfVElNRU9VVCA9IDFlNDtcbnZhciBTT0NLRVRfQ09OTkVDVF9USU1FT1VUID0gMWU0O1xudmFyIFN0b3BSZXRyeWluZyA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihyZWFzb24pO1xuICB9XG59O1xuZnVuY3Rpb24gbmV4dEJhY2tvZmZEZWxheShjdXJyZW50RGVsYXksIGRlbGF5cykge1xuICByZXR1cm4gZGVsYXlzLmZpbmQoKGRlbGF5KSA9PiBkZWxheSA+IGN1cnJlbnREZWxheSkgPz8gZGVsYXlzW2RlbGF5cy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGluY3JlYXNlQmFja29mZkRlbGF5KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7XG4gICAgYmFja29mZkRlbGF5OiBuZXh0QmFja29mZkRlbGF5KGNvbnRleHQuYmFja29mZkRlbGF5LCBCQUNLT0ZGX0RFTEFZUylcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVNfU0xPVylcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNldFN1Y2Nlc3NDb3VudChjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goeyBzdWNjZXNzQ291bnQ6IDAgfSk7XG59XG5mdW5jdGlvbiBsb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgY29uc3QgbG9nZ2VyID0gbGV2ZWwgPT09IDIgLyogRVJST1IgKi8gPyBlcnJvcjIgOiBsZXZlbCA9PT0gMSAvKiBXQVJOICovID8gd2FybiA6IChcbiAgICAvKiBibGFjayBob2xlICovXG4gICAgKCkgPT4ge1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsb2dnZXIobWVzc2FnZSk7XG4gIH07XG59XG5mdW5jdGlvbiBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlKSB7XG4gIGNvbnN0IGNvbm4gPSBcIkNvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyXCI7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgd2FybihgJHtjb25ufSBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuICR7U3RyaW5nKGUpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBpc0Nsb3NlRXZlbnQoZSkgPyBgJHtjb25ufSBjbG9zZWQgcHJlbWF0dXJlbHkgKGNvZGU6ICR7ZS5jb2RlfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gIDogYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbG9nQ2xvc2VFdmVudChldmVudCkge1xuICBjb25zdCBkZXRhaWxzID0gW2Bjb2RlOiAke2V2ZW50LmNvZGV9YF07XG4gIGlmIChldmVudC5yZWFzb24pIHtcbiAgICBkZXRhaWxzLnB1c2goYHJlYXNvbjogJHtldmVudC5yZWFzb259YCk7XG4gIH1cbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYENvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZCAoJHtkZXRhaWxzLmpvaW4oXCIsIFwiKX0pLiBSZXRyeWluZyBpbiAke2N0eC5iYWNrb2ZmRGVsYXl9bXMuYFxuICAgICk7XG4gIH07XG59XG52YXIgbG9nUGVybWFuZW50Q2xvc2UgPSBsb2coXG4gIDEgLyogV0FSTiAqLyxcbiAgXCJDb25uZWN0aW9uIHRvIFdlYlNvY2tldCBjbG9zZWQgcGVybWFuZW50bHkuIFdvbid0IHJldHJ5LlwiXG4pO1xuZnVuY3Rpb24gaXNDbG9zZUV2ZW50KGVycm9yMykge1xuICByZXR1cm4gIShlcnJvcjMgaW5zdGFuY2VvZiBFcnJvcikgJiYgZXJyb3IzLnR5cGUgPT09IFwiY2xvc2VcIjtcbn1cbmZ1bmN0aW9uIGVuYWJsZVRyYWNpbmcobWFjaGluZSkge1xuICBjb25zdCBzdGFydCA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICBmdW5jdGlvbiBsb2cyKC4uLmFyZ3MpIHtcbiAgICB3YXJuKFxuICAgICAgYCR7KCgoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIDFlMykudG9GaXhlZCgyKX0gW0ZTTSAjJHttYWNoaW5lLmlkfV1gLFxuICAgICAgLi4uYXJnc1xuICAgICk7XG4gIH1cbiAgY29uc3QgdW5zdWJzID0gW1xuICAgIG1hY2hpbmUuZXZlbnRzLmRpZFJlY2VpdmVFdmVudC5zdWJzY3JpYmUoKGUpID0+IGxvZzIoYEV2ZW50ICR7ZS50eXBlfWApKSxcbiAgICBtYWNoaW5lLmV2ZW50cy53aWxsVHJhbnNpdGlvbi5zdWJzY3JpYmUoXG4gICAgICAoeyBmcm9tLCB0byB9KSA9PiBsb2cyKFwiVHJhbnNpdGlvbmluZ1wiLCBmcm9tLCBcIlxcdTIxOTJcIiwgdG8pXG4gICAgKSxcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRJZ25vcmVFdmVudC5zdWJzY3JpYmUoXG4gICAgICAoZSkgPT4gbG9nMihcIklnbm9yZWQgZXZlbnRcIiwgZS50eXBlLCBlLCBcIihjdXJyZW50IHN0YXRlIHdvbid0IGhhbmRsZSBpdClcIilcbiAgICApXG4gICAgLy8gbWFjaGluZS5ldmVudHMud2lsbEV4aXRTdGF0ZS5zdWJzY3JpYmUoKHMpID0+IGxvZyhcIkV4aXRpbmcgc3RhdGVcIiwgcykpLFxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFbnRlcmluZyBzdGF0ZVwiLCBzKSksXG4gIF07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICAgIHVuc3ViKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhdHVzRGlkQ2hhbmdlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZENvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3QgZGlkRGlzY29ubmVjdCA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBsZXQgbGFzdFN0YXR1cyA9IG51bGw7XG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gbWFjaGluZS5ldmVudHMuZGlkRW50ZXJTdGF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJTdGF0dXMgPSB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSk7XG4gICAgaWYgKGN1cnJTdGF0dXMgIT09IGxhc3RTdGF0dXMpIHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZS5ub3RpZnkoY3VyclN0YXR1cyk7XG4gICAgfVxuICAgIGlmIChsYXN0U3RhdHVzID09PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZERpc2Nvbm5lY3Qubm90aWZ5KCk7XG4gICAgfSBlbHNlIGlmIChsYXN0U3RhdHVzICE9PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZENvbm5lY3Qubm90aWZ5KCk7XG4gICAgfVxuICAgIGxhc3RTdGF0dXMgPSBjdXJyU3RhdHVzO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNEaWRDaGFuZ2U6IHN0YXR1c0RpZENoYW5nZS5vYnNlcnZhYmxlLFxuICAgIGRpZENvbm5lY3Q6IGRpZENvbm5lY3Qub2JzZXJ2YWJsZSxcbiAgICBkaWREaXNjb25uZWN0OiBkaWREaXNjb25uZWN0Lm9ic2VydmFibGUsXG4gICAgdW5zdWJzY3JpYmVcbiAgfTtcbn1cbnZhciBhc3NpZ24gPSAocGF0Y2gpID0+IChjdHgpID0+IGN0eC5wYXRjaChwYXRjaCk7XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKGRlbGVnYXRlcywgb3B0aW9ucykge1xuICBjb25zdCBvbk1lc3NhZ2UgPSBtYWtlQnVmZmVyYWJsZUV2ZW50U291cmNlKCk7XG4gIG9uTWVzc2FnZS5wYXVzZSgpO1xuICBjb25zdCBvbkNvbm5lY3Rpb25FcnJvciA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBmaXJlRXJyb3JFdmVudChtZXNzYWdlLCBjb2RlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9uQ29ubmVjdGlvbkVycm9yLm5vdGlmeSh7IG1lc3NhZ2UsIGNvZGUgfSk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBpbml0aWFsQ29udGV4dCA9IHtcbiAgICBzdWNjZXNzQ291bnQ6IDAsXG4gICAgYXV0aFZhbHVlOiBudWxsLFxuICAgIHNvY2tldDogbnVsbCxcbiAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gIH07XG4gIGNvbnN0IG1hY2hpbmUgPSBuZXcgRlNNKGluaXRpYWxDb250ZXh0KS5hZGRTdGF0ZShcIkBpZGxlLmluaXRpYWxcIikuYWRkU3RhdGUoXCJAaWRsZS5mYWlsZWRcIikuYWRkU3RhdGUoXCJAaWRsZS56b21iaWVcIikuYWRkU3RhdGUoXCJAYXV0aC5idXN5XCIpLmFkZFN0YXRlKFwiQGF1dGguYmFja29mZlwiKS5hZGRTdGF0ZShcIkBjb25uZWN0aW5nLmJ1c3lcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIpLmFkZFN0YXRlKFwiQG9rLmNvbm5lY3RlZFwiKS5hZGRTdGF0ZShcIkBvay5hd2FpdGluZy1wb25nXCIpO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiKlwiLCB7XG4gICAgUkVDT05ORUNUOiB7XG4gICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIHJlc2V0U3VjY2Vzc0NvdW50XVxuICAgIH0sXG4gICAgRElTQ09OTkVDVDogXCJAaWRsZS5pbml0aWFsXCJcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBpZGxlLipcIiwgcmVzZXRTdWNjZXNzQ291bnQpLmFkZFRyYW5zaXRpb25zKFwiQGlkbGUuKlwiLCB7XG4gICAgQ09OTkVDVDogKF8sIGN0eCkgPT4gKFxuICAgICAgLy8gSWYgd2Ugc3RpbGwgaGF2ZSBhIGtub3duIGF1dGhWYWx1ZSwgdHJ5IHRvIHJlY29ubmVjdCB0byB0aGUgc29ja2V0IGRpcmVjdGx5LFxuICAgICAgLy8gb3RoZXJ3aXNlLCB0cnkgdG8gb2J0YWluIGEgbmV3IGF1dGhWYWx1ZVxuICAgICAgY3R4LmF1dGhWYWx1ZSAhPT0gbnVsbCA/IFwiQGNvbm5lY3RpbmcuYnVzeVwiIDogXCJAYXV0aC5idXN5XCJcbiAgICApXG4gIH0pO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGF1dGguYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGF1dGguYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAYXV0aC5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAYXV0aC5idXN5XCIsXG4gICAgKCkgPT4gd2l0aFRpbWVvdXQoXG4gICAgICBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCksXG4gICAgICBBVVRIX1RJTUVPVVQsXG4gICAgICBcIlRpbWVkIG91dCBkdXJpbmcgYXV0aFwiXG4gICAgKSxcbiAgICAvLyBPbiBzdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uXG4gICAgKG9rRXZlbnQpID0+ICh7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oe1xuICAgICAgICBhdXRoVmFsdWU6IG9rRXZlbnQuZGF0YVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAvLyBBdXRoIGZhaWxlZFxuICAgIChmYWlsZWRFdmVudCkgPT4ge1xuICAgICAgaWYgKGZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIFN0b3BSZXRyeWluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSksXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSwgLTEpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgaW5jcmVhc2VCYWNrb2ZmRGVsYXksXG4gICAgICAgICAgbG9nKFxuICAgICAgICAgICAgMiAvKiBFUlJPUiAqLyxcbiAgICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZmFpbGVkRXZlbnQucmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSA6IFN0cmluZyhmYWlsZWRFdmVudC5yZWFzb24pfWBcbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICApO1xuICBjb25zdCBvblNvY2tldEVycm9yID0gKGV2ZW50KSA9PiBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9FUlJPUlwiLCBldmVudCB9KTtcbiAgY29uc3Qgb25Tb2NrZXRDbG9zZSA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfQ0xPU0VcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0TWVzc2FnZSA9IChldmVudCkgPT4gZXZlbnQuZGF0YSA9PT0gXCJwb25nXCIgPyBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlBPTkdcIiB9KSA6IG9uTWVzc2FnZS5ub3RpZnkoZXZlbnQpO1xuICBmdW5jdGlvbiB0ZWFyZG93blNvY2tldChzb2NrZXQpIHtcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsIHtcbiAgICBOQVZJR0FUT1JfT05MSU5FOiB7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oeyBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZIH0pXG4gICAgfVxuICB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXG4gICAgXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgKGN0eCkgPT4gY3R4LmJhY2tvZmZEZWxheSxcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIlxuICApLm9uRW50ZXJBc3luYyhcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAvL1xuICAgIC8vIFVzZSB0aGUgXCJjcmVhdGVTb2NrZXRcIiBkZWxlZ2F0ZSBmdW5jdGlvbiAocHJvdmlkZWQgdG8gdGhlXG4gICAgLy8gTWFuYWdlZFNvY2tldCkgdG8gY3JlYXRlIHRoZSBhY3R1YWwgV2ViU29ja2V0IGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAgLy8gVGhlbiwgc2V0IHVwIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycywgYW5kIHdhaXQgZm9yIHRoZVxuICAgIC8vIFwib3BlblwiIGV2ZW50IHRvIG9jY3VyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgXCJvcGVuXCIgZXZlbnQgaGFwcGVucywgd2UncmUgcmVhZHkgdG8gdHJhbnNpdGlvbiB0byB0aGVcbiAgICAvLyBPSyBzdGF0ZS4gVGhpcyBpcyBkb25lIGJ5IHJlc29sdmluZyB0aGUgUHJvbWlzZS5cbiAgICAvL1xuICAgIGFzeW5jIChjdHgsIHNpZ25hbCkgPT4ge1xuICAgICAgbGV0IGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQgPSBudWxsO1xuICAgICAgbGV0IHVuY29uZmlybWVkU29ja2V0ID0gbnVsbDtcbiAgICAgIGNvbnN0IGNvbm5lY3QkID0gbmV3IFByb21pc2UoXG4gICAgICAgIChyZXNvbHZlLCByZWopID0+IHtcbiAgICAgICAgICBpZiAoY3R4LmF1dGhWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCBhdXRoVmFsdWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNvY2tldCA9IGRlbGVnYXRlcy5jcmVhdGVTb2NrZXQoY3R4LmF1dGhWYWx1ZSk7XG4gICAgICAgICAgdW5jb25maXJtZWRTb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgZnVuY3Rpb24gcmVqZWN0KGV2ZW50KSB7XG4gICAgICAgICAgICBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgICAgICAgIHJlaihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IFthY3RvciQsIGRpZFJlY2VpdmVBY3Rvcl0gPSBjb250cm9sbGVkUHJvbWlzZSgpO1xuICAgICAgICAgIGlmICghb3B0aW9ucy53YWl0Rm9yQWN0b3JJZCkge1xuICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHdhaXRGb3JBY3RvcklkKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJNc2cgPSB0cnlQYXJzZUpzb24oZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZiAoc2VydmVyTXNnPy50eXBlID09PSAxMDQgLyogUk9PTV9TVEFURSAqLykge1xuICAgICAgICAgICAgICBkaWRSZWNlaXZlQWN0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB3YWl0Rm9yQWN0b3JJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsICgpID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Tb2NrZXRFcnJvcik7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgICAgICAgY29uc3QgdW5zdWIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZvaWQgYWN0b3IkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKFtzb2NrZXQsIHVuc3ViXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB3aXRoVGltZW91dChcbiAgICAgICAgY29ubmVjdCQsXG4gICAgICAgIFNPQ0tFVF9DT05ORUNUX1RJTUVPVVQsXG4gICAgICAgIFwiVGltZWQgb3V0IGR1cmluZyB3ZWJzb2NrZXQgY29ubmVjdGlvblwiXG4gICAgICApLnRoZW4oXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBhcnQgMzpcbiAgICAgICAgLy8gQnkgbm93LCBvdXIgXCJvcGVuXCIgZXZlbnQgaGFzIGZpcmVkLCBhbmQgdGhlIHByb21pc2UgaGFzIGJlZW5cbiAgICAgICAgLy8gcmVzb2x2ZWQuIFR3byBwb3NzaWJsZSBzY2VuYXJpb3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIFRoZSBoYXBweSBwYXRoLiBNb3N0IGxpa2VseS5cbiAgICAgICAgLy8gMi4gVWgtb2guIEEgcHJlbWF0dXJlIGNsb3NlL2Vycm9yIGV2ZW50IGhhcyBiZWVuIG9ic2VydmVkLiBMZXQnc1xuICAgICAgICAvLyAgICByZWplY3QgdGhlIHByb21pc2UgYWZ0ZXIgYWxsLlxuICAgICAgICAvL1xuICAgICAgICAvLyBBbnkgY2xvc2UvZXJyb3IgZXZlbnQgdGhhdCB3aWxsIGdldCBzY2hlZHVsZWQgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBvbndhcmRzLCB3aWxsIGJlIGNhdWdodCBpbiB0aGUgT0sgc3RhdGUsIGFuZCBkZWFsdCB3aXRoXG4gICAgICAgIC8vIGFjY29yZGluZ2x5LlxuICAgICAgICAvL1xuICAgICAgICAoW3NvY2tldCwgdW5zdWJdKSA9PiB7XG4gICAgICAgICAgdW5zdWIoKTtcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFib3J0ZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYXB0dXJlZFByZW1hdHVyZUV2ZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBjYXB0dXJlZFByZW1hdHVyZUV2ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgICB9XG4gICAgICApLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRlYXJkb3duU29ja2V0KHVuY29uZmlybWVkU29ja2V0KTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gT25seSB0cmFuc2l0aW9uIHRvIE9LIHN0YXRlIGFmdGVyIGEgc3VjY2Vzc2Z1bGx5IG9wZW5lZCBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBvay5jb25uZWN0ZWRcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgc29ja2V0OiBva0V2ZW50LmRhdGEsXG4gICAgICAgIGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVlcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZFxuICAgIChmYWlsdXJlKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBmYWlsdXJlLnJlYXNvbjtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Nsb3NlRXZlbnQoZXJyKSkge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGVyci5jb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5LFxuICAgICAgICAgICAgICBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkRGlzY29ubmVjdChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBlcnIucmVhc29uKSxcbiAgICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLnJlYXNvbiwgZXJyLmNvZGUpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGVycildXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgc2VuZEhlYXJ0YmVhdCA9IHtcbiAgICB0YXJnZXQ6IFwiQG9rLmF3YWl0aW5nLXBvbmdcIixcbiAgICBlZmZlY3Q6IChjdHgpID0+IHtcbiAgICAgIGN0eC5zb2NrZXQ/LnNlbmQoXCJwaW5nXCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWF5YmVIZWFydGJlYXQgPSAoKSA9PiB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3QgY2FuWm9tYmllID0gZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIgJiYgZGVsZWdhdGVzLmNhblpvbWJpZSgpO1xuICAgIHJldHVybiBjYW5ab21iaWUgPyBcIkBpZGxlLnpvbWJpZVwiIDogc2VuZEhlYXJ0YmVhdDtcbiAgfTtcbiAgbWFjaGluZS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suY29ubmVjdGVkXCIsIEhFQVJUQkVBVF9JTlRFUlZBTCwgbWF5YmVIZWFydGJlYXQpLmFkZFRyYW5zaXRpb25zKFwiQG9rLmNvbm5lY3RlZFwiLCB7XG4gICAgTkFWSUdBVE9SX09GRkxJTkU6IG1heWJlSGVhcnRiZWF0LFxuICAgIC8vIERvbid0IHRha2UgdGhlIGJyb3dzZXIncyB3b3JkIGZvciBpdCB3aGVuIGl0IHNheXMgaXQncyBvZmZsaW5lLiBEbyBhIHBpbmcvcG9uZyB0byBtYWtlIHN1cmUuXG4gICAgV0lORE9XX0dPVF9GT0NVUzogc2VuZEhlYXJ0YmVhdFxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLnpvbWJpZVwiLCB7XG4gICAgV0lORE9XX0dPVF9GT0NVUzogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCJcbiAgICAvLyBXaGVuIGluIHpvbWJpZSBzdGF0ZSwgdGhlIGNsaWVudCB3aWxsIHRyeSB0byB3YWtlIHVwIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgd2luZG93IHJlZ2FpbnMgZm9jdXNcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBvay4qXCIsIChjdHgpID0+IHtcbiAgICBjdHgucGF0Y2goeyBzdWNjZXNzQ291bnQ6IGN0eC5zdWNjZXNzQ291bnQgKyAxIH0pO1xuICAgIGNvbnN0IHRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgLy8gT24gdGhlIG5leHQgdGljaywgc3RhcnQgZGVsaXZlcmluZyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGFscmVhZHlcbiAgICAgIC8vIGJlZW4gcmVjZWl2ZWQsIGFuZCBjb250aW51ZSBzeW5jaHJvbm91cyBkZWxpdmVyeSBvZiBhbGwgZnV0dXJlXG4gICAgICAvLyBpbmNvbWluZyBtZXNzYWdlcy5cbiAgICAgIG9uTWVzc2FnZS51bnBhdXNlLFxuICAgICAgMFxuICAgICk7XG4gICAgcmV0dXJuIChjdHgyKSA9PiB7XG4gICAgICB0ZWFyZG93blNvY2tldChjdHgyLnNvY2tldCk7XG4gICAgICBjdHgyLnBhdGNoKHsgc29ja2V0OiBudWxsIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpO1xuICAgICAgb25NZXNzYWdlLnBhdXNlKCk7XG4gICAgfTtcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suYXdhaXRpbmctcG9uZ1wiLCB7IFBPTkc6IFwiQG9rLmNvbm5lY3RlZFwiIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcIkBvay5hd2FpdGluZy1wb25nXCIsIFBPTkdfVElNRU9VVCwge1xuICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy8gTG9nIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcyBhbmQgZHJvcCB0aGUgY3VycmVudCBvcGVuIHNvY2tldFxuICAgIGVmZmVjdDogbG9nKFxuICAgICAgMSAvKiBXQVJOICovLFxuICAgICAgXCJSZWNlaXZlZCBubyBwb25nIGZyb20gc2VydmVyLCBhc3N1bWUgaW1wbGljaXQgY29ubmVjdGlvbiBsb3NzLlwiXG4gICAgKVxuICB9KS5hZGRUcmFuc2l0aW9ucyhcIkBvay4qXCIsIHtcbiAgICAvLyBXaGVuIGEgc29ja2V0IHJlY2VpdmVzIGFuIGVycm9yLCB0aGlzIGNhbiBjYXVzZSB0aGUgY2xvc2luZyBvZiB0aGVcbiAgICAvLyBzb2NrZXQsIG9yIG5vdC4gU28gYWx3YXlzIGNoZWNrIHRvIHNlZSBpZiB0aGUgc29ja2V0IGlzIHN0aWxsIE9QRU4gb3JcbiAgICAvLyBub3QuIFdoZW4gc3RpbGwgT1BFTiwgZG9uJ3QgdHJhbnNpdGlvbi5cbiAgICBFWFBMSUNJVF9TT0NLRVRfRVJST1I6IChfLCBjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5zb2NrZXQ/LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IGluY3JlYXNlQmFja29mZkRlbGF5XG4gICAgICB9O1xuICAgIH0sXG4gICAgRVhQTElDSVRfU09DS0VUX0NMT1NFOiAoZSkgPT4ge1xuICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZ1Blcm1hbmVudENsb3NlLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZS5ldmVudC5yZWFzb24sIGUuZXZlbnQuY29kZSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVhdXRoKGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgaWYgKGUuZXZlbnQuY29kZSA9PT0gNDEwOSAvKiBUT0tFTl9FWFBJUkVEICovKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQGF1dGguYnVzeVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHZvaWQgMDtcbiAgICBjb25zdCByb290ID0gd2luID8/IGRvYztcbiAgICBtYWNoaW5lLm9uRW50ZXIoXCIqXCIsIChjdHgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya09mZmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09GRkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya0JhY2tPbmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09OTElORVwiIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJXSU5ET1dfR09UX0ZPQ1VTXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb25OZXR3b3JrT2ZmbGluZSk7XG4gICAgICByb290Py5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcm9vdD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uTmV0d29ya0JhY2tPbmxpbmUpO1xuICAgICAgICB3aW4/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgICB0ZWFyZG93blNvY2tldChjdHguc29ja2V0KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgY2xlYW51cHMgPSBbXTtcbiAgY29uc3QgeyBzdGF0dXNEaWRDaGFuZ2UsIGRpZENvbm5lY3QsIGRpZERpc2Nvbm5lY3QsIHVuc3Vic2NyaWJlIH0gPSBkZWZpbmVDb25uZWN0aXZpdHlFdmVudHMobWFjaGluZSk7XG4gIGNsZWFudXBzLnB1c2godW5zdWJzY3JpYmUpO1xuICBpZiAob3B0aW9ucy5lbmFibGVEZWJ1Z0xvZ2dpbmcpIHtcbiAgICBjbGVhbnVwcy5wdXNoKGVuYWJsZVRyYWNpbmcobWFjaGluZSkpO1xuICB9XG4gIG1hY2hpbmUuc3RhcnQoKTtcbiAgcmV0dXJuIHtcbiAgICBtYWNoaW5lLFxuICAgIGNsZWFudXBzLFxuICAgIC8vIE9ic2VydmFibGUgZXZlbnRzIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoaXMgbWFjaGluZVxuICAgIGV2ZW50czoge1xuICAgICAgc3RhdHVzRGlkQ2hhbmdlLFxuICAgICAgZGlkQ29ubmVjdCxcbiAgICAgIGRpZERpc2Nvbm5lY3QsXG4gICAgICBvbk1lc3NhZ2U6IG9uTWVzc2FnZS5vYnNlcnZhYmxlLFxuICAgICAgb25Db25uZWN0aW9uRXJyb3I6IG9uQ29ubmVjdGlvbkVycm9yLm9ic2VydmFibGVcbiAgICB9XG4gIH07XG59XG52YXIgTWFuYWdlZFNvY2tldCA9IGNsYXNzIHtcbiAgI21hY2hpbmU7XG4gICNjbGVhbnVwcztcbiAgZXZlbnRzO1xuICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZXMsIGVuYWJsZURlYnVnTG9nZ2luZyA9IGZhbHNlLCB3YWl0Rm9yQWN0b3JJZCA9IHRydWUpIHtcbiAgICBjb25zdCB7IG1hY2hpbmUsIGV2ZW50cywgY2xlYW51cHMgfSA9IGNyZWF0ZUNvbm5lY3Rpb25TdGF0ZU1hY2hpbmUoXG4gICAgICBkZWxlZ2F0ZXMsXG4gICAgICB7IHdhaXRGb3JBY3RvcklkLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgfVxuICAgICk7XG4gICAgdGhpcy4jbWFjaGluZSA9IG1hY2hpbmU7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy4jY2xlYW51cHMgPSBjbGVhbnVwcztcbiAgfVxuICBnZXRTdGF0dXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0b05ld0Nvbm5lY3Rpb25TdGF0dXModGhpcy4jbWFjaGluZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1dGggYXV0aFZhbHVlLlxuICAgKi9cbiAgZ2V0IGF1dGhWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFjaGluZS5jb250ZXh0LmF1dGhWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byB0cnkgdG8gY29ubmVjdCB0byBhIFdlYlNvY2tldC4gVGhpcyBvbmx5IGhhcyBhbiBlZmZlY3RcbiAgICogaWYgdGhlIG1hY2hpbmUgaXMgaWRsZSBhdCB0aGUgbW9tZW50LCBvdGhlcndpc2UgdGhpcyBpcyBhIG5vLW9wLlxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICB0aGlzLiNtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkNPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogSWYgaWRsZSwgd2lsbCB0cnkgdG8gY29ubmVjdC4gT3RoZXJ3aXNlLCBpdCB3aWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0IHRvXG4gICAqIHRoZSBzb2NrZXQsIHBvdGVudGlhbGx5IG9idGFpbmluZyBhIG5ldyBhdXRoVmFsdWUgZmlyc3QsIGlmIG5lZWRlZC5cbiAgICovXG4gIHJlY29ubmVjdCgpIHtcbiAgICB0aGlzLiNtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlJFQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIGRpc2Nvbm5lY3QgZnJvbSB0aGUgY3VycmVudCBXZWJTb2NrZXQuIElzIGdvaW5nIHRvIGJlXG4gICAqIGEgbm8tb3AgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGNvbm5lY3Rpb24uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuI21hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRElTQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gc3RvcCB0aGUgbWFjaGluZSBhbmQgcnVuIG5lY2Vzc2FyeSBjbGVhbnVwIGZ1bmN0aW9ucy4gQWZ0ZXJcbiAgICogY2FsbGluZyBkZXN0cm95KCksIHlvdSBjYW4gbm8gbG9uZ2VyIHVzZSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXMgYmVmb3JlXG4gICAqIGxldHRpbmcgdGhlIGluc3RhbmNlIGdldCBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jbWFjaGluZS5zdG9wKCk7XG4gICAgbGV0IGNsZWFudXA7XG4gICAgd2hpbGUgKGNsZWFudXAgPSB0aGlzLiNjbGVhbnVwcy5wb3AoKSkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2FmZWx5IHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uLiBXaWxsIGVtaXQgYSBsb2dcbiAgICogbWVzc2FnZSBpZiB0aGlzIGlzIHNvbWVob3cgaW1wb3NzaWJsZS5cbiAgICovXG4gIHNlbmQoZGF0YSkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXMuI21hY2hpbmUuY29udGV4dD8uc29ja2V0O1xuICAgIGlmIChzb2NrZXQgPT09IG51bGwpIHtcbiAgICAgIHdhcm4oXCJDYW5ub3Qgc2VuZDogbm90IGNvbm5lY3RlZCB5ZXRcIiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gMSkge1xuICAgICAgd2FybihcIkNhbm5vdCBzZW5kOiBXZWJTb2NrZXQgbm8gbG9uZ2VyIG9wZW5cIiwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvY2tldC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTk9URTogVXNlZCBieSB0aGUgRTJFIGFwcCBvbmx5LCB0byBzaW11bGF0ZSBleHBsaWNpdCBldmVudHMuXG4gICAqIE5vdCBpZGVhbCB0byBrZWVwIGV4cG9zZWQgOihcbiAgICovXG4gIF9wcml2YXRlU2VuZE1hY2hpbmVFdmVudChldmVudCkge1xuICAgIHRoaXMuI21hY2hpbmUuc2VuZChldmVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9pbnRlcm5hbC50c1xudmFyIGtJbnRlcm5hbCA9IFN5bWJvbCgpO1xuXG4vLyBzcmMvbGliL0luY3JlbWVudGFsSnNvblBhcnNlci50c1xudmFyIEVNUFRZX09CSkVDVCA9IE9iamVjdC5mcmVlemUoe30pO1xudmFyIE5VTExfS0VZV09SRF9DSEFSUyA9IEFycmF5LmZyb20obmV3IFNldChcIm51bGxcIikpO1xudmFyIFRSVUVfS0VZV09SRF9DSEFSUyA9IEFycmF5LmZyb20obmV3IFNldChcInRydWVcIikpO1xudmFyIEZBTFNFX0tFWVdPUkRfQ0hBUlMgPSBBcnJheS5mcm9tKG5ldyBTZXQoXCJmYWxzZVwiKSk7XG52YXIgQUxMX0tFWVdPUkRfQ0hBUlMgPSBBcnJheS5mcm9tKG5ldyBTZXQoXCJudWxsdHJ1ZWZhbHNlXCIpKTtcbmZ1bmN0aW9uIHN0cmlwQ2hhcihzdHIsIGNoYXJzKSB7XG4gIGNvbnN0IGxhc3RDaGFyID0gc3RyW3N0ci5sZW5ndGggLSAxXTtcbiAgaWYgKGNoYXJzLmluY2x1ZGVzKGxhc3RDaGFyKSkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgLTEpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG52YXIgSW5jcmVtZW50YWxKc29uUGFyc2VyID0gY2xhc3Mge1xuICAvLyBJbnB1dFxuICAjc291cmNlVGV4dCA9IFwiXCI7XG4gIC8vIE91dHB1dFxuICAjY2FjaGVkSnNvbjtcbiAgLyoqIEhvdyBtdWNoIHdlJ3ZlIGFscmVhZHkgcGFyc2VkICovXG4gICNzY2FuSW5kZXggPSAwO1xuICAvKiogV2hldGhlciB0aGUgbGFzdCBjaGFyIHByb2Nlc3NlZCB3YXMgYSBiYWNrc2xhc2ggKi9cbiAgI2VzY2FwZWQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBsYXN0IHVudGVybWluYXRlZCBzdHJpbmcsIC0xIGlmIHdlJ3JlIG5vdCBpbnNpZGVcbiAgICogYSBzdHJpbmcgY3VycmVudGx5LlxuICAgKlxuICAgKiBFeGFtcGxlOiAne1wiYVwiOiBcImZvbydcbiAgICogICAgICAgICAgICAgICAgIF5cbiAgICovXG4gICNsYXN0VW50ZXJtaW5hdGVkU3RyaW5nID0gLTE7XG4gIC8qKlxuICAgKiBTdGFydCBwb3NpdGlvbiBvZiB0aGUgbGFzdCBmdWxseSB0ZXJtaW5hdGVkIHN0cmluZyB3ZSd2ZSBzZWVuLlxuICAgKlxuICAgKiBFeGFtcGxlOiAne1wiYVwiOiBcImZvbydcbiAgICogICAgICAgICAgICBeXG4gICAqL1xuICAjbGFzdFRlcm1pbmF0ZWRTdHJpbmcgPSAtMTtcbiAgLyoqIFRoZSBicmFja2V0IHN0YWNrIG9mIGV4cGVjdGVkIGNsb3NpbmcgY2hhcnMuIEZvciBpbnB1dCAne1wiYVwiOiBbXCJmb28nLCB0aGUgc3RhY2sgd291bGQgYmUgWyd9JywgJ10nXS4gKi9cbiAgI3N0YWNrID0gW107XG4gIGNvbnN0cnVjdG9yKHRleHQgPSBcIlwiKSB7XG4gICAgdGhpcy5hcHBlbmQodGV4dCk7XG4gIH1cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc291cmNlVGV4dDtcbiAgfVxuICBnZXQganNvbigpIHtcbiAgICBpZiAodGhpcy4jY2FjaGVkSnNvbiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLiNjYWNoZWRKc29uID0gdGhpcy4jcGFyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlZEpzb247XG4gIH1cbiAgLyoqIFdoZXRoZXIgd2UncmUgY3VycmVudGx5IGluc2lkZSBhbiB1bnRlcm1pbmF0ZWQgc3RyaW5nLCBlLmcuICd7XCJoZWxsbycgKi9cbiAgZ2V0ICNpblN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jbGFzdFVudGVybWluYXRlZFN0cmluZyA+PSAwO1xuICB9XG4gIGFwcGVuZChkZWx0YSkge1xuICAgIGlmIChkZWx0YSkge1xuICAgICAgaWYgKHRoaXMuI3NvdXJjZVRleHQgPT09IFwiXCIpIHtcbiAgICAgICAgZGVsdGEgPSBkZWx0YS50cmltU3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NvdXJjZVRleHQgKz0gZGVsdGE7XG4gICAgICB0aGlzLiNjYWNoZWRKc29uID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICAjYXV0b2NvbXBsZXRlVGFpbChvdXRwdXQpIHtcbiAgICBpZiAodGhpcy4jaW5TdHJpbmcpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBsYXN0Q2hhciA9IG91dHB1dC5jaGFyQXQob3V0cHV0Lmxlbmd0aCAtIDEpO1xuICAgIGlmIChsYXN0Q2hhciA9PT0gXCJcIikgcmV0dXJuIFwiXCI7XG4gICAgaWYgKGxhc3RDaGFyID09PSBcIi1cIikge1xuICAgICAgcmV0dXJuIFwiMFwiO1xuICAgIH1cbiAgICBpZiAoIUFMTF9LRVlXT1JEX0NIQVJTLmluY2x1ZGVzKGxhc3RDaGFyKSkgcmV0dXJuIFwiXCI7XG4gICAgaWYgKE5VTExfS0VZV09SRF9DSEFSUy5pbmNsdWRlcyhsYXN0Q2hhcikpIHtcbiAgICAgIGlmIChvdXRwdXQuZW5kc1dpdGgoXCJudWxcIikpIHJldHVybiBcImxcIjtcbiAgICAgIGlmIChvdXRwdXQuZW5kc1dpdGgoXCJudVwiKSkgcmV0dXJuIFwibGxcIjtcbiAgICAgIGlmIChvdXRwdXQuZW5kc1dpdGgoXCJuXCIpKSByZXR1cm4gXCJ1bGxcIjtcbiAgICB9XG4gICAgaWYgKFRSVUVfS0VZV09SRF9DSEFSUy5pbmNsdWRlcyhsYXN0Q2hhcikpIHtcbiAgICAgIGlmIChvdXRwdXQuZW5kc1dpdGgoXCJ0cnVcIikpIHJldHVybiBcImVcIjtcbiAgICAgIGlmIChvdXRwdXQuZW5kc1dpdGgoXCJ0clwiKSkgcmV0dXJuIFwidWVcIjtcbiAgICAgIGlmIChvdXRwdXQuZW5kc1dpdGgoXCJ0XCIpKSByZXR1cm4gXCJydWVcIjtcbiAgICB9XG4gICAgaWYgKEZBTFNFX0tFWVdPUkRfQ0hBUlMuaW5jbHVkZXMobGFzdENoYXIpKSB7XG4gICAgICBpZiAob3V0cHV0LmVuZHNXaXRoKFwiZmFsc1wiKSkgcmV0dXJuIFwiZVwiO1xuICAgICAgaWYgKG91dHB1dC5lbmRzV2l0aChcImZhbFwiKSkgcmV0dXJuIFwic2VcIjtcbiAgICAgIGlmIChvdXRwdXQuZW5kc1dpdGgoXCJmYVwiKSkgcmV0dXJuIFwibHNlXCI7XG4gICAgICBpZiAob3V0cHV0LmVuZHNXaXRoKFwiZlwiKSkgcmV0dXJuIFwiYWxzZVwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgcGFyc2luZyBzdGF0ZSBieSBwcm9jZXNzaW5nIGFueSBuZXcgY29udGVudFxuICAgKiB0aGF0IGhhcyBiZWVuIGFwcGVuZGVkIHNpbmNlIHRoZSBsYXN0IHBhcnNlLiBUaGlzIHVwZGF0ZXMgdGhlIHN0YXRlIHdpdGhcbiAgICogZmFjdHMgb25seS4gQW55IGludGVycHJldGF0aW9uIGlzIGxlZnQgdG8gdGhlICNwYXJzZSgpIG1ldGhvZC5cbiAgICovXG4gICNjYXRjaHVwKCkge1xuICAgIGNvbnN0IG5ld0NvbnRlbnQgPSB0aGlzLiNzb3VyY2VUZXh0LnNsaWNlKHRoaXMuI3NjYW5JbmRleCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaCA9IG5ld0NvbnRlbnRbaV07XG4gICAgICBjb25zdCBhYnNvbHV0ZVBvcyA9IHRoaXMuI3NjYW5JbmRleCArIGk7XG4gICAgICBpZiAodGhpcy4jaW5TdHJpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuI2VzY2FwZWQpIHtcbiAgICAgICAgICB0aGlzLiNlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgdGhpcy4jZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICB0aGlzLiNsYXN0VGVybWluYXRlZFN0cmluZyA9IHRoaXMuI2xhc3RVbnRlcm1pbmF0ZWRTdHJpbmc7XG4gICAgICAgICAgdGhpcy4jbGFzdFVudGVybWluYXRlZFN0cmluZyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICB0aGlzLiNsYXN0VW50ZXJtaW5hdGVkU3RyaW5nID0gYWJzb2x1dGVQb3M7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgICAgICAgdGhpcy4jc3RhY2sucHVzaChcIn1cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiW1wiKSB7XG4gICAgICAgICAgdGhpcy4jc3RhY2sucHVzaChcIl1cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwifVwiICYmIHRoaXMuI3N0YWNrLmxlbmd0aCA+IDAgJiYgdGhpcy4jc3RhY2tbdGhpcy4jc3RhY2subGVuZ3RoIC0gMV0gPT09IFwifVwiKSB7XG4gICAgICAgICAgdGhpcy4jc3RhY2sucG9wKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIHRoaXMuI3N0YWNrLmxlbmd0aCA+IDAgJiYgdGhpcy4jc3RhY2tbdGhpcy4jc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiXVwiKSB7XG4gICAgICAgICAgdGhpcy4jc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2NhbkluZGV4ID0gdGhpcy4jc291cmNlVGV4dC5sZW5ndGg7XG4gIH1cbiAgI3BhcnNlKCkge1xuICAgIHRoaXMuI2NhdGNodXAoKTtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy4jc291cmNlVGV4dDtcbiAgICBpZiAocmVzdWx0LmNoYXJBdCgwKSAhPT0gXCJ7XCIpIHtcbiAgICAgIHJldHVybiBFTVBUWV9PQkpFQ1Q7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuZW5kc1dpdGgoXCJ9XCIpKSB7XG4gICAgICBjb25zdCBxdWlja0NoZWNrID0gdHJ5UGFyc2VKc29uKHJlc3VsdCk7XG4gICAgICBpZiAocXVpY2tDaGVjaykge1xuICAgICAgICByZXR1cm4gcXVpY2tDaGVjaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuI2luU3RyaW5nKSB7XG4gICAgICBpZiAodGhpcy4jZXNjYXBlZCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ICs9ICdcIic7XG4gICAgfVxuICAgIHJlc3VsdCA9IHJlc3VsdC50cmltRW5kKCk7XG4gICAgcmVzdWx0ID0gc3RyaXBDaGFyKHJlc3VsdCwgXCIsLlwiKTtcbiAgICByZXN1bHQgPSByZXN1bHQgKyB0aGlzLiNhdXRvY29tcGxldGVUYWlsKHJlc3VsdCk7XG4gICAgY29uc3Qgc3VmZml4ID0gdGhpcy4jc3RhY2sucmVkdWNlUmlnaHQoKGFjYywgY2gpID0+IGFjYyArIGNoLCBcIlwiKTtcbiAgICB7XG4gICAgICBjb25zdCBhdHRlbXB0ID0gdHJ5UGFyc2VKc29uKHJlc3VsdCArIHN1ZmZpeCk7XG4gICAgICBpZiAoYXR0ZW1wdCkge1xuICAgICAgICByZXR1cm4gYXR0ZW1wdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuI2luU3RyaW5nKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgdGhpcy4jbGFzdFVudGVybWluYXRlZFN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHN0cmlwQ2hhcihyZXN1bHQsIFwiOlwiKTtcbiAgICAgIGlmIChyZXN1bHQuZW5kc1dpdGgoJ1wiJykpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHRoaXMuI2xhc3RUZXJtaW5hdGVkU3RyaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ID0gc3RyaXBDaGFyKHJlc3VsdCwgXCIsXCIpO1xuICAgIHJlc3VsdCArPSBzdWZmaXg7XG4gICAgcmV0dXJuIHRyeVBhcnNlSnNvbihyZXN1bHQpID8/IEVNUFRZX09CSkVDVDtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9zaGFsbG93LnRzXG5mdW5jdGlvbiBzaGFsbG93QXJyYXkoeHMsIHlzKSB7XG4gIGlmICh4cy5sZW5ndGggIT09IHlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3QuaXMoeHNbaV0sIHlzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dPYmoob2JqQSwgb2JqQikge1xuICBpZiAoIWlzUGxhaW5PYmplY3Qob2JqQSkgfHwgIWlzUGxhaW5PYmplY3Qob2JqQikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqQikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBrZXlzQS5ldmVyeShcbiAgICAoa2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5KSAmJiBPYmplY3QuaXMob2JqQVtrZXldLCBvYmpCW2tleV0pXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93KGEsIGIpIHtcbiAgaWYgKE9iamVjdC5pcyhhLCBiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgY29uc3QgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICBpZiAoaXNBcnJheUEgfHwgaXNBcnJheUIpIHtcbiAgICBpZiAoIWlzQXJyYXlBIHx8ICFpc0FycmF5Qikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhbGxvd0FycmF5KGEsIGIpO1xuICB9XG4gIHJldHVybiBzaGFsbG93T2JqKGEsIGIpO1xufVxuZnVuY3Rpb24gc2hhbGxvdzIoYSwgYikge1xuICBpZiAoIWlzUGxhaW5PYmplY3QoYSkgfHwgIWlzUGxhaW5PYmplY3QoYikpIHtcbiAgICByZXR1cm4gc2hhbGxvdyhhLCBiKTtcbiAgfVxuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGtleXNBLmV2ZXJ5KFxuICAgIChrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpICYmIHNoYWxsb3coYVtrZXldLCBiW2tleV0pXG4gICk7XG59XG5cbi8vIHNyYy9saWIvVHJlZVBvb2wudHNcbnZhciBUcmVlUG9vbCA9IGNsYXNzIHtcbiAgI19pdGVtcztcbiAgI19jaGlsZHJlbk9mO1xuICAjX3NvcnRlZDtcbiAgI19wcmltYXJ5S2V5O1xuICAjX3BhcmVudEtleUZuO1xuICAjX2x0O1xuICBjb25zdHJ1Y3RvcihwcmltYXJ5S2V5LCBwYXJlbnRLZXksIGx0KSB7XG4gICAgdGhpcy4jX3ByaW1hcnlLZXkgPSBwcmltYXJ5S2V5O1xuICAgIHRoaXMuI19wYXJlbnRLZXlGbiA9IHBhcmVudEtleTtcbiAgICB0aGlzLiNfbHQgPSBsdDtcbiAgICB0aGlzLiNfaXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuI19jaGlsZHJlbk9mID0gbmV3IERlZmF1bHRNYXAoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgdGhpcy4jX3NvcnRlZCA9IFNvcnRlZExpc3Qud2l0aChsdCk7XG4gIH1cbiAgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI19pdGVtcy5nZXQoaWQpO1xuICB9XG4gIGdldE9yVGhyb3coaWQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoaWQpID8/IHJhaXNlKGBJdGVtIHdpdGggaWQgJHtpZH0gbm90IGZvdW5kYCk7XG4gIH1cbiAgZ2V0IHNvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jX3NvcnRlZDtcbiAgfVxuICBnZXRQYXJlbnRJZChpZCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmdldE9yVGhyb3coaWQpO1xuICAgIHJldHVybiB0aGlzLiNfcGFyZW50S2V5Rm4oaXRlbSk7XG4gIH1cbiAgZ2V0UGFyZW50KGlkKSB7XG4gICAgY29uc3QgcGFyZW50SWQgPSB0aGlzLmdldFBhcmVudElkKGlkKTtcbiAgICByZXR1cm4gcGFyZW50SWQgPyB0aGlzLmdldE9yVGhyb3cocGFyZW50SWQpIDogbnVsbDtcbiAgfVxuICBnZXRDaGlsZHJlbihpZCkge1xuICAgIGNvbnN0IGNoaWxkSWRzID0gdGhpcy4jX2NoaWxkcmVuT2YuZ2V0KGlkKTtcbiAgICBpZiAoIWNoaWxkSWRzKSByZXR1cm4gW107XG4gICAgcmV0dXJuIEFycmF5LmZyb20oY2hpbGRJZHMpLm1hcChcbiAgICAgIChpZDIpID0+IHRoaXMuI19pdGVtcy5nZXQoaWQyKVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICk7XG4gIH1cbiAgKndhbGtVcChpZCwgcHJlZGljYXRlKSB7XG4gICAgY29uc3QgaW5jbHVkZVNlbGYgPSB0cnVlO1xuICAgIGxldCBub2RlSWQgPSBpZDtcbiAgICBkbyB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5nZXRPclRocm93KG5vZGVJZCk7XG4gICAgICBpZiAoaW5jbHVkZVNlbGYgfHwgbm9kZUlkICE9PSBpZCkge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoaXRlbSkpIHtcbiAgICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlSWQgPSB0aGlzLiNfcGFyZW50S2V5Rm4oaXRlbSk7XG4gICAgfSB3aGlsZSAobm9kZUlkICE9PSBudWxsKTtcbiAgfVxuICAvLyBYWFhYIEdlbmVyYWxpemVcbiAgKndhbGtMZWZ0KGlkLCBwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRPclRocm93KGlkKTtcbiAgICBjb25zdCBzaWJsaW5ncyA9IFNvcnRlZExpc3QuZnJvbSh0aGlzLmdldFNpYmxpbmdzKGlkKSwgdGhpcy4jX2x0KTtcbiAgICBmb3IgKGNvbnN0IHNpYmxpbmcgb2Ygc2libGluZ3MuaXRlclJldmVyc2VkKCkpIHtcbiAgICAgIGlmICh0aGlzLiNfbHQoc2VsZiwgc2libGluZykpIGNvbnRpbnVlO1xuICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHNpYmxpbmcpKSB7XG4gICAgICAgIHlpZWxkIHNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFhYWFggR2VuZXJhbGl6ZVxuICAqd2Fsa1JpZ2h0KGlkLCBwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRPclRocm93KGlkKTtcbiAgICBjb25zdCBzaWJsaW5ncyA9IFNvcnRlZExpc3QuZnJvbSh0aGlzLmdldFNpYmxpbmdzKGlkKSwgdGhpcy4jX2x0KTtcbiAgICBmb3IgKGNvbnN0IHNpYmxpbmcgb2Ygc2libGluZ3MpIHtcbiAgICAgIGlmICh0aGlzLiNfbHQoc2libGluZywgc2VsZikpIGNvbnRpbnVlO1xuICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHNpYmxpbmcpKSB7XG4gICAgICAgIHlpZWxkIHNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFhYWFggR2VuZXJhbGl6ZVxuICAqd2Fsa0Rvd24oaWQsIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gU29ydGVkTGlzdC5mcm9tKHRoaXMuZ2V0Q2hpbGRyZW4oaWQpLCB0aGlzLiNfbHQpLnJhd0FycmF5O1xuICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHlpZWxkKiB0aGlzLndhbGtEb3duKFxuICAgICAgICB0aGlzLiNfcHJpbWFyeUtleShjaGlsZCksXG4gICAgICAgIHByZWRpY2F0ZVxuICAgICAgICAvLyBcImRlcHRoLWZpcnN0XCIsXG4gICAgICAgIC8vIHRydWVcbiAgICAgICk7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoY2hpbGQpKSB7XG4gICAgICAgIHlpZWxkIGNoaWxkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogUmV0dXJucyBhbGwgc2libGluZ3MsIG5vdCBpbmNsdWRpbmcgdGhlIGl0ZW0gaXRzZWxmLiAqL1xuICBnZXRTaWJsaW5ncyhpZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldE9yVGhyb3coaWQpO1xuICAgIGNvbnN0IHBhcmVudElkID0gdGhpcy5nZXRQYXJlbnRJZChpZCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4ocGFyZW50SWQpLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gc2VsZik7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI19zb3J0ZWRbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gIHVwc2VydChpdGVtKSB7XG4gICAgY29uc3QgcGsgPSB0aGlzLiNfcHJpbWFyeUtleShpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuI19pdGVtcy5nZXQocGspO1xuICAgIGlmIChleGlzdGluZykge1xuICAgICAgaWYgKHRoaXMuI19wYXJlbnRLZXlGbihleGlzdGluZykgIT09IHRoaXMuI19wYXJlbnRLZXlGbihpdGVtKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3QgdXBzZXJ0IHBhcmVudCBJRCBjaGFuZ2VzIHRoYXQgY2hhbmdlIHRoZSB0cmVlIHN0cnVjdHVyZS4gUmVtb3ZlIHRoZSBlbnRyeSBmaXJzdCwgYW5kIHJlY3JlYXRlIGl0XCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI19zb3J0ZWQucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICB9XG4gICAgdGhpcy4jX2l0ZW1zLnNldChwaywgaXRlbSk7XG4gICAgdGhpcy4jX3NvcnRlZC5hZGQoaXRlbSk7XG4gICAgY29uc3QgcGFyZW50SWQgPSB0aGlzLiNfcGFyZW50S2V5Rm4oaXRlbSk7XG4gICAgdGhpcy4jX2NoaWxkcmVuT2YuZ2V0T3JDcmVhdGUocGFyZW50SWQpLmFkZChwayk7XG4gIH1cbiAgcmVtb3ZlKHBrKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuI19pdGVtcy5nZXQocGspO1xuICAgIGlmICghaXRlbSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGNoaWxkSWRzID0gdGhpcy4jX2NoaWxkcmVuT2YuZ2V0KHBrKTtcbiAgICBpZiAoY2hpbGRJZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCByZW1vdmUgaXRlbSAnJHtwa30nIHdoaWxlIGl0IHN0aWxsIGhhcyBjaGlsZHJlbi4gUmVtb3ZlIGNoaWxkcmVuIGZpcnN0LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudElkID0gdGhpcy4jX3BhcmVudEtleUZuKGl0ZW0pO1xuICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy4jX2NoaWxkcmVuT2YuZ2V0KHBhcmVudElkKTtcbiAgICBpZiAoc2libGluZ3MpIHtcbiAgICAgIHNpYmxpbmdzLmRlbGV0ZShwayk7XG4gICAgICBpZiAoc2libGluZ3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLiNfY2hpbGRyZW5PZi5kZWxldGUocGFyZW50SWQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNfc29ydGVkLnJlbW92ZShpdGVtKTtcbiAgICB0aGlzLiNfY2hpbGRyZW5PZi5kZWxldGUocGspO1xuICAgIHRoaXMuI19pdGVtcy5kZWxldGUocGspO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLiNfaXRlbXMuc2l6ZSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuI19jaGlsZHJlbk9mLmNsZWFyKCk7XG4gICAgdGhpcy4jX2l0ZW1zLmNsZWFyKCk7XG4gICAgdGhpcy4jX3NvcnRlZC5jbGVhcigpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvQXV0aFRva2VuLnRzXG52YXIgUGVybWlzc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKFBlcm1pc3Npb24yKSA9PiB7XG4gIFBlcm1pc3Npb24yW1wiUmVhZFwiXSA9IFwicm9vbTpyZWFkXCI7XG4gIFBlcm1pc3Npb24yW1wiV3JpdGVcIl0gPSBcInJvb206d3JpdGVcIjtcbiAgUGVybWlzc2lvbjJbXCJQcmVzZW5jZVdyaXRlXCJdID0gXCJyb29tOnByZXNlbmNlOndyaXRlXCI7XG4gIFBlcm1pc3Npb24yW1wiQ29tbWVudHNXcml0ZVwiXSA9IFwiY29tbWVudHM6d3JpdGVcIjtcbiAgUGVybWlzc2lvbjJbXCJDb21tZW50c1JlYWRcIl0gPSBcImNvbW1lbnRzOnJlYWRcIjtcbiAgcmV0dXJuIFBlcm1pc3Npb24yO1xufSkoUGVybWlzc2lvbiB8fCB7fSk7XG5mdW5jdGlvbiBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gY2FuQ29tbWVudChzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOndyaXRlXCIgLyogQ29tbWVudHNXcml0ZSAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkKGRhdGEpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoZGF0YSkgJiYgKGRhdGEuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcImlkXCIgLyogSURfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXV0aFRva2VuKHJhd1Rva2VuU3RyaW5nKSB7XG4gIGNvbnN0IHRva2VuUGFydHMgPSByYXdUb2tlblN0cmluZy5zcGxpdChcIi5cIik7XG4gIGlmICh0b2tlblBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBpbnZhbGlkIEpXVCB0b2tlblwiKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gdHJ5UGFyc2VKc29uKGI2NGRlY29kZSh0b2tlblBhcnRzWzFdKSk7XG4gIGlmICghKHBheWxvYWQgJiYgaXNWYWxpZEF1dGhUb2tlblBheWxvYWQocGF5bG9hZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBdXRoZW50aWNhdGlvbiBlcnJvcjogZXhwZWN0ZWQgYSB2YWxpZCB0b2tlbiBidXQgZGlkIG5vdCBnZXQgb25lLiBIaW50OiBpZiB5b3UgYXJlIHVzaW5nIGEgY2FsbGJhY2ssIGVuc3VyZSB0aGUgcm9vbSBpcyBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgdG9rZW4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudENhbGxiYWNrXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmF3OiByYXdUb2tlblN0cmluZyxcbiAgICBwYXJzZWQ6IHBheWxvYWRcbiAgfTtcbn1cblxuLy8gc3JjL2FpLnRzXG52YXIgREVGQVVMVF9SRVFVRVNUX1RJTUVPVVQgPSA0ZTM7XG5mdW5jdGlvbiBkZWZpbmVBaVRvb2woKSB7XG4gIHJldHVybiAoZGVmKSA9PiB7XG4gICAgcmV0dXJuIGRlZjtcbiAgfTtcbn1cbnZhciBLbm93bGVkZ2VTdGFjayA9IGNsYXNzIHtcbiAgI19sYXllcnM7XG4gICNzdGFjaztcbiAgLy8gICAgICAgICAgICAgICAgIC8gICAgICAgICAgICAgICAgXFxcbiAgLy8gICAgICBrbm93bGVkZ2Uga2V5ICAgICAgICAgICAgICAgXCJsYXllclwiIGtleVxuICAvLyAgICAgIChyYW5kb20sIG9yIG9wdGlvbmFsbHkgICAgICAob25lIGVudHJ5IHBlciBtb3VudGVkIGNvbXBvbmVudClcbiAgLy8gICAgICAgc2V0IGJ5IHVzZXIpXG4gICNfY2FjaGU7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuI19sYXllcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuI3N0YWNrID0gbmV3IERlZmF1bHRNYXAoXG4gICAgICAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gICAgKTtcbiAgICB0aGlzLiNfY2FjaGUgPSB2b2lkIDA7XG4gIH1cbiAgLy8gVHlwaWNhbGx5IGEgdXNlSWQoKVxuICByZWdpc3RlckxheWVyKHVuaXF1ZUxheWVySWQpIHtcbiAgICBjb25zdCBsYXllcktleSA9IHVuaXF1ZUxheWVySWQ7XG4gICAgaWYgKHRoaXMuI19sYXllcnMuaGFzKGxheWVyS2V5KSlcbiAgICAgIHJhaXNlKGBMYXllciAnJHtsYXllcktleX0nIGFscmVhZHkgZXhpc3RzLCBwcm92aWRlIGEgdW5pcXVlIGxheWVyIGlkYCk7XG4gICAgdGhpcy4jX2xheWVycy5hZGQobGF5ZXJLZXkpO1xuICAgIHJldHVybiBsYXllcktleTtcbiAgfVxuICBkZXJlZ2lzdGVyTGF5ZXIobGF5ZXJLZXkpIHtcbiAgICB0aGlzLiNfbGF5ZXJzLmRlbGV0ZShsYXllcktleSk7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGtub3dsZWRnZV0gb2YgdGhpcy4jc3RhY2spIHtcbiAgICAgIGlmIChrbm93bGVkZ2UuZGVsZXRlKGxheWVyS2V5KSkge1xuICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChrbm93bGVkZ2Uuc2l6ZSA9PT0gMClcbiAgICAgICAgdGhpcy4jc3RhY2suZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGlmIChkZWxldGVkKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLiNfY2FjaGUgPz89IHRoaXMuI3JlY29tcHV0ZSgpO1xuICB9XG4gIGludmFsaWRhdGUoKSB7XG4gICAgdGhpcy4jX2NhY2hlID0gdm9pZCAwO1xuICB9XG4gICNyZWNvbXB1dGUoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jc3RhY2sudmFsdWVzKCkpLmZsYXRNYXAoXG4gICAgICAobGF5ZXIpID0+IChcbiAgICAgICAgLy8gUmV0dXJuIG9ubHkgdGhlIGxhc3QgaXRlbSAocmV0dXJucyBbXSB3aGVuIGVtcHR5KVxuICAgICAgICBBcnJheS5mcm9tKGxheWVyLnZhbHVlcygpKS5zbGljZSgtMSkuZmlsdGVyKGlzRGVmaW5lZClcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHVwZGF0ZUtub3dsZWRnZShsYXllcktleSwga2V5LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLiNfbGF5ZXJzLmhhcyhsYXllcktleSkpIHJhaXNlKGBVbmtub3duIGxheWVyIGtleTogJHtsYXllcktleX1gKTtcbiAgICB0aGlzLiNzdGFjay5nZXRPckNyZWF0ZShrZXkpLnNldChsYXllcktleSwgZGF0YSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVTdG9yZV9mb3JLbm93bGVkZ2UoKSB7XG4gIGNvbnN0IGtub3dsZWRnZUJ5Q2hhdElkID0gbmV3IERlZmF1bHRNYXAoXG4gICAgKF9jaGF0SWQpID0+IG5ldyBLbm93bGVkZ2VTdGFjaygpXG4gICk7XG4gIGZ1bmN0aW9uIGdldEtub3dsZWRnZVN0YWNrKGNoYXRJZCkge1xuICAgIHJldHVybiBrbm93bGVkZ2VCeUNoYXRJZC5nZXRPckNyZWF0ZShjaGF0SWQgPz8ga1dJTERDQVJEKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRLbm93bGVkZ2VGb3JDaGF0KGNoYXRJZCkge1xuICAgIGNvbnN0IGdsb2JhbEtub3dsZWRnZSA9IGtub3dsZWRnZUJ5Q2hhdElkLmdldE9yQ3JlYXRlKGtXSUxEQ0FSRCkuZ2V0KCk7XG4gICAgY29uc3Qgc2NvcGVkS25vd2xlZGdlID0ga25vd2xlZGdlQnlDaGF0SWQuZ2V0KGNoYXRJZCk/LmdldCgpID8/IFtdO1xuICAgIHJldHVybiBbLi4uZ2xvYmFsS25vd2xlZGdlLCAuLi5zY29wZWRLbm93bGVkZ2VdO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0S25vd2xlZGdlU3RhY2ssXG4gICAgZ2V0S25vd2xlZGdlRm9yQ2hhdFxuICB9O1xufVxuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpO1xufVxudmFyIGtXSUxEQ0FSRCA9IFN5bWJvbChcIipcIik7XG5mdW5jdGlvbiBjcmVhdGVTdG9yZV9mb3JUb29scygpIHtcbiAgY29uc3QgdG9vbHNCeUNoYXRJZFxcdTAzQTMgPSBuZXcgRGVmYXVsdE1hcChcbiAgICAoX2NoYXRJZCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0TWFwKChfbmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25hbCh2b2lkIDApO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xuICBjb25zdCBnbG9iYWxPclNjb3BlZFRvb2xcXHUwM0EzID0gbmV3IERlZmF1bHRNYXAoKG5hbWVBbmRDaGF0KSA9PiB7XG4gICAgY29uc3QgW25hbWUsIGNoYXRJZF0gPSB0cnlQYXJzZUpzb24obmFtZUFuZENoYXQpO1xuICAgIHJldHVybiBEZXJpdmVkU2lnbmFsLmZyb20oKCkgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLy8gQSB0b29sIHRoYXQncyByZWdpc3RlcmVkIGFuZCBzY29wZWQgdG8gYSBzcGVjaWZpYyBjaGF0IElELi4uXG4gICAgICAgIChjaGF0SWQgIT09IHZvaWQgMCA/IHRvb2xzQnlDaGF0SWRcXHUwM0EzLmdldE9yQ3JlYXRlKGNoYXRJZCkuZ2V0T3JDcmVhdGUobmFtZSkgOiB2b2lkIDApPy5nZXQoKSA/PyAvLyAuLi5vciBhIGdsb2JhbGx5IHJlZ2lzdGVyZWQgdG9vbFxuICAgICAgICB0b29sc0J5Q2hhdElkXFx1MDNBMy5nZXRPckNyZWF0ZShrV0lMRENBUkQpLmdldE9yQ3JlYXRlKG5hbWUpLmdldCgpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbiAgZnVuY3Rpb24gZ2V0VG9vbFxcdTAzQTMobmFtZSwgY2hhdElkKSB7XG4gICAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoY2hhdElkICE9PSB2b2lkIDAgPyBbbmFtZSwgY2hhdElkXSA6IFtuYW1lXSk7XG4gICAgcmV0dXJuIGdsb2JhbE9yU2NvcGVkVG9vbFxcdTAzQTMuZ2V0T3JDcmVhdGUoa2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3RlclRvb2wobmFtZSwgdG9vbCwgY2hhdElkKSB7XG4gICAgaWYgKCF0b29sLmV4ZWN1dGUgJiYgIXRvb2wucmVuZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQSB0b29sIGRlZmluaXRpb24gbXVzdCBoYXZlIGFuIGV4ZWN1dGUoKSBmdW5jdGlvbiwgYSByZW5kZXIoKSBmdW5jdGlvbiwgb3IgYm90aC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gY2hhdElkID8/IGtXSUxEQ0FSRDtcbiAgICB0b29sc0J5Q2hhdElkXFx1MDNBMy5nZXRPckNyZWF0ZShrZXkpLmdldE9yQ3JlYXRlKG5hbWUpLnNldCh0b29sKTtcbiAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlclRvb2woa2V5LCBuYW1lKTtcbiAgfVxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyVG9vbChjaGF0SWQsIG5hbWUpIHtcbiAgICBjb25zdCB0b29scyA9IHRvb2xzQnlDaGF0SWRcXHUwM0EzLmdldChjaGF0SWQpO1xuICAgIGlmICh0b29scyA9PT0gdm9pZCAwKSByZXR1cm47XG4gICAgY29uc3QgdG9vbCA9IHRvb2xzLmdldChuYW1lKTtcbiAgICBpZiAodG9vbCA9PT0gdm9pZCAwKSByZXR1cm47XG4gICAgdG9vbC5zZXQodm9pZCAwKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRUb29sRGVzY3JpcHRpb25zKGNoYXRJZCkge1xuICAgIGNvbnN0IGdsb2JhbFRvb2xzXFx1MDNBMyA9IHRvb2xzQnlDaGF0SWRcXHUwM0EzLmdldChrV0lMRENBUkQpO1xuICAgIGNvbnN0IHNjb3BlZFRvb2xzXFx1MDNBMyA9IHRvb2xzQnlDaGF0SWRcXHUwM0EzLmdldChjaGF0SWQpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKFtcbiAgICAgIC4uLmdsb2JhbFRvb2xzXFx1MDNBMz8uZW50cmllcygpID8/IFtdLFxuICAgICAgLi4uc2NvcGVkVG9vbHNcXHUwM0EzPy5lbnRyaWVzKCkgPz8gW11cbiAgICBdKS5mbGF0TWFwKChbbmFtZSwgdG9vbFxcdTAzQTNdKSA9PiB7XG4gICAgICBjb25zdCB0b29sID0gdG9vbFxcdTAzQTMuZ2V0KCk7XG4gICAgICByZXR1cm4gdG9vbCAmJiAodG9vbC5lbmFibGVkID8/IHRydWUpID8gW3sgbmFtZSwgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24sIHBhcmFtZXRlcnM6IHRvb2wucGFyYW1ldGVycyB9XSA6IFtdO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0VG9vbERlc2NyaXB0aW9ucyxcbiAgICBnZXRUb29sXFx1MDNBMyxcbiAgICByZWdpc3RlclRvb2xcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlX2ZvckNoYXRNZXNzYWdlcyh0b29sc1N0b3JlLCBzZXRUb29sUmVzdWx0Rm4pIHtcbiAgY29uc3QgbXlNZXNzYWdlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGhhbmRsZWRJbnZvY2F0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IG1lc3NhZ2VQb29sQnlDaGF0SWRcXHUwM0EzID0gbmV3IERlZmF1bHRNYXAoXG4gICAgKF9jaGF0SWQpID0+IG5ldyBNdXRhYmxlU2lnbmFsKFxuICAgICAgbmV3IFRyZWVQb29sKFxuICAgICAgICAoeCkgPT4geC5pZCxcbiAgICAgICAgKHgpID0+IHgucGFyZW50SWQsXG4gICAgICAgICh4LCB5KSA9PiB4LmNyZWF0ZWRBdCA8IHkuY3JlYXRlZEF0XG4gICAgICApXG4gICAgKVxuICApO1xuICBjb25zdCBnZW5lcmF0aW5nTWVzc2FnZXNcXHUwM0EzID0gbmV3IE11dGFibGVTaWduYWwoXG4gICAgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICApO1xuICBmdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljYWxseShjaGF0SWQsIHJvbGUsIHBhcmVudElkLCB0aGlyZCkge1xuICAgIGNvbnN0IGlkID0gYG1zXyR7bmFub2lkKCl9YDtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBub3coKTtcbiAgICBpZiAocm9sZSA9PT0gXCJ1c2VyXCIpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlyZDtcbiAgICAgIHVwc2VydCh7XG4gICAgICAgIGlkLFxuICAgICAgICBjaGF0SWQsXG4gICAgICAgIHJvbGUsXG4gICAgICAgIHBhcmVudElkLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIF9vcHRpbWlzdGljOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29waWxvdElkID0gdGhpcmQ7XG4gICAgICB1cHNlcnQoe1xuICAgICAgICBpZCxcbiAgICAgICAgY2hhdElkLFxuICAgICAgICByb2xlLFxuICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICBzdGF0dXM6IFwiZ2VuZXJhdGluZ1wiLFxuICAgICAgICBjb250ZW50U29GYXI6IFtdLFxuICAgICAgICBjb3BpbG90SWQsXG4gICAgICAgIF9vcHRpbWlzdGljOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnkobWVzc2FnZXMpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgdXBzZXJ0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZShjaGF0SWQsIG1lc3NhZ2VJZCkge1xuICAgIGNvbnN0IGNoYXRNc2dzXFx1MDNBMyA9IG1lc3NhZ2VQb29sQnlDaGF0SWRcXHUwM0EzLmdldChjaGF0SWQpO1xuICAgIGlmICghY2hhdE1zZ3NcXHUwM0EzKSByZXR1cm47XG4gICAgY29uc3QgZXhpc3RpbmcgPSBjaGF0TXNnc1xcdTAzQTMuZ2V0KCkuZ2V0KG1lc3NhZ2VJZCk7XG4gICAgaWYgKCFleGlzdGluZyB8fCBleGlzdGluZy5kZWxldGVkQXQpIHJldHVybjtcbiAgICBpZiAoZXhpc3Rpbmcucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiAmJiBleGlzdGluZy5zdGF0dXMgIT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgIHVwc2VydCh7IC4uLmV4aXN0aW5nLCBkZWxldGVkQXQ6IG5vdygpLCBjb250ZW50U29GYXI6IFtdIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cHNlcnQoeyAuLi5leGlzdGluZywgZGVsZXRlZEF0OiBub3coKSwgY29udGVudDogW10gfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUJ5Q2hhdElkKGNoYXRJZCkge1xuICAgIGNvbnN0IGNoYXRNc2dzXFx1MDNBMyA9IG1lc3NhZ2VQb29sQnlDaGF0SWRcXHUwM0EzLmdldChjaGF0SWQpO1xuICAgIGlmIChjaGF0TXNnc1xcdTAzQTMgPT09IHZvaWQgMCkgcmV0dXJuO1xuICAgIGNoYXRNc2dzXFx1MDNBMy5tdXRhdGUoKHBvb2wpID0+IHBvb2wuY2xlYXIoKSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0KG1lc3NhZ2UpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICBjb25zdCBjaGF0TXNnc1xcdTAzQTMgPSBtZXNzYWdlUG9vbEJ5Q2hhdElkXFx1MDNBMy5nZXRPckNyZWF0ZShtZXNzYWdlLmNoYXRJZCk7XG4gICAgICBjaGF0TXNnc1xcdTAzQTMubXV0YXRlKChwb29sKSA9PiBwb29sLnVwc2VydChtZXNzYWdlKSk7XG4gICAgICBpZiAobWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiICYmIG1lc3NhZ2Uuc3RhdHVzID09PSBcImdlbmVyYXRpbmdcIikge1xuICAgICAgICBnZW5lcmF0aW5nTWVzc2FnZXNcXHUwM0EzLm11dGF0ZSgobHV0KSA9PiB7XG4gICAgICAgICAgbHV0LnNldChtZXNzYWdlLmlkLCBzdHJ1Y3R1cmVkQ2xvbmUobWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyYXRpbmdNZXNzYWdlc1xcdTAzQTMubXV0YXRlKChsdXQpID0+IHtcbiAgICAgICAgICBsdXQuZGVsZXRlKG1lc3NhZ2UuaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnJvbGUgPT09IFwiYXNzaXN0YW50XCIgJiYgbWVzc2FnZS5zdGF0dXMgPT09IFwiYXdhaXRpbmctdG9vbFwiKSB7XG4gICAgICAgIGlmIChteU1lc3NhZ2VzLmhhcyhtZXNzYWdlLmlkKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgdG9vbEludm9jYXRpb24gb2YgbWVzc2FnZS5jb250ZW50U29GYXIuZmlsdGVyKFxuICAgICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWludm9jYXRpb25cIiAmJiBwYXJ0LnN0YWdlID09PSBcImV4ZWN1dGluZ1wiXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVkSW52b2NhdGlvbnMuaGFzKHRvb2xJbnZvY2F0aW9uLmludm9jYXRpb25JZCkpIHtcbiAgICAgICAgICAgICAgaGFuZGxlZEludm9jYXRpb25zLmFkZCh0b29sSW52b2NhdGlvbi5pbnZvY2F0aW9uSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlRm4gPSB0b29sc1N0b3JlLmdldFRvb2xcXHUwM0EzKHRvb2xJbnZvY2F0aW9uLm5hbWUsIG1lc3NhZ2UuY2hhdElkKS5nZXQoKT8uZXhlY3V0ZTtcbiAgICAgICAgICAgIGlmIChleGVjdXRlRm4pIHtcbiAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlRm4odG9vbEludm9jYXRpb24uYXJncywge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbEludm9jYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgIGludm9jYXRpb25JZDogdG9vbEludm9jYXRpb24uaW52b2NhdGlvbklkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHNldFRvb2xSZXN1bHRGbihcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hhdElkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9uLmludm9jYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA/PyB7IGRhdGE6IHt9IH0sXG4gICAgICAgICAgICAgICAgICB7IGNvcGlsb3RJZDogbWVzc2FnZS5jb3BpbG90SWQgfVxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIHBhc3MgdGhlIG90aGVyIGdlbmVyYXRpb24gb3B0aW9ucyAodG9vbHMsIGtub3dsZWRnZSkgYXMgd2VsbD9cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KSgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBlcnJvcjIoXG4gICAgICAgICAgICAgICAgICBgRXJyb3IgdHJ5aW5nIHRvIHJlc3BvbmQgdG8gdG9vbC1jYWxsOiAke1N0cmluZyhlcnIpfSAoaW4gZXhlY3V0ZSgpKWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnJvbGUgPT09IFwiYXNzaXN0YW50XCIgJiYgbWVzc2FnZS5zdGF0dXMgPT09IFwiZ2VuZXJhdGluZ1wiKSB7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXlNZXNzYWdlcy5kZWxldGUobWVzc2FnZS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhZGREZWx0YShtZXNzYWdlSWQsIGRlbHRhKSB7XG4gICAgZ2VuZXJhdGluZ01lc3NhZ2VzXFx1MDNBMy5tdXRhdGUoKGx1dCkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGx1dC5nZXQobWVzc2FnZUlkKTtcbiAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHJldHVybiBmYWxzZTtcbiAgICAgIHBhdGNoQ29udGVudFdpdGhEZWx0YShtZXNzYWdlLmNvbnRlbnRTb0ZhciwgZGVsdGEpO1xuICAgICAgbHV0LnNldChtZXNzYWdlSWQsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24qIGl0ZXJHZW5lcmF0aW5nTWVzc2FnZXMoKSB7XG4gICAgZm9yIChjb25zdCBjaGF0TXNnc1xcdTAzQTMgb2YgbWVzc2FnZVBvb2xCeUNoYXRJZFxcdTAzQTMudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBjaGF0TXNnc1xcdTAzQTMuZ2V0KCkpIHtcbiAgICAgICAgaWYgKG0ucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiAmJiBtLnN0YXR1cyA9PT0gXCJnZW5lcmF0aW5nXCIgJiYgIW0uX29wdGltaXN0aWMpIHtcbiAgICAgICAgICB5aWVsZCBtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZhaWxBbGxQZW5kaW5nKCkge1xuICAgIGJhdGNoKCgpID0+IHtcbiAgICAgIGdlbmVyYXRpbmdNZXNzYWdlc1xcdTAzQTMubXV0YXRlKChsdXQpID0+IHtcbiAgICAgICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgbHV0KSB7XG4gICAgICAgICAgaWYgKCF2Ll9vcHRpbWlzdGljKSB7XG4gICAgICAgICAgICBsdXQuZGVsZXRlKGspO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWxldGVkO1xuICAgICAgfSk7XG4gICAgICB1cHNlcnRNYW55KFxuICAgICAgICBBcnJheS5mcm9tKGl0ZXJHZW5lcmF0aW5nTWVzc2FnZXMoKSkubWFwKFxuICAgICAgICAgIChtZXNzYWdlKSA9PiAoe1xuICAgICAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgICAgIHN0YXR1czogXCJmYWlsZWRcIixcbiAgICAgICAgICAgIGVycm9yUmVhc29uOiBcIkxvc3QgY29ubmVjdGlvblwiXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRNZXNzYWdlQnlJZChtZXNzYWdlSWQpIHtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2VzXFx1MDNBMyBvZiBtZXNzYWdlUG9vbEJ5Q2hhdElkXFx1MDNBMy52YWx1ZXMoKSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzXFx1MDNBMy5nZXQoKS5nZXQobWVzc2FnZUlkKTtcbiAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIGZpcnN0KGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gaXRlcmFibGUubmV4dCgpO1xuICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHZvaWQgMCA6IHJlc3VsdC52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RCcmFuY2gocG9vbCwgcHJlZmVycmVkQnJhbmNoKSB7XG4gICAgZnVuY3Rpb24gaXNBbGl2ZShtZXNzYWdlMikge1xuICAgICAgaWYgKCFtZXNzYWdlMi5kZWxldGVkQXQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IF8gb2YgcG9vbC53YWxrRG93bihtZXNzYWdlMi5pZCwgKG0pID0+ICFtLmRlbGV0ZWRBdCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlbGVjdFNwaW5lKGxlYWYpIHtcbiAgICAgIGNvbnN0IHNwaW5lID0gW107XG4gICAgICBsZXQgbGFzdFZpc2l0ZWRNZXNzYWdlID0gbnVsbDtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZTIgb2YgcG9vbC53YWxrVXAobGVhZi5pZCkpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpcnN0KHBvb2wud2Fsa0xlZnQobWVzc2FnZTIuaWQsIGlzQWxpdmUpKT8uaWQgPz8gbnVsbDtcbiAgICAgICAgY29uc3QgbmV4dCA9IGZpcnN0KHBvb2wud2Fsa1JpZ2h0KG1lc3NhZ2UyLmlkLCBpc0FsaXZlKSk/LmlkID8/IG51bGw7XG4gICAgICAgIGlmICghbWVzc2FnZTIuZGVsZXRlZEF0IHx8IHByZXYgfHwgbmV4dCkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICAuLi5tZXNzYWdlMixcbiAgICAgICAgICAgIG5hdmlnYXRpb246IHsgcGFyZW50OiBudWxsLCBwcmV2LCBuZXh0IH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChsYXN0VmlzaXRlZE1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxhc3RWaXNpdGVkTWVzc2FnZS5uYXZpZ2F0aW9uLnBhcmVudCA9IG5vZGUuaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RWaXNpdGVkTWVzc2FnZSA9IG5vZGU7XG4gICAgICAgICAgc3BpbmUucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNwaW5lLnJldmVyc2UoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmFsbGJhY2soKSB7XG4gICAgICBjb25zdCBsYXRlc3QgPSBwb29sLnNvcnRlZC5maW5kUmlnaHQoKG0pID0+ICFtLmRlbGV0ZWRBdCk7XG4gICAgICByZXR1cm4gbGF0ZXN0ID8gc2VsZWN0U3BpbmUobGF0ZXN0KSA6IFtdO1xuICAgIH1cbiAgICBpZiAocHJlZmVycmVkQnJhbmNoID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsbGJhY2soKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IHBvb2wuZ2V0KHByZWZlcnJlZEJyYW5jaCk7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gZmFsbGJhY2soKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjdXJyZW50IG9mIHBvb2wud2Fsa1VwKG1lc3NhZ2UuaWQpKSB7XG4gICAgICBmb3IgKGNvbnN0IGRlc2Mgb2YgcG9vbC53YWxrRG93bihjdXJyZW50LmlkLCAobSkgPT4gIW0uZGVsZXRlZEF0KSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0U3BpbmUoZGVzYyk7XG4gICAgICB9XG4gICAgICBpZiAoIWN1cnJlbnQuZGVsZXRlZEF0KSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RTcGluZShjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrKCk7XG4gIH1cbiAgY29uc3QgaW1tdXRhYmxlTWVzc2FnZXNCeUJyYW5jaCA9IG5ldyBEZWZhdWx0TWFwKChjaGF0SWQpID0+IHtcbiAgICByZXR1cm4gbmV3IERlZmF1bHRNYXAoKGJyYW5jaElkKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlc1xcdTAzQTMgPSBEZXJpdmVkU2lnbmFsLmZyb20oKCkgPT4ge1xuICAgICAgICBjb25zdCBwb29sID0gbWVzc2FnZVBvb2xCeUNoYXRJZFxcdTAzQTMuZ2V0T3JDcmVhdGUoY2hhdElkKS5nZXQoKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdEJyYW5jaChwb29sLCBicmFuY2hJZCk7XG4gICAgICB9LCBzaGFsbG93Mik7XG4gICAgICByZXR1cm4gRGVyaXZlZFNpZ25hbC5mcm9tKCgpID0+IHtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGluZ01lc3NhZ2VzID0gZ2VuZXJhdGluZ01lc3NhZ2VzXFx1MDNBMy5nZXQoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzXFx1MDNBMy5nZXQoKS5tYXAoKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICBpZiAobWVzc2FnZS5yb2xlICE9PSBcImFzc2lzdGFudFwiIHx8IG1lc3NhZ2Uuc3RhdHVzICE9PSBcImdlbmVyYXRpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGdlbmVyYXRpbmdNZXNzYWdlID0gZ2VuZXJhdGluZ01lc3NhZ2VzLmdldChtZXNzYWdlLmlkKTtcbiAgICAgICAgICBpZiAoZ2VuZXJhdGluZ01lc3NhZ2UgPT09IHZvaWQgMCkgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgICAgICBjb250ZW50U29GYXI6IGdlbmVyYXRpbmdNZXNzYWdlLmNvbnRlbnRTb0ZhclxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSwgc2hhbGxvdyk7XG4gICAgfSk7XG4gIH0pO1xuICBmdW5jdGlvbiBnZXRDaGF0TWVzc2FnZXNGb3JCcmFuY2hcXHUwM0EzKGNoYXRJZCwgYnJhbmNoKSB7XG4gICAgcmV0dXJuIGltbXV0YWJsZU1lc3NhZ2VzQnlCcmFuY2guZ2V0T3JDcmVhdGUoY2hhdElkKS5nZXRPckNyZWF0ZShicmFuY2ggfHwgbnVsbCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TGFzdFVzZWRDb3BpbG90SWQoY2hhdElkKSB7XG4gICAgY29uc3QgcG9vbCA9IG1lc3NhZ2VQb29sQnlDaGF0SWRcXHUwM0EzLmdldE9yQ3JlYXRlKGNoYXRJZCkuZ2V0KCk7XG4gICAgY29uc3QgbGF0ZXN0ID0gcG9vbC5zb3J0ZWQuZmluZFJpZ2h0KFxuICAgICAgKG0pID0+IG0ucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiAmJiAhbS5kZWxldGVkQXRcbiAgICApO1xuICAgIHJldHVybiBsYXRlc3Q/LmNvcGlsb3RJZDtcbiAgfVxuICByZXR1cm4ge1xuICAgIC8vIFJlYWRlcnNcbiAgICBnZXRNZXNzYWdlQnlJZCxcbiAgICBnZXRDaGF0TWVzc2FnZXNGb3JCcmFuY2hcXHUwM0EzLFxuICAgIGdldExhc3RVc2VkQ29waWxvdElkLFxuICAgIC8vIE11dGF0aW9uc1xuICAgIGNyZWF0ZU9wdGltaXN0aWNhbGx5LFxuICAgIHVwc2VydCxcbiAgICB1cHNlcnRNYW55LFxuICAgIHJlbW92ZSxcbiAgICByZW1vdmVCeUNoYXRJZCxcbiAgICBhZGREZWx0YSxcbiAgICBmYWlsQWxsUGVuZGluZyxcbiAgICBtYXJrTWluZShtZXNzYWdlSWQpIHtcbiAgICAgIG15TWVzc2FnZXMuYWRkKG1lc3NhZ2VJZCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBteSBhdXRvLWV4ZWN1dGluZyBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIFRoZXNlIGFyZSBtZXNzYWdlcyB0aGF0IG1hdGNoIGFsbCB0aGVzZSBjb25kaXRpb25zOlxuICAgICAqIC0gVGhlIG1lc3NhZ2UgaXMgYW4gYXNzaXN0YW50IG1lc3NhZ2VcbiAgICAgKiAtIFRoZSBtZXNzYWdlIGlzIG93bmVkIGJ5IHRoaXMgY2xpZW50IChcIm1pbmVcIilcbiAgICAgKiAtIFRoZSBtZXNzYWdlIGlzIGN1cnJlbnRseSBpbiBcImF3YWl0aW5nLXRvb2xcIiBzdGF0dXNcbiAgICAgKiAtIFRoZSBtZXNzYWdlIGhhcyBhdCBsZWFzdCBvbmUgdG9vbCBpbnZvY2F0aW9uIGluIFwiZXhlY3V0aW5nXCIgc3RhZ2VcbiAgICAgKiAtIFRoZSB0b29sIGludm9jYXRpb24gaGFzIGFuIGV4ZWN1dGUoKSBmdW5jdGlvbiBkZWZpbmVkXG4gICAgICovXG4gICAgKmdldEF1dG9FeGVjdXRpbmdNZXNzYWdlSWRzKCkge1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlSWQgb2YgbXlNZXNzYWdlcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2V0TWVzc2FnZUJ5SWQobWVzc2FnZUlkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2U/LnJvbGUgPT09IFwiYXNzaXN0YW50XCIgJiYgbWVzc2FnZS5zdGF0dXMgPT09IFwiYXdhaXRpbmctdG9vbFwiKSB7XG4gICAgICAgICAgY29uc3QgaXNBdXRvRXhlY3V0aW5nID0gbWVzc2FnZS5jb250ZW50U29GYXIuc29tZSgocGFydCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWludm9jYXRpb25cIiAmJiBwYXJ0LnN0YWdlID09PSBcImV4ZWN1dGluZ1wiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2wgPSB0b29sc1N0b3JlLmdldFRvb2xcXHUwM0EzKHBhcnQubmFtZSwgbWVzc2FnZS5jaGF0SWQpLmdldCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRvb2w/LmV4ZWN1dGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaXNBdXRvRXhlY3V0aW5nKSB7XG4gICAgICAgICAgICB5aWVsZCBtZXNzYWdlLmlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlX2ZvclVzZXJBaUNoYXRzKCkge1xuICBjb25zdCBjaGF0c0RCID0gbmV3IEFpQ2hhdERCKCk7XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnkoY2hhdHMpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGNoYXQgb2YgY2hhdHMpIHtcbiAgICAgICAgY2hhdHNEQi51cHNlcnQoY2hhdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0KGNoYXQpIHtcbiAgICBjaGF0c0RCLnVwc2VydChjaGF0KTtcbiAgfVxuICBmdW5jdGlvbiBtYXJrRGVsZXRlZChjaGF0SWQpIHtcbiAgICBjaGF0c0RCLm1hcmtEZWxldGVkKGNoYXRJZCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2hhdEJ5SWQoY2hhdElkKSB7XG4gICAgcmV0dXJuIGNoYXRzREIuZ2V0RXZlbklmRGVsZXRlZChjaGF0SWQpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRNYW55KHF1ZXJ5KSB7XG4gICAgcmV0dXJuIGNoYXRzREIuc2lnbmFsLmdldCgpLmZpbmRNYW55KHF1ZXJ5KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldENoYXRCeUlkLFxuICAgIGZpbmRNYW55LFxuICAgIC8vIE11dGF0aW9uc1xuICAgIHVwc2VydCxcbiAgICB1cHNlcnRNYW55LFxuICAgIG1hcmtEZWxldGVkXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBaShjb25maWcpIHtcbiAgY29uc3QgbWFuYWdlZFNvY2tldCA9IG5ldyBNYW5hZ2VkU29ja2V0KFxuICAgIGNvbmZpZy5kZWxlZ2F0ZXMsXG4gICAgY29uZmlnLmVuYWJsZURlYnVnTG9nZ2luZyxcbiAgICBmYWxzZVxuICAgIC8vIEFJIGRvZXNuJ3QgaGF2ZSBhY3RvcnMgKHlldCwgYnV0IGl0IHdpbGwpXG4gICk7XG4gIGNvbnN0IGNoYXRzU3RvcmUgPSBjcmVhdGVTdG9yZV9mb3JVc2VyQWlDaGF0cygpO1xuICBjb25zdCB0b29sc1N0b3JlID0gY3JlYXRlU3RvcmVfZm9yVG9vbHMoKTtcbiAgY29uc3Qga25vd2xlZGdlU3RvcmUgPSBjcmVhdGVTdG9yZV9mb3JLbm93bGVkZ2UoKTtcbiAgY29uc3QgbWVzc2FnZXNTdG9yZSA9IGNyZWF0ZVN0b3JlX2ZvckNoYXRNZXNzYWdlcyh0b29sc1N0b3JlLCBzZXRUb29sUmVzdWx0KTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBzdGF0aWNTZXNzaW9uSW5mb1NpZzogbmV3IFNpZ25hbChudWxsKSxcbiAgICBkeW5hbWljU2Vzc2lvbkluZm9TaWc6IG5ldyBTaWduYWwobnVsbCksXG4gICAgcGVuZGluZ0NtZHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgY2hhdHNTdG9yZSxcbiAgICBtZXNzYWdlc1N0b3JlLFxuICAgIHRvb2xzU3RvcmUsXG4gICAga25vd2xlZGdlU3RvcmVcbiAgfTtcbiAgY29uc3Qgc3RhdHVzXFx1MDNBMyA9IG5ldyBTaWduYWwoXCJpbml0aWFsXCIpO1xuICBjb25zdCBERUxUQV9USFJPVFRMRSA9IDI1O1xuICBsZXQgcGVuZGluZ0RlbHRhcyA9IFtdO1xuICBsZXQgZGVsdGFCYXRjaFRpbWVyID0gbnVsbDtcbiAgZnVuY3Rpb24gZmx1c2hQZW5kaW5nRGVsdGFzKCkge1xuICAgIGNvbnN0IGN1cnJlbnRRdWV1ZSA9IHBlbmRpbmdEZWx0YXM7XG4gICAgcGVuZGluZ0RlbHRhcyA9IFtdO1xuICAgIGlmIChkZWx0YUJhdGNoVGltZXIgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dChkZWx0YUJhdGNoVGltZXIpO1xuICAgICAgZGVsdGFCYXRjaFRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgYmF0Y2goKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCB7IGlkLCBkZWx0YSB9IG9mIGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICBjb250ZXh0Lm1lc3NhZ2VzU3RvcmUuYWRkRGVsdGEoaWQsIGRlbHRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBlbnF1ZXVlRGVsdGEoaWQsIGRlbHRhKSB7XG4gICAgcGVuZGluZ0RlbHRhcy5wdXNoKHsgaWQsIGRlbHRhIH0pO1xuICAgIGlmIChkZWx0YUJhdGNoVGltZXIgPT09IG51bGwpIHtcbiAgICAgIGRlbHRhQmF0Y2hUaW1lciA9IHNldFRpbWVvdXQoZmx1c2hQZW5kaW5nRGVsdGFzLCBERUxUQV9USFJPVFRMRSk7XG4gICAgfVxuICB9XG4gIGxldCBsYXN0VG9rZW5LZXk7XG4gIGZ1bmN0aW9uIG9uU3RhdHVzRGlkQ2hhbmdlKG5ld1N0YXR1cykge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlO1xuICAgIGlmIChhdXRoVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRva2VuS2V5ID0gZ2V0QmVhcmVyVG9rZW5Gcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSk7XG4gICAgICBpZiAodG9rZW5LZXkgIT09IGxhc3RUb2tlbktleSkge1xuICAgICAgICBsYXN0VG9rZW5LZXkgPSB0b2tlbktleTtcbiAgICAgICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICAgICAgY29uc3QgdG9rZW4gPSBhdXRoVmFsdWUudG9rZW4ucGFyc2VkO1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm9TaWcuc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmlkIDogdG9rZW4udWlkLFxuICAgICAgICAgICAgdXNlckluZm86IHRva2VuLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8gPyB0b2tlbi5pbmZvIDogdG9rZW4udWlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvU2lnLnNldCh7XG4gICAgICAgICAgICB1c2VySWQ6IHZvaWQgMCxcbiAgICAgICAgICAgIHVzZXJJbmZvOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0dXNcXHUwM0EzLnNldChuZXdTdGF0dXMpO1xuICB9XG4gIGxldCBfY29ubmVjdGlvbkxvc3NUaW1lcklkO1xuICBsZXQgX2hhc0xvc3RDb25uZWN0aW9uID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGhhbmRsZUNvbm5lY3Rpb25Mb3NzRXZlbnQobmV3U3RhdHVzKSB7XG4gICAgaWYgKG5ld1N0YXR1cyA9PT0gXCJyZWNvbm5lY3RpbmdcIikge1xuICAgICAgX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgfSwgY29uZmlnLmxvc3RDb25uZWN0aW9uVGltZW91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dChfY29ubmVjdGlvbkxvc3NUaW1lcklkKTtcbiAgICAgIGlmIChfaGFzTG9zdENvbm5lY3Rpb24pIHtcbiAgICAgICAgX2hhc0xvc3RDb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uRGlkQ29ubmVjdCgpIHtcbiAgfVxuICBmdW5jdGlvbiBvbkRpZERpc2Nvbm5lY3QoKSB7XG4gICAgZmx1c2hQZW5kaW5nRGVsdGFzKCk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlU2VydmVyTWVzc2FnZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBtc2cgPSB0cnlQYXJzZUpzb24oZXZlbnQuZGF0YSk7XG4gICAgaWYgKCFtc2cpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY21kSWQgPSBcImNtZElkXCIgaW4gbXNnID8gbXNnLmNtZElkIDogbXNnLmV2ZW50ID09PSBcImNtZC1mYWlsZWRcIiA/IG1zZy5mYWlsZWRDbWRJZCA6IHZvaWQgMDtcbiAgICBjb25zdCBwZW5kaW5nQ21kID0gY29udGV4dC5wZW5kaW5nQ21kcy5nZXQoY21kSWQpO1xuICAgIGlmIChjbWRJZCAmJiAhcGVuZGluZ0NtZCkge1xuICAgICAgd2FybihcIklnbm9yaW5nIHVuZXhwZWN0ZWQgY29tbWFuZCByZXNwb25zZS4gQWxyZWFkeSB0aW1lZCBvdXQsIG9yIG5vdCBmb3IgdXM/XCIsIG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChcImV2ZW50XCIgaW4gbXNnKSB7XG4gICAgICBpZiAobXNnLmV2ZW50ID09PSBcImRlbHRhXCIpIHtcbiAgICAgICAgY29uc3QgeyBpZCwgZGVsdGEgfSA9IG1zZztcbiAgICAgICAgZW5xdWV1ZURlbHRhKGlkLCBkZWx0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgICAgZmx1c2hQZW5kaW5nRGVsdGFzKCk7XG4gICAgICAgICAgc3dpdGNoIChtc2cuZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjbWQtZmFpbGVkXCI6XG4gICAgICAgICAgICAgIHBlbmRpbmdDbWQ/LnJlamVjdChuZXcgRXJyb3IobXNnLmVycm9yKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNldHRsZVwiOiB7XG4gICAgICAgICAgICAgIGNvbnRleHQubWVzc2FnZXNTdG9yZS51cHNlcnQobXNnLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ3YXJuaW5nXCI6XG4gICAgICAgICAgICAgIHdhcm4obXNnLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICBlcnJvcjIobXNnLmVycm9yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmVib290ZWRcIjpcbiAgICAgICAgICAgICAgY29udGV4dC5tZXNzYWdlc1N0b3JlLmZhaWxBbGxQZW5kaW5nKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN5bmNcIjpcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBtIG9mIG1zZ1tcIi1tZXNzYWdlc1wiXSA/PyBbXSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubWVzc2FnZXNTdG9yZS5yZW1vdmUobS5jaGF0SWQsIG0uaWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgY2hhdElkIG9mIG1zZ1tcIi1jaGF0c1wiXSA/PyBbXSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2hhdHNTdG9yZS5tYXJrRGVsZXRlZChjaGF0SWQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubWVzc2FnZXNTdG9yZS5yZW1vdmVCeUNoYXRJZChjaGF0SWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgY2hhdElkIG9mIG1zZy5jbGVhciA/PyBbXSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubWVzc2FnZXNTdG9yZS5yZW1vdmVCeUNoYXRJZChjaGF0SWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtc2cuY2hhdHMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNoYXRzU3RvcmUudXBzZXJ0TWFueShtc2cuY2hhdHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtc2cubWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1lc3NhZ2VzU3RvcmUudXBzZXJ0TWFueShtc2cubWVzc2FnZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKG1zZywgXCJVbmhhbmRsZWQgY2FzZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKG1zZy5jbWQpIHtcbiAgICAgICAgY2FzZSBcImdldC1jaGF0c1wiOlxuICAgICAgICAgIGNvbnRleHQuY2hhdHNTdG9yZS51cHNlcnRNYW55KG1zZy5jaGF0cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJnZXQtb3ItY3JlYXRlLWNoYXRcIjpcbiAgICAgICAgICBjb250ZXh0LmNoYXRzU3RvcmUudXBzZXJ0KG1zZy5jaGF0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlbGV0ZS1jaGF0XCI6XG4gICAgICAgICAgY29udGV4dC5jaGF0c1N0b3JlLm1hcmtEZWxldGVkKG1zZy5jaGF0SWQpO1xuICAgICAgICAgIGNvbnRleHQubWVzc2FnZXNTdG9yZS5yZW1vdmVCeUNoYXRJZChtc2cuY2hhdElkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImdldC1tZXNzYWdlLXRyZWVcIjpcbiAgICAgICAgICBjb250ZXh0LmNoYXRzU3RvcmUudXBzZXJ0KG1zZy5jaGF0KTtcbiAgICAgICAgICBjb250ZXh0Lm1lc3NhZ2VzU3RvcmUudXBzZXJ0TWFueShtc2cubWVzc2FnZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGVsZXRlLW1lc3NhZ2VcIjpcbiAgICAgICAgICBjb250ZXh0Lm1lc3NhZ2VzU3RvcmUucmVtb3ZlKG1zZy5jaGF0SWQsIG1zZy5tZXNzYWdlSWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2xlYXItY2hhdFwiOlxuICAgICAgICAgIGNvbnRleHQubWVzc2FnZXNTdG9yZS5yZW1vdmVCeUNoYXRJZChtc2cuY2hhdElkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFzay1pbi1jaGF0XCI6XG4gICAgICAgICAgaWYgKG1zZy5zb3VyY2VNZXNzYWdlKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm1lc3NhZ2VzU3RvcmUudXBzZXJ0KG1zZy5zb3VyY2VNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dC5tZXNzYWdlc1N0b3JlLnVwc2VydChtc2cudGFyZ2V0TWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhYm9ydC1haVwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2V0LXRvb2wtcmVzdWx0XCI6XG4gICAgICAgICAgaWYgKG1zZy5vaykge1xuICAgICAgICAgICAgY29udGV4dC5tZXNzYWdlc1N0b3JlLnVwc2VydChtc2cubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBhc3NlcnROZXZlcihtc2csIFwiVW5oYW5kbGVkIGNhc2VcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHBlbmRpbmdDbWQ/LnJlc29sdmUobXNnKTtcbiAgfVxuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5vbk1lc3NhZ2Uuc3Vic2NyaWJlKGhhbmRsZVNlcnZlck1lc3NhZ2UpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5zdGF0dXNEaWRDaGFuZ2Uuc3Vic2NyaWJlKG9uU3RhdHVzRGlkQ2hhbmdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShoYW5kbGVDb25uZWN0aW9uTG9zc0V2ZW50KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuZGlkQ29ubmVjdC5zdWJzY3JpYmUob25EaWRDb25uZWN0KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuZGlkRGlzY29ubmVjdC5zdWJzY3JpYmUob25EaWREaXNjb25uZWN0KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25Db25uZWN0aW9uRXJyb3Iuc3Vic2NyaWJlKCh7IG1lc3NhZ2UsIGNvZGUgfSkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGVycm9yMihcbiAgICAgICAgYENvbm5lY3Rpb24gdG8gd2Vic29ja2V0IHNlcnZlciBjbG9zZWQuIFJlYXNvbjogJHttZXNzYWdlfSAoY29kZTogJHtjb2RlfSkuYFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBjb25uZWN0SW5pdGlhbGx5KCkge1xuICAgIGlmIChtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpID09PSBcImluaXRpYWxcIikge1xuICAgICAgbWFuYWdlZFNvY2tldC5jb25uZWN0KCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHNlbmRDbGllbnRNc2dXaXRoUmVzcG9uc2UobXNnKSB7XG4gICAgY29ubmVjdEluaXRpYWxseSgpO1xuICAgIGlmIChtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBhd2FpdCBtYW5hZ2VkU29ja2V0LmV2ZW50cy5kaWRDb25uZWN0LndhaXRVbnRpbCgpO1xuICAgIH1cbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCk7XG4gICAgY29uc3QgYWJvcnRTaWduYWwgPSBBYm9ydFNpZ25hbC50aW1lb3V0KERFRkFVTFRfUkVRVUVTVF9USU1FT1VUKTtcbiAgICBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4gcmVqZWN0KGFib3J0U2lnbmFsLnJlYXNvbiksIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBjbWRJZCA9IG5hbm9pZCg3KTtcbiAgICBjb250ZXh0LnBlbmRpbmdDbWRzLnNldChjbWRJZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgc2VuZENsaWVudE1zZyh7IC4uLm1zZywgY21kSWQgfSk7XG4gICAgcmV0dXJuIHByb21pc2UuZmluYWxseSgoKSA9PiB7XG4gICAgICBjb250ZXh0LnBlbmRpbmdDbWRzLmRlbGV0ZShjbWRJZCk7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgZXJyb3IyKGVyci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZW5kQ2xpZW50TXNnKG1zZykge1xuICAgIG1hbmFnZWRTb2NrZXQuc2VuZChcbiAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgLi4ubXNnXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2hhdHMob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHNlbmRDbGllbnRNc2dXaXRoUmVzcG9uc2Uoe1xuICAgICAgY21kOiBcImdldC1jaGF0c1wiLFxuICAgICAgY3Vyc29yOiBvcHRpb25zLmN1cnNvcixcbiAgICAgIHF1ZXJ5OiBvcHRpb25zLnF1ZXJ5XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0T3JDcmVhdGVDaGF0KGlkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHNlbmRDbGllbnRNc2dXaXRoUmVzcG9uc2Uoe1xuICAgICAgY21kOiBcImdldC1vci1jcmVhdGUtY2hhdFwiLFxuICAgICAgaWQsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZVRyZWUoY2hhdElkKSB7XG4gICAgcmV0dXJuIHNlbmRDbGllbnRNc2dXaXRoUmVzcG9uc2Uoe1xuICAgICAgY21kOiBcImdldC1tZXNzYWdlLXRyZWVcIixcbiAgICAgIGNoYXRJZFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHNldFRvb2xSZXN1bHQoY2hhdElkLCBtZXNzYWdlSWQsIGludm9jYXRpb25JZCwgcmVzdWx0LCBvcHRpb25zKSB7XG4gICAgY29uc3Qga25vd2xlZGdlID0gY29udGV4dC5rbm93bGVkZ2VTdG9yZS5nZXRLbm93bGVkZ2VGb3JDaGF0KGNoYXRJZCk7XG4gICAgY29uc3QgdG9vbHMgPSBjb250ZXh0LnRvb2xzU3RvcmUuZ2V0VG9vbERlc2NyaXB0aW9ucyhjaGF0SWQpO1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBzZW5kQ2xpZW50TXNnV2l0aFJlc3BvbnNlKHtcbiAgICAgIGNtZDogXCJzZXQtdG9vbC1yZXN1bHRcIixcbiAgICAgIGNoYXRJZCxcbiAgICAgIG1lc3NhZ2VJZCxcbiAgICAgIGludm9jYXRpb25JZCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIGdlbmVyYXRpb25PcHRpb25zOiB7XG4gICAgICAgIGNvcGlsb3RJZDogb3B0aW9ucz8uY29waWxvdElkLFxuICAgICAgICBzdHJlYW06IG9wdGlvbnM/LnN0cmVhbSxcbiAgICAgICAgdGltZW91dDogb3B0aW9ucz8udGltZW91dCxcbiAgICAgICAgLy8gS25vd2xlZGdlIGFuZCB0b29scyBhcmVuJ3QgY29taW5nIGZyb20gdGhlIG9wdGlvbnMsIGJ1dCByZXRyaWV2ZWRcbiAgICAgICAgLy8gZnJvbSB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAgICAga25vd2xlZGdlOiBrbm93bGVkZ2UubGVuZ3RoID4gMCA/IGtub3dsZWRnZSA6IHZvaWQgMCxcbiAgICAgICAgdG9vbHM6IHRvb2xzLmxlbmd0aCA+IDAgPyB0b29scyA6IHZvaWQgMFxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyZXNwLm9rKSB7XG4gICAgICBtZXNzYWdlc1N0b3JlLm1hcmtNaW5lKHJlc3AubWVzc2FnZS5pZCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUJlZm9yZVVubG9hZCgpIHtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2VJZCBvZiBjb250ZXh0Lm1lc3NhZ2VzU3RvcmUuZ2V0QXV0b0V4ZWN1dGluZ01lc3NhZ2VJZHMoKSkge1xuICAgICAgc2VuZENsaWVudE1zZ1dpdGhSZXNwb25zZSh7IGNtZDogXCJhYm9ydC1haVwiLCBtZXNzYWdlSWQgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBoYW5kbGVCZWZvcmVVbmxvYWQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICBba0ludGVybmFsXToge1xuICAgICAgICBjb250ZXh0XG4gICAgICB9LFxuICAgICAgY29ubmVjdEluaXRpYWxseSxcbiAgICAgIC8vIHJlY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKSxcbiAgICAgIGRpc2Nvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQuZGlzY29ubmVjdCgpLFxuICAgICAgZ2V0Q2hhdHMsXG4gICAgICBnZXRPckNyZWF0ZUNoYXQsXG4gICAgICBkZWxldGVDaGF0OiAoY2hhdElkKSA9PiB7XG4gICAgICAgIHJldHVybiBzZW5kQ2xpZW50TXNnV2l0aFJlc3BvbnNlKHsgY21kOiBcImRlbGV0ZS1jaGF0XCIsIGNoYXRJZCB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRNZXNzYWdlVHJlZSxcbiAgICAgIGRlbGV0ZU1lc3NhZ2U6IChjaGF0SWQsIG1lc3NhZ2VJZCkgPT4gc2VuZENsaWVudE1zZ1dpdGhSZXNwb25zZSh7IGNtZDogXCJkZWxldGUtbWVzc2FnZVwiLCBjaGF0SWQsIG1lc3NhZ2VJZCB9KSxcbiAgICAgIGNsZWFyQ2hhdDogKGNoYXRJZCkgPT4gc2VuZENsaWVudE1zZ1dpdGhSZXNwb25zZSh7IGNtZDogXCJjbGVhci1jaGF0XCIsIGNoYXRJZCB9KSxcbiAgICAgIGFza1VzZXJNZXNzYWdlSW5DaGF0OiBhc3luYyAoY2hhdElkLCB1c2VyTWVzc2FnZSwgdGFyZ2V0TWVzc2FnZUlkLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGtub3dsZWRnZSA9IGNvbnRleHQua25vd2xlZGdlU3RvcmUuZ2V0S25vd2xlZGdlRm9yQ2hhdChjaGF0SWQpO1xuICAgICAgICBjb25zdCByZXF1ZXN0S25vd2xlZGdlID0gb3B0aW9ucz8ua25vd2xlZGdlIHx8IFtdO1xuICAgICAgICBjb25zdCBjb21iaW5lZEtub3dsZWRnZSA9IFsuLi5rbm93bGVkZ2UsIC4uLnJlcXVlc3RLbm93bGVkZ2VdO1xuICAgICAgICBjb25zdCB0b29scyA9IGNvbnRleHQudG9vbHNTdG9yZS5nZXRUb29sRGVzY3JpcHRpb25zKGNoYXRJZCk7XG4gICAgICAgIG1lc3NhZ2VzU3RvcmUubWFya01pbmUodGFyZ2V0TWVzc2FnZUlkKTtcbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHNlbmRDbGllbnRNc2dXaXRoUmVzcG9uc2Uoe1xuICAgICAgICAgIGNtZDogXCJhc2staW4tY2hhdFwiLFxuICAgICAgICAgIGNoYXRJZCxcbiAgICAgICAgICBzb3VyY2VNZXNzYWdlOiB1c2VyTWVzc2FnZSxcbiAgICAgICAgICB0YXJnZXRNZXNzYWdlSWQsXG4gICAgICAgICAgZ2VuZXJhdGlvbk9wdGlvbnM6IHtcbiAgICAgICAgICAgIGNvcGlsb3RJZDogb3B0aW9ucz8uY29waWxvdElkLFxuICAgICAgICAgICAgc3RyZWFtOiBvcHRpb25zPy5zdHJlYW0sXG4gICAgICAgICAgICB0aW1lb3V0OiBvcHRpb25zPy50aW1lb3V0LFxuICAgICAgICAgICAgLy8gQ29tYmluZSBnbG9iYWwga25vd2xlZGdlIHdpdGggcmVxdWVzdC1zcGVjaWZpYyBrbm93bGVkZ2VcbiAgICAgICAgICAgIGtub3dsZWRnZTogY29tYmluZWRLbm93bGVkZ2UubGVuZ3RoID4gMCA/IGNvbWJpbmVkS25vd2xlZGdlIDogdm9pZCAwLFxuICAgICAgICAgICAgdG9vbHM6IHRvb2xzLmxlbmd0aCA+IDAgPyB0b29scyA6IHZvaWQgMFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwO1xuICAgICAgfSxcbiAgICAgIGFib3J0OiAobWVzc2FnZUlkKSA9PiBzZW5kQ2xpZW50TXNnV2l0aFJlc3BvbnNlKHsgY21kOiBcImFib3J0LWFpXCIsIG1lc3NhZ2VJZCB9KSxcbiAgICAgIHNldFRvb2xSZXN1bHQsXG4gICAgICBnZXRTdGF0dXM6ICgpID0+IG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCksXG4gICAgICBzaWduYWxzOiB7XG4gICAgICAgIGdldENoYXRNZXNzYWdlc0ZvckJyYW5jaFxcdTAzQTM6IGNvbnRleHQubWVzc2FnZXNTdG9yZS5nZXRDaGF0TWVzc2FnZXNGb3JCcmFuY2hcXHUwM0EzLFxuICAgICAgICBnZXRUb29sXFx1MDNBMzogY29udGV4dC50b29sc1N0b3JlLmdldFRvb2xcXHUwM0EzLFxuICAgICAgICBzdGF0dXNcXHUwM0EzXG4gICAgICB9LFxuICAgICAgZ2V0Q2hhdEJ5SWQ6IGNvbnRleHQuY2hhdHNTdG9yZS5nZXRDaGF0QnlJZCxcbiAgICAgIHF1ZXJ5Q2hhdHM6IGNvbnRleHQuY2hhdHNTdG9yZS5maW5kTWFueSxcbiAgICAgIGdldExhc3RVc2VkQ29waWxvdElkOiBjb250ZXh0Lm1lc3NhZ2VzU3RvcmUuZ2V0TGFzdFVzZWRDb3BpbG90SWQsXG4gICAgICByZWdpc3Rlcktub3dsZWRnZUxheWVyOiAodW5pcXVlTGF5ZXJJZCwgY2hhdElkKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gY29udGV4dC5rbm93bGVkZ2VTdG9yZS5nZXRLbm93bGVkZ2VTdGFjayhjaGF0SWQpO1xuICAgICAgICBjb25zdCBsYXllcktleSA9IHN0YWNrLnJlZ2lzdGVyTGF5ZXIodW5pcXVlTGF5ZXJJZCk7XG4gICAgICAgIGNvbnN0IGRlcmVnaXN0ZXIgPSAoKSA9PiBzdGFjay5kZXJlZ2lzdGVyTGF5ZXIobGF5ZXJLZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxheWVyS2V5LFxuICAgICAgICAgIGRlcmVnaXN0ZXJcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVLbm93bGVkZ2U6IChsYXllcktleSwgZGF0YSwga2V5LCBjaGF0SWQpID0+IHtcbiAgICAgICAgY29udGV4dC5rbm93bGVkZ2VTdG9yZS5nZXRLbm93bGVkZ2VTdGFjayhjaGF0SWQpLnVwZGF0ZUtub3dsZWRnZShsYXllcktleSwga2V5ID8/IG5hbm9pZCgpLCBkYXRhKTtcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclRvb2w6IGNvbnRleHQudG9vbHNTdG9yZS5yZWdpc3RlclRvb2xcbiAgICB9LFxuICAgIGtJbnRlcm5hbCxcbiAgICB7IGVudW1lcmFibGU6IGZhbHNlIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIG1ha2VDcmVhdGVTb2NrZXREZWxlZ2F0ZUZvckFpKGJhc2VVcmwsIFdlYlNvY2tldFBvbHlmaWxsKSB7XG4gIHJldHVybiAoYXV0aFZhbHVlKSA9PiB7XG4gICAgY29uc3Qgd3MgPSBXZWJTb2NrZXRQb2x5ZmlsbCA/PyAodHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IFdlYlNvY2tldCk7XG4gICAgaWYgKHdzID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBwb2x5ZmlsbC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXJsMiA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgdXJsMi5wcm90b2NvbCA9IHVybDIucHJvdG9jb2wgPT09IFwiaHR0cDpcIiA/IFwid3NcIiA6IFwid3NzXCI7XG4gICAgdXJsMi5wYXRobmFtZSA9IFwiL2FpL3Y3XCI7XG4gICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tcIiwgYXV0aFZhbHVlLnRva2VuLnJhdyk7XG4gICAgfSBlbHNlIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHVibGljIGtleSBub3Qgc3VwcG9ydGVkIHdpdGggQUkgQ29waWxvdHNcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihhdXRoVmFsdWUsIFwiVW5oYW5kbGVkIGNhc2VcIik7XG4gICAgfVxuICAgIHVybDIuc2VhcmNoUGFyYW1zLnNldChcInZlcnNpb25cIiwgUEtHX1ZFUlNJT04gfHwgXCJkZXZcIik7XG4gICAgcmV0dXJuIG5ldyB3cyh1cmwyLnRvU3RyaW5nKCkpO1xuICB9O1xufVxuZnVuY3Rpb24gcmVwbGFjZU9yQXBwZW5kKGNvbnRlbnQsIG5ld0l0ZW0sIGtleUZuLCBub3cyKSB7XG4gIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBmaW5kTGFzdEluZGV4KFxuICAgIGNvbnRlbnQsXG4gICAgKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gbmV3SXRlbS50eXBlICYmIGtleUZuKGl0ZW0pID09PSBrZXlGbihuZXdJdGVtKVxuICApO1xuICBpZiAoZXhpc3RpbmdJbmRleCA+IC0xKSB7XG4gICAgY29udGVudFtleGlzdGluZ0luZGV4XSA9IG5ld0l0ZW07XG4gIH0gZWxzZSB7XG4gICAgY2xvc2VQYXJ0KGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSwgbm93Mik7XG4gICAgY29udGVudC5wdXNoKG5ld0l0ZW0pO1xuICB9XG59XG5mdW5jdGlvbiBjbG9zZVBhcnQocHJldlBhcnQsIGVuZGVkQXQpIHtcbiAgaWYgKHByZXZQYXJ0Py50eXBlID09PSBcInJlYXNvbmluZ1wiKSB7XG4gICAgcHJldlBhcnQuZW5kZWRBdCA/Pz0gZW5kZWRBdDtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hDb250ZW50V2l0aERlbHRhKGNvbnRlbnQsIGRlbHRhKSB7XG4gIGlmIChkZWx0YSA9PT0gbnVsbClcbiAgICByZXR1cm47XG4gIGNvbnN0IHBhcnRzID0gY29udGVudC5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJzb3VyY2VzXCJcbiAgKTtcbiAgY29uc3Qgc291cmNlcyA9IGNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwic291cmNlc1wiKS5mbGF0TWFwKChwYXJ0KSA9PiBwYXJ0LnNvdXJjZXMpO1xuICBjb25zdCBub3cyID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpO1xuICBjb25zdCBsYXN0UGFydCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICBzd2l0Y2ggKGRlbHRhLnR5cGUpIHtcbiAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgaWYgKGxhc3RQYXJ0Py50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICBsYXN0UGFydC50ZXh0ICs9IGRlbHRhLnRleHREZWx0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlUGFydChsYXN0UGFydCwgbm93Mik7XG4gICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiBcInRleHRcIiwgdGV4dDogZGVsdGEudGV4dERlbHRhIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJlYXNvbmluZy1kZWx0YVwiOlxuICAgICAgaWYgKGxhc3RQYXJ0Py50eXBlID09PSBcInJlYXNvbmluZ1wiKSB7XG4gICAgICAgIGxhc3RQYXJ0LnRleHQgKz0gZGVsdGEudGV4dERlbHRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VQYXJ0KGxhc3RQYXJ0LCBub3cyKTtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICB0ZXh0OiBkZWx0YS50ZXh0RGVsdGEsXG4gICAgICAgICAgc3RhcnRlZEF0OiBub3cyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRvb2wtc3RyZWFtXCI6IHtcbiAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uID0gY3JlYXRlUmVjZWl2aW5nVG9vbEludm9jYXRpb24oXG4gICAgICAgIGRlbHRhLmludm9jYXRpb25JZCxcbiAgICAgICAgZGVsdGEubmFtZVxuICAgICAgKTtcbiAgICAgIHBhcnRzLnB1c2godG9vbEludm9jYXRpb24pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ0b29sLWRlbHRhXCI6IHtcbiAgICAgIGlmIChsYXN0UGFydD8udHlwZSA9PT0gXCJ0b29sLWludm9jYXRpb25cIiAmJiBsYXN0UGFydC5zdGFnZSA9PT0gXCJyZWNlaXZpbmdcIikge1xuICAgICAgICBsYXN0UGFydC5fX2FwcGVuZERlbHRhPy4oZGVsdGEuZGVsdGEpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ0b29sLWludm9jYXRpb25cIjpcbiAgICAgIHJlcGxhY2VPckFwcGVuZChwYXJ0cywgZGVsdGEsICh4KSA9PiB4Lmludm9jYXRpb25JZCwgbm93Mik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmV0cmlldmFsXCI6XG4gICAgICByZXBsYWNlT3JBcHBlbmQocGFydHMsIGRlbHRhLCAoeCkgPT4geC5pZCwgbm93Mik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic291cmNlXCI6IHtcbiAgICAgIHNvdXJjZXMucHVzaChkZWx0YSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihkZWx0YSwgXCJVbmhhbmRsZWQgY2FzZVwiKTtcbiAgfVxuICBpZiAoc291cmNlcy5sZW5ndGggPiAwKSB7XG4gICAgcGFydHMucHVzaCh7XG4gICAgICB0eXBlOiBcInNvdXJjZXNcIixcbiAgICAgIHNvdXJjZXNcbiAgICB9KTtcbiAgfVxuICBjb250ZW50Lmxlbmd0aCA9IDA7XG4gIGNvbnRlbnQucHVzaCguLi5wYXJ0cyk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWNlaXZpbmdUb29sSW52b2NhdGlvbihpbnZvY2F0aW9uSWQsIG5hbWUsIHBhcnRpYWxBcmdzVGV4dCA9IFwiXCIpIHtcbiAgY29uc3QgcGFyc2VyID0gbmV3IEluY3JlbWVudGFsSnNvblBhcnNlcihwYXJ0aWFsQXJnc1RleHQpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9vbC1pbnZvY2F0aW9uXCIsXG4gICAgc3RhZ2U6IFwicmVjZWl2aW5nXCIsXG4gICAgaW52b2NhdGlvbklkLFxuICAgIG5hbWUsXG4gICAgLy8gLS0tIEFsdGVybmF0aXZlIGltcGxlbWVudGF0aW9uIGZvciBGUk9OVEVORCBvbmx5IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldCBwYXJ0aWFsQXJnc1RleHQoKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLnNvdXJjZTtcbiAgICB9LFxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCBwYXJ0aWFsQXJncygpIHtcbiAgICAgIHJldHVybiBwYXJzZXIuanNvbjtcbiAgICB9LFxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIF9fYXBwZW5kRGVsdGEoZGVsdGEpIHtcbiAgICAgIHBhcnNlci5hcHBlbmQoZGVsdGEpO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgfTtcbn1cblxuLy8gc3JjL2F1dGgtbWFuYWdlci50c1xudmFyIE5PTl9SRVRSWV9TVEFUVVNfQ09ERVMgPSBbXG4gIDQwMCxcbiAgNDAxLFxuICA0MDMsXG4gIDQwNCxcbiAgNDA1LFxuICA0MTAsXG4gIDQxMixcbiAgNDE0LFxuICA0MjIsXG4gIDQzMSxcbiAgNDUxXG5dO1xuZnVuY3Rpb24gY3JlYXRlQXV0aE1hbmFnZXIoYXV0aE9wdGlvbnMsIG9uQXV0aGVudGljYXRlKSB7XG4gIGNvbnN0IGF1dGhlbnRpY2F0aW9uID0gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKTtcbiAgY29uc3Qgc2VlblRva2VucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBjb25zdCBleHBpcnlUaW1lcyA9IFtdO1xuICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBzZWVuVG9rZW5zLmNsZWFyKCk7XG4gICAgdG9rZW5zLmxlbmd0aCA9IDA7XG4gICAgZXhwaXJ5VGltZXMubGVuZ3RoID0gMDtcbiAgICByZXF1ZXN0UHJvbWlzZXMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RlZFNjb3BlLCBzY29wZXMpIHtcbiAgICBpZiAocmVxdWVzdGVkU2NvcGUgPT09IFwiY29tbWVudHM6cmVhZFwiKSB7XG4gICAgICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6cmVhZFwiIC8qIENvbW1lbnRzUmVhZCAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6d3JpdGVcIiAvKiBDb21tZW50c1dyaXRlICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOnJlYWRcIiAvKiBSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdGVkU2NvcGUgPT09IFwicm9vbTpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOnJlYWRcIiAvKiBSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdE9wdGlvbnMpIHtcbiAgICBjb25zdCBub3cyID0gTWF0aC5jZWlsKERhdGUubm93KCkgLyAxZTMpO1xuICAgIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gZXhwaXJ5VGltZXNbaV07XG4gICAgICBpZiAoZXhwaXJlc0F0IDw9IG5vdzIpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXhwaXJ5VGltZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayA9PT0gXCJpZFwiIC8qIElEX1RPS0VOICovKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiYWNjXCIgLyogQUNDRVNTX1RPS0VOICovKSB7XG4gICAgICAgIGlmICghcmVxdWVzdE9wdGlvbnMucm9vbUlkICYmIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCBzY29wZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykpIHtcbiAgICAgICAgICBpZiAoIXJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICAgICAgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiByZXF1ZXN0T3B0aW9ucy5yb29tSWQuc3RhcnRzV2l0aChyZXNvdXJjZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSkgfHwgcmVxdWVzdE9wdGlvbnMucm9vbUlkID09PSByZXNvdXJjZSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFrZUF1dGhSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZXRjaGVyID0gYXV0aE9wdGlvbnMucG9seWZpbGxzPy5mZXRjaCA/PyAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHdpbmRvdy5mZXRjaCk7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICBpZiAoZmV0Y2hlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50IHdpdGggYSB1cmwgYXMgYXV0aCBlbmRwb2ludCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIGZldGNoIHBvbHlmaWxsLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQXV0aEVuZHBvaW50KGZldGNoZXIsIGF1dGhlbnRpY2F0aW9uLnVybCwge1xuICAgICAgICByb29tOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICBpZiAoc2VlblRva2Vucy5oYXMocGFyc2VkLnJhdykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIlRoZSBzYW1lIExpdmVibG9ja3MgYXV0aCB0b2tlbiB3YXMgaXNzdWVkIGZyb20gdGhlIGJhY2tlbmQgYmVmb3JlLiBDYWNoaW5nIExpdmVibG9ja3MgdG9rZW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG9uQXV0aGVudGljYXRlPy4ocGFyc2VkLnBhcnNlZCk7XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGlvbi5jYWxsYmFjayhvcHRpb25zLnJvb21JZCk7XG4gICAgICBpZiAocmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UudG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICAgICAgb25BdXRoZW50aWNhdGU/LihwYXJzZWQucGFyc2VkKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5lcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7XCJyZWFzb25cIiBpbiByZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UucmVhc29uID09PSBcInN0cmluZ1wiID8gcmVzcG9uc2UucmVhc29uIDogXCJGb3JiaWRkZW5cIn1gO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvciA9PT0gXCJmb3JiaWRkZW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhyZWFzb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1lvdXIgYXV0aGVudGljYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIHRva2VuLCBidXQgaXQgZGlkIG5vdC4gSGludDogdGhlIHJldHVybiB2YWx1ZSBzaG91bGQgbG9vayBsaWtlOiB7IHRva2VuOiBcIi4uLlwiIH0nXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlVuZXhwZWN0ZWQgYXV0aGVudGljYXRpb24gdHlwZS4gTXVzdCBiZSBwcml2YXRlIG9yIGN1c3RvbS5cIlxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFZhbHVlKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwicHVibGljXCIsIHB1YmxpY0FwaUtleTogYXV0aGVudGljYXRpb24ucHVibGljQXBpS2V5IH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZFRva2VuID0gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdE9wdGlvbnMpO1xuICAgIGlmIChjYWNoZWRUb2tlbiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInNlY3JldFwiLCB0b2tlbjogY2FjaGVkVG9rZW4gfTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRQcm9taXNlO1xuICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVxdWVzdFByb21pc2VzLmdldChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpO1xuICAgICAgaWYgKGN1cnJlbnRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgY3VycmVudFByb21pc2UgPSBtYWtlQXV0aFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuc2V0KHJlcXVlc3RPcHRpb25zLnJvb21JZCwgY3VycmVudFByb21pc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlcy5nZXQoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIik7XG4gICAgICBpZiAoY3VycmVudFByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBjdXJyZW50UHJvbWlzZSA9IG1ha2VBdXRoUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5zZXQoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIiwgY3VycmVudFByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBjdXJyZW50UHJvbWlzZTtcbiAgICAgIGNvbnN0IEJVRkZFUiA9IDMwO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSArICh0b2tlbi5wYXJzZWQuZXhwIC0gdG9rZW4ucGFyc2VkLmlhdCkgLSBCVUZGRVI7XG4gICAgICBzZWVuVG9rZW5zLmFkZCh0b2tlbi5yYXcpO1xuICAgICAgaWYgKHRva2VuLnBhcnNlZC5rICE9PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgZXhwaXJ5VGltZXMucHVzaChleHBpcmVzQXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW4gfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKHJlcXVlc3RPcHRpb25zLnJvb21JZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc2V0LFxuICAgIGdldEF1dGhWYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKSB7XG4gIGNvbnN0IHsgcHVibGljQXBpS2V5LCBhdXRoRW5kcG9pbnQgfSA9IGF1dGhPcHRpb25zO1xuICBpZiAoYXV0aEVuZHBvaW50ICE9PSB2b2lkIDAgJiYgcHVibGljQXBpS2V5ICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgdXNlIGBwdWJsaWNBcGlLZXlgIGFuZCBgYXV0aEVuZHBvaW50YCBvcHRpb25zLiBQbGVhc2UgcGljayBvbmUgYW5kIGxlYXZlIHRoZSBvdGhlciBvcHRpb24gdW5zcGVjaWZpZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFwiXG4gICAgKTtcbiAgfVxuICBpZiAodHlwZW9mIHB1YmxpY0FwaUtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChwdWJsaWNBcGlLZXkuc3RhcnRzV2l0aChcInNrX1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgYHB1YmxpY0FwaUtleWAgb3B0aW9uLiBUaGUgdmFsdWUgeW91IHBhc3NlZCBpcyBhIHNlY3JldCBrZXksIHdoaWNoIHNob3VsZCBub3QgYmUgdXNlZCBmcm9tIHRoZSBjbGllbnQuIFBsZWFzZSBvbmx5IGV2ZXIgcGFzcyBhIHB1YmxpYyBrZXkgaGVyZS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghcHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJwa19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGtleS4gUGxlYXNlIHVzZSB0aGUgcHVibGljIGtleSBmb3JtYXQ6IHBrXzxwdWJsaWMga2V5Pi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInB1YmxpY1wiLFxuICAgICAgcHVibGljQXBpS2V5XG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInByaXZhdGVcIixcbiAgICAgIHVybDogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXV0aEVuZHBvaW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjdXN0b21cIixcbiAgICAgIGNhbGxiYWNrOiBhdXRoRW5kcG9pbnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgYGF1dGhFbmRwb2ludGAgb3B0aW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50QXV0aEVuZHBvaW50XCJcbiAgICApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBcIkludmFsaWQgTGl2ZWJsb2NrcyBjbGllbnQgb3B0aW9ucy4gUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgYHB1YmxpY0FwaUtleWAgb3IgYGF1dGhFbmRwb2ludGAgb3B0aW9uLiBUaGV5IGNhbm5vdCBib3RoIGJlIGVtcHR5LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBdXRoRW5kcG9pbnQoZmV0Y2gsIGVuZHBvaW50LCBib2R5KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgYm9keTogc3RyaW5naWZ5T3JMb2coYm9keSlcbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgY29uc3QgcmVhc29uID0gYCR7KGF3YWl0IHJlcy50ZXh0KCkpLnRyaW0oKSB8fCBcInJlYXNvbiBub3QgcHJvdmlkZWQgaW4gYXV0aCByZXNwb25zZVwifSAoJHtyZXMuc3RhdHVzfSByZXR1cm5lZCBieSBQT1NUICR7ZW5kcG9pbnR9KWA7XG4gICAgaWYgKE5PTl9SRVRSWV9TVEFUVVNfQ09ERVMuaW5jbHVkZXMocmVzLnN0YXR1cykpIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoYFVuYXV0aG9yaXplZDogJHtyZWFzb259YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZTogJHtyZWFzb259YCk7XG4gICAgfVxuICB9XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIEpTT04gcmVzcG9uc2Ugd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIuICR7U3RyaW5nKFxuICAgICAgICBlclxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkgfHwgdHlwZW9mIGRhdGEudG9rZW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIG9mIHRoZSBmb3JtIFxcYHsgdG9rZW46IFwiLi4uXCIgfVxcYCB3aGVuIGRvaW5nIGEgUE9TVCByZXF1ZXN0IG9uIFwiJHtlbmRwb2ludH1cIiwgYnV0IGdvdCAke3N0cmluZ2lmeU9yTG9nKFxuICAgICAgICBkYXRhXG4gICAgICApfWBcbiAgICApO1xuICB9XG4gIGNvbnN0IHsgdG9rZW4gfSA9IGRhdGE7XG4gIHJldHVybiB7IHRva2VuIH07XG59XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBERUZBVUxUX0JBU0VfVVJMID0gXCJodHRwczovL2FwaS5saXZlYmxvY2tzLmlvXCI7XG52YXIgTUVOVElPTl9DSEFSQUNURVIgPSBcIkBcIjtcblxuLy8gc3JjL2RldnRvb2xzL2JyaWRnZS50c1xudmFyIF9icmlkZ2VBY3RpdmUgPSBmYWxzZTtcbmZ1bmN0aW9uIGFjdGl2YXRlQnJpZGdlKGFsbG93ZWQpIHtcbiAgX2JyaWRnZUFjdGl2ZSA9IGFsbG93ZWQ7XG59XG5mdW5jdGlvbiBzZW5kVG9QYW5lbChtZXNzYWdlLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmdWxsTXNnID0ge1xuICAgIC4uLm1lc3NhZ2UsXG4gICAgc291cmNlOiBcImxpdmVibG9ja3MtZGV2dG9vbHMtY2xpZW50XCJcbiAgfTtcbiAgaWYgKCEob3B0aW9ucz8uZm9yY2UgfHwgX2JyaWRnZUFjdGl2ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LnBvc3RNZXNzYWdlKGZ1bGxNc2csIFwiKlwiKTtcbn1cbnZhciBldmVudFNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQuc291cmNlID09PSB3aW5kb3cgJiYgZXZlbnQuZGF0YT8uc291cmNlID09PSBcImxpdmVibG9ja3MtZGV2dG9vbHMtcGFuZWxcIikge1xuICAgICAgZXZlbnRTb3VyY2Uubm90aWZ5KGV2ZW50LmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgfVxuICB9KTtcbn1cbnZhciBvbk1lc3NhZ2VGcm9tUGFuZWwgPSBldmVudFNvdXJjZS5vYnNlcnZhYmxlO1xuXG4vLyBzcmMvZGV2dG9vbHMvaW5kZXgudHNcbnZhciBWRVJTSU9OID0gUEtHX1ZFUlNJT04gfHwgXCJkZXZcIjtcbnZhciBfZGV2dG9vbHNTZXR1cEhhc1J1biA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBEZXZUb29scyhnZXRBbGxSb29tcykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKF9kZXZ0b29sc1NldHVwSGFzUnVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gdHJ1ZTtcbiAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgc3dpdGNoIChtc2cubXNnKSB7XG4gICAgICAvLyBXaGVuIGEgZGV2dG9vbCBwYW5lbCBzZW5kcyBhbiBleHBsaWNpdCBcImNvbm5lY3RcIiBtZXNzYWdlIGJhY2sgdG8gdGhpc1xuICAgICAgLy8gbGl2ZSBydW5uaW5nIGNsaWVudCAoaW4gcmVzcG9uc2UgdG8gdGhlIFwid2FrZS11cC1kZXZ0b29sc1wiIG1lc3NhZ2UsXG4gICAgICAvLyBvciB3aGVuIHRoZSBkZXZ0b29sIHBhbmVsIGlzIG9wZW5lZCBmb3IgdGhlIGZpcnN0IHRpbWUpLCBpdCBtZWFucyB0aGF0IGl0J3Mgb2theSB0b1xuICAgICAgLy8gc3RhcnQgZW1pdHRpbmcgbWVzc2FnZXMuXG4gICAgICAvLyBCZWZvcmUgdGhpcyBleHBsaWNpdCBhY2tub3dsZWRnZW1lbnQsIGFueSBjYWxsIHRvIHNlbmRUb1BhbmVsKCkgd2lsbFxuICAgICAgLy8gYmUgYSBuby1vcC5cbiAgICAgIGNhc2UgXCJjb25uZWN0XCI6IHtcbiAgICAgICAgYWN0aXZhdGVCcmlkZ2UodHJ1ZSk7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbUlkIG9mIGdldEFsbFJvb21zKCkpIHtcbiAgICAgICAgICBzZW5kVG9QYW5lbCh7XG4gICAgICAgICAgICBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICBjbGllbnRWZXJzaW9uOiBWRVJTSU9OXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwid2FrZS11cC1kZXZ0b29sc1wiIH0sIHsgZm9yY2U6IHRydWUgfSk7XG59XG52YXIgdW5zdWJzQnlSb29tSWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFN5bmNTdHJlYW0ocm9vbUlkKSB7XG4gIGNvbnN0IHVuc3VicyA9IHVuc3Vic0J5Um9vbUlkLmdldChyb29tSWQpID8/IFtdO1xuICB1bnN1YnNCeVJvb21JZC5kZWxldGUocm9vbUlkKTtcbiAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICB1bnN1YigpO1xuICB9XG59XG5mdW5jdGlvbiBzdGFydFN5bmNTdHJlYW0ocm9vbSkge1xuICBzdG9wU3luY1N0cmVhbShyb29tLmlkKTtcbiAgZnVsbFN5bmMocm9vbSk7XG4gIHVuc3Vic0J5Um9vbUlkLnNldChyb29tLmlkLCBbXG4gICAgLy8gV2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlc1xuICAgIHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pKSxcbiAgICAvLyBXaGVuIHN0b3JhZ2UgaW5pdGlhbGl6ZXMsIHNlbmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2UoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBzdG9yYWdlIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyBzdG9yYWdlIHJvb3RcbiAgICByb29tLmV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSksXG4gICAgLy8gQW55IHRpbWUgXCJtZVwiIG9yIFwib3RoZXJzXCIgdXBkYXRlcywgc2VuZCB0aGUgbmV3IHZhbHVlcyBhY2NvcmRpbmdseVxuICAgIHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jTWUocm9vbSkpLFxuICAgIHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNPdGhlcnMocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIHlkb2MgaXMgdXBkYXRlZCwgZm9yd2FyZCB0aGUgdXBkYXRlXG4gICAgcm9vbS5ldmVudHMueWRvYy5zdWJzY3JpYmUoKHVwZGF0ZSkgPT4gc3luY1lkb2NVcGRhdGUocm9vbSwgdXBkYXRlKSksXG4gICAgLy8gQW55IHRpbWUgYSBjdXN0b20gcm9vbSBldmVudCBpcyByZWNlaXZlZCwgZm9yd2FyZCBpdFxuICAgIHJvb20uZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgIChldmVudERhdGEpID0+IGZvcndhcmRFdmVudChyb29tLCBldmVudERhdGEpXG4gICAgKVxuICBdKTtcbn1cbmZ1bmN0aW9uIHN5bmNZZG9jVXBkYXRlKHJvb20sIHVwZGF0ZSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6Onlkb2NcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgdXBkYXRlXG4gIH0pO1xufVxudmFyIGxvYWRlZEF0ID0gRGF0ZS5ub3coKTtcbnZhciBldmVudENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gbmV4dEV2ZW50SWQoKSB7XG4gIHJldHVybiBgZXZlbnQtJHtsb2FkZWRBdH0tJHtldmVudENvdW50ZXIrK31gO1xufVxuZnVuY3Rpb24gZm9yd2FyZEV2ZW50KHJvb20sIGV2ZW50RGF0YSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OmV2ZW50czo6Y3VzdG9tLWV2ZW50XCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBcIkN1c3RvbUV2ZW50XCIsXG4gICAgICBpZDogbmV4dEV2ZW50SWQoKSxcbiAgICAgIGtleTogXCJFdmVudFwiLFxuICAgICAgY29ubmVjdGlvbklkOiBldmVudERhdGEuY29ubmVjdGlvbklkLFxuICAgICAgcGF5bG9hZDogZXZlbnREYXRhLmV2ZW50XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jQ29ubmVjdGlvbihyb29tKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBzdGF0dXM6IHJvb20uZ2V0U3RhdHVzKClcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkge1xuICBjb25zdCByb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgaWYgKHJvb3QpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgc3RvcmFnZTogcm9vdC50b1RyZWVOb2RlKFwicm9vdFwiKS5wYXlsb2FkXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jTWUocm9vbSkge1xuICBjb25zdCBtZSA9IHJvb21ba0ludGVybmFsXS5nZXRTZWxmX2ZvckRldlRvb2xzKCk7XG4gIGlmIChtZSkge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBtZVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY090aGVycyhyb29tKSB7XG4gIGNvbnN0IG90aGVycyA9IHJvb21ba0ludGVybmFsXS5nZXRPdGhlcnNfZm9yRGV2VG9vbHMoKTtcbiAgaWYgKG90aGVycykge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBvdGhlcnNcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZnVsbFN5bmMocm9vbSkge1xuICBjb25zdCByb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgY29uc3QgbWUgPSByb29tW2tJbnRlcm5hbF0uZ2V0U2VsZl9mb3JEZXZUb29scygpO1xuICBjb25zdCBvdGhlcnMgPSByb29tW2tJbnRlcm5hbF0uZ2V0T3RoZXJzX2ZvckRldlRvb2xzKCk7XG4gIHJvb20uZmV0Y2hZRG9jKFwiXCIpO1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6OmZ1bGxcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgc3RhdHVzOiByb29tLmdldFN0YXR1cygpLFxuICAgIHN0b3JhZ2U6IHJvb3Q/LnRvVHJlZU5vZGUoXCJyb290XCIpLnBheWxvYWQgPz8gbnVsbCxcbiAgICBtZSxcbiAgICBvdGhlcnNcbiAgfSk7XG59XG52YXIgcm9vbUNoYW5uZWxMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKSB7XG4gIGNvbnN0IGxpc3RlbmVyID0gcm9vbUNoYW5uZWxMaXN0ZW5lcnMuZ2V0KHJvb21JZCk7XG4gIHJvb21DaGFubmVsTGlzdGVuZXJzLmRlbGV0ZShyb29tSWQpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcigpO1xuICB9XG59XG5mdW5jdGlvbiBsaW5rRGV2VG9vbHMocm9vbUlkLCByb29tKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBzZW5kVG9QYW5lbCh7IG1zZzogXCJyb29tOjphdmFpbGFibGVcIiwgcm9vbUlkLCBjbGllbnRWZXJzaW9uOiBWRVJTSU9OIH0pO1xuICBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpO1xuICByb29tQ2hhbm5lbExpc3RlbmVycy5zZXQoXG4gICAgcm9vbUlkLFxuICAgIC8vIFJldHVybnMgdGhlIHVuc3Vic2NyaWJlIGNhbGxiYWNrLCB0aGF0IHdlIHN0b3JlIGluIHRoZVxuICAgIC8vIHJvb21DaGFubmVsTGlzdGVuZXJzIHJlZ2lzdHJ5XG4gICAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgICAgLy8gU2VudCBieSB0aGUgZGV2dG9vbCBwYW5lbCB3aGVuIGl0IHdhbnRzIHRvIHJlY2VpdmUgdGhlIHN5bmMgc3RyZWFtXG4gICAgICAgIC8vIGZvciBhIHJvb21cbiAgICAgICAgY2FzZSBcInJvb206OnN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgaWYgKG1zZy5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgc3RhcnRTeW5jU3RyZWFtKHJvb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicm9vbTo6dW5zdWJzY3JpYmVcIjoge1xuICAgICAgICAgIGlmIChtc2cucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgIHN0b3BTeW5jU3RyZWFtKHJvb21JZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHVubGlua0RldlRvb2xzKHJvb21JZCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RvcFN5bmNTdHJlYW0ocm9vbUlkKTtcbiAgc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKTtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjp1bmF2YWlsYWJsZVwiLFxuICAgIHJvb21JZFxuICB9KTtcbn1cblxuLy8gc3JjL2xpYi93YXJuaW5ncy50c1xudmFyIF9lbWl0dGVkV2FybmluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSwga2V5ID0gbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFfZW1pdHRlZFdhcm5pbmdzLmhhcyhrZXkpKSB7XG4gICAgICBfZW1pdHRlZFdhcm5pbmdzLmFkZChrZXkpO1xuICAgICAgd2FybihtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5PbmNlSWYoY29uZGl0aW9uLCBtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgY29uZGl0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBjb25kaXRpb24oKSA6IGNvbmRpdGlvbikge1xuICAgIHdhcm5PbmNlKG1lc3NhZ2UsIGtleSk7XG4gIH1cbn1cblxuLy8gc3JjL3Byb3RvY29sL05vdGlmaWNhdGlvblNldHRpbmdzLnRzXG52YXIga1BsYWluID0gU3ltYm9sKFwibm90aWZpY2F0aW9uLXNldHRpbmdzLXBsYWluXCIpO1xuZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MocGxhaW4pIHtcbiAgY29uc3QgY2hhbm5lbHMgPSBbXG4gICAgXCJlbWFpbFwiLFxuICAgIFwic2xhY2tcIixcbiAgICBcInRlYW1zXCIsXG4gICAgXCJ3ZWJQdXNoXCJcbiAgXTtcbiAgY29uc3QgZGVzY3JpcHRvcnMgPSB7XG4gICAgW2tQbGFpbl06IHtcbiAgICAgIHZhbHVlOiBwbGFpbixcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfVxuICB9O1xuICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgY2hhbm5lbHMpIHtcbiAgICBkZXNjcmlwdG9yc1tjaGFubmVsXSA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAvKipcbiAgICAgICAqIEluIHRoZSBUeXBlU2NyaXB0IHN0YW5kYXJkIGxpYnJhcnkgZGVmaW5pdGlvbnMsIHRoZSBidWlsdC1pbiBpbnRlcmZhY2UgZm9yIGEgcHJvcGVydHkgZGVzY3JpcHRvclxuICAgICAgICogZG9lcyBub3QgaW5jbHVkZSBhIHNwZWNpYWxpemVkIHR5cGUgZm9yIHRoZSDigJx0aGlz4oCdIGNvbnRleHQgaW4gdGhlIGdldHRlciBvciBzZXR0ZXIgZnVuY3Rpb25zLlxuICAgICAgICogQXMgYSByZXN1bHQsIGJvdGggdGhlIOKBoGdldCBhbmQg4oGgc2V0IG1ldGhvZHMgaW1wbGljaXRseSBoYXZlIOKBoHRoaXM6IGFueS5cbiAgICAgICAqIFRoZSByZWFzb24gaXMgdGhhdCBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBpbiBKYXZhU2NyaXB0IGFyZSB1c2VkIGFjcm9zcyB2YXJpb3VzIG9iamVjdHMgd2l0aFxuICAgICAgICogbm8gZW5mb3JjZWQgc2hhcGUgZm9yIOKBoHRoaXMuIEFuZCBzbyB0aGUgc3RhbmRhcmQgbGlicmFyeSBkZWZpbml0aW9ucyBoYXZlIHRvIHJlbWFpbiBhcyBicm9hZCBhcyBwb3NzaWJsZVxuICAgICAgICogdG8gc3VwcG9ydCBhbnkgdmFsaWQgSmF2YVNjcmlwdCB1c2FnZSAoZS5nIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgKS5cbiAgICAgICAqXG4gICAgICAgKiBTbyB3ZSBjYW4gc2FmZWx5IHRlbGxzIHRoYXQgdGhpcyBnZXR0ZXIgaXMgdHlwZWQgYXMgYHRoaXM6IE5vdGlmaWNhdGlvblNldHRpbmdzYCBiZWNhdXNlIHdlJ3JlXG4gICAgICAgKiBjcmVhdGluZyBhIHdlbGwga25vd24gc2hhcGVkIG9iamVjdCDihpIgYE5vdGlmaWNhdGlvblNldHRpbmdzYC5cbiAgICAgICAqL1xuICAgICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNba1BsYWluXVtjaGFubmVsXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGVycm9yMihcbiAgICAgICAgICAgIGBJbiBvcmRlciB0byB1c2UgdGhlICcke2NoYW5uZWx9JyBjaGFubmVsLCBwbGVhc2Ugc2V0IHVwIHlvdXIgcHJvamVjdCBmaXJzdC4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9lbmFibGUtYS1ub3RpZmljYXRpb24tY2hhbm5lbGBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBjcmVhdGUobnVsbCwgZGVzY3JpcHRvcnMpO1xufVxuZnVuY3Rpb24gcGF0Y2hOb3RpZmljYXRpb25TZXR0aW5ncyhleGlzdGluZywgcGF0Y2gpIHtcbiAgY29uc3Qgb3V0Y29taW5nID0gY3JlYXRlTm90aWZpY2F0aW9uU2V0dGluZ3Moe1xuICAgIC4uLmV4aXN0aW5nW2tQbGFpbl1cbiAgfSk7XG4gIGZvciAoY29uc3QgY2hhbm5lbCBvZiBrZXlzKHBhdGNoKSkge1xuICAgIGNvbnN0IHVwZGF0ZXMgPSBwYXRjaFtjaGFubmVsXTtcbiAgICBpZiAodXBkYXRlcyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBraW5kVXBkYXRlcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgZW50cmllcyh1cGRhdGVzKS5maWx0ZXIoKFssIHZhbHVlXSkgPT4gdmFsdWUgIT09IHZvaWQgMClcbiAgICAgICk7XG4gICAgICBvdXRjb21pbmdba1BsYWluXVtjaGFubmVsXSA9IHtcbiAgICAgICAgLi4ub3V0Y29taW5nW2tQbGFpbl1bY2hhbm5lbF0sXG4gICAgICAgIC4uLmtpbmRVcGRhdGVzXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0Y29taW5nO1xufVxuZnVuY3Rpb24gaXNOb3RpZmljYXRpb25DaGFubmVsRW5hYmxlZChzZXR0aW5ncykge1xuICByZXR1cm4gc2V0dGluZ3MgIT09IG51bGwgPyB2YWx1ZXMoc2V0dGluZ3MpLmV2ZXJ5KChlbmFibGVkKSA9PiBlbmFibGVkID09PSB0cnVlKSA6IGZhbHNlO1xufVxuXG4vLyBzcmMvbGliL3Bvc2l0aW9uLnRzXG52YXIgTUlOX0NPREUgPSAzMjtcbnZhciBNQVhfQ09ERSA9IDEyNjtcbnZhciBOVU1fRElHSVRTID0gTUFYX0NPREUgLSBNSU5fQ09ERSArIDE7XG52YXIgWkVSTyA9IG50aERpZ2l0KDApO1xudmFyIE9ORSA9IG50aERpZ2l0KDEpO1xudmFyIFpFUk9fTklORSA9IFpFUk8gKyBudGhEaWdpdCgtMSk7XG5mdW5jdGlvbiBudGhEaWdpdChuKSB7XG4gIGNvbnN0IGNvZGUgPSBNSU5fQ09ERSArIChuIDwgMCA/IE5VTV9ESUdJVFMgKyBuIDogbik7XG4gIGlmIChjb2RlIDwgTUlOX0NPREUgfHwgY29kZSA+IE1BWF9DT0RFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG4gdmFsdWU6ICR7bn1gKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbn1cbmZ1bmN0aW9uIG1ha2VQb3NpdGlvbih4LCB5KSB7XG4gIGlmICh4ICE9PSB2b2lkIDAgJiYgeSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGJldHdlZW4oeCwgeSk7XG4gIH0gZWxzZSBpZiAoeCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGFmdGVyKHgpO1xuICB9IGVsc2UgaWYgKHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZWZvcmUoeSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9ORTtcbiAgfVxufVxuZnVuY3Rpb24gYmVmb3JlKHBvcykge1xuICBjb25zdCBsYXN0SW5kZXggPSBwb3MubGVuZ3RoIC0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdEluZGV4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gcG9zLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPD0gTUlOX0NPREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gbGFzdEluZGV4KSB7XG4gICAgICBpZiAoY29kZSA9PT0gTUlOX0NPREUgKyAxKSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgWkVST19OSU5FO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSArIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT05FO1xufVxuZnVuY3Rpb24gYWZ0ZXIocG9zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHBvcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gcG9zLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPj0gTUFYX0NPREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSArIDEpO1xuICB9XG4gIHJldHVybiBwb3MgKyBPTkU7XG59XG5mdW5jdGlvbiBiZXR3ZWVuKGxvLCBoaSkge1xuICBpZiAobG8gPCBoaSkge1xuICAgIHJldHVybiBfYmV0d2VlbihsbywgaGkpO1xuICB9IGVsc2UgaWYgKGxvID4gaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4oaGksIGxvKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSB2YWx1ZSBiZXR3ZWVuIHR3byBlcXVhbCBwb3NpdGlvbnNcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9iZXR3ZWVuKGxvLCBoaSkge1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBsb0xlbiA9IGxvLmxlbmd0aDtcbiAgY29uc3QgaGlMZW4gPSBoaS5sZW5ndGg7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbG9Db2RlID0gaW5kZXggPCBsb0xlbiA/IGxvLmNoYXJDb2RlQXQoaW5kZXgpIDogTUlOX0NPREU7XG4gICAgY29uc3QgaGlDb2RlID0gaW5kZXggPCBoaUxlbiA/IGhpLmNoYXJDb2RlQXQoaW5kZXgpIDogTUFYX0NPREU7XG4gICAgaWYgKGxvQ29kZSA9PT0gaGlDb2RlKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChoaUNvZGUgLSBsb0NvZGUgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBpbmRleCArIDE7XG4gICAgICBsZXQgcHJlZml4ID0gbG8uc3Vic3RyaW5nKDAsIHNpemUpO1xuICAgICAgaWYgKHByZWZpeC5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIHByZWZpeCArPSBaRVJPLnJlcGVhdChzaXplIC0gcHJlZml4Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWZmaXggPSBsby5zdWJzdHJpbmcoc2l6ZSk7XG4gICAgICBjb25zdCBuaW5lcyA9IFwiXCI7XG4gICAgICByZXR1cm4gcHJlZml4ICsgX2JldHdlZW4oc3VmZml4LCBuaW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0YWtlTihsbywgaW5kZXgpICsgU3RyaW5nLmZyb21DaGFyQ29kZShoaUNvZGUgKyBsb0NvZGUgPj4gMSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0YWtlTihwb3MsIG4pIHtcbiAgcmV0dXJuIG4gPCBwb3MubGVuZ3RoID8gcG9zLnN1YnN0cmluZygwLCBuKSA6IHBvcyArIFpFUk8ucmVwZWF0KG4gLSBwb3MubGVuZ3RoKTtcbn1cbnZhciBNSU5fTk9OX1pFUk9fQ09ERSA9IE1JTl9DT0RFICsgMTtcbmZ1bmN0aW9uIGlzUG9zKHN0cikge1xuICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxhc3RJZHggPSBzdHIubGVuZ3RoIC0gMTtcbiAgY29uc3QgbGFzdCA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJZHgpO1xuICBpZiAobGFzdCA8IE1JTl9OT05fWkVST19DT0RFIHx8IGxhc3QgPiBNQVhfQ09ERSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJZHg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1BvcyhzdHIpIHtcbiAgY29uc3QgY29kZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgY29kZXMucHVzaChjb2RlIDwgTUlOX0NPREUgPyBNSU5fQ09ERSA6IGNvZGUgPiBNQVhfQ09ERSA/IE1BWF9DT0RFIDogY29kZSk7XG4gIH1cbiAgd2hpbGUgKGNvZGVzLmxlbmd0aCA+IDAgJiYgY29kZXNbY29kZXMubGVuZ3RoIC0gMV0gPT09IE1JTl9DT0RFKSB7XG4gICAgY29kZXMubGVuZ3RoLS07XG4gIH1cbiAgcmV0dXJuIGNvZGVzLmxlbmd0aCA+IDAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmNvZGVzKSA6IChcbiAgICAvLyBFZGdlIGNhc2U6IHRoZSBzdHIgd2FzIGEgMC1vbmx5IHN0cmluZywgd2hpY2ggaXMgaW52YWxpZC4gRGVmYXVsdCBiYWNrIHRvIC4xXG4gICAgT05FXG4gICk7XG59XG5mdW5jdGlvbiBhc1BvcyhzdHIpIHtcbiAgcmV0dXJuIGlzUG9zKHN0cikgPyBzdHIgOiBjb252ZXJ0VG9Qb3Moc3RyKTtcbn1cblxuLy8gc3JjL3Byb3RvY29sL09wLnRzXG52YXIgT3BDb2RlID0gLyogQF9fUFVSRV9fICovICgoT3BDb2RlMikgPT4ge1xuICBPcENvZGUyW09wQ29kZTJbXCJJTklUXCJdID0gMF0gPSBcIklOSVRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiU0VUX1BBUkVOVF9LRVlcIl0gPSAxXSA9IFwiU0VUX1BBUkVOVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX0xJU1RcIl0gPSAyXSA9IFwiQ1JFQVRFX0xJU1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiVVBEQVRFX09CSkVDVFwiXSA9IDNdID0gXCJVUERBVEVfT0JKRUNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9PQkpFQ1RcIl0gPSA0XSA9IFwiQ1JFQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJERUxFVEVfQ1JEVFwiXSA9IDVdID0gXCJERUxFVEVfQ1JEVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJERUxFVEVfT0JKRUNUX0tFWVwiXSA9IDZdID0gXCJERUxFVEVfT0JKRUNUX0tFWVwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfTUFQXCJdID0gN10gPSBcIkNSRUFURV9NQVBcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX1JFR0lTVEVSXCJdID0gOF0gPSBcIkNSRUFURV9SRUdJU1RFUlwiO1xuICByZXR1cm4gT3BDb2RlMjtcbn0pKE9wQ29kZSB8fCB7fSk7XG5mdW5jdGlvbiBhY2tPcChvcElkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICBpZDogXCJBQ0tcIixcbiAgICAvLyAoSClBQ0tcbiAgICBvcElkXG4gIH07XG59XG5mdW5jdGlvbiBpc0Fja09wKG9wKSB7XG4gIHJldHVybiBvcC50eXBlID09PSA1IC8qIERFTEVURV9DUkRUICovICYmIG9wLmlkID09PSBcIkFDS1wiO1xufVxuXG4vLyBzcmMvY3JkdHMvQWJzdHJhY3RDcmR0LnRzXG5mdW5jdGlvbiBjcmVhdGVNYW5hZ2VkUG9vbChyb29tSWQsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGdldEN1cnJlbnRDb25uZWN0aW9uSWQsXG4gICAgb25EaXNwYXRjaCxcbiAgICBpc1N0b3JhZ2VXcml0YWJsZSA9ICgpID0+IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCBjbG9jayA9IDA7XG4gIGxldCBvcENsb2NrID0gMDtcbiAgY29uc3Qgbm9kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4ge1xuICAgIHJvb21JZCxcbiAgICBub2RlcyxcbiAgICBnZXROb2RlOiAoaWQpID0+IG5vZGVzLmdldChpZCksXG4gICAgYWRkTm9kZTogKGlkLCBub2RlKSA9PiB2b2lkIG5vZGVzLnNldChpZCwgbm9kZSksXG4gICAgZGVsZXRlTm9kZTogKGlkKSA9PiB2b2lkIG5vZGVzLmRlbGV0ZShpZCksXG4gICAgZ2VuZXJhdGVJZDogKCkgPT4gYCR7Z2V0Q3VycmVudENvbm5lY3Rpb25JZCgpfToke2Nsb2NrKyt9YCxcbiAgICBnZW5lcmF0ZU9wSWQ6ICgpID0+IGAke2dldEN1cnJlbnRDb25uZWN0aW9uSWQoKX06JHtvcENsb2NrKyt9YCxcbiAgICBkaXNwYXRjaChvcHMsIHJldmVyc2UsIHN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgICBvbkRpc3BhdGNoPy4ob3BzLCByZXZlcnNlLCBzdG9yYWdlVXBkYXRlcyk7XG4gICAgfSxcbiAgICBhc3NlcnRTdG9yYWdlSXNXcml0YWJsZTogKCkgPT4ge1xuICAgICAgaWYgKCFpc1N0b3JhZ2VXcml0YWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCB3cml0ZSB0byBzdG9yYWdlIHdpdGggYSByZWFkIG9ubHkgdXNlciwgcGxlYXNlIGVuc3VyZSB0aGUgdXNlciBoYXMgd3JpdGUgcGVybWlzc2lvbnNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZHRBc0xpdmVOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIEhhc1BhcmVudChub2RlLCBrZXksIHBvcyA9IGFzUG9zKGtleSkpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyB0eXBlOiBcIkhhc1BhcmVudFwiLCBub2RlLCBrZXksIHBvcyB9KTtcbn1cbnZhciBOb1BhcmVudCA9IE9iamVjdC5mcmVlemUoeyB0eXBlOiBcIk5vUGFyZW50XCIgfSk7XG5mdW5jdGlvbiBPcnBoYW5lZChvbGRLZXksIG9sZFBvcyA9IGFzUG9zKG9sZEtleSkpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyB0eXBlOiBcIk9ycGhhbmVkXCIsIG9sZEtleSwgb2xkUG9zIH0pO1xufVxudmFyIEFic3RyYWN0Q3JkdCA9IGNsYXNzIHtcbiAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eXl5eXl4gVE9ETzogTWFrZSB0aGlzIGFuIGludGVyZmFjZVxuICAjcG9vbDtcbiAgI2lkO1xuICAjcGFyZW50ID0gTm9QYXJlbnQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldFBhcmVudEtleU9yVGhyb3coKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5rZXk7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRLZXk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3BhcmVudFBvcygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnBvcztcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQga2V5IGlzIG1pc3NpbmdcIik7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZFBvcztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcG9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9vbDtcbiAgfVxuICBnZXQgcm9vbUlkKCkge1xuICAgIHJldHVybiB0aGlzLiNwb29sID8gdGhpcy4jcG9vbC5yb29tSWQgOiBudWxsO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9pZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaWQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNwYXJlbnQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3BhcmVudEtleSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBfaXNMb2NhbCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGUuX2RldGFjaENoaWxkKGNyZHRBc0xpdmVOb2RlKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2V0UGFyZW50TGluayhuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Lm5vZGUgIT09IG5ld1BhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHBhcmVudDogbm9kZSBhbHJlYWR5IGhhcyBhIHBhcmVudFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNwYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gSGFzUGFyZW50KG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBpZiAodGhpcy4jaWQgfHwgdGhpcy4jcG9vbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGF0dGFjaCBub2RlOiBhbHJlYWR5IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBwb29sLmFkZE5vZGUoaWQsIGNyZHRBc0xpdmVOb2RlKHRoaXMpKTtcbiAgICB0aGlzLiNpZCA9IGlkO1xuICAgIHRoaXMuI3Bvb2wgPSBwb29sO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBpZiAodGhpcy4jcG9vbCAmJiB0aGlzLiNpZCkge1xuICAgICAgdGhpcy4jcG9vbC5kZWxldGVOb2RlKHRoaXMuI2lkKTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gT3JwaGFuZWQodGhpcy5wYXJlbnQua2V5LCB0aGlzLnBhcmVudC5wb3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuI3BhcmVudCA9IE5vUGFyZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOiB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gICAgdGhpcy4jcG9vbCA9IHZvaWQgMDtcbiAgfVxuICAvKiogVGhpcyBjYWNoZXMgdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCAudG9JbW11dGFibGUoKSBjYWxsIGZvciB0aGlzIExpdmUgbm9kZS4gKi9cbiAgI2NhY2hlZEltbXV0YWJsZTtcbiAgI2NhY2hlZFRyZWVOb2RlS2V5O1xuICAvKiogVGhpcyBjYWNoZXMgdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCAudG9UcmVlTm9kZSgpIGNhbGwgZm9yIHRoaXMgTGl2ZSBub2RlLiAqL1xuICAjY2FjaGVkVHJlZU5vZGU7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQ2xlYXIgdGhlIEltbXV0YWJsZSBjYWNoZSwgc28gdGhhdCB0aGUgbmV4dCBjYWxsIHRvIGAudG9JbW11dGFibGUoKWAgd2lsbFxuICAgKiByZWNvbXB1dGUgdGhlIGVxdWl2YWxlbnQgSW1tdXRhYmxlIHZhbHVlIGFnYWluLiAgQ2FsbCB0aGlzIGFmdGVyIGV2ZXJ5XG4gICAqIG11dGF0aW9uIHRvIHRoZSBMaXZlIG5vZGUuXG4gICAqL1xuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICh0aGlzLiNjYWNoZWRJbW11dGFibGUgIT09IHZvaWQgMCB8fCB0aGlzLiNjYWNoZWRUcmVlTm9kZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLiNjYWNoZWRJbW11dGFibGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLiNjYWNoZWRUcmVlTm9kZSA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFJldHVybiBhbiBzbmFwc2hvdCBvZiB0aGlzIExpdmUgdHJlZSBmb3IgdXNlIGluIERldlRvb2xzLlxuICAgKi9cbiAgdG9UcmVlTm9kZShrZXkpIHtcbiAgICBpZiAodGhpcy4jY2FjaGVkVHJlZU5vZGUgPT09IHZvaWQgMCB8fCB0aGlzLiNjYWNoZWRUcmVlTm9kZUtleSAhPT0ga2V5KSB7XG4gICAgICB0aGlzLiNjYWNoZWRUcmVlTm9kZUtleSA9IGtleTtcbiAgICAgIHRoaXMuI2NhY2hlZFRyZWVOb2RlID0gdGhpcy5fdG9UcmVlTm9kZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVkVHJlZU5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpbW11dGFibGUgc25hcHNob3Qgb2YgdGhpcyBMaXZlIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICovXG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIGlmICh0aGlzLiNjYWNoZWRJbW11dGFibGUgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy4jY2FjaGVkSW1tdXRhYmxlID0gdGhpcy5fdG9JbW11dGFibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlZEltbXV0YWJsZTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3RvY29sL1NlcmlhbGl6ZWRDcmR0LnRzXG52YXIgQ3JkdFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChDcmR0VHlwZTIpID0+IHtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk9CSkVDVFwiXSA9IDBdID0gXCJPQkpFQ1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIkxJU1RcIl0gPSAxXSA9IFwiTElTVFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiTUFQXCJdID0gMl0gPSBcIk1BUFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiUkVHSVNURVJcIl0gPSAzXSA9IFwiUkVHSVNURVJcIjtcbiAgcmV0dXJuIENyZHRUeXBlMjtcbn0pKENyZHRUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGlzUm9vdENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC50eXBlID09PSAwIC8qIE9CSkVDVCAqLyAmJiAhaXNDaGlsZENyZHQoY3JkdCk7XG59XG5mdW5jdGlvbiBpc0NoaWxkQ3JkdChjcmR0KSB7XG4gIHJldHVybiBjcmR0LnBhcmVudElkICE9PSB2b2lkIDAgJiYgY3JkdC5wYXJlbnRLZXkgIT09IHZvaWQgMDtcbn1cblxuLy8gc3JjL2NyZHRzL0xpdmVSZWdpc3Rlci50c1xudmFyIExpdmVSZWdpc3RlciA9IGNsYXNzIF9MaXZlUmVnaXN0ZXIgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICAjZGF0YTtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jZGF0YSA9IGRhdGE7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGE7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZCwgaXRlbV0sIF9wYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgcmVnaXN0ZXIgPSBuZXcgX0xpdmVSZWdpc3RlcihpdGVtLmRhdGEpO1xuICAgIHJlZ2lzdGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiByZWdpc3RlcjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDYW5ub3Qgc2VyaWFsaXplIHJlZ2lzdGVyIGlmIHBhcmVudElkIG9yIHBhcmVudEtleSBpcyB1bmRlZmluZWRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogOCAvKiBDUkVBVEVfUkVHSVNURVIgKi8sXG4gICAgICAgIG9wSWQ6IHBvb2w/LmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgIHBhcmVudElkLFxuICAgICAgICBwYXJlbnRLZXksXG4gICAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnBhcmVudC50eXBlICE9PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIExpdmVSZWdpc3RlciBpZiBwYXJlbnQgaXMgbWlzc2luZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDMgLyogUkVHSVNURVIgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5LFxuICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChfb3ApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChfY3JkdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBpc0xvY2FsKSB7XG4gICAgcmV0dXJuIHN1cGVyLl9hcHBseShvcCwgaXNMb2NhbCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJKc29uXCIsXG4gICAgICBpZDogdGhpcy5faWQgPz8gbmFub2lkKCksXG4gICAgICBrZXksXG4gICAgICBwYXlsb2FkOiB0aGlzLiNkYXRhXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZGF0YTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gZGVlcENsb25lKHRoaXMuZGF0YSk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9MaXZlTGlzdC50c1xuZnVuY3Rpb24gY29tcGFyZU5vZGVQb3NpdGlvbihpdGVtQSwgaXRlbUIpIHtcbiAgY29uc3QgcG9zQSA9IGl0ZW1BLl9wYXJlbnRQb3M7XG4gIGNvbnN0IHBvc0IgPSBpdGVtQi5fcGFyZW50UG9zO1xuICByZXR1cm4gcG9zQSA9PT0gcG9zQiA/IDAgOiBwb3NBIDwgcG9zQiA/IC0xIDogMTtcbn1cbnZhciBMaXZlTGlzdCA9IGNsYXNzIF9MaXZlTGlzdCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIC8vIFRPRE86IE5haXZlIGFycmF5IGF0IGZpcnN0LCBmaW5kIGEgYmV0dGVyIGRhdGEgc3RydWN0dXJlLiBNYXliZSBhbiBPcmRlciBzdGF0aXN0aWNzIHRyZWU/XG4gICNpdGVtcztcbiAgI2ltcGxpY2l0bHlEZWxldGVkSXRlbXM7XG4gICN1bmFja25vd2xlZGdlZFNldHM7XG4gIGNvbnN0cnVjdG9yKGl0ZW1zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNpdGVtcyA9IFtdO1xuICAgIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBwb3NpdGlvbiA9IHZvaWQgMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gbWFrZVBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IG5vZGUgPSBsc29uVG9MaXZlTm9kZShpdGVtKTtcbiAgICAgIG5vZGUuX3NldFBhcmVudExpbmsodGhpcywgbmV3UG9zaXRpb24pO1xuICAgICAgdGhpcy4jaXRlbXMucHVzaChub2RlKTtcbiAgICAgIHBvc2l0aW9uID0gbmV3UG9zaXRpb247XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbGlzdCA9IG5ldyBfTGl2ZUxpc3QoW10pO1xuICAgIGxpc3QuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChpZCk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZDIsIGNyZHRdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGRlc2VyaWFsaXplKFtpZDIsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKGxpc3QsIGNyZHQucGFyZW50S2V5KTtcbiAgICAgIGxpc3QuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZSByZXN1bHRpbmcgb3BzIHdpbGwgYmUgc2VudCB0byB0aGUgc2VydmVyIGlmIHRoZXkgaGF2ZSBhbiAnb3BJZCdcbiAgICogc28gd2UgbXV0YXRlIF91bmFja25vd2xlZGdlZFNldHMgdG8gYXZvaWQgcG90ZW50aWFsIGZsaWNrZXJpbmdcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2xpdmVibG9ja3MvbGl2ZWJsb2Nrcy9wdWxsLzExNzdcbiAgICpcbiAgICogVGhpcyBpcyBxdWl0ZSB1bmludHVpdGl2ZSBhbmQgc2hvdWxkIGRpc2FwcGVhciBhcyBzb29uIGFzXG4gICAqIHdlIGludHJvZHVjZSBhbiBleHBsaWNpdCBMaXZlTGlzdC5TZXQgb3BlcmF0aW9uXG4gICAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBvcCA9IHtcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIG9wSWQ6IHBvb2w/LmdlbmVyYXRlT3BJZCgpLFxuICAgICAgdHlwZTogMiAvKiBDUkVBVEVfTElTVCAqLyxcbiAgICAgIHBhcmVudElkLFxuICAgICAgcGFyZW50S2V5XG4gICAgfTtcbiAgICBvcHMucHVzaChvcCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuI2l0ZW1zKSB7XG4gICAgICBjb25zdCBwYXJlbnRLZXkyID0gaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgICAgY29uc3QgY2hpbGRPcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzLl9pZCwgcGFyZW50S2V5MiwgcG9vbCksXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGNoaWxkT3BJZCA9IGNoaWxkT3BzWzBdLm9wSWQ7XG4gICAgICBpZiAoY2hpbGRPcElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXRzLnNldChwYXJlbnRLZXkyLCBjaGlsZE9wSWQpO1xuICAgICAgfVxuICAgICAgb3BzLnB1c2goLi4uY2hpbGRPcHMpO1xuICAgIH1cbiAgICByZXR1cm4gb3BzO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQWRkcyBhIG5ldyBpdGVtIGludG8gdGhlIHNvcnRlZCBsaXN0LCBpbiB0aGUgY29ycmVjdCBwb3NpdGlvbi5cbiAgICovXG4gIF9pbnNlcnRBbmRTb3J0KGl0ZW0pIHtcbiAgICB0aGlzLiNpdGVtcy5wdXNoKGl0ZW0pO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NvcnRJdGVtcygpIHtcbiAgICB0aGlzLiNpdGVtcy5zb3J0KGNvbXBhcmVOb2RlUG9zaXRpb24pO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2luZGV4T2ZQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLiNpdGVtcy5maW5kSW5kZXgoXG4gICAgICAoaXRlbSkgPT4gaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpID09PSBwb3NpdGlvblxuICAgICk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuI2l0ZW1zKSB7XG4gICAgICBpdGVtLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNpdGVtcykge1xuICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgfVxuICB9XG4gICNhcHBseVNldFJlbW90ZShvcCkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNvbnN0IGRlbGV0ZWRJZCA9IG9wLmRlbGV0ZWRJZDtcbiAgICBjb25zdCBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgY29uc3QgaXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLiNpdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dO1xuICAgICAgaWYgKGl0ZW1XaXRoU2FtZVBvc2l0aW9uLl9pZCA9PT0gZGVsZXRlZElkKSB7XG4gICAgICAgIGl0ZW1XaXRoU2FtZVBvc2l0aW9uLl9kZXRhY2goKTtcbiAgICAgICAgdGhpcy4jaXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXSA9IGNoaWxkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIHNldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgY2hpbGQpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuYWRkKGl0ZW1XaXRoU2FtZVBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy4jaXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXSA9IGNoaWxkO1xuICAgICAgICBjb25zdCBkZWx0YSA9IFtcbiAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLiNkZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgICApO1xuICAgICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXTtcbiAgICAgIGNvbnN0IGRlbGV0ZURlbHRhMiA9IHRoaXMuI2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oXG4gICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgKTtcbiAgICAgIGlmIChkZWxldGVEZWx0YTIpIHtcbiAgICAgICAgdXBkYXRlcy5wdXNoKGRlbGV0ZURlbHRhMik7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHVwZGF0ZXMucHVzaChpbnNlcnREZWx0YSh0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KSwgY2hpbGQpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJldmVyc2U6IFtdLFxuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVzKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgI2FwcGx5U2V0QWNrKG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLiNkZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWREZWx0YSkge1xuICAgICAgZGVsdGEucHVzaChkZWxldGVkRGVsdGEpO1xuICAgIH1cbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wSWQgPSB0aGlzLiN1bmFja25vd2xlZGdlZFNldHMuZ2V0KG9wLnBhcmVudEtleSk7XG4gICAgaWYgKHVuYWNrbm93bGVkZ2VkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSBvcC5vcElkKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5sZW5ndGggPT09IDAgPyB7IG1vZGlmaWVkOiBmYWxzZSB9IDogeyBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksIHJldmVyc2U6IFtdIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldHMuZGVsZXRlKG9wLnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuI2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtLl9wYXJlbnRLZXkgPT09IG9wLnBhcmVudEtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBkZWx0YS5sZW5ndGggPiAwID8gbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSkgOiBmYWxzZSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5hZGQoXG4gICAgICAgICAgdGhpcy4jaXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBbcHJldk5vZGVdID0gdGhpcy4jaXRlbXMuc3BsaWNlKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgMSk7XG4gICAgICAgIGRlbHRhLnB1c2goZGVsZXRlRGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBwcmV2Tm9kZSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldkluZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xuICAgICAgZXhpc3RpbmdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG9wLnBhcmVudEtleSk7XG4gICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xuICAgICAgaWYgKG5ld0luZGV4ICE9PSBwcmV2SW5kZXgpIHtcbiAgICAgICAgZGVsdGEucHVzaChtb3ZlRGVsdGEocHJldkluZGV4LCBuZXdJbmRleCwgZXhpc3RpbmdJdGVtKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZGVsdGEubGVuZ3RoID4gMCA/IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpIDogZmFsc2UsXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcnBoYW4gPSB0aGlzLl9wb29sLmdldE5vZGUob3AuaWQpO1xuICAgICAgaWYgKG9ycGhhbiAmJiB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhvcnBoYW4pKSB7XG4gICAgICAgIG9ycGhhbi5fc2V0UGFyZW50TGluayh0aGlzLCBvcC5wYXJlbnRLZXkpO1xuICAgICAgICB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShvcnBoYW4pO1xuICAgICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG9ycGhhbik7XG4gICAgICAgIGNvbnN0IHJlY3JlYXRlZEl0ZW1JbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2Yob3JwaGFuKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIGF0IHRoaXMgcG9zaXRpb24sIHVwZGF0ZSBpcyBhIHNldCwgZWxzZSBpdCdzIGFuIGluc2VydFxuICAgICAgICAgICAgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID09PSAtMSA/IGluc2VydERlbHRhKHJlY3JlYXRlZEl0ZW1JbmRleCwgb3JwaGFuKSA6IHNldERlbHRhKHJlY3JlYXRlZEl0ZW1JbmRleCwgb3JwaGFuKSxcbiAgICAgICAgICAgIC4uLmRlbHRhXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy4jaXRlbXMuc3BsaWNlKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy4jY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQoXG4gICAgICAgICAgb3AsXG4gICAgICAgICAgb3AucGFyZW50S2V5XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSkgOiBzZXREZWx0YShuZXdJbmRleCwgbmV3SXRlbSksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1cGRhdGUgZGVsdGEgb2YgdGhlIGRlbGV0aW9uIG9yIG51bGxcbiAgICovXG4gICNkZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKGRlbGV0ZWRJZCkge1xuICAgIGlmIChkZWxldGVkSWQgPT09IHZvaWQgMCB8fCB0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkZWxldGVkSXRlbSA9IHRoaXMuX3Bvb2wuZ2V0Tm9kZShkZWxldGVkSWQpO1xuICAgIGlmIChkZWxldGVkSXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGV0YWNoQ2hpbGQoZGVsZXRlZEl0ZW0pO1xuICAgIGlmIChyZXN1bHQubW9kaWZpZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5tb2RpZmllZC51cGRhdGVzWzBdO1xuICB9XG4gICNhcHBseVJlbW90ZUluc2VydChvcCkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGFzUG9zKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLiNzaGlmdEl0ZW1Qb3NpdGlvbihleGlzdGluZ0l0ZW1JbmRleCwga2V5KTtcbiAgICB9XG4gICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy4jY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQob3AsIGtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSldKSxcbiAgICAgIHJldmVyc2U6IFtdXG4gICAgfTtcbiAgfVxuICAjYXBwbHlJbnNlcnRBY2sob3ApIHtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLiNpdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLl9pZCA9PT0gb3AuaWQpO1xuICAgIGNvbnN0IGtleSA9IGFzUG9zKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgaXRlbUluZGV4QXRQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW0pIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvbGRQb3NpdGlvbkluZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLiNzaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSBvbGRQb3NpdGlvbkluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEob2xkUG9zaXRpb25JbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcnBoYW4gPSBubih0aGlzLl9wb29sKS5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgb3JwaGFuKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLiNzaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuI2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSldKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjYXBwbHlJbnNlcnRVbmRvUmVkbyhvcCkge1xuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbD8uZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNoaWxkLl9hdHRhY2goaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgbGV0IG5ld0tleSA9IGtleTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBiZWZvcmUyID0gdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdPy5fcGFyZW50UG9zO1xuICAgICAgY29uc3QgYWZ0ZXIyID0gdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcztcbiAgICAgIG5ld0tleSA9IG1ha2VQb3NpdGlvbihiZWZvcmUyLCBhZnRlcjIpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICB9XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgIHJldmVyc2U6IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dXG4gICAgfTtcbiAgfVxuICAjYXBwbHlTZXRVbmRvUmVkbyhvcCkge1xuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbD8uZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQoa2V5LCBubihvcC5vcElkKSk7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGNoaWxkLl9hdHRhY2goaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNvbnN0IG5ld0tleSA9IGtleTtcbiAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuI2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVLZXldO1xuICAgICAgZXhpc3RpbmdJdGVtLl9kZXRhY2goKTtcbiAgICAgIHRoaXMuI2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVLZXldID0gY2hpbGQ7XG4gICAgICBjb25zdCByZXZlcnNlID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdJdGVtLl90b09wcyhubih0aGlzLl9pZCksIGtleSwgdGhpcy5fcG9vbCksXG4gICAgICAgIG9wLmlkXG4gICAgICApO1xuICAgICAgY29uc3QgZGVsdGEgPSBbc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSwgY2hpbGQpXTtcbiAgICAgIGNvbnN0IGRlbGV0ZWREZWx0YSA9IHRoaXMuI2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oXG4gICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgKTtcbiAgICAgIGlmIChkZWxldGVkRGVsdGEpIHtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVkRGVsdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpLFxuICAgICAgICByZXZlcnNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHRoaXMuI2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24ob3AuZGVsZXRlZElkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBjaGlsZCldKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQob3AsIHNvdXJjZSkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKG9wLmludGVudCA9PT0gXCJzZXRcIikge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy4jYXBwbHlTZXRSZW1vdGUob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuI2FwcGx5U2V0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuI2FwcGx5U2V0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLiNhcHBseVJlbW90ZUluc2VydChvcCk7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy4jYXBwbHlJbnNlcnRBY2sob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy4jYXBwbHlJbnNlcnRVbmRvUmVkbyhvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXN1bHQubW9kaWZpZWQgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKG5uKHRoaXMuX2lkKSwgcGFyZW50S2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IGluZGV4VG9EZWxldGUgPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChpbmRleFRvRGVsZXRlID09PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgW3ByZXZpb3VzTm9kZV0gPSB0aGlzLiNpdGVtcy5zcGxpY2UoaW5kZXhUb0RlbGV0ZSwgMSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIGNoaWxkLl9kZXRhY2goKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtkZWxldGVEZWx0YShpbmRleFRvRGVsZXRlLCBwcmV2aW91c05vZGUpXSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gICNhcHBseVNldENoaWxkS2V5UmVtb3RlKG5ld0tleSwgY2hpbGQpIHtcbiAgICBpZiAodGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMoY2hpbGQpKSB7XG4gICAgICB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzS2V5ID0gY2hpbGQuX3BhcmVudEtleTtcbiAgICBpZiAobmV3S2V5ID09PSBwcmV2aW91c0tleSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAobmV3SW5kZXggPT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICB0aGlzLFxuICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAobmV3SW5kZXggPT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgI2FwcGx5U2V0Q2hpbGRLZXlBY2sobmV3S2V5LCBjaGlsZCkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgaWYgKHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKGNoaWxkKSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICAgIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5ld0tleSA9PT0gcHJldmlvdXNLZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBsZXQgYWN0dWFsTmV3S2V5ID0gbmV3S2V5O1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIGFjdHVhbE5ld0tleSA9IG1ha2VQb3NpdGlvbihcbiAgICAgICAgbmV3S2V5LFxuICAgICAgICB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zXG4gICAgICApO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBhY3R1YWxOZXdLZXkpO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgIHJldmVyc2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQ6IG5uKGNoaWxkLl9pZCksXG4gICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c0tleVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRDaGlsZEtleShuZXdLZXksIGNoaWxkLCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICByZXR1cm4gdGhpcy4jYXBwbHlTZXRDaGlsZEtleUFjayhuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuI2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZUxpc3QgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzLlxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXRlbXMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9uZSBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIExpdmVMaXN0LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIHJldHVybiB0aGlzLmluc2VydChlbGVtZW50LCB0aGlzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgb25lIGVsZW1lbnQgYXQgYSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB5b3Ugd2FudCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqL1xuICBpbnNlcnQoZWxlbWVudCwgaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLiNpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBpbnNlcnQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLiNpdGVtcy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuI2l0ZW1zW2luZGV4IC0gMV0gPyB0aGlzLiNpdGVtc1tpbmRleCAtIDFdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgYWZ0ZXIyID0gdGhpcy4jaXRlbXNbaW5kZXhdID8gdGhpcy4jaXRlbXNbaW5kZXhdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxzb25Ub0xpdmVOb2RlKGVsZW1lbnQpO1xuICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIHZhbHVlLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgdmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdGhpcy5fcG9vbCksXG4gICAgICAgIFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShpbmRleCwgdmFsdWUpXSldXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW92ZSBvbmUgZWxlbWVudCBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyLlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIG1vdmVcbiAgICogQHBhcmFtIHRhcmdldEluZGV4IFRoZSBpbmRleCB3aGVyZSB0aGUgZWxlbWVudCBzaG91bGQgYmUgYWZ0ZXIgbW92aW5nLlxuICAgKi9cbiAgbW92ZShpbmRleCwgdGFyZ2V0SW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ID49IHRoaXMuI2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInRhcmdldEluZGV4IGNhbm5vdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIGxpc3QgbGVuZ3RoXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IHRoaXMuI2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIik7XG4gICAgfVxuICAgIGxldCBiZWZvcmVQb3NpdGlvbiA9IG51bGw7XG4gICAgbGV0IGFmdGVyUG9zaXRpb24gPSBudWxsO1xuICAgIGlmIChpbmRleCA8IHRhcmdldEluZGV4KSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IHRoaXMuI2l0ZW1zLmxlbmd0aCAtIDEgPyB2b2lkIDAgOiB0aGlzLiNpdGVtc1t0YXJnZXRJbmRleCArIDFdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRoaXMuI2l0ZW1zW3RhcmdldEluZGV4XS5fcGFyZW50UG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGhpcy4jaXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRhcmdldEluZGV4ID09PSAwID8gdm9pZCAwIDogdGhpcy4jaXRlbXNbdGFyZ2V0SW5kZXggLSAxXS5fcGFyZW50UG9zO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmVQb3NpdGlvbiwgYWZ0ZXJQb3NpdGlvbik7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuI2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwcmV2aW91c1Bvc2l0aW9uID0gaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGl0ZW0uX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEoaW5kZXgsIHRhcmdldEluZGV4LCBpdGVtKV0pXVxuICAgICAgXSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgICBpZDogbm4oaXRlbS5faWQpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c1Bvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy4jaXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZGVsZXRlIGxpc3QgaXRlbSBhdCBpbmRleCBcIiR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy4jaXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gdGhpcy4jaXRlbXNbaW5kZXhdO1xuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIGNvbnN0IFtwcmV2XSA9IHRoaXMuI2l0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IGNoaWxkUmVjb3JkSWQgPSBpdGVtLl9pZDtcbiAgICAgIGlmIChjaGlsZFJlY29yZElkKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgIG5uKHRoaXMuX2lkKSxcbiAgICAgICAgICBtYWtlVXBkYXRlKHRoaXMsIFtkZWxldGVEZWx0YShpbmRleCwgcHJldildKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6IGNoaWxkUmVjb3JkSWQsXG4gICAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGl0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwgaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpKSxcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0aGlzLl9wb29sKSB7XG4gICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICAgIGNvbnN0IHVwZGF0ZURlbHRhID0gW107XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jaXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICAgIGNvbnN0IGNoaWxkSWQgPSBpdGVtLl9pZDtcbiAgICAgICAgaWYgKGNoaWxkSWQpIHtcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICAgICAgaWQ6IGNoaWxkSWQsXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKFxuICAgICAgICAgICAgLi4uaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB1cGRhdGVEZWx0YS5wdXNoKGRlbGV0ZURlbHRhKDAsIGl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy4jaXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KG5uKHRoaXMuX2lkKSwgbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVEZWx0YSkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuI2l0ZW1zKSB7XG4gICAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jaXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBzZXQoaW5kZXgsIGl0ZW0pIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy4jaXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IGxpc3QgaXRlbSBhdCBpbmRleCBcIlx1MDAxZCR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy4jaXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLiNpdGVtc1tpbmRleF07XG4gICAgY29uc3QgcG9zaXRpb24gPSBleGlzdGluZ0l0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICBjb25zdCBleGlzdGluZ0lkID0gZXhpc3RpbmdJdGVtLl9pZDtcbiAgICBleGlzdGluZ0l0ZW0uX2RldGFjaCgpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuI2l0ZW1zW2luZGV4XSA9IHZhbHVlO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW3NldERlbHRhKGluZGV4LCB2YWx1ZSldKSk7XG4gICAgICBjb25zdCBvcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgZXhpc3RpbmdJZFxuICAgICAgKTtcbiAgICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocG9zaXRpb24sIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICBjb25zdCByZXZlcnNlT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdJdGVtLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHZvaWQgMCksXG4gICAgICAgIGlkXG4gICAgICApO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gQXJyYXkgb2YgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLiNpdGVtcy5tYXAoXG4gICAgICAoZW50cnkpID0+IGxpdmVOb2RlVG9Mc29uKGVudHJ5KVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciBhbGwgZWxlbWVudHMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LCB0YWtpbmcgdHdvIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCkuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBldmVyeSBlbGVtZW50LiBPdGhlcndpc2UsIGZhbHNlLlxuICAgKi9cbiAgZXZlcnkocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmV2ZXJ5KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBvZiB0aGUgTGl2ZUxpc3QuIFJldHVybiBhIHZhbHVlIHRoYXQgY29lcmNlcyB0byB0cnVlIHRvIGtlZXAgdGhlIGVsZW1lbnQsIG9yIHRvIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0LlxuICAgKi9cbiAgZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maWx0ZXIocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUuXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uIE90aGVyd2lzZSwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZmluZChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZChwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHBhc3NlcyB0aGUgdGVzdC4gT3RoZXJ3aXNlLCAtMS5cbiAgICovXG4gIGZpbmRJbmRleChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2tmbikge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrZm4pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvbiB0aGUgZWxlbWVudCB0byBnZXQuXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLiNpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih0aGlzLiNpdGVtc1tpbmRleF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0LlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0OyAtMSBpZiBub3QgZm91bmQuXG4gICAqL1xuICBpbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5pbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgTGl2ZUxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LiBUaGUgTGl2ZUxzaXQgaXMgc2VhcmNoZWQgYmFja3dhcmRzLCBzdGFydGluZyBhdCBmcm9tSW5kZXguXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcgYmFja3dhcmRzLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZXZlcnkgZWxlbWVudC5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnQgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBtYXAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy4jaXRlbXMubWFwKFxuICAgICAgKGVudHJ5LCBpKSA9PiBjYWxsYmFjayhcbiAgICAgICAgbGl2ZU5vZGVUb0xzb24oZW50cnkpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgICAgIGlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCBwYXNzZXMgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgYXQgbGVhc3Qgb25lIGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBzb21lKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5zb21lKHByZWRpY2F0ZSk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdEl0ZXJhdG9yKHRoaXMuI2l0ZW1zKTtcbiAgfVxuICAjY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQob3AsIGtleSkge1xuICAgIGNvbnN0IG5ld0l0ZW0gPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgbmV3SXRlbS5fYXR0YWNoKG9wLmlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgbmV3SXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIHRoaXMuX2luc2VydEFuZFNvcnQobmV3SXRlbSk7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICByZXR1cm4geyBuZXdJdGVtLCBuZXdJbmRleCB9O1xuICB9XG4gICNzaGlmdEl0ZW1Qb3NpdGlvbihpbmRleCwga2V5KSB7XG4gICAgY29uc3Qgc2hpZnRlZFBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKFxuICAgICAga2V5LFxuICAgICAgdGhpcy4jaXRlbXMubGVuZ3RoID4gaW5kZXggKyAxID8gdGhpcy4jaXRlbXNbaW5kZXggKyAxXT8uX3BhcmVudFBvcyA6IHZvaWQgMFxuICAgICk7XG4gICAgdGhpcy4jaXRlbXNbaW5kZXhdLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHNoaWZ0ZWRQb3NpdGlvbik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlTGlzdFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogdGhpcy4jaXRlbXMubWFwKFxuICAgICAgICAoaXRlbSwgaW5kZXgpID0+IGl0ZW0udG9UcmVlTm9kZShpbmRleC50b1N0cmluZygpKVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jaXRlbXMubWFwKChub2RlKSA9PiBub2RlLnRvSW1tdXRhYmxlKCkpO1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZUxpc3QodGhpcy4jaXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLmNsb25lKCkpKTtcbiAgfVxufTtcbnZhciBMaXZlTGlzdEl0ZXJhdG9yID0gY2xhc3Mge1xuICAjaW5uZXJJdGVyYXRvcjtcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICB0aGlzLiNpbm5lckl0ZXJhdG9yID0gaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5leHQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1ha2VVcGRhdGUobGl2ZUxpc3QsIGRlbHRhVXBkYXRlcykge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IGxpdmVMaXN0LFxuICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICB1cGRhdGVzOiBkZWx0YVVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldERlbHRhKGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJzZXRcIixcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlRGVsdGEoaW5kZXgsIGRlbGV0ZWROb2RlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJkZWxldGVcIixcbiAgICBpbmRleCxcbiAgICBkZWxldGVkSXRlbTogZGVsZXRlZE5vZGUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBkZWxldGVkTm9kZS5kYXRhIDogZGVsZXRlZE5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGluc2VydERlbHRhKGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJpbnNlcnRcIixcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJtb3ZlXCIsXG4gICAgaW5kZXgsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW0sXG4gICAgcHJldmlvdXNJbmRleFxuICB9O1xufVxuZnVuY3Rpb24gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihvcHMsIGRlbGV0ZWRJZCkge1xuICByZXR1cm4gb3BzLm1hcCgob3AsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBjb25zdCBmaXJzdE9wID0gb3A7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5maXJzdE9wLFxuICAgICAgICBpbnRlbnQ6IFwic2V0XCIsXG4gICAgICAgIGRlbGV0ZWRJZFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9jcmR0cy9MaXZlTWFwLnRzXG52YXIgTGl2ZU1hcCA9IGNsYXNzIF9MaXZlTWFwIGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgI21hcDtcbiAgI3VuYWNrbm93bGVkZ2VkU2V0O1xuICBjb25zdHJ1Y3RvcihlbnRyaWVzMikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmIChlbnRyaWVzMikge1xuICAgICAgY29uc3QgbWFwcGVkRW50cmllcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllczIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGxzb25Ub0xpdmVOb2RlKHZhbHVlKTtcbiAgICAgICAgbm9kZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICBtYXBwZWRFbnRyaWVzLnB1c2goW2tleSwgbm9kZV0pO1xuICAgICAgfVxuICAgICAgdGhpcy4jbWFwID0gbmV3IE1hcChtYXBwZWRFbnRyaWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBvcCA9IHtcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIG9wSWQ6IHBvb2w/LmdlbmVyYXRlT3BJZCgpLFxuICAgICAgdHlwZTogNyAvKiBDUkVBVEVfTUFQICovLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXlcbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLiNtYXApIHtcbiAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZCwgX2l0ZW1dLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IF9MaXZlTWFwKCk7XG4gICAgbWFwLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZDIsIGNyZHRdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGRlc2VyaWFsaXplKFtpZDIsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKG1hcCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbWFwLiNtYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBtYXAuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIHN1cGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGZvciAoY29uc3QgW19rZXksIHZhbHVlXSBvZiB0aGlzLiNtYXApIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fYXR0YWNoKHBvb2wuZ2VuZXJhdGVJZCgpLCBwb29sKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQob3AsIHNvdXJjZSkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleSwgb3BJZCB9ID0gb3A7XG4gICAgY29uc3Qga2V5ID0gcGFyZW50S2V5O1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sLmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgY29uc3QgbGFzdFVwZGF0ZU9wSWQgPSB0aGlzLiN1bmFja25vd2xlZGdlZFNldC5nZXQoa2V5KTtcbiAgICAgIGlmIChsYXN0VXBkYXRlT3BJZCA9PT0gb3BJZCkge1xuICAgICAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldC5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9IGVsc2UgaWYgKGxhc3RVcGRhdGVPcElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldC5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICBsZXQgcmV2ZXJzZTtcbiAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgICAgcmV2ZXJzZSA9IHByZXZpb3VzVmFsdWUuX3RvT3BzKHRoaXNJZCwga2V5KTtcbiAgICAgIHByZXZpb3VzVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXZlcnNlID0gW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV07XG4gICAgfVxuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgdGhpcy4jbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNtYXAudmFsdWVzKCkpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICBpZiAodmFsdWUgPT09IGNoaWxkKSB7XG4gICAgICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNoaWxkLl9kZXRhY2goKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlID0ge1xuICAgICAgbm9kZTogdGhpcyxcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgdXBkYXRlczoge1xuICAgICAgICBbcGFyZW50S2V5XToge1xuICAgICAgICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgICAgICAgZGVsZXRlZEl0ZW06IGxpdmVOb2RlVG9Mc29uKGNoaWxkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyBtb2RpZmllZDogc3RvcmFnZVVwZGF0ZSwgcmV2ZXJzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTWFwIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMiAvKiBNQVAgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIExpdmVNYXAuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIHRoaXMuI21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIGl0ZW0uX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb3BzID0gaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldC5zZXQoa2V5LCBubihvcHNbMF0ub3BJZCkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCksXG4gICAgICAgIG9sZFZhbHVlID8gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpIDogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBMaXZlTWFwLlxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5zaXplO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBvciBub3QuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byB0ZXN0IGZvciBwcmVzZW5jZS5cbiAgICovXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmhhcyhrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBieSBrZXkuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgYW4gZWxlbWVudCBleGlzdGVkIGFuZCBoYXMgYmVlbiByZW1vdmVkLCBvciBmYWxzZSBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgaWYgKGl0ZW0gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB0aGlzLiNtYXAuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgaXRlbS5faWQpIHtcbiAgICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzSWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBba2V5XToge1xuICAgICAgICAgICAgdHlwZTogXCJkZWxldGVcIixcbiAgICAgICAgICAgIGRlbGV0ZWRJdGVtOiBsaXZlTm9kZVRvTHNvbihpdGVtKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXNJZCwga2V5KSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBba2V5LCB2YWx1ZV0gcGFpcnMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGVudHJpZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuI21hcC5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlcmF0b3JWYWx1ZS52YWx1ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gZW50cnlbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZVsxXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IFtrZXksIHZhbHVlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbnRyaWVzIG1ldGhvZC5cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmtleXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICB2YWx1ZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuI21hcC52YWx1ZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIE1hcCBvYmplY3QsIGluIGluc2VydGlvbiBvcmRlci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZW50cnkgaW4gdGhlIG1hcC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLiNtYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsXSkgPT4gdmFsLnRvVHJlZU5vZGUoa2V5MilcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9JbW11dGFibGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTWFwKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLiNtYXApLm1hcCgoW2tleSwgbm9kZV0pID0+IFtrZXksIG5vZGUuY2xvbmUoKV0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVPYmplY3QudHNcbnZhciBNQVhfTElWRV9PQkpFQ1RfU0laRSA9IDEyOCAqIDEwMjQ7XG52YXIgTGl2ZU9iamVjdCA9IGNsYXNzIF9MaXZlT2JqZWN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgI21hcDtcbiAgI3Byb3BUb0xhc3RVcGRhdGU7XG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBkZXRlY3Rpb24gb2YgdG9vIGxhcmdlIExpdmVPYmplY3RzLlxuICAgKiBXaGVuIGVuYWJsZWQsIHRocm93cyBhbiBlcnJvciBpZiBMaXZlT2JqZWN0IHN0YXRpYyBkYXRhIGV4Y2VlZHMgMTI4S0IsIHdoaWNoXG4gICAqIGlzIHRoZSBtYXhpbXVtIHZhbHVlIHRoZSBzZXJ2ZXIgd2lsbCBiZSBhYmxlIHRvIGFjY2VwdC5cbiAgICogQnkgZGVmYXVsdCwgdGhpcyBiZWhhdmlvciBpcyBkaXNhYmxlZCB0byBhdm9pZCB0aGUgcnVudGltZSBwZXJmb3JtYW5jZVxuICAgKiBvdmVyaGVhZCBvbiBldmVyeSBMaXZlT2JqZWN0LnNldCgpIG9yIExpdmVPYmplY3QudXBkYXRlKCkgY2FsbC5cbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc3RhdGljIGRldGVjdExhcmdlT2JqZWN0cyA9IGZhbHNlO1xuICBzdGF0aWMgI2J1aWxkUm9vdEFuZFBhcmVudFRvQ2hpbGRyZW4oaXRlbXMpIHtcbiAgICBjb25zdCBwYXJlbnRUb0NoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcm9vdCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBbaWQsIGNyZHRdIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAoaXNSb290Q3JkdChjcmR0KSkge1xuICAgICAgICByb290ID0gW2lkLCBjcmR0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHR1cGxlID0gW2lkLCBjcmR0XTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChjcmR0LnBhcmVudElkKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHR1cGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRUb0NoaWxkcmVuLnNldChjcmR0LnBhcmVudElkLCBbdHVwbGVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBjYW4ndCBiZSBudWxsXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW3Jvb3QsIHBhcmVudFRvQ2hpbGRyZW5dO1xuICB9XG4gIC8qKiBAcHJpdmF0ZSBEbyBub3QgdXNlIHRoaXMgQVBJIGRpcmVjdGx5ICovXG4gIHN0YXRpYyBfZnJvbUl0ZW1zKGl0ZW1zLCBwb29sKSB7XG4gICAgY29uc3QgW3Jvb3QsIHBhcmVudFRvQ2hpbGRyZW5dID0gX0xpdmVPYmplY3QuI2J1aWxkUm9vdEFuZFBhcmVudFRvQ2hpbGRyZW4oaXRlbXMpO1xuICAgIHJldHVybiBfTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoXG4gICAgICByb290LFxuICAgICAgcGFyZW50VG9DaGlsZHJlbixcbiAgICAgIHBvb2xcbiAgICApO1xuICB9XG4gIGNvbnN0cnVjdG9yKG9iaiA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNwcm9wVG9MYXN0VXBkYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBvID0gY29tcGFjdE9iamVjdChvYmopO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG8pKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ba2V5XTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNtYXAgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKG8pKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wSWQgPSBwb29sPy5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBvcCA9IHtcbiAgICAgIHR5cGU6IDQgLyogQ1JFQVRFX09CSkVDVCAqLyxcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIG9wSWQsXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleSxcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBvcHMucHVzaChvcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wLmRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BzO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIGl0ZW1dLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbGl2ZU9iaiA9IG5ldyBfTGl2ZU9iamVjdChpdGVtLmRhdGEpO1xuICAgIGxpdmVPYmouX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplQ2hpbGRyZW4obGl2ZU9iaiwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplQ2hpbGRyZW4obGl2ZU9iaiwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQobm4obGl2ZU9iai5faWQpKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpdmVPYmo7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZVRvTHNvbihbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGlmIChpc0xpdmVTdHJ1Y3R1cmUoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKGxpdmVPYmosIGNyZHQucGFyZW50S2V5KTtcbiAgICAgIH1cbiAgICAgIGxpdmVPYmouI21hcC5zZXQoY3JkdC5wYXJlbnRLZXksIGNoaWxkKTtcbiAgICAgIGxpdmVPYmouaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZU9iajtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBvcElkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9Mc29uKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbC5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gb3BJZCkge1xuICAgICAgICB0aGlzLiNwcm9wVG9MYXN0VXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovKSB7XG4gICAgICB0aGlzLiNwcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKG9wSWQpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IHZvaWQgMCkge1xuICAgIH0gZWxzZSBpZiAodGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gb3BJZCkge1xuICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUocHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgIHJldmVyc2UgPSBwcmV2aW91c1ZhbHVlLl90b09wcyh0aGlzSWQsIGtleSk7XG4gICAgICBwcmV2aW91c1ZhbHVlLl9kZXRhY2goKTtcbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFt7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzSWQsIGtleSB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZDogdGhpc0lkLFxuICAgICAgICAgIGRhdGE6IHsgW2tleV06IHByZXZpb3VzVmFsdWUgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLiNtYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmIChpc0xpdmVTdHJ1Y3R1cmUoY2hpbGQpKSB7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXZlcnNlLFxuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhpZCwgcGFyZW50S2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgICBpZiAodmFsdWUgPT09IGNoaWxkKSB7XG4gICAgICAgICAgdGhpcy4jbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlID0ge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczoge1xuICAgICAgICAgIFtwYXJlbnRLZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IHN0b3JhZ2VVcGRhdGUsIHJldmVyc2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI21hcC52YWx1ZXMoKSkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICBpZiAob3AudHlwZSA9PT0gMyAvKiBVUERBVEVfT0JKRUNUICovKSB7XG4gICAgICByZXR1cm4gdGhpcy4jYXBwbHlVcGRhdGUob3AsIGlzTG9jYWwpO1xuICAgIH0gZWxzZSBpZiAob3AudHlwZSA9PT0gNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLl9hcHBseShvcCwgaXNMb2NhbCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLiNtYXApIHtcbiAgICAgIGlmICghaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiICYmIHRoaXMucGFyZW50Lm5vZGUuX2lkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE9CSkVDVCAqLyxcbiAgICAgICAgcGFyZW50SWQ6IHRoaXMucGFyZW50Lm5vZGUuX2lkLFxuICAgICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfVxuICB9XG4gICNhcHBseVVwZGF0ZShvcCwgaXNMb2NhbCkge1xuICAgIGxldCBpc01vZGlmaWVkID0gZmFsc2U7XG4gICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgY29uc3QgcmV2ZXJzZSA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VVcGRhdGUgPSB7XG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBpZCxcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKGlkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VVcGRhdGUuZGF0YVtrZXldID0gb2xkVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZS5wdXNoKHsgdHlwZTogNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLywgaWQsIGtleSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9wLmRhdGFba2V5XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTG9jYWwpIHtcbiAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcC5vcElkKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IHZvaWQgMCkge1xuICAgICAgICBpc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gb3Aub3BJZCkge1xuICAgICAgICB0aGlzLiNwcm9wVG9MYXN0VXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgICB0aGlzLiNtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlLmRhdGEpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV2ZXJzZS51bnNoaWZ0KHJldmVyc2VVcGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gaXNNb2RpZmllZCA/IHtcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9IDogeyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAjYXBwbHlEZWxldGVPYmplY3RLZXkob3AsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBrZXkgPSBvcC5rZXk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoIWlzTG9jYWwgJiYgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgbGV0IHJldmVyc2UgPSBbXTtcbiAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgIHJldmVyc2UgPSBvbGRWYWx1ZS5fdG9PcHMoaWQsIG9wLmtleSk7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChvbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXZlcnNlID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGRhdGE6IHsgW2tleV06IG9sZFZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy4jbWFwLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczoge1xuICAgICAgICAgIFtvcC5rZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIsIGRlbGV0ZWRJdGVtOiBvbGRWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBMaXZlT2JqZWN0IGludG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLiNtYXApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSBwcm9wZXJ0eSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgdGhpcy51cGRhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSB0aGUgTGl2ZU9iamVjdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGZyb20gdGhlIExpdmVPYmplY3RcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5O1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXlBc1N0cmluZyk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXlBc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgZGF0YTogeyBba2V5QXNTdHJpbmddOiBvbGRWYWx1ZSB9LFxuICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLiNtYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB7XG4gICAgICAgIFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIsIGRlbGV0ZWRJdGVtOiBvbGRWYWx1ZSB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sXG4gICAgICAgICAga2V5OiBrZXlBc1N0cmluZyxcbiAgICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZSB3aXRoIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHBhdGNoIFRoZSBvYmplY3QgdXNlZCB0byBvdmVycmlkZXMgcHJvcGVydGllc1xuICAgKi9cbiAgdXBkYXRlKHBhdGNoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAoX0xpdmVPYmplY3QuZGV0ZWN0TGFyZ2VPYmplY3RzKSB7XG4gICAgICBjb25zdCBkYXRhID0ge307XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLiNtYXApIHtcbiAgICAgICAgaWYgKCFpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXRjaCkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgIGlmICghaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgY29uc3QgdXBwZXJCb3VuZFNpemUgPSBqc29uU3RyaW5nLmxlbmd0aCAqIDQ7XG4gICAgICBpZiAodXBwZXJCb3VuZFNpemUgPiBNQVhfTElWRV9PQkpFQ1RfU0laRSkge1xuICAgICAgICBjb25zdCBwcmVjaXNlU2l6ZSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShqc29uU3RyaW5nKS5sZW5ndGg7XG4gICAgICAgIGlmIChwcmVjaXNlU2l6ZSA+IE1BWF9MSVZFX09CSkVDVF9TSVpFKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYExpdmVPYmplY3Qgc2l6ZSBleGNlZWRlZCBsaW1pdDogJHtwcmVjaXNlU2l6ZX0gYnl0ZXMgPiAke01BWF9MSVZFX09CSkVDVF9TSVpFfSBieXRlcy4gU2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL2xpbWl0cyNMaXZlYmxvY2tzLVN0b3JhZ2UtbGltaXRzYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHBhdGNoW2tleV07XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMaXZlTm9kZShuZXdWYWx1ZSkpIHtcbiAgICAgICAgICBuZXdWYWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21hcC5zZXQoa2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCByZXZlcnNlT3BzID0gW107XG4gICAgY29uc3Qgb3BJZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3QgdXBkYXRlZFByb3BzID0ge307XG4gICAgY29uc3QgcmV2ZXJzZVVwZGF0ZU9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZURlbHRhID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKC4uLm9sZFZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5KSk7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpcy5faWQsIGtleSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldmVyc2VVcGRhdGVPcC5kYXRhW2tleV0gPSBvbGRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICBuZXdWYWx1ZS5fYXR0YWNoKHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpLCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgbmV3QXR0YWNoQ2hpbGRPcHMgPSBuZXdWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUNyZHRPcCA9IG5ld0F0dGFjaENoaWxkT3BzLmZpbmQoXG4gICAgICAgICAgKG9wKSA9PiBvcC5wYXJlbnRJZCA9PT0gdGhpcy5faWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGNyZWF0ZUNyZHRPcCkge1xuICAgICAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgbm4oY3JlYXRlQ3JkdE9wLm9wSWQpKTtcbiAgICAgICAgfVxuICAgICAgICBvcHMucHVzaCguLi5uZXdBdHRhY2hDaGlsZE9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVkUHJvcHNba2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLiNwcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG9wSWQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgdXBkYXRlRGVsdGFba2V5XSA9IHsgdHlwZTogXCJ1cGRhdGVcIiB9O1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMocmV2ZXJzZVVwZGF0ZU9wLmRhdGEpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV2ZXJzZU9wcy51bnNoaWZ0KHJldmVyc2VVcGRhdGVPcCk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh1cGRhdGVkUHJvcHMpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgb3BzLnVuc2hpZnQoe1xuICAgICAgICBvcElkLFxuICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgZGF0YTogdXBkYXRlZFByb3BzXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwge1xuICAgICAgbm9kZTogdGhpcyxcbiAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgdXBkYXRlczogdXBkYXRlRGVsdGFcbiAgICB9KTtcbiAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4gc3VwZXIudG9UcmVlTm9kZShrZXkpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgY29uc3Qgbm9kZUlkID0gdGhpcy5faWQgPz8gbmFub2lkKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IEFycmF5LmZyb20odGhpcy4jbWFwLmVudHJpZXMoKSkubWFwKFxuICAgICAgICAoW2tleTIsIHZhbHVlXSkgPT4gaXNMaXZlTm9kZSh2YWx1ZSkgPyB2YWx1ZS50b1RyZWVOb2RlKGtleTIpIDogeyB0eXBlOiBcIkpzb25cIiwgaWQ6IGAke25vZGVJZH06JHtrZXkyfWAsIGtleToga2V5MiwgcGF5bG9hZDogdmFsdWUgfVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuI21hcCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBpc0xpdmVTdHJ1Y3R1cmUodmFsKSA/IHZhbC50b0ltbXV0YWJsZSgpIDogdmFsO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gcmVzdWx0IDogT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVPYmplY3QoXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIEFycmF5LmZyb20odGhpcy4jbWFwKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSlcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvY3JkdHMvbGl2ZWJsb2Nrcy1oZWxwZXJzLnRzXG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCkge1xuICByZXR1cm4gbHNvblRvTGl2ZU5vZGUoY3JlYXRpb25PcFRvTHNvbihvcCkpO1xufVxuZnVuY3Rpb24gY3JlYXRpb25PcFRvTHNvbihvcCkge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOlxuICAgICAgcmV0dXJuIG9wLmRhdGE7XG4gICAgY2FzZSA0IC8qIENSRUFURV9PQkpFQ1QgKi86XG4gICAgICByZXR1cm4gbmV3IExpdmVPYmplY3Qob3AuZGF0YSk7XG4gICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICByZXR1cm4gbmV3IExpdmVNYXAoKTtcbiAgICBjYXNlIDIgLyogQ1JFQVRFX0xJU1QgKi86XG4gICAgICByZXR1cm4gbmV3IExpdmVMaXN0KFtdKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKG9wLCBcIlVua25vd24gY3JlYXRpb24gT3BcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZSwgcGFyZW50KSB7XG4gIGlmIChub2RlID09PSBwYXJlbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgIHJldHVybiBpc1NhbWVOb2RlT3JDaGlsZE9mKG5vZGUucGFyZW50Lm5vZGUsIHBhcmVudCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICBzd2l0Y2ggKGNyZHQudHlwZSkge1xuICAgIGNhc2UgMCAvKiBPQkpFQ1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlT2JqZWN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAxIC8qIExJU1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTGlzdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMiAvKiBNQVAgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTWFwLl9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAzIC8qIFJFR0lTVEVSICovOiB7XG4gICAgICByZXR1cm4gTGl2ZVJlZ2lzdGVyLl9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVRvTHNvbihbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBjcmR0LmRhdGE7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgQ1JEVCB0eXBlXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNMaXZlU3RydWN0dXJlKHZhbHVlKSB7XG4gIHJldHVybiBpc0xpdmVMaXN0KHZhbHVlKSB8fCBpc0xpdmVNYXAodmFsdWUpIHx8IGlzTGl2ZU9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0xpdmVOb2RlKHZhbHVlKSB7XG4gIHJldHVybiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHx8IGlzTGl2ZVJlZ2lzdGVyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZUxpc3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVNYXAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0O1xufVxuZnVuY3Rpb24gaXNMaXZlUmVnaXN0ZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyO1xufVxuZnVuY3Rpb24gY2xvbmVMc29uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNMaXZlU3RydWN0dXJlKHZhbHVlKSA/IHZhbHVlLmNsb25lKCkgOiBkZWVwQ2xvbmUodmFsdWUpO1xufVxuZnVuY3Rpb24gbGl2ZU5vZGVUb0xzb24ob2JqKSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIpIHtcbiAgICByZXR1cm4gb2JqLmRhdGE7XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGl2ZUxpc3QgfHwgb2JqIGluc3RhbmNlb2YgTGl2ZU1hcCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob2JqLCBcIlVua25vd24gQWJzdHJhY3RDcmR0XCIpO1xuICB9XG59XG5mdW5jdGlvbiBsc29uVG9MaXZlTm9kZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0IHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgTGl2ZVJlZ2lzdGVyKHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJlZXNEaWZmT3BlcmF0aW9ucyhjdXJyZW50SXRlbXMsIG5ld0l0ZW1zKSB7XG4gIGNvbnN0IG9wcyA9IFtdO1xuICBjdXJyZW50SXRlbXMuZm9yRWFjaCgoXywgaWQpID0+IHtcbiAgICBpZiAoIW5ld0l0ZW1zLmdldChpZCkpIHtcbiAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIG5ld0l0ZW1zLmZvckVhY2goKGNyZHQsIGlkKSA9PiB7XG4gICAgY29uc3QgY3VycmVudENyZHQgPSBjdXJyZW50SXRlbXMuZ2V0KGlkKTtcbiAgICBpZiAoY3VycmVudENyZHQpIHtcbiAgICAgIGlmIChjcmR0LnR5cGUgPT09IDAgLyogT0JKRUNUICovKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q3JkdC50eXBlICE9PSAwIC8qIE9CSkVDVCAqLyB8fCBzdHJpbmdpZnlPckxvZyhjcmR0LmRhdGEpICE9PSBzdHJpbmdpZnlPckxvZyhjdXJyZW50Q3JkdC5kYXRhKSkge1xuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjcmR0LnBhcmVudEtleSAhPT0gY3VycmVudENyZHQucGFyZW50S2V5KSB7XG4gICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhcmVudEtleTogbm4oY3JkdC5wYXJlbnRLZXksIFwiUGFyZW50IGtleSBtdXN0IG5vdCBiZSBtaXNzaW5nXCIpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGNyZHQudHlwZSkge1xuICAgICAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogOCAvKiBDUkVBVEVfUkVHSVNURVIgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogTElTVCAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwIC8qIE9CSkVDVCAqLzpcbiAgICAgICAgICBpZiAoY3JkdC5wYXJlbnRJZCA9PT0gdm9pZCAwIHx8IGNyZHQucGFyZW50S2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnRlcm5hbCBlcnJvci4gQ2Fubm90IHNlcmlhbGl6ZSBzdG9yYWdlIHJvb3QgaW50byBhbiBvcGVyYXRpb25cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogNCAvKiBDUkVBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXksXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIE1BUCAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvcHM7XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSBmaXJzdC51cGRhdGVzO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKHNlY29uZC51cGRhdGVzKSkge1xuICAgIHVwZGF0ZXNba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc2Vjb25kLFxuICAgIHVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTGlzdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIHJldHVybiB7XG4gICAgLi4uc2Vjb25kLFxuICAgIHVwZGF0ZXM6IHVwZGF0ZXMuY29uY2F0KHNlY29uZC51cGRhdGVzKVxuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGlmIChmaXJzdCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHNlY29uZDtcbiAgfVxuICBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZU9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlTWFwXCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZU1hcFwiKSB7XG4gICAgcmV0dXJuIG1lcmdlTWFwU3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlTGlzdFwiICYmIHNlY29uZC50eXBlID09PSBcIkxpdmVMaXN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSB7XG4gIH1cbiAgcmV0dXJuIHNlY29uZDtcbn1cbmZ1bmN0aW9uIGlzUGxhaW4odmFsdWUpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHZhbHVlLCBwYXRoID0gXCJcIikge1xuICBpZiAoIWlzUGxhaW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCB8fCBcInJvb3RcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgbmVzdGVkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmICghaXNQbGFpbihuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qgbm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoXG4gICAgICAgIG5lc3RlZFZhbHVlLFxuICAgICAgICBuZXN0ZWRQYXRoXG4gICAgICApO1xuICAgICAgaWYgKG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvbGliL0RlcXVlLnRzXG52YXIgRGVxdWUgPSBjbGFzcyB7XG4gICNkYXRhO1xuICAjZnJvbnQ7XG4gICNiYWNrO1xuICAjc2l6ZTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy4jZGF0YSA9IHt9O1xuICAgIHRoaXMuI2Zyb250ID0gMDtcbiAgICB0aGlzLiNiYWNrID0gMTtcbiAgICB0aGlzLiNzaXplID0gMDtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiNzaXplO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy4jc2l6ZTtcbiAgICBjb25zdCBmcm9udCA9IHRoaXMuI2Zyb250O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB5aWVsZCB0aGlzLiNkYXRhW2Zyb250ICsgaV07XG4gICAgfVxuICB9XG4gIHB1c2godmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZXMyID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgaWYgKHRoaXMuI2JhY2sgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAtIHZhbHVlczIubGVuZ3RoIC0gMSlcbiAgICAgIHJhaXNlKFwiRGVxdWUgZnVsbFwiKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlMiBvZiB2YWx1ZXMyKSB7XG4gICAgICB0aGlzLiNkYXRhW3RoaXMuI2JhY2srKyAtIDFdID0gdmFsdWUyO1xuICAgIH1cbiAgICB0aGlzLiNzaXplICs9IHZhbHVlczIubGVuZ3RoO1xuICB9XG4gIHBvcCgpIHtcbiAgICBpZiAodGhpcy4jc2l6ZSA8IDEpIHJldHVybiB2b2lkIDA7XG4gICAgdGhpcy4jYmFjay0tO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZGF0YVt0aGlzLiNiYWNrIC0gMV07XG4gICAgZGVsZXRlIHRoaXMuI2RhdGFbdGhpcy4jYmFjayAtIDFdO1xuICAgIHRoaXMuI3NpemUtLTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcHVzaExlZnQodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZXMyID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgaWYgKHRoaXMuI2Zyb250IDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgKyB2YWx1ZXMyLmxlbmd0aClcbiAgICAgIHJhaXNlKFwiRGVxdWUgZnVsbFwiKTtcbiAgICBmb3IgKGxldCBpID0gdmFsdWVzMi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy4jZGF0YVstLXRoaXMuI2Zyb250XSA9IHZhbHVlczJbaV07XG4gICAgfVxuICAgIHRoaXMuI3NpemUgKz0gdmFsdWVzMi5sZW5ndGg7XG4gIH1cbiAgcG9wTGVmdCgpIHtcbiAgICBpZiAodGhpcy4jc2l6ZSA8IDEpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNkYXRhW3RoaXMuI2Zyb250XTtcbiAgICBkZWxldGUgdGhpcy4jZGF0YVt0aGlzLiNmcm9udF07XG4gICAgdGhpcy4jZnJvbnQrKztcbiAgICB0aGlzLiNzaXplLS07XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL0pzb24udHNcbmZ1bmN0aW9uIGlzSnNvblNjYWxhcihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBkYXRhID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzSnNvbkFycmF5KGRhdGEpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoZGF0YSkge1xuICByZXR1cm4gIWlzSnNvblNjYWxhcihkYXRhKSAmJiAhaXNKc29uQXJyYXkoZGF0YSk7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9DbGllbnRNc2cudHNcbnZhciBDbGllbnRNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoQ2xpZW50TXNnQ29kZTIpID0+IHtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJCUk9BRENBU1RfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RfRVZFTlRcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9TVE9SQUdFXCJdID0gMjAwXSA9IFwiRkVUQ0hfU1RPUkFHRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9ZRE9DXCJdID0gMzAwXSA9IFwiRkVUQ0hfWURPQ1wiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAxXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgcmV0dXJuIENsaWVudE1zZ0NvZGUyO1xufSkoQ2xpZW50TXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy9yZWZzL01hbmFnZWRPdGhlcnMudHNcbmZ1bmN0aW9uIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKSB7XG4gIGNvbnN0IHsgY29ubmVjdGlvbklkLCBpZCwgaW5mbyB9ID0gY29ubjtcbiAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoY29ubi5zY29wZXMpO1xuICByZXR1cm4gZnJlZXplKFxuICAgIGNvbXBhY3RPYmplY3Qoe1xuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgaWQsXG4gICAgICBpbmZvLFxuICAgICAgY2FuV3JpdGUsXG4gICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGNvbm4uc2NvcGVzKSxcbiAgICAgIGlzUmVhZE9ubHk6ICFjYW5Xcml0ZSxcbiAgICAgIC8vIERlcHJlY2F0ZWQsIGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcbiAgICAgIHByZXNlbmNlXG4gICAgfSlcbiAgKTtcbn1cbnZhciBNYW5hZ2VkT3RoZXJzID0gY2xhc3Mge1xuICAvLyBUcmFjayBtdXRhYmxlIHN0YXRlIGludGVybmFsbHksIGJ1dCBzaWduYWwgdG8gdGhlIG91dHNpZGUgd2hlbiB0aGVcbiAgLy8gb2JzZXJ2YWJsZSBkZXJpdmVkIHN0YXRlIGNoYW5nZXMgb25seVxuICAjaW50ZXJuYWw7XG4gICN1c2VyQ2FjaGU7XG4gIC8vIFRoZSBcImNsZWFuXCIgc2lnbmFsIHRoYXQgaXMgZXhwb3NlZCB0byB0aGUgb3V0c2lkZSB3b3JsZFxuICBzaWduYWw7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuI2ludGVybmFsID0gbmV3IE11dGFibGVTaWduYWwoe1xuICAgICAgY29ubmVjdGlvbnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBwcmVzZW5jZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICB9KTtcbiAgICB0aGlzLnNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICAgIHRoaXMuI2ludGVybmFsLFxuICAgICAgKF9pZ25vcmUpID0+IGNvbXBhY3QoXG4gICAgICAgIEFycmF5LmZyb20odGhpcy4jaW50ZXJuYWwuZ2V0KCkucHJlc2VuY2VzLmtleXMoKSkubWFwKFxuICAgICAgICAgIChjb25uZWN0aW9uSWQpID0+IHRoaXMuZ2V0VXNlcihOdW1iZXIoY29ubmVjdGlvbklkKSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy4jdXNlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvLyBTaG9ydGhhbmQgZm9yIC5zaWduYWwuZ2V0KClcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnNpZ25hbC5nZXQoKTtcbiAgfVxuICBjb25uZWN0aW9uSWRzKCkge1xuICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbC5nZXQoKS5jb25uZWN0aW9ucy5rZXlzKCk7XG4gIH1cbiAgY2xlYXJPdGhlcnMoKSB7XG4gICAgdGhpcy4jaW50ZXJuYWwubXV0YXRlKChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUuY29ubmVjdGlvbnMuY2xlYXIoKTtcbiAgICAgIHN0YXRlLnByZXNlbmNlcy5jbGVhcigpO1xuICAgICAgdGhpcy4jdXNlckNhY2hlLmNsZWFyKCk7XG4gICAgfSk7XG4gIH1cbiAgI19nZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jaW50ZXJuYWwuZ2V0KCk7XG4gICAgY29uc3QgY29ubiA9IHN0YXRlLmNvbm5lY3Rpb25zLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGNvbnN0IHByZXNlbmNlID0gc3RhdGUucHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb25uICE9PSB2b2lkIDAgJiYgcHJlc2VuY2UgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNhY2hlZFVzZXIgPSB0aGlzLiN1c2VyQ2FjaGUuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNhY2hlZFVzZXIpIHtcbiAgICAgIHJldHVybiBjYWNoZWRVc2VyO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZFVzZXIgPSB0aGlzLiNfZ2V0VXNlcihjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb21wdXRlZFVzZXIpIHtcbiAgICAgIHRoaXMuI3VzZXJDYWNoZS5zZXQoY29ubmVjdGlvbklkLCBjb21wdXRlZFVzZXIpO1xuICAgICAgcmV0dXJuIGNvbXB1dGVkVXNlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAjaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgdGhpcy4jdXNlckNhY2hlLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNvcmRzIGEga25vd24gY29ubmVjdGlvbi4gVGhpcyByZWNvcmRzIHRoZSBjb25uZWN0aW9uIElEIGFuZCB0aGVcbiAgICogYXNzb2NpYXRlZCBtZXRhZGF0YS5cbiAgICovXG4gIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBtZXRhVXNlcklkLCBtZXRhVXNlckluZm8sIHNjb3Blcykge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNvbm5lY3Rpb25zLnNldChcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICBmcmVlemUoe1xuICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICBpZDogbWV0YVVzZXJJZCxcbiAgICAgICAgICBpbmZvOiBtZXRhVXNlckluZm8sXG4gICAgICAgICAgc2NvcGVzXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgaWYgKCFzdGF0ZS5wcmVzZW5jZXMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBrbm93biBjb25uZWN0aW9uSWQuIFJlbW92ZXMgYm90aCB0aGUgY29ubmVjdGlvbidzIG1ldGFkYXRhIGFuZFxuICAgKiB0aGUgcHJlc2VuY2UgaW5mb3JtYXRpb24uXG4gICAqL1xuICByZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCkge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNvbm5lY3Rpb25zLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgc3RhdGUucHJlc2VuY2VzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RvcmVzIGEgbmV3IHVzZXIgZnJvbSBhIGZ1bGwgcHJlc2VuY2UgdXBkYXRlLiBJZiB0aGUgdXNlciBhbHJlYWR5IGV4aXN0cyxcbiAgICogaXRzIGtub3duIHByZXNlbmNlIGRhdGEgaXMgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBzZXRPdGhlcihjb25uZWN0aW9uSWQsIHByZXNlbmNlKSB7XG4gICAgdGhpcy4jaW50ZXJuYWwubXV0YXRlKChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUucHJlc2VuY2VzLnNldChjb25uZWN0aW9uSWQsIGZyZWV6ZShjb21wYWN0T2JqZWN0KHByZXNlbmNlKSkpO1xuICAgICAgaWYgKCFzdGF0ZS5jb25uZWN0aW9ucy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgcHJlc2VuY2UgZGF0YSBmb3IgYW4gZXhpc3RpbmcgXCJvdGhlclwiLiBJZiB3ZSBkb24ndCBrbm93IHRoZVxuICAgKiBpbml0aWFsIHByZXNlbmNlIGRhdGEgZm9yIHRoaXMgdXNlciB5ZXQsIGRpc2NhcmQgdGhpcyBwYXRjaCBhbmQgYXdhaXQgdGhlXG4gICAqIGZ1bGwgLnNldE90aGVyKCkgY2FsbCBmaXJzdC5cbiAgICovXG4gIHBhdGNoT3RoZXIoY29ubmVjdGlvbklkLCBwYXRjaCkge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IG9sZFByZXNlbmNlID0gc3RhdGUucHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgaWYgKG9sZFByZXNlbmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3UHJlc2VuY2UgPSBtZXJnZShvbGRQcmVzZW5jZSwgcGF0Y2gpO1xuICAgICAgaWYgKG9sZFByZXNlbmNlID09PSBuZXdQcmVzZW5jZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKG5ld1ByZXNlbmNlKSk7XG4gICAgICByZXR1cm4gdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3R5cGVzL0xpdmVibG9ja3NFcnJvci50c1xudmFyIExpdmVibG9ja3NFcnJvciA9IGNsYXNzIF9MaXZlYmxvY2tzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnRleHQ7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvbnRleHQsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZSB9KTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiTGl2ZWJsb2Nrc0Vycm9yXCI7XG4gIH1cbiAgLyoqIENvbnZlbmllbmNlIGFjY2Vzc29yIGZvciBlcnJvci5jb250ZXh0LnJvb21JZCAoaWYgYXZhaWxhYmxlKSAqL1xuICBnZXQgcm9vbUlkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucm9vbUlkO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgVXNlIGBjb250ZXh0LmNvZGVgIGluc3RlYWQsIHRvIGVuYWJsZSB0eXBlIG5hcnJvd2luZyAqL1xuICBnZXQgY29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmNvZGU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMaXZlYmxvY2tzRXJyb3IgZnJvbSBhIGdlbmVyaWMgZXJyb3IsIGJ5IGF0dGFjaGluZyBMaXZlYmxvY2tzXG4gICAqIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gbGlrZSByb29tIElELCB0aHJlYWQgSUQsIGV0Yy5cbiAgICovXG4gIHN0YXRpYyBmcm9tKGNvbnRleHQsIGNhdXNlKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZWJsb2Nrc0Vycm9yKFxuICAgICAgZGVmYXVsdE1lc3NhZ2VGcm9tQ29udGV4dChjb250ZXh0KSxcbiAgICAgIGNvbnRleHQsXG4gICAgICBjYXVzZVxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBkZWZhdWx0TWVzc2FnZUZyb21Db250ZXh0KGNvbnRleHQpIHtcbiAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICBjYXNlIFwiUk9PTV9DT05ORUNUSU9OX0VSUk9SXCI6IHtcbiAgICAgIHN3aXRjaCAoY29udGV4dC5jb2RlKSB7XG4gICAgICAgIGNhc2UgNDAwMTpcbiAgICAgICAgICByZXR1cm4gXCJOb3QgYWxsb3dlZCB0byBjb25uZWN0IHRvIHRoZSByb29tXCI7XG4gICAgICAgIGNhc2UgNDAwNTpcbiAgICAgICAgICByZXR1cm4gXCJSb29tIGlzIGFscmVhZHkgZnVsbFwiO1xuICAgICAgICBjYXNlIDQwMDY6XG4gICAgICAgICAgcmV0dXJuIFwiS2lja2VkIG91dCBvZiB0aGUgcm9vbSwgYmVjYXVzZSB0aGUgcm9vbSBJRCBjaGFuZ2VkXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGNvbm5lY3QgdG8gdGhlIHJvb21cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgY2FzZSBcIkFJX0NPTk5FQ1RJT05fRVJST1JcIjoge1xuICAgICAgc3dpdGNoIChjb250ZXh0LmNvZGUpIHtcbiAgICAgICAgY2FzZSA0MDAxOlxuICAgICAgICAgIHJldHVybiBcIk5vdCBhbGxvd2VkIHRvIGNvbm5lY3QgdG8gYWlcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gXCJDb3VsZCBub3QgY29ubmVjdCB0byB0aGUgcm9vbVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXNlIFwiQ1JFQVRFX1RIUkVBRF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGNyZWF0ZSBuZXcgdGhyZWFkXCI7XG4gICAgY2FzZSBcIkRFTEVURV9USFJFQURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgdGhyZWFkXCI7XG4gICAgY2FzZSBcIkVESVRfVEhSRUFEX01FVEFEQVRBX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgZWRpdCB0aHJlYWQgbWV0YWRhdGFcIjtcbiAgICBjYXNlIFwiTUFSS19USFJFQURfQVNfUkVTT0xWRURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBtYXJrIHRocmVhZCBhcyByZXNvbHZlZFwiO1xuICAgIGNhc2UgXCJNQVJLX1RIUkVBRF9BU19VTlJFU09MVkVEX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgbWFyayB0aHJlYWQgYXMgdW5yZXNvbHZlZFwiO1xuICAgIGNhc2UgXCJTVUJTQ1JJQkVfVE9fVEhSRUFEX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3Qgc3Vic2NyaWJlIHRvIHRocmVhZFwiO1xuICAgIGNhc2UgXCJVTlNVQlNDUklCRV9GUk9NX1RIUkVBRF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IHVuc3Vic2NyaWJlIGZyb20gdGhyZWFkXCI7XG4gICAgY2FzZSBcIkNSRUFURV9DT01NRU5UX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgY3JlYXRlIG5ldyBjb21tZW50XCI7XG4gICAgY2FzZSBcIkVESVRfQ09NTUVOVF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGVkaXQgY29tbWVudFwiO1xuICAgIGNhc2UgXCJERUxFVEVfQ09NTUVOVF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGRlbGV0ZSBjb21tZW50XCI7XG4gICAgY2FzZSBcIkFERF9SRUFDVElPTl9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGFkZCByZWFjdGlvblwiO1xuICAgIGNhc2UgXCJSRU1PVkVfUkVBQ1RJT05fRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCByZW1vdmUgcmVhY3Rpb25cIjtcbiAgICBjYXNlIFwiTUFSS19JTkJPWF9OT1RJRklDQVRJT05fQVNfUkVBRF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IG1hcmsgaW5ib3ggbm90aWZpY2F0aW9uIGFzIHJlYWRcIjtcbiAgICBjYXNlIFwiREVMRVRFX0lOQk9YX05PVElGSUNBVElPTl9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGRlbGV0ZSBpbmJveCBub3RpZmljYXRpb25cIjtcbiAgICBjYXNlIFwiTUFSS19BTExfSU5CT1hfTk9USUZJQ0FUSU9OU19BU19SRUFEX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgbWFyayBhbGwgaW5ib3ggbm90aWZpY2F0aW9ucyBhcyByZWFkXCI7XG4gICAgY2FzZSBcIkRFTEVURV9BTExfSU5CT1hfTk9USUZJQ0FUSU9OU19FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGRlbGV0ZSBhbGwgaW5ib3ggbm90aWZpY2F0aW9uc1wiO1xuICAgIGNhc2UgXCJVUERBVEVfUk9PTV9TVUJTQ1JJUFRJT05fU0VUVElOR1NfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCB1cGRhdGUgcm9vbSBzdWJzY3JpcHRpb24gc2V0dGluZ3NcIjtcbiAgICBjYXNlIFwiVVBEQVRFX05PVElGSUNBVElPTl9TRVRUSU5HU19FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IHVwZGF0ZSBub3RpZmljYXRpb24gc2V0dGluZ3NcIjtcbiAgICBjYXNlIFwiTEFSR0VfTUVTU0FHRV9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IHNlbmQgbGFyZ2UgbWVzc2FnZVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoY29udGV4dCwgXCJVbmhhbmRsZWQgY2FzZVwiKTtcbiAgfVxufVxuXG4vLyBzcmMvcm9vbS50c1xudmFyIE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFID0gMTAyNCAqIDEwMjQgLSA1MTI7XG5mdW5jdGlvbiBtYWtlSWRGYWN0b3J5KGNvbm5lY3Rpb25JZCkge1xuICBsZXQgY291bnQgPSAwO1xuICByZXR1cm4gKCkgPT4gYCR7Y29ubmVjdGlvbklkfToke2NvdW50Kyt9YDtcbn1cbmZ1bmN0aW9uIHVzZXJUb1RyZWVOb2RlKGtleSwgdXNlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVXNlclwiLFxuICAgIGlkOiBgJHt1c2VyLmNvbm5lY3Rpb25JZH1gLFxuICAgIGtleSxcbiAgICBwYXlsb2FkOiB7XG4gICAgICBjb25uZWN0aW9uSWQ6IHVzZXIuY29ubmVjdGlvbklkLFxuICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICBpbmZvOiB1c2VyLmluZm8sXG4gICAgICBwcmVzZW5jZTogdXNlci5wcmVzZW5jZSxcbiAgICAgIGlzUmVhZE9ubHk6ICF1c2VyLmNhbldyaXRlXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaW5zdGFsbEJhY2tncm91bmRUYWJTcHkoKSB7XG4gIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICBjb25zdCBpbkJhY2tncm91bmRTaW5jZSA9IHsgY3VycmVudDogbnVsbCB9O1xuICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgaWYgKGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiKSB7XG4gICAgICBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID0gaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCA/PyBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZG9jPy5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICBjb25zdCB1bnN1YiA9ICgpID0+IHtcbiAgICBkb2M/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIH07XG4gIHJldHVybiBbaW5CYWNrZ3JvdW5kU2luY2UsIHVuc3ViXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb20ob3B0aW9ucywgY29uZmlnKSB7XG4gIGNvbnN0IHJvb21JZCA9IGNvbmZpZy5yb29tSWQ7XG4gIGNvbnN0IGluaXRpYWxQcmVzZW5jZSA9IG9wdGlvbnMuaW5pdGlhbFByZXNlbmNlO1xuICBjb25zdCBpbml0aWFsU3RvcmFnZSA9IG9wdGlvbnMuaW5pdGlhbFN0b3JhZ2U7XG4gIGNvbnN0IGh0dHBDbGllbnQgPSBjb25maWcucm9vbUh0dHBDbGllbnQ7XG4gIGNvbnN0IFtpbkJhY2tncm91bmRTaW5jZSwgdW5pbnN0YWxsQmdUYWJTcHldID0gaW5zdGFsbEJhY2tncm91bmRUYWJTcHkoKTtcbiAgY29uc3QgZGVsZWdhdGVzID0ge1xuICAgIC4uLmNvbmZpZy5kZWxlZ2F0ZXMsXG4gICAgLy8gQSBjb25uZWN0aW9uIGlzIGFsbG93ZWQgdG8gZ28gaW50byBcInpvbWJpZSBzdGF0ZVwiIG9ubHkgaWYgYWxsIG9mIHRoZVxuICAgIC8vIGZvbGxvd2luZyBjb25kaXRpb25zIGFwcGx5OlxuICAgIC8vXG4gICAgLy8gLSBUaGUgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBjbGllbnQgb3B0aW9uIGlzIGNvbmZpZ3VyZWRcbiAgICAvLyAtIFRoZSBicm93c2VyIHdpbmRvdyBoYXMgYmVlbiBpbiB0aGUgYmFja2dyb3VuZCBmb3IgYXQgbGVhc3RcbiAgICAvLyAgIGBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dGAgbWlsbGlzZWNvbmRzXG4gICAgLy8gLSBUaGVyZSBhcmUgbm8gcGVuZGluZyBjaGFuZ2VzXG4gICAgLy9cbiAgICBjYW5ab21iaWUoKSB7XG4gICAgICByZXR1cm4gY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICE9PSB2b2lkIDAgJiYgaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCAhPT0gbnVsbCAmJiBEYXRlLm5vdygpID4gaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCArIGNvbmZpZy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCAmJiBnZXRTdG9yYWdlU3RhdHVzKCkgIT09IFwic3luY2hyb25pemluZ1wiO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWFuYWdlZFNvY2tldCA9IG5ldyBNYW5hZ2VkU29ja2V0KFxuICAgIGRlbGVnYXRlcyxcbiAgICBjb25maWcuZW5hYmxlRGVidWdMb2dnaW5nXG4gICk7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgYnVmZmVyOiB7XG4gICAgICBmbHVzaFRpbWVySUQ6IHZvaWQgMCxcbiAgICAgIGxhc3RGbHVzaGVkQXQ6IDAsXG4gICAgICBwcmVzZW5jZVVwZGF0ZXM6IChcbiAgICAgICAgLy8gUXVldWUgdXAgdGhlIGluaXRpYWwgcHJlc2VuY2UgbWVzc2FnZSBhcyBhIEZ1bGwgUHJlc2VuY2XihKIgdXBkYXRlXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImZ1bGxcIixcbiAgICAgICAgICBkYXRhOiBpbml0aWFsUHJlc2VuY2VcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXVxuICAgIH0sXG4gICAgc3RhdGljU2Vzc2lvbkluZm9TaWc6IG5ldyBTaWduYWwobnVsbCksXG4gICAgZHluYW1pY1Nlc3Npb25JbmZvU2lnOiBuZXcgU2lnbmFsKG51bGwpLFxuICAgIG15UHJlc2VuY2U6IG5ldyBQYXRjaGFibGVTaWduYWwoaW5pdGlhbFByZXNlbmNlKSxcbiAgICBvdGhlcnM6IG5ldyBNYW5hZ2VkT3RoZXJzKCksXG4gICAgaW5pdGlhbFN0b3JhZ2UsXG4gICAgaWRGYWN0b3J5OiBudWxsLFxuICAgIC8vIFRoZSBZanMgcHJvdmlkZXIgYXNzb2NpYXRlZCB0byB0aGlzIHJvb21cbiAgICB5anNQcm92aWRlcjogdm9pZCAwLFxuICAgIHlqc1Byb3ZpZGVyRGlkQ2hhbmdlOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAvLyBTdG9yYWdlXG4gICAgcG9vbDogY3JlYXRlTWFuYWdlZFBvb2wocm9vbUlkLCB7XG4gICAgICBnZXRDdXJyZW50Q29ubmVjdGlvbklkLFxuICAgICAgb25EaXNwYXRjaCxcbiAgICAgIGlzU3RvcmFnZVdyaXRhYmxlXG4gICAgfSksXG4gICAgcm9vdDogdm9pZCAwLFxuICAgIHVuZG9TdGFjazogW10sXG4gICAgcmVkb1N0YWNrOiBbXSxcbiAgICBwYXVzZWRIaXN0b3J5OiBudWxsLFxuICAgIGFjdGl2ZUJhdGNoOiBudWxsLFxuICAgIHVuYWNrbm93bGVkZ2VkT3BzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gIH07XG4gIGxldCBsYXN0VG9rZW5LZXk7XG4gIGZ1bmN0aW9uIG9uU3RhdHVzRGlkQ2hhbmdlKG5ld1N0YXR1cykge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlO1xuICAgIGlmIChhdXRoVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRva2VuS2V5ID0gZ2V0QmVhcmVyVG9rZW5Gcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSk7XG4gICAgICBpZiAodG9rZW5LZXkgIT09IGxhc3RUb2tlbktleSkge1xuICAgICAgICBsYXN0VG9rZW5LZXkgPSB0b2tlbktleTtcbiAgICAgICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICAgICAgY29uc3QgdG9rZW4gPSBhdXRoVmFsdWUudG9rZW4ucGFyc2VkO1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm9TaWcuc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmlkIDogdG9rZW4udWlkLFxuICAgICAgICAgICAgdXNlckluZm86IHRva2VuLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8gPyB0b2tlbi5pbmZvIDogdG9rZW4udWlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvU2lnLnNldCh7XG4gICAgICAgICAgICB1c2VySWQ6IHZvaWQgMCxcbiAgICAgICAgICAgIHVzZXJJbmZvOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBldmVudEh1Yi5zdGF0dXMubm90aWZ5KG5ld1N0YXR1cyk7XG4gICAgbm90aWZ5U2VsZkNoYW5nZWQoKTtcbiAgfVxuICBsZXQgX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZDtcbiAgbGV0IF9oYXNMb3N0Q29ubmVjdGlvbiA9IGZhbHNlO1xuICBmdW5jdGlvbiBoYW5kbGVDb25uZWN0aW9uTG9zc0V2ZW50KG5ld1N0YXR1cykge1xuICAgIGlmIChuZXdTdGF0dXMgPT09IFwicmVjb25uZWN0aW5nXCIpIHtcbiAgICAgIF9jb25uZWN0aW9uTG9zc1RpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwibG9zdFwiKTtcbiAgICAgICAgX2hhc0xvc3RDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5vdGhlcnMuY2xlYXJPdGhlcnMoKTtcbiAgICAgICAgbm90aWZ5KHsgb3RoZXJzOiBbeyB0eXBlOiBcInJlc2V0XCIgfV0gfSk7XG4gICAgICB9LCBjb25maWcubG9zdENvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KF9jb25uZWN0aW9uTG9zc1RpbWVySWQpO1xuICAgICAgaWYgKF9oYXNMb3N0Q29ubmVjdGlvbikge1xuICAgICAgICBpZiAobmV3U3RhdHVzID09PSBcImRpc2Nvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwiZmFpbGVkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm5vdGlmeShcInJlc3RvcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9oYXNMb3N0Q29ubmVjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRpZENvbm5lY3QoKSB7XG4gICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0ge1xuICAgICAgdHlwZTogXCJmdWxsXCIsXG4gICAgICBkYXRhOiAoXG4gICAgICAgIC8vIEJlY2F1c2UgY29udGV4dC5tZS5jdXJyZW50IGlzIGEgcmVhZG9ubHkgb2JqZWN0LCB3ZSdsbCBoYXZlIHRvXG4gICAgICAgIC8vIG1ha2UgYSBjb3B5IGhlcmUuIE90aGVyd2lzZSwgdHlwZSBlcnJvcnMgaGFwcGVuIGxhdGVyIHdoZW5cbiAgICAgICAgLy8gXCJwYXRjaGluZ1wiIG15IHByZXNlbmNlLlxuICAgICAgICB7IC4uLmNvbnRleHQubXlQcmVzZW5jZS5nZXQoKSB9XG4gICAgICApXG4gICAgfTtcbiAgICBpZiAoX2dldFN0b3JhZ2UkICE9PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRpZERpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gIH1cbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25NZXNzYWdlLnN1YnNjcmliZShoYW5kbGVTZXJ2ZXJNZXNzYWdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShvblN0YXR1c0RpZENoYW5nZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUoaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZENvbm5lY3Quc3Vic2NyaWJlKG9uRGlkQ29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZERpc2Nvbm5lY3Quc3Vic2NyaWJlKG9uRGlkRGlzY29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uQ29ubmVjdGlvbkVycm9yLnN1YnNjcmliZSgoeyBtZXNzYWdlLCBjb2RlIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gXCJST09NX0NPTk5FQ1RJT05fRVJST1JcIjtcbiAgICBjb25zdCBlcnIgPSBuZXcgTGl2ZWJsb2Nrc0Vycm9yKG1lc3NhZ2UsIHsgdHlwZSwgY29kZSwgcm9vbUlkIH0pO1xuICAgIGNvbnN0IGRpZE5vdGlmeSA9IGNvbmZpZy5lcnJvckV2ZW50U291cmNlLm5vdGlmeShlcnIpO1xuICAgIGlmICghZGlkTm90aWZ5KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGVycm9yMihcbiAgICAgICAgICBgQ29ubmVjdGlvbiB0byB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZC4gUmVhc29uOiAke21lc3NhZ2V9IChjb2RlOiAke2NvZGV9KS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gb25EaXNwYXRjaChvcHMsIHJldmVyc2UsIHN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gub3BzLnB1c2gob3ApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyhcbiAgICAgICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gudXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5nZXQoa2V5KSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnB1c2hMZWZ0KHJldmVyc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRUb1VuZG9TdGFjayhyZXZlcnNlKTtcbiAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICBkaXNwYXRjaE9wcyhvcHMpO1xuICAgICAgbm90aWZ5KHsgc3RvcmFnZVVwZGF0ZXMgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzU3RvcmFnZVdyaXRhYmxlKCkge1xuICAgIGNvbnN0IHNjb3BlcyA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvU2lnLmdldCgpPy5zY29wZXM7XG4gICAgcmV0dXJuIHNjb3BlcyAhPT0gdm9pZCAwID8gY2FuV3JpdGVTdG9yYWdlKHNjb3BlcykgOiB0cnVlO1xuICB9XG4gIGNvbnN0IGV2ZW50SHViID0ge1xuICAgIHN0YXR1czogbWFrZUV2ZW50U291cmNlKCksXG4gICAgLy8gTmV3L3JlY29tbWVuZGVkIEFQSVxuICAgIGxvc3RDb25uZWN0aW9uOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBjdXN0b21FdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc2VsZjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgbXlQcmVzZW5jZTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgb3RoZXJzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlQmF0Y2g6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGhpc3Rvcnk6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlU3RhdHVzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICB5ZG9jOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBjb21tZW50czogbWFrZUV2ZW50U291cmNlKCksXG4gICAgcm9vbVdpbGxEZXN0cm95OiBtYWtlRXZlbnRTb3VyY2UoKVxuICB9O1xuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUZXh0TWVudGlvbihtZW50aW9uSWQsIG1lbnRpb24pIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5jcmVhdGVUZXh0TWVudGlvbih7IHJvb21JZCwgbWVudGlvbklkLCBtZW50aW9uIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRleHRNZW50aW9uKG1lbnRpb25JZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmRlbGV0ZVRleHRNZW50aW9uKHsgcm9vbUlkLCBtZW50aW9uSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVwb3J0VGV4dEVkaXRvcih0eXBlLCByb290S2V5KSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5yZXBvcnRUZXh0RWRpdG9yKHsgcm9vbUlkLCB0eXBlLCByb290S2V5IH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnMoKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQubGlzdFRleHRWZXJzaW9ucyh7IHJvb21JZCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsaXN0VGV4dFZlcnNpb25zU2luY2Uob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5saXN0VGV4dFZlcnNpb25zU2luY2Uoe1xuICAgICAgcm9vbUlkLFxuICAgICAgc2luY2U6IG9wdGlvbnMyLnNpbmNlLFxuICAgICAgc2lnbmFsOiBvcHRpb25zMi5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUZXh0VmVyc2lvbih2ZXJzaW9uSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXRUZXh0VmVyc2lvbih7IHJvb21JZCwgdmVyc2lvbklkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRleHRWZXJzaW9uKCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmNyZWF0ZVRleHRWZXJzaW9uKHsgcm9vbUlkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVDb250ZXh0dWFsUHJvbXB0KG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZXhlY3V0ZUNvbnRleHR1YWxQcm9tcHQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgLi4ub3B0aW9uczJcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiogY2h1bmtPcHMobXNnKSB7XG4gICAgY29uc3QgeyBvcHMsIC4uLnJlc3QgfSA9IG1zZztcbiAgICBpZiAob3BzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzcGxpdCBvcHMgaW50byBzbWFsbGVyIGNodW5rc1wiKTtcbiAgICB9XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcihvcHMubGVuZ3RoIC8gMik7XG4gICAgY29uc3QgZmlyc3RIYWxmID0gb3BzLnNsaWNlKDAsIG1pZCk7XG4gICAgY29uc3Qgc2Vjb25kSGFsZiA9IG9wcy5zbGljZShtaWQpO1xuICAgIGZvciAoY29uc3QgaGFsZk9wcyBvZiBbZmlyc3RIYWxmLCBzZWNvbmRIYWxmXSkge1xuICAgICAgY29uc3QgaGFsZiA9IHsgb3BzOiBoYWxmT3BzLCAuLi5yZXN0IH07XG4gICAgICBjb25zdCB0ZXh0ID0gc3RyaW5naWZ5T3JMb2coW2hhbGZdKTtcbiAgICAgIGlmICghaXNUb29CaWdGb3JXZWJTb2NrZXQodGV4dCkpIHtcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkKiBjaHVua09wcyhoYWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24qIGNodW5rTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICBpZiAobWVzc2FnZXMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKG1lc3NhZ2VzWzBdLnR5cGUgPT09IDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLykge1xuICAgICAgICB5aWVsZCogY2h1bmtPcHMobWVzc2FnZXNbMF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3Qgc3BsaXQgaW50byBjaHVua3Mgc21hbGxlciB0aGFuIHRoZSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IobWVzc2FnZXMubGVuZ3RoIC8gMik7XG4gICAgY29uc3QgZmlyc3RIYWxmID0gbWVzc2FnZXMuc2xpY2UoMCwgbWlkKTtcbiAgICBjb25zdCBzZWNvbmRIYWxmID0gbWVzc2FnZXMuc2xpY2UobWlkKTtcbiAgICBmb3IgKGNvbnN0IGhhbGYgb2YgW2ZpcnN0SGFsZiwgc2Vjb25kSGFsZl0pIHtcbiAgICAgIGNvbnN0IHRleHQgPSBzdHJpbmdpZnlPckxvZyhoYWxmKTtcbiAgICAgIGlmICghaXNUb29CaWdGb3JXZWJTb2NrZXQodGV4dCkpIHtcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkKiBjaHVua01lc3NhZ2VzKGhhbGYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1Rvb0JpZ0ZvcldlYlNvY2tldCh0ZXh0KSB7XG4gICAgaWYgKHRleHQubGVuZ3RoICogNCA8IE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCkubGVuZ3RoID49IE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFO1xuICB9XG4gIGZ1bmN0aW9uIHNlbmRNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29uZmlnLmxhcmdlTWVzc2FnZVN0cmF0ZWd5ID8/IFwiZGVmYXVsdFwiO1xuICAgIGNvbnN0IHRleHQgPSBzdHJpbmdpZnlPckxvZyhtZXNzYWdlcyk7XG4gICAgaWYgKCFpc1Rvb0JpZ0ZvcldlYlNvY2tldCh0ZXh0KSkge1xuICAgICAgcmV0dXJuIG1hbmFnZWRTb2NrZXQuc2VuZCh0ZXh0KTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgY2FzZSBcImRlZmF1bHRcIjoge1xuICAgICAgICBjb25zdCB0eXBlID0gXCJMQVJHRV9NRVNTQUdFX0VSUk9SXCI7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBMaXZlYmxvY2tzRXJyb3IoXCJNZXNzYWdlIGlzIHRvbyBsYXJnZSBmb3Igd2Vic29ja2V0c1wiLCB7XG4gICAgICAgICAgdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGlkTm90aWZ5ID0gY29uZmlnLmVycm9yRXZlbnRTb3VyY2Uubm90aWZ5KGVycik7XG4gICAgICAgIGlmICghZGlkTm90aWZ5KSB7XG4gICAgICAgICAgZXJyb3IyKFxuICAgICAgICAgICAgXCJNZXNzYWdlIGlzIHRvbyBsYXJnZSBmb3Igd2Vic29ja2V0cy4gIENvbmZpZ3VyZSBsYXJnZU1lc3NhZ2VTdHJhdGVneSBvcHRpb24gb3IgdXNlRXJyb3JMaXN0ZW5lciB0byBoYW5kbGUgdGhpcy5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FzZSBcInNwbGl0XCI6IHtcbiAgICAgICAgd2FybihcIk1lc3NhZ2UgaXMgdG9vIGxhcmdlIGZvciB3ZWJzb2NrZXRzLCBzcGxpdHRpbmcgaW50byBzbWFsbGVyIGNodW5rc1wiKTtcbiAgICAgICAgZm9yIChjb25zdCBjaHVuazIgb2YgY2h1bmtNZXNzYWdlcyhtZXNzYWdlcykpIHtcbiAgICAgICAgICBtYW5hZ2VkU29ja2V0LnNlbmQoY2h1bmsyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBOT1RFOiBUaGlzIHN0cmF0ZWd5IGlzIGV4cGVyaW1lbnRhbCBhcyBpdCB3aWxsIG5vdCB3b3JrIGluIGFsbCBzaXR1YXRpb25zLlxuICAgICAgLy8gSXQgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgYnJvYWRjYXN0aW5nLCBwcmVzZW5jZSB1cGRhdGVzLCBidXQgaXNuJ3Qgc3VpdGFibGVcbiAgICAgIC8vIGZvciBTdG9yYWdlIG9yIFlqcyB1cGRhdGVzIHlldCAoYmVjYXVzZSB0aHJvdWdoIHRoaXMgY2hhbm5lbCB0aGUgc2VydmVyIGRvZXNcbiAgICAgIC8vIG5vdCByZXNwb25kIHdpdGggYWNrcyBvciByZWplY3Rpb25zLCBjYXVzaW5nIHRoZSBjbGllbnQncyByZXBvcnRlZCBzdGF0dXMgdG9cbiAgICAgIC8vIGJlIHN0dWNrIGluIFwic3luY2hyb25pemluZ1wiIGZvcmV2ZXIpLlxuICAgICAgY2FzZSBcImV4cGVyaW1lbnRhbC1mYWxsYmFjay10by1odHRwXCI6IHtcbiAgICAgICAgd2FybihcIk1lc3NhZ2UgaXMgdG9vIGxhcmdlIGZvciB3ZWJzb2NrZXRzLCBzbyBzZW5kaW5nIG92ZXIgSFRUUCBpbnN0ZWFkXCIpO1xuICAgICAgICBjb25zdCBub25jZSA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvU2lnLmdldCgpPy5ub25jZSA/PyByYWlzZShcIlNlc3Npb24gaXMgbm90IGF1dGhvcml6ZWQgdG8gc2VuZCBtZXNzYWdlIG92ZXIgSFRUUFwiKTtcbiAgICAgICAgdm9pZCBodHRwQ2xpZW50LnNlbmRNZXNzYWdlc092ZXJIVFRQKHsgcm9vbUlkLCBub25jZSwgbWVzc2FnZXMgfSkudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgIGlmICghcmVzcC5vayAmJiByZXNwLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICBtYW5hZ2VkU29ja2V0LnJlY29ubmVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGVycm9yMihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZGVsaXZlciBtZXNzYWdlIG92ZXIgSFRUUDogJHtTdHJpbmcoZXJyKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgc2VsZiA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvU2lnLFxuICAgIGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvU2lnLFxuICAgIGNvbnRleHQubXlQcmVzZW5jZSxcbiAgICAoc3RhdGljU2Vzc2lvbiwgZHluYW1pY1Nlc3Npb24sIG15UHJlc2VuY2UpID0+IHtcbiAgICAgIGlmIChzdGF0aWNTZXNzaW9uID09PSBudWxsIHx8IGR5bmFtaWNTZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoZHluYW1pY1Nlc3Npb24uc2NvcGVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb25uZWN0aW9uSWQ6IGR5bmFtaWNTZXNzaW9uLmFjdG9yLFxuICAgICAgICAgIGlkOiBzdGF0aWNTZXNzaW9uLnVzZXJJZCxcbiAgICAgICAgICBpbmZvOiBzdGF0aWNTZXNzaW9uLnVzZXJJbmZvLFxuICAgICAgICAgIHByZXNlbmNlOiBteVByZXNlbmNlLFxuICAgICAgICAgIGNhbldyaXRlLFxuICAgICAgICAgIGNhbkNvbW1lbnQ6IGNhbkNvbW1lbnQoZHluYW1pY1Nlc3Npb24uc2NvcGVzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgbGV0IF9sYXN0U2VsZjtcbiAgZnVuY3Rpb24gbm90aWZ5U2VsZkNoYW5nZWQoKSB7XG4gICAgY29uc3QgY3VyclNlbGYgPSBzZWxmLmdldCgpO1xuICAgIGlmIChjdXJyU2VsZiAhPT0gbnVsbCAmJiBjdXJyU2VsZiAhPT0gX2xhc3RTZWxmKSB7XG4gICAgICBldmVudEh1Yi5zZWxmLm5vdGlmeShjdXJyU2VsZik7XG4gICAgICBfbGFzdFNlbGYgPSBjdXJyU2VsZjtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2VsZkFzVHJlZU5vZGUgPSBEZXJpdmVkU2lnbmFsLmZyb20oXG4gICAgc2VsZixcbiAgICAobWUpID0+IG1lICE9PSBudWxsID8gdXNlclRvVHJlZU5vZGUoXCJNZVwiLCBtZSkgOiBudWxsXG4gICk7XG4gIGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlUm9vdEZyb21NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiBjYW5ub3QgbG9hZCBzdG9yYWdlIHdpdGhvdXQgaXRlbXNcIik7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LnJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgdXBkYXRlUm9vdChtZXNzYWdlLml0ZW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5yb290ID0gTGl2ZU9iamVjdC5fZnJvbUl0ZW1zKG1lc3NhZ2UuaXRlbXMsIGNvbnRleHQucG9vbCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbldyaXRlID0gc2VsZi5nZXQoKT8uY2FuV3JpdGUgPz8gdHJ1ZTtcbiAgICBjb25zdCBzdGFja1NpemVCZWZvcmUgPSBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGg7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29udGV4dC5pbml0aWFsU3RvcmFnZSkge1xuICAgICAgaWYgKGNvbnRleHQucm9vdC5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChjYW5Xcml0ZSkge1xuICAgICAgICAgIGNvbnRleHQucm9vdC5zZXQoa2V5LCBjbG9uZUxzb24oY29udGV4dC5pbml0aWFsU3RvcmFnZVtrZXldKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gcG9wdWxhdGUgbWlzc2luZyBzdG9yYWdlIGtleSAnJHtrZXl9JywgYnV0IGN1cnJlbnQgdXNlciBoYXMgbm8gd3JpdGUgYWNjZXNzYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29udGV4dC51bmRvU3RhY2subGVuZ3RoID0gc3RhY2tTaXplQmVmb3JlO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJvb3QoaXRlbXMpIHtcbiAgICBpZiAoY29udGV4dC5yb290ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgbm9kZV0gb2YgY29udGV4dC5wb29sLm5vZGVzKSB7XG4gICAgICBjdXJyZW50SXRlbXMuc2V0KGlkLCBub2RlLl9zZXJpYWxpemUoKSk7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IGdldFRyZWVzRGlmZk9wZXJhdGlvbnMoY3VycmVudEl0ZW1zLCBuZXcgTWFwKGl0ZW1zKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMob3BzLCBmYWxzZSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzKTtcbiAgfVxuICBmdW5jdGlvbiBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMpIHtcbiAgICBpZiAoY29udGV4dC51bmRvU3RhY2subGVuZ3RoID49IDUwKSB7XG4gICAgICBjb250ZXh0LnVuZG9TdGFjay5zaGlmdCgpO1xuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5wdXNoKGhpc3RvcnlPcHMpO1xuICAgIG9uSGlzdG9yeUNoYW5nZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFRvVW5kb1N0YWNrKGhpc3RvcnlPcHMpIHtcbiAgICBpZiAoY29udGV4dC5wYXVzZWRIaXN0b3J5ICE9PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkucHVzaExlZnQoaGlzdG9yeU9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeSh1cGRhdGVzKSB7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSB1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzO1xuICAgIGNvbnN0IG90aGVyc1VwZGF0ZXMgPSB1cGRhdGVzLm90aGVycztcbiAgICBpZiAob3RoZXJzVXBkYXRlcyAhPT0gdm9pZCAwICYmIG90aGVyc1VwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuZ2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIG90aGVyc1VwZGF0ZXMpIHtcbiAgICAgICAgZXZlbnRIdWIub3RoZXJzLm5vdGlmeSh7IC4uLmV2ZW50LCBvdGhlcnMgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGVzLnByZXNlbmNlID8/IGZhbHNlKSB7XG4gICAgICBub3RpZnlTZWxmQ2hhbmdlZCgpO1xuICAgICAgZXZlbnRIdWIubXlQcmVzZW5jZS5ub3RpZnkoY29udGV4dC5teVByZXNlbmNlLmdldCgpKTtcbiAgICB9XG4gICAgaWYgKHN0b3JhZ2VVcGRhdGVzICE9PSB2b2lkIDAgJiYgc3RvcmFnZVVwZGF0ZXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IHVwZGF0ZXMyID0gQXJyYXkuZnJvbShzdG9yYWdlVXBkYXRlcy52YWx1ZXMoKSk7XG4gICAgICBldmVudEh1Yi5zdG9yYWdlQmF0Y2gubm90aWZ5KHVwZGF0ZXMyKTtcbiAgICB9XG4gICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRDb25uZWN0aW9uSWQoKSB7XG4gICAgY29uc3QgaW5mbyA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvU2lnLmdldCgpO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICByZXR1cm4gaW5mby5hY3RvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnRlcm5hbC4gVHJpZWQgdG8gZ2V0IGNvbm5lY3Rpb24gaWQgYnV0IGNvbm5lY3Rpb24gd2FzIG5ldmVyIG9wZW5cIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlPcHMocmF3T3BzLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgcmV2ZXJzZTogbmV3IERlcXVlKCksXG4gICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIHByZXNlbmNlOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgY3JlYXRlZE5vZGVJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IG9wcyA9IHJhd09wcy5tYXAoKG9wKSA9PiB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiICYmICFvcC5vcElkKSB7XG4gICAgICAgIHJldHVybiB7IC4uLm9wLCBvcElkOiBjb250ZXh0LnBvb2wuZ2VuZXJhdGVPcElkKCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgPT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb25zdCByZXZlcnNlID0ge1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgcmV2ZXJzZS5kYXRhW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuZ2V0KClba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Lm15UHJlc2VuY2UucGF0Y2gob3AuZGF0YSk7XG4gICAgICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7IHR5cGU6IFwicGFydGlhbFwiLCBkYXRhOiBvcC5kYXRhIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFba2V5XSA9IG9wLmRhdGFba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnJldmVyc2UucHVzaExlZnQocmV2ZXJzZSk7XG4gICAgICAgIG91dHB1dC5wcmVzZW5jZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc291cmNlO1xuICAgICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICAgIHNvdXJjZSA9IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9wSWQgPSBubihvcC5vcElkKTtcbiAgICAgICAgICBjb25zdCBkZWxldGVkID0gY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5kZWxldGUob3BJZCk7XG4gICAgICAgICAgc291cmNlID0gZGVsZXRlZCA/IDIgLyogQUNLICovIDogMSAvKiBSRU1PVEUgKi87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwbHlPcFJlc3VsdCA9IGFwcGx5T3Aob3AsIHNvdXJjZSk7XG4gICAgICAgIGlmIChhcHBseU9wUmVzdWx0Lm1vZGlmaWVkKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUlkID0gYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZDtcbiAgICAgICAgICBpZiAoIShub2RlSWQgJiYgY3JlYXRlZE5vZGVJZHMuaGFzKG5vZGVJZCkpKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICBubihhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkKSxcbiAgICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyhcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMuZ2V0KG5uKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQpKSxcbiAgICAgICAgICAgICAgICBhcHBseU9wUmVzdWx0Lm1vZGlmaWVkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXQucmV2ZXJzZS5wdXNoTGVmdChhcHBseU9wUmVzdWx0LnJldmVyc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gMiAvKiBDUkVBVEVfTElTVCAqLyB8fCBvcC50eXBlID09PSA3IC8qIENSRUFURV9NQVAgKi8gfHwgb3AudHlwZSA9PT0gNCAvKiBDUkVBVEVfT0JKRUNUICovKSB7XG4gICAgICAgICAgICBjcmVhdGVkTm9kZUlkcy5hZGQobm4ob3AuaWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wcyxcbiAgICAgIHJldmVyc2U6IEFycmF5LmZyb20ob3V0cHV0LnJldmVyc2UpLFxuICAgICAgdXBkYXRlczoge1xuICAgICAgICBzdG9yYWdlVXBkYXRlczogb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLFxuICAgICAgICBwcmVzZW5jZTogb3V0cHV0LnByZXNlbmNlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAoaXNBY2tPcChvcCkpIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLzpcbiAgICAgIGNhc2UgMyAvKiBVUERBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0LnBvb2wubm9kZXMuZ2V0KG9wLmlkKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLl9hcHBseShvcCwgc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLyk7XG4gICAgICB9XG4gICAgICBjYXNlIDEgLyogU0VUX1BBUkVOVF9LRVkgKi86IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRleHQucG9vbC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudC5ub2RlLl9zZXRDaGlsZEtleShcbiAgICAgICAgICAgIGFzUG9zKG9wLnBhcmVudEtleSksXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOiB7XG4gICAgICAgIGlmIChvcC5wYXJlbnRJZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNvbnRleHQucG9vbC5ub2Rlcy5nZXQob3AucGFyZW50SWQpO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudE5vZGUuX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVQcmVzZW5jZShwYXRjaCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBvbGRWYWx1ZXMgPSB7fTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7XG4gICAgICAgIHR5cGU6IFwicGFydGlhbFwiLFxuICAgICAgICBkYXRhOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlVmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG92ZXJyaWRlVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhW2tleV0gPSBvdmVycmlkZVZhbHVlO1xuICAgICAgb2xkVmFsdWVzW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuZ2V0KClba2V5XTtcbiAgICB9XG4gICAgY29udGV4dC5teVByZXNlbmNlLnBhdGNoKHBhdGNoKTtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnB1c2hMZWZ0KHtcbiAgICAgICAgICB0eXBlOiBcInByZXNlbmNlXCIsXG4gICAgICAgICAgZGF0YTogb2xkVmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC51cGRhdGVzLnByZXNlbmNlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICAgIGlmIChvcHRpb25zMj8uYWRkVG9IaXN0b3J5KSB7XG4gICAgICAgIGFkZFRvVW5kb1N0YWNrKFt7IHR5cGU6IFwicHJlc2VuY2VcIiwgZGF0YTogb2xkVmFsdWVzIH1dKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeSh7IHByZXNlbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UudGFyZ2V0QWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qgb2xkVXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgY29uc3QgbmV3VXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBpZiAob2xkVXNlciA9PT0gdm9pZCAwICYmIG5ld1VzZXIgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVudGVyXCIsIHVzZXI6IG5ld1VzZXIgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5vdGhlcnMucGF0Y2hPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpLCBtZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgdXBkYXRlczogbWVzc2FnZS5kYXRhLFxuICAgICAgICB1c2VyXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24obWVzc2FnZS5hY3Rvcik7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImxlYXZlXCIsIHVzZXIgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gb25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mb1NpZy5zZXQoe1xuICAgICAgYWN0b3I6IG1lc3NhZ2UuYWN0b3IsXG4gICAgICBub25jZTogbWVzc2FnZS5ub25jZSxcbiAgICAgIHNjb3BlczogbWVzc2FnZS5zY29wZXNcbiAgICB9KTtcbiAgICBjb250ZXh0LmlkRmFjdG9yeSA9IG1ha2VJZEZhY3RvcnkobWVzc2FnZS5hY3Rvcik7XG4gICAgbm90aWZ5U2VsZkNoYW5nZWQoKTtcbiAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb25JZCBvZiBjb250ZXh0Lm90aGVycy5jb25uZWN0aW9uSWRzKCkpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2Nvbm5lY3Rpb25JZF07XG4gICAgICBpZiAodXNlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbklkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWVzc2FnZS51c2Vycykge1xuICAgICAgY29uc3QgdXNlciA9IG1lc3NhZ2UudXNlcnNba2V5XTtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25JZCA9IE51bWJlcihrZXkpO1xuICAgICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICB1c2VyLmlkLFxuICAgICAgICB1c2VyLmluZm8sXG4gICAgICAgIHVzZXIuc2NvcGVzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInJlc2V0XCIgfTtcbiAgfVxuICBmdW5jdGlvbiBjYW5VbmRvKCkge1xuICAgIHJldHVybiBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIGNhblJlZG8oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gb25IaXN0b3J5Q2hhbmdlKCkge1xuICAgIGV2ZW50SHViLmhpc3Rvcnkubm90aWZ5KHsgY2FuVW5kbzogY2FuVW5kbygpLCBjYW5SZWRvOiBjYW5SZWRvKCkgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgIG1lc3NhZ2UuYWN0b3IsXG4gICAgICBtZXNzYWdlLmlkLFxuICAgICAgbWVzc2FnZS5pbmZvLFxuICAgICAgbWVzc2FnZS5zY29wZXNcbiAgICApO1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgIGRhdGE6IGNvbnRleHQubXlQcmVzZW5jZS5nZXQoKSxcbiAgICAgIHRhcmdldEFjdG9yOiBtZXNzYWdlLmFjdG9yXG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICByZXR1cm4gdXNlciA/IHsgdHlwZTogXCJlbnRlclwiLCB1c2VyIH0gOiB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTZXJ2ZXJNZXNzYWdlKGRhdGEpIHtcbiAgICBpZiAoIWlzSnNvbk9iamVjdChkYXRhKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VydmVyTWVzc2FnZXModGV4dCkge1xuICAgIGNvbnN0IGRhdGEgPSB0cnlQYXJzZUpzb24odGV4dCk7XG4gICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChpc0pzb25BcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoZGF0YS5tYXAoKGl0ZW0pID0+IHBhcnNlU2VydmVyTWVzc2FnZShpdGVtKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29tcGFjdChbcGFyc2VTZXJ2ZXJNZXNzYWdlKGRhdGEpXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFwcGx5QW5kU2VuZE9wcyhvZmZsaW5lT3BzKSB7XG4gICAgaWYgKG9mZmxpbmVPcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGNvbnN0IGluT3BzID0gQXJyYXkuZnJvbShvZmZsaW5lT3BzLnZhbHVlcygpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhpbk9wcywgdHJ1ZSk7XG4gICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICBvcHM6IHJlc3VsdC5vcHNcbiAgICB9KTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMpO1xuICAgIHNlbmRNZXNzYWdlcyhtZXNzYWdlcyk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlU2VydmVyTWVzc2FnZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IHBhcnNlU2VydmVyTWVzc2FnZXMoZXZlbnQuZGF0YSk7XG4gICAgaWYgKG1lc3NhZ2VzID09PSBudWxsIHx8IG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVzID0ge1xuICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBvdGhlcnM6IFtdXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMTAxIC8qIFVTRVJfSk9JTkVEICovOiB7XG4gICAgICAgICAgY29uc3QgdXNlckpvaW5lZFVwZGF0ZSA9IG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgaWYgKHVzZXJKb2luZWRVcGRhdGUpIHtcbiAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2godXNlckpvaW5lZFVwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLzoge1xuICAgICAgICAgIGNvbnN0IG90aGVyc1ByZXNlbmNlVXBkYXRlID0gb25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgaWYgKG90aGVyc1ByZXNlbmNlVXBkYXRlKSB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG90aGVyc1ByZXNlbmNlVXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxMDMgLyogQlJPQURDQVNURURfRVZFTlQgKi86IHtcbiAgICAgICAgICBjb25zdCBvdGhlcnMgPSBjb250ZXh0Lm90aGVycy5nZXQoKTtcbiAgICAgICAgICBldmVudEh1Yi5jdXN0b21FdmVudC5ub3RpZnkoe1xuICAgICAgICAgICAgY29ubmVjdGlvbklkOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgICAgICAgdXNlcjogbWVzc2FnZS5hY3RvciA8IDAgPyBudWxsIDogb3RoZXJzLmZpbmQoKHUpID0+IHUuY29ubmVjdGlvbklkID09PSBtZXNzYWdlLmFjdG9yKSA/PyBudWxsLFxuICAgICAgICAgICAgZXZlbnQ6IG1lc3NhZ2UuZXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDEwMiAvKiBVU0VSX0xFRlQgKi86IHtcbiAgICAgICAgICBjb25zdCBldmVudDIgPSBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICBpZiAoZXZlbnQyKSB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKGV2ZW50Mik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzAwIC8qIFVQREFURV9ZRE9DICovOiB7XG4gICAgICAgICAgZXZlbnRIdWIueWRvYy5ub3RpZnkobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxMDQgLyogUk9PTV9TVEFURSAqLzoge1xuICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2gob25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi86IHtcbiAgICAgICAgICBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgZXZlbnRcbiAgICAgICAgY2FzZSAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi86IHtcbiAgICAgICAgICBjb25zdCBhcHBseVJlc3VsdCA9IGFwcGx5T3BzKG1lc3NhZ2Uub3BzLCBmYWxzZSk7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXBwbHlSZXN1bHQudXBkYXRlcy5zdG9yYWdlVXBkYXRlcykge1xuICAgICAgICAgICAgdXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyh1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLmdldChrZXkpLCB2YWx1ZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY2VpdmluZyBhIFJlamVjdGVkT3BzIG1lc3NhZ2UgaW4gdGhlIGNsaWVudCBtZWFucyB0aGF0IHRoZSBzZXJ2ZXIgaXMgbm9cbiAgICAgICAgLy8gbG9uZ2VyIGluIHN5bmMgd2l0aCB0aGUgY2xpZW50LiBUcnlpbmcgdG8gc3luY2hyb25pemUgdGhlIGNsaWVudCBhZ2FpbiBieVxuICAgICAgICAvLyByb2xsaW5nIGJhY2sgcGFydGljdWxhciBPcHMgbWF5IGJlIGhhcmQvaW1wb3NzaWJsZS4gSXQncyBmaW5lIHRvIG5vdCB0cnkgYW5kXG4gICAgICAgIC8vIGFjY2VwdCB0aGUgb3V0LW9mLXN5bmMgcmVhbGl0eSBhbmQgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgIGNhc2UgMjk5IC8qIFJFSkVDVF9TVE9SQUdFX09QICovOiB7XG4gICAgICAgICAgZXJyb3JXaXRoVGl0bGUoXG4gICAgICAgICAgICBcIlN0b3JhZ2UgbXV0YXRpb24gcmVqZWN0aW9uIGVycm9yXCIsXG4gICAgICAgICAgICBtZXNzYWdlLnJlYXNvblxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgU3RvcmFnZSBtdXRhdGlvbnMgcmVqZWN0ZWQgYnkgc2VydmVyOiAke21lc3NhZ2UucmVhc29ufWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNDAwIC8qIFRIUkVBRF9DUkVBVEVEICovOlxuICAgICAgICBjYXNlIDQwNyAvKiBUSFJFQURfREVMRVRFRCAqLzpcbiAgICAgICAgY2FzZSA0MDEgLyogVEhSRUFEX01FVEFEQVRBX1VQREFURUQgKi86XG4gICAgICAgIGNhc2UgNDA4IC8qIFRIUkVBRF9VUERBVEVEICovOlxuICAgICAgICBjYXNlIDQwNSAvKiBDT01NRU5UX1JFQUNUSU9OX0FEREVEICovOlxuICAgICAgICBjYXNlIDQwNiAvKiBDT01NRU5UX1JFQUNUSU9OX1JFTU9WRUQgKi86XG4gICAgICAgIGNhc2UgNDAyIC8qIENPTU1FTlRfQ1JFQVRFRCAqLzpcbiAgICAgICAgY2FzZSA0MDMgLyogQ09NTUVOVF9FRElURUQgKi86XG4gICAgICAgIGNhc2UgNDA0IC8qIENPTU1FTlRfREVMRVRFRCAqLzoge1xuICAgICAgICAgIGV2ZW50SHViLmNvbW1lbnRzLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBub3RpZnkodXBkYXRlcyk7XG4gIH1cbiAgZnVuY3Rpb24gZmx1c2hOb3dPclNvb24oKSB7XG4gICAgY29uc3Qgc3RvcmFnZU9wcyA9IGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zO1xuICAgIGlmIChzdG9yYWdlT3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3Qgb3Agb2Ygc3RvcmFnZU9wcykge1xuICAgICAgICBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNldChubihvcC5vcElkKSwgb3ApO1xuICAgICAgfVxuICAgICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIH1cbiAgICBpZiAobWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMgPSBbXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm93MiA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZE1pbGxpcyA9IG5vdzIgLSBjb250ZXh0LmJ1ZmZlci5sYXN0Rmx1c2hlZEF0O1xuICAgIGlmIChlbGFwc2VkTWlsbGlzID49IGNvbmZpZy50aHJvdHRsZURlbGF5KSB7XG4gICAgICBjb25zdCBtZXNzYWdlc1RvRmx1c2ggPSBzZXJpYWxpemVCdWZmZXIoKTtcbiAgICAgIGlmIChtZXNzYWdlc1RvRmx1c2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbmRNZXNzYWdlcyhtZXNzYWdlc1RvRmx1c2gpO1xuICAgICAgY29udGV4dC5idWZmZXIgPSB7XG4gICAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgICBsYXN0Rmx1c2hlZEF0OiBub3cyLFxuICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXSxcbiAgICAgICAgcHJlc2VuY2VVcGRhdGVzOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCA9IHNldFRpbWVvdXQoXG4gICAgICAgIGZsdXNoTm93T3JTb29uLFxuICAgICAgICBjb25maWcudGhyb3R0bGVEZWxheSAtIGVsYXBzZWRNaWxsaXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlcigpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goXG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy50eXBlID09PSBcImZ1bGxcIiA/IHtcbiAgICAgICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgICAgIC8vIFBvcHVsYXRpbmcgdGhlIGB0YXJnZXRBY3RvcmAgZmllbGQgdHVybnMgdGhpcyBtZXNzYWdlIGludG9cbiAgICAgICAgICAvLyBhIEZ1bGwgUHJlc2VuY2XihKIgdXBkYXRlIG1lc3NhZ2UgKG5vdCBhIHBhdGNoKSwgd2hpY2ggd2lsbCBnZXRcbiAgICAgICAgICAvLyBpbnRlcnByZXRlZCBieSBvdGhlciBjbGllbnRzIGFzIHN1Y2guXG4gICAgICAgICAgdGFyZ2V0QWN0b3I6IC0xLFxuICAgICAgICAgIGRhdGE6IGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICAgIG9wczogY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZXM7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlWURvYyh1cGRhdGUsIGd1aWQsIGlzVjIpIHtcbiAgICBjb25zdCBjbGllbnRNc2cgPSB7XG4gICAgICB0eXBlOiAzMDEgLyogVVBEQVRFX1lET0MgKi8sXG4gICAgICB1cGRhdGUsXG4gICAgICBndWlkLFxuICAgICAgdjI6IGlzVjJcbiAgICB9O1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goY2xpZW50TXNnKTtcbiAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShjbGllbnRNc2cpO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gYnJvYWRjYXN0RXZlbnQoZXZlbnQsIG9wdGlvbnMyID0ge1xuICAgIHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIgJiYgIW9wdGlvbnMyLnNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAzIC8qIEJST0FEQ0FTVF9FVkVOVCAqLyxcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaE9wcyhvcHMpIHtcbiAgICBjb25zdCB7IHN0b3JhZ2VPcGVyYXRpb25zIH0gPSBjb250ZXh0LmJ1ZmZlcjtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgbGV0IF9nZXRTdG9yYWdlJCA9IG51bGw7XG4gIGxldCBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlID0gbnVsbDtcbiAgZnVuY3Rpb24gcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wcyA9IG5ldyBNYXAoY29udGV4dC51bmFja25vd2xlZGdlZE9wcyk7XG4gICAgY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgYXBwbHlBbmRTZW5kT3BzKHVuYWNrbm93bGVkZ2VkT3BzKTtcbiAgICBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlPy4oKTtcbiAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgZXZlbnRIdWIuc3RvcmFnZURpZExvYWQubm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RyZWFtU3RvcmFnZSgpIHtcbiAgICBpZiAoIW1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlKSByZXR1cm47XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCBodHRwQ2xpZW50LnN0cmVhbVN0b3JhZ2UoeyByb29tSWQgfSk7XG4gICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKHsgdHlwZTogMjAwIC8qIElOSVRJQUxfU1RPUkFHRV9TVEFURSAqLywgaXRlbXMgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaFN0b3JhZ2Uob3B0aW9uczIpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzO1xuICAgIGlmIChjb25maWcudW5zdGFibGVfc3RyZWFtRGF0YSkge1xuICAgICAgdm9pZCBzdHJlYW1TdG9yYWdlKCk7XG4gICAgfSBlbHNlIGlmICghbWVzc2FnZXMuc29tZSgobXNnKSA9PiBtc2cudHlwZSA9PT0gMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8pKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHsgdHlwZTogMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8gfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zMi5mbHVzaCkge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRMb2FkaW5nU3RvcmFnZSgpIHtcbiAgICBpZiAoX2dldFN0b3JhZ2UkID09PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiB0cnVlIH0pO1xuICAgICAgX2dldFN0b3JhZ2UkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlJDtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU25hcHNob3QoKSB7XG4gICAgY29uc3Qgcm9vdCA9IGNvbnRleHQucm9vdDtcbiAgICBpZiAocm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdm9pZCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmFnZSgpIHtcbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICByb290OiBjb250ZXh0LnJvb3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IG5uKGNvbnRleHQucm9vdClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZldGNoWURvYyh2ZWN0b3IsIGd1aWQsIGlzVjIpIHtcbiAgICBpZiAoIWNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLmZpbmQoKG0pID0+IHtcbiAgICAgIHJldHVybiBtLnR5cGUgPT09IDMwMCAvKiBGRVRDSF9ZRE9DICovICYmIG0udmVjdG9yID09PSB2ZWN0b3IgJiYgbS5ndWlkID09PSBndWlkICYmIG0udjIgPT09IGlzVjI7XG4gICAgfSkpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAzMDAgLyogRkVUQ0hfWURPQyAqLyxcbiAgICAgICAgdmVjdG9yLFxuICAgICAgICBndWlkLFxuICAgICAgICB2MjogaXNWMlxuICAgICAgfSk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gdW5kbygpIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5kbyBpcyBub3QgYWxsb3dlZCBkdXJpbmcgYSBiYXRjaFwiKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQudW5kb1N0YWNrLnBvcCgpO1xuICAgIGlmIChoaXN0b3J5T3BzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhoaXN0b3J5T3BzLCB0cnVlKTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMpO1xuICAgIGNvbnRleHQucmVkb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgIG9uSGlzdG9yeUNoYW5nZSgpO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiByZWRvKCkge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWRvIGlzIG5vdCBhbGxvd2VkIGR1cmluZyBhIGJhdGNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5yZWRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGhpc3RvcnlPcHMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKGhpc3RvcnlPcHMsIHRydWUpO1xuICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcyk7XG4gICAgY29udGV4dC51bmRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgb25IaXN0b3J5Q2hhbmdlKCk7XG4gICAgZm9yIChjb25zdCBvcCBvZiByZXN1bHQub3BzKSB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgfVxuICBmdW5jdGlvbiBiYXRjaDIoY2FsbGJhY2spIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGxldCByZXR1cm5WYWx1ZSA9IHZvaWQgMDtcbiAgICBjb250ZXh0LmFjdGl2ZUJhdGNoID0ge1xuICAgICAgb3BzOiBbXSxcbiAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICAgIHByZXNlbmNlOiBmYWxzZSxcbiAgICAgICAgb3RoZXJzOiBbXVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VPcHM6IG5ldyBEZXF1ZSgpXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb25zdCBjdXJyZW50QmF0Y2ggPSBjb250ZXh0LmFjdGl2ZUJhdGNoO1xuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IG51bGw7XG4gICAgICBpZiAoY3VycmVudEJhdGNoLnJldmVyc2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBhZGRUb1VuZG9TdGFjayhBcnJheS5mcm9tKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzKSk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRpc3BhdGNoT3BzKGN1cnJlbnRCYXRjaC5vcHMpO1xuICAgICAgfVxuICAgICAgbm90aWZ5KGN1cnJlbnRCYXRjaC51cGRhdGVzKTtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZUhpc3RvcnkoKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbmV3IERlcXVlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZUhpc3RvcnkoKSB7XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucGF1c2VkSGlzdG9yeTtcbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGlmIChoaXN0b3J5T3BzICE9PSBudWxsICYmIGhpc3RvcnlPcHMubGVuZ3RoID4gMCkge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhBcnJheS5mcm9tKGhpc3RvcnlPcHMpKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3luY1NvdXJjZUZvclN0b3JhZ2UgPSBjb25maWcuY3JlYXRlU3luY1NvdXJjZSgpO1xuICBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHVzKCkge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIF9nZXRTdG9yYWdlJCA9PT0gbnVsbCA/IFwibm90LWxvYWRlZFwiIDogXCJsb2FkaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNpemUgPT09IDAgPyBcInN5bmNocm9uaXplZFwiIDogXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9XG4gIGxldCBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgY29uc3Qgc3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgICBpZiAoX2xhc3RTdG9yYWdlU3RhdHVzICE9PSBzdG9yYWdlU3RhdHVzKSB7XG4gICAgICBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBzdG9yYWdlU3RhdHVzO1xuICAgICAgZXZlbnRIdWIuc3RvcmFnZVN0YXR1cy5ub3RpZnkoc3RvcmFnZVN0YXR1cyk7XG4gICAgfVxuICAgIHN5bmNTb3VyY2VGb3JTdG9yYWdlLnNldFN5bmNTdGF0dXMoXG4gICAgICBzdG9yYWdlU3RhdHVzID09PSBcInN5bmNocm9uaXppbmdcIiA/IFwic3luY2hyb25pemluZ1wiIDogXCJzeW5jaHJvbml6ZWRcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gaXNQcmVzZW5jZVJlYWR5KCkge1xuICAgIHJldHVybiBzZWxmLmdldCgpICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFByZXNlbmNlUmVhZHkoKSB7XG4gICAgd2hpbGUgKCFpc1ByZXNlbmNlUmVhZHkoKSkge1xuICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBQcm9taXNlX3dpdGhSZXNvbHZlcnMoKTtcbiAgICAgIGNvbnN0IHVuc3ViMSA9IGV2ZW50cy5zZWxmLnN1YnNjcmliZU9uY2UocmVzb2x2ZSk7XG4gICAgICBjb25zdCB1bnN1YjIgPSBldmVudHMuc3RhdHVzLnN1YnNjcmliZU9uY2UocmVzb2x2ZSk7XG4gICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgdW5zdWIxKCk7XG4gICAgICB1bnN1YjIoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdG9yYWdlUmVhZHkoKSB7XG4gICAgcmV0dXJuIGdldFN0b3JhZ2VTbmFwc2hvdCgpICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFN0b3JhZ2VSZWFkeSgpIHtcbiAgICB3aGlsZSAoIWlzU3RvcmFnZVJlYWR5KCkpIHtcbiAgICAgIGF3YWl0IGdldFN0b3JhZ2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb3RoZXJzX2ZvckRldlRvb2xzID0gRGVyaXZlZFNpZ25hbC5mcm9tKFxuICAgIGNvbnRleHQub3RoZXJzLnNpZ25hbCxcbiAgICAob3RoZXJzKSA9PiBvdGhlcnMubWFwKChvdGhlciwgaW5kZXgpID0+IHVzZXJUb1RyZWVOb2RlKGBPdGhlciAke2luZGV4fWAsIG90aGVyKSlcbiAgKTtcbiAgY29uc3QgZXZlbnRzID0ge1xuICAgIHN0YXR1czogZXZlbnRIdWIuc3RhdHVzLm9ic2VydmFibGUsXG4gICAgbG9zdENvbm5lY3Rpb246IGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm9ic2VydmFibGUsXG4gICAgY3VzdG9tRXZlbnQ6IGV2ZW50SHViLmN1c3RvbUV2ZW50Lm9ic2VydmFibGUsXG4gICAgb3RoZXJzOiBldmVudEh1Yi5vdGhlcnMub2JzZXJ2YWJsZSxcbiAgICBzZWxmOiBldmVudEh1Yi5zZWxmLm9ic2VydmFibGUsXG4gICAgbXlQcmVzZW5jZTogZXZlbnRIdWIubXlQcmVzZW5jZS5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VCYXRjaDogZXZlbnRIdWIuc3RvcmFnZUJhdGNoLm9ic2VydmFibGUsXG4gICAgaGlzdG9yeTogZXZlbnRIdWIuaGlzdG9yeS5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBldmVudEh1Yi5zdG9yYWdlRGlkTG9hZC5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VTdGF0dXM6IGV2ZW50SHViLnN0b3JhZ2VTdGF0dXMub2JzZXJ2YWJsZSxcbiAgICB5ZG9jOiBldmVudEh1Yi55ZG9jLm9ic2VydmFibGUsXG4gICAgY29tbWVudHM6IGV2ZW50SHViLmNvbW1lbnRzLm9ic2VydmFibGUsXG4gICAgcm9vbVdpbGxEZXN0cm95OiBldmVudEh1Yi5yb29tV2lsbERlc3Ryb3kub2JzZXJ2YWJsZVxuICB9O1xuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzU2luY2Uob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXRUaHJlYWRzU2luY2Uoe1xuICAgICAgcm9vbUlkLFxuICAgICAgc2luY2U6IG9wdGlvbnMyLnNpbmNlLFxuICAgICAgc2lnbmFsOiBvcHRpb25zMi5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0VGhyZWFkcyh7XG4gICAgICByb29tSWQsXG4gICAgICBxdWVyeTogb3B0aW9uczI/LnF1ZXJ5LFxuICAgICAgY3Vyc29yOiBvcHRpb25zMj8uY3Vyc29yXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkKHRocmVhZElkKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0VGhyZWFkKHsgcm9vbUlkLCB0aHJlYWRJZCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUaHJlYWQob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5jcmVhdGVUaHJlYWQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgdGhyZWFkSWQ6IG9wdGlvbnMyLnRocmVhZElkLFxuICAgICAgY29tbWVudElkOiBvcHRpb25zMi5jb21tZW50SWQsXG4gICAgICBtZXRhZGF0YTogb3B0aW9uczIubWV0YWRhdGEsXG4gICAgICBib2R5OiBvcHRpb25zMi5ib2R5LFxuICAgICAgYXR0YWNobWVudElkczogb3B0aW9uczIuYXR0YWNobWVudElkc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRocmVhZCh0aHJlYWRJZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmRlbGV0ZVRocmVhZCh7IHJvb21JZCwgdGhyZWFkSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdFRocmVhZE1ldGFkYXRhKHtcbiAgICBtZXRhZGF0YSxcbiAgICB0aHJlYWRJZFxuICB9KSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZWRpdFRocmVhZE1ldGFkYXRhKHsgcm9vbUlkLCB0aHJlYWRJZCwgbWV0YWRhdGEgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzUmVzb2x2ZWQodGhyZWFkSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5tYXJrVGhyZWFkQXNSZXNvbHZlZCh7IHJvb21JZCwgdGhyZWFkSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzVW5yZXNvbHZlZCh0aHJlYWRJZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50Lm1hcmtUaHJlYWRBc1VucmVzb2x2ZWQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgdGhyZWFkSWRcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdWJzY3JpYmVUb1RocmVhZCh0aHJlYWRJZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnN1YnNjcmliZVRvVGhyZWFkKHsgcm9vbUlkLCB0aHJlYWRJZCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1bnN1YnNjcmliZUZyb21UaHJlYWQodGhyZWFkSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC51bnN1YnNjcmliZUZyb21UaHJlYWQoeyByb29tSWQsIHRocmVhZElkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5jcmVhdGVDb21tZW50KHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHRocmVhZElkOiBvcHRpb25zMi50aHJlYWRJZCxcbiAgICAgIGNvbW1lbnRJZDogb3B0aW9uczIuY29tbWVudElkLFxuICAgICAgYm9keTogb3B0aW9uczIuYm9keSxcbiAgICAgIGF0dGFjaG1lbnRJZHM6IG9wdGlvbnMyLmF0dGFjaG1lbnRJZHNcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlZGl0Q29tbWVudChvcHRpb25zMikge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmVkaXRDb21tZW50KHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHRocmVhZElkOiBvcHRpb25zMi50aHJlYWRJZCxcbiAgICAgIGNvbW1lbnRJZDogb3B0aW9uczIuY29tbWVudElkLFxuICAgICAgYm9keTogb3B0aW9uczIuYm9keSxcbiAgICAgIGF0dGFjaG1lbnRJZHM6IG9wdGlvbnMyLmF0dGFjaG1lbnRJZHNcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVDb21tZW50KHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWRcbiAgfSkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmRlbGV0ZUNvbW1lbnQoeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gYWRkUmVhY3Rpb24oe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBlbW9qaVxuICB9KSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuYWRkUmVhY3Rpb24oeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVJlYWN0aW9uKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIHJldHVybiBhd2FpdCBodHRwQ2xpZW50LnJlbW92ZVJlYWN0aW9uKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHRocmVhZElkLFxuICAgICAgY29tbWVudElkLFxuICAgICAgZW1vamlcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBwcmVwYXJlQXR0YWNobWVudChmaWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibG9jYWxBdHRhY2htZW50XCIsXG4gICAgICBzdGF0dXM6IFwiaWRsZVwiLFxuICAgICAgaWQ6IGNyZWF0ZUNvbW1lbnRBdHRhY2htZW50SWQoKSxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgIG1pbWVUeXBlOiBmaWxlLnR5cGUsXG4gICAgICBmaWxlXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1cGxvYWRBdHRhY2htZW50KGF0dGFjaG1lbnQsIG9wdGlvbnMyID0ge30pIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC51cGxvYWRBdHRhY2htZW50KHtcbiAgICAgIHJvb21JZCxcbiAgICAgIGF0dGFjaG1lbnQsXG4gICAgICBzaWduYWw6IG9wdGlvbnMyLnNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEF0dGFjaG1lbnRVcmwoYXR0YWNobWVudElkKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0QXR0YWNobWVudFVybCh7IHJvb21JZCwgYXR0YWNobWVudElkIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvblNldHRpbmdzKG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0U3Vic2NyaXB0aW9uU2V0dGluZ3Moe1xuICAgICAgcm9vbUlkLFxuICAgICAgc2lnbmFsOiBvcHRpb25zMj8uc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlU3Vic2NyaXB0aW9uU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC51cGRhdGVTdWJzY3JpcHRpb25TZXR0aW5ncyh7IHJvb21JZCwgc2V0dGluZ3MgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50Lm1hcmtSb29tSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25JZFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHN5bmNTb3VyY2VGb3JZanMgPSBjb25maWcuY3JlYXRlU3luY1NvdXJjZSgpO1xuICBmdW5jdGlvbiB5anNTdGF0dXNEaWRDaGFuZ2Uoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN5bmNTb3VyY2VGb3JZanMuc2V0U3luY1N0YXR1cyhcbiAgICAgIHN0YXR1cyA9PT0gXCJzeW5jaHJvbml6aW5nXCIgfHwgc3RhdHVzID09PSBcImxvYWRpbmdcIiA/IFwic3luY2hyb25pemluZ1wiIDogXCJzeW5jaHJvbml6ZWRcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICBba0ludGVybmFsXToge1xuICAgICAgICBnZXQgcHJlc2VuY2VCdWZmZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXM/LmRhdGEgPz8gbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgdW5kb1N0YWNrKCkge1xuICAgICAgICAgIHJldHVybiBkZWVwQ2xvbmUoY29udGV4dC51bmRvU3RhY2spO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0IG5vZGVDb3VudCgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5wb29sLm5vZGVzLnNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXRZanNQcm92aWRlcigpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC55anNQcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0WWpzUHJvdmlkZXIobmV3UHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0Lnlqc1Byb3ZpZGVyPy5vZmYoXCJzdGF0dXNcIiwgeWpzU3RhdHVzRGlkQ2hhbmdlKTtcbiAgICAgICAgICBjb250ZXh0Lnlqc1Byb3ZpZGVyID0gbmV3UHJvdmlkZXI7XG4gICAgICAgICAgbmV3UHJvdmlkZXI/Lm9uKFwic3RhdHVzXCIsIHlqc1N0YXR1c0RpZENoYW5nZSk7XG4gICAgICAgICAgY29udGV4dC55anNQcm92aWRlckRpZENoYW5nZS5ub3RpZnkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgeWpzUHJvdmlkZXJEaWRDaGFuZ2U6IGNvbnRleHQueWpzUHJvdmlkZXJEaWRDaGFuZ2Uub2JzZXJ2YWJsZSxcbiAgICAgICAgLy8gc2VuZCBtZXRhZGF0YSB3aGVuIHVzaW5nIGEgdGV4dCBlZGl0b3JcbiAgICAgICAgcmVwb3J0VGV4dEVkaXRvcixcbiAgICAgICAgLy8gY3JlYXRlIGEgdGV4dCBtZW50aW9uIHdoZW4gdXNpbmcgYSB0ZXh0IGVkaXRvclxuICAgICAgICBjcmVhdGVUZXh0TWVudGlvbixcbiAgICAgICAgLy8gZGVsZXRlIGEgdGV4dCBtZW50aW9uIHdoZW4gdXNpbmcgYSB0ZXh0IGVkaXRvclxuICAgICAgICBkZWxldGVUZXh0TWVudGlvbixcbiAgICAgICAgLy8gbGlzdCB2ZXJzaW9ucyBvZiB0aGUgZG9jdW1lbnRcbiAgICAgICAgbGlzdFRleHRWZXJzaW9ucyxcbiAgICAgICAgLy8gTGlzdCB2ZXJzaW9ucyBvZiB0aGUgZG9jdW1lbnQgc2luY2UgdGhlIHNwZWNpZmllZCBkYXRlXG4gICAgICAgIGxpc3RUZXh0VmVyc2lvbnNTaW5jZSxcbiAgICAgICAgLy8gZ2V0IGEgc3BlY2lmaWMgdmVyc2lvblxuICAgICAgICBnZXRUZXh0VmVyc2lvbixcbiAgICAgICAgLy8gY3JlYXRlIGEgdmVyc2lvblxuICAgICAgICBjcmVhdGVUZXh0VmVyc2lvbixcbiAgICAgICAgLy8gZXhlY3V0ZSBhIGNvbnRleHR1YWwgcHJvbXB0XG4gICAgICAgIGV4ZWN1dGVDb250ZXh0dWFsUHJvbXB0LFxuICAgICAgICAvLyBTdXBwb3J0IGZvciB0aGUgTGl2ZWJsb2NrcyBicm93c2VyIGV4dGVuc2lvblxuICAgICAgICBnZXRTZWxmX2ZvckRldlRvb2xzOiAoKSA9PiBzZWxmQXNUcmVlTm9kZS5nZXQoKSxcbiAgICAgICAgZ2V0T3RoZXJzX2ZvckRldlRvb2xzOiAoKSA9PiBvdGhlcnNfZm9yRGV2VG9vbHMuZ2V0KCksXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBzaW11bGF0ZToge1xuICAgICAgICAgIC8vIFRoZXNlIGV4aXN0IG9ubHkgZm9yIG91ciBFMkUgdGVzdGluZyBhcHBcbiAgICAgICAgICBleHBsaWNpdENsb3NlOiAoZXZlbnQpID0+IG1hbmFnZWRTb2NrZXQuX3ByaXZhdGVTZW5kTWFjaGluZUV2ZW50KHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfQ0xPU0VcIiwgZXZlbnQgfSksXG4gICAgICAgICAgcmF3U2VuZDogKGRhdGEpID0+IG1hbmFnZWRTb2NrZXQuc2VuZChkYXRhKVxuICAgICAgICB9LFxuICAgICAgICBhdHRhY2htZW50VXJsc1N0b3JlOiBodHRwQ2xpZW50LmdldE9yQ3JlYXRlQXR0YWNobWVudFVybHNTdG9yZShyb29tSWQpXG4gICAgICB9LFxuICAgICAgaWQ6IHJvb21JZCxcbiAgICAgIHN1YnNjcmliZTogbWFrZUNsYXNzaWNTdWJzY3JpYmVGbihcbiAgICAgICAgcm9vbUlkLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIGNvbmZpZy5lcnJvckV2ZW50U291cmNlXG4gICAgICApLFxuICAgICAgY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5jb25uZWN0KCksXG4gICAgICByZWNvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCksXG4gICAgICBkaXNjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmRpc2Nvbm5lY3QoKSxcbiAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByb29tV2lsbERlc3Ryb3ksIC4uLmV2ZW50c0V4Y2VwdERlc3Ryb3kgfSA9IGV2ZW50SHViO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBPYmplY3QudmFsdWVzKGV2ZW50c0V4Y2VwdERlc3Ryb3kpKSB7XG4gICAgICAgICAgc291cmNlLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBldmVudEh1Yi5yb29tV2lsbERlc3Ryb3kubm90aWZ5KCk7XG4gICAgICAgIGNvbnRleHQueWpzUHJvdmlkZXI/Lm9mZihcInN0YXR1c1wiLCB5anNTdGF0dXNEaWRDaGFuZ2UpO1xuICAgICAgICBzeW5jU291cmNlRm9yU3RvcmFnZS5kZXN0cm95KCk7XG4gICAgICAgIHN5bmNTb3VyY2VGb3JZanMuZGVzdHJveSgpO1xuICAgICAgICB1bmluc3RhbGxCZ1RhYlNweSgpO1xuICAgICAgICBtYW5hZ2VkU29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgcm9vbVdpbGxEZXN0cm95LmRpc3Bvc2UoKTtcbiAgICAgIH0sXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgdXBkYXRlUHJlc2VuY2UsXG4gICAgICB1cGRhdGVZRG9jLFxuICAgICAgYnJvYWRjYXN0RXZlbnQsXG4gICAgICAvLyBTdG9yYWdlXG4gICAgICBiYXRjaDogYmF0Y2gyLFxuICAgICAgaGlzdG9yeToge1xuICAgICAgICB1bmRvLFxuICAgICAgICByZWRvLFxuICAgICAgICBjYW5VbmRvLFxuICAgICAgICBjYW5SZWRvLFxuICAgICAgICBjbGVhcixcbiAgICAgICAgcGF1c2U6IHBhdXNlSGlzdG9yeSxcbiAgICAgICAgcmVzdW1lOiByZXN1bWVIaXN0b3J5XG4gICAgICB9LFxuICAgICAgZmV0Y2hZRG9jLFxuICAgICAgZ2V0U3RvcmFnZSxcbiAgICAgIGdldFN0b3JhZ2VTbmFwc2hvdCxcbiAgICAgIGdldFN0b3JhZ2VTdGF0dXMsXG4gICAgICBpc1ByZXNlbmNlUmVhZHksXG4gICAgICBpc1N0b3JhZ2VSZWFkeSxcbiAgICAgIHdhaXRVbnRpbFByZXNlbmNlUmVhZHk6IG1lbW9pemVPblN1Y2Nlc3Mod2FpdFVudGlsUHJlc2VuY2VSZWFkeSksXG4gICAgICB3YWl0VW50aWxTdG9yYWdlUmVhZHk6IG1lbW9pemVPblN1Y2Nlc3Mod2FpdFVudGlsU3RvcmFnZVJlYWR5KSxcbiAgICAgIGV2ZW50cyxcbiAgICAgIC8vIENvcmVcbiAgICAgIGdldFN0YXR1czogKCkgPT4gbWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSxcbiAgICAgIGdldFNlbGY6ICgpID0+IHNlbGYuZ2V0KCksXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgZ2V0UHJlc2VuY2U6ICgpID0+IGNvbnRleHQubXlQcmVzZW5jZS5nZXQoKSxcbiAgICAgIGdldE90aGVyczogKCkgPT4gY29udGV4dC5vdGhlcnMuZ2V0KCksXG4gICAgICAvLyBDb21tZW50c1xuICAgICAgZ2V0VGhyZWFkcyxcbiAgICAgIGdldFRocmVhZHNTaW5jZSxcbiAgICAgIGdldFRocmVhZCxcbiAgICAgIGNyZWF0ZVRocmVhZCxcbiAgICAgIGRlbGV0ZVRocmVhZCxcbiAgICAgIGVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICAgIG1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICAgICAgbWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICAgIHN1YnNjcmliZVRvVGhyZWFkLFxuICAgICAgdW5zdWJzY3JpYmVGcm9tVGhyZWFkLFxuICAgICAgY3JlYXRlQ29tbWVudCxcbiAgICAgIGVkaXRDb21tZW50LFxuICAgICAgZGVsZXRlQ29tbWVudCxcbiAgICAgIGFkZFJlYWN0aW9uLFxuICAgICAgcmVtb3ZlUmVhY3Rpb24sXG4gICAgICBwcmVwYXJlQXR0YWNobWVudCxcbiAgICAgIHVwbG9hZEF0dGFjaG1lbnQsXG4gICAgICBnZXRBdHRhY2htZW50VXJsLFxuICAgICAgLy8gTm90aWZpY2F0aW9uc1xuICAgICAgZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3M6IGdldFN1YnNjcmlwdGlvblNldHRpbmdzLFxuICAgICAgZ2V0U3Vic2NyaXB0aW9uU2V0dGluZ3MsXG4gICAgICB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5nczogdXBkYXRlU3Vic2NyaXB0aW9uU2V0dGluZ3MsXG4gICAgICB1cGRhdGVTdWJzY3JpcHRpb25TZXR0aW5ncyxcbiAgICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZFxuICAgIH0sXG4gICAgLy8gRXhwbGljdGx5IG1ha2UgdGhlIGludGVybmFsIGZpZWxkIG5vbi1lbnVtZXJhYmxlLCB0byBhdm9pZCBhZ2dyZXNzaXZlXG4gICAgLy8gZnJlZXppbmcgd2hlbiB1c2VkIHdpdGggSW1tZXJcbiAgICBrSW50ZXJuYWwsXG4gICAgeyBlbnVtZXJhYmxlOiBmYWxzZSB9XG4gICk7XG59XG5mdW5jdGlvbiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKHJvb21JZCwgZXZlbnRzLCBlcnJvckV2ZW50cykge1xuICBmdW5jdGlvbiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVEZWVwbHkobm9kZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoKHVwZGF0ZXMpID0+IHtcbiAgICAgIGNvbnN0IHJlbGF0ZWRVcGRhdGVzID0gdXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICh1cGRhdGUpID0+IGlzU2FtZU5vZGVPckNoaWxkT2YodXBkYXRlLm5vZGUsIG5vZGUpXG4gICAgICApO1xuICAgICAgaWYgKHJlbGF0ZWRVcGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2FsbGJhY2socmVsYXRlZFVwZGF0ZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZVNoYWxsb3dseShub2RlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgZm9yIChjb25zdCB1cGRhdGUgb2YgdXBkYXRlcykge1xuICAgICAgICBpZiAodXBkYXRlLm5vZGUuX2lkID09PSBub2RlLl9pZCkge1xuICAgICAgICAgIGNhbGxiYWNrKHVwZGF0ZS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShmaXJzdCwgc2Vjb25kLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJzdHJpbmdcIiAmJiBpc1Jvb21FdmVudE5hbWUoZmlyc3QpKSB7XG4gICAgICBpZiAodHlwZW9mIHNlY29uZCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgY2FsbGJhY2sgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHNlY29uZDtcbiAgICAgIHN3aXRjaCAoZmlyc3QpIHtcbiAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJteS1wcmVzZW5jZVwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMubXlQcmVzZW5jZS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwib3RoZXJzXCI6IHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrO1xuICAgICAgICAgIHJldHVybiBldmVudHMub3RoZXJzLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3RoZXJzLCAuLi5pbnRlcm5hbEV2ZW50IH0gPSBldmVudDtcbiAgICAgICAgICAgIHJldHVybiBjYihvdGhlcnMsIGludGVybmFsRXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yRXZlbnRzLnN1YnNjcmliZSgoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwibG9zdC1jb25uZWN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJoaXN0b3J5XCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJzdG9yYWdlLXN0YXR1c1wiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuc3RvcmFnZVN0YXR1cy5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJjb21tZW50c1wiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuY29tbWVudHMuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBhc3NlcnROZXZlcihcbiAgICAgICAgICAgIGZpcnN0LFxuICAgICAgICAgICAgYFwiJHtTdHJpbmcoZmlyc3QpfVwiIGlzIG5vdCBhIHZhbGlkIGV2ZW50IG5hbWVgXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlY29uZCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBmaXJzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNhbGxiYWNrID0gZmlyc3Q7XG4gICAgICAgIHJldHVybiBldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZShzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNwZWNpZnkgYSBsaXN0ZW5lciBjYWxsYmFja1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTGl2ZU5vZGUoZmlyc3QpKSB7XG4gICAgICBjb25zdCBub2RlID0gZmlyc3Q7XG4gICAgICBpZiAob3B0aW9ucz8uaXNEZWVwKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IHNlY29uZDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZUNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIG5vZGVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAke1N0cmluZyhmaXJzdCl9IGlzIG5vdCBhIHZhbHVlIHRoYXQgY2FuIGJlIHN1YnNjcmliZWQgdG8uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHN1YnNjcmliZTtcbn1cbmZ1bmN0aW9uIGlzUm9vbUV2ZW50TmFtZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwibXktcHJlc2VuY2VcIiB8fCB2YWx1ZSA9PT0gXCJvdGhlcnNcIiB8fCB2YWx1ZSA9PT0gXCJldmVudFwiIHx8IHZhbHVlID09PSBcImVycm9yXCIgfHwgdmFsdWUgPT09IFwiaGlzdG9yeVwiIHx8IHZhbHVlID09PSBcInN0YXR1c1wiIHx8IHZhbHVlID09PSBcInN0b3JhZ2Utc3RhdHVzXCIgfHwgdmFsdWUgPT09IFwibG9zdC1jb25uZWN0aW9uXCIgfHwgdmFsdWUgPT09IFwiY29ubmVjdGlvblwiIHx8IHZhbHVlID09PSBcImNvbW1lbnRzXCI7XG59XG5mdW5jdGlvbiBtYWtlQXV0aERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGF1dGhNYW5hZ2VyKSB7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcInJvb206cmVhZFwiLCByb29tSWQgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYmFzZVVybCwgV2ViU29ja2V0UG9seWZpbGwpIHtcbiAgcmV0dXJuIChhdXRoVmFsdWUpID0+IHtcbiAgICBjb25zdCB3cyA9IFdlYlNvY2tldFBvbHlmaWxsID8/ICh0eXBlb2YgV2ViU29ja2V0ID09PSBcInVuZGVmaW5lZFwiID8gdm9pZCAwIDogV2ViU29ja2V0KTtcbiAgICBpZiAod3MgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50LCB5b3UgbmVlZCB0byBwcm92aWRlIGEgV2ViU29ja2V0IHBvbHlmaWxsLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1cmwyID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICB1cmwyLnByb3RvY29sID0gdXJsMi5wcm90b2NvbCA9PT0gXCJodHRwOlwiID8gXCJ3c1wiIDogXCJ3c3NcIjtcbiAgICB1cmwyLnBhdGhuYW1lID0gXCIvdjdcIjtcbiAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJyb29tSWRcIiwgcm9vbUlkKTtcbiAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIpIHtcbiAgICAgIHVybDIuc2VhcmNoUGFyYW1zLnNldChcInRva1wiLCBhdXRoVmFsdWUudG9rZW4ucmF3KTtcbiAgICB9IGVsc2UgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJwdWJrZXlcIiwgYXV0aFZhbHVlLnB1YmxpY0FwaUtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihhdXRoVmFsdWUsIFwiVW5oYW5kbGVkIGNhc2VcIik7XG4gICAgfVxuICAgIHVybDIuc2VhcmNoUGFyYW1zLnNldChcInZlcnNpb25cIiwgUEtHX1ZFUlNJT04gfHwgXCJkZXZcIik7XG4gICAgcmV0dXJuIG5ldyB3cyh1cmwyLnRvU3RyaW5nKCkpO1xuICB9O1xufVxuXG4vLyBzcmMvY2xpZW50LnRzXG52YXIgTUlOX1RIUk9UVExFID0gMTY7XG52YXIgTUFYX1RIUk9UVExFID0gMWUzO1xudmFyIERFRkFVTFRfVEhST1RUTEUgPSAxMDA7XG52YXIgTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUID0gMTVlMztcbnZhciBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAyMDA7XG52YXIgUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMWUzO1xudmFyIE1BWF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDNlNDtcbnZhciBERUZBVUxUX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gNWUzO1xudmFyIFJFU09MVkVfVVNFUlNfQkFUQ0hfREVMQVkgPSA1MDtcbnZhciBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgPSA1MDtcbnZhciBSRVNPTFZFX0dST1VQU19JTkZPX0JBVENIX0RFTEFZID0gNTA7XG5mdW5jdGlvbiBnZXRCYXNlVXJsKGJhc2VVcmwpIHtcbiAgaWYgKHR5cGVvZiBiYXNlVXJsID09PSBcInN0cmluZ1wiICYmIGJhc2VVcmwuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICByZXR1cm4gYmFzZVVybDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gREVGQVVMVF9CQVNFX1VSTDtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KG9wdGlvbnMpIHtcbiAgY29uc3QgY2xpZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIGNvbnN0IHRocm90dGxlRGVsYXkgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY2xpZW50T3B0aW9ucy5fX0RBTkdFUk9VU0xZX2Rpc2FibGVUaHJvdHRsaW5nID8gMCA6IGdldFRocm90dGxlKGNsaWVudE9wdGlvbnMudGhyb3R0bGUgPz8gREVGQVVMVF9USFJPVFRMRSk7XG4gIGNvbnN0IGxvc3RDb25uZWN0aW9uVGltZW91dCA9IGdldExvc3RDb25uZWN0aW9uVGltZW91dChcbiAgICBjbGllbnRPcHRpb25zLmxvc3RDb25uZWN0aW9uVGltZW91dCA/PyBERUZBVUxUX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUXG4gICk7XG4gIGNvbnN0IGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ID0gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQoXG4gICAgY2xpZW50T3B0aW9ucy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFxuICApO1xuICBjb25zdCBiYXNlVXJsID0gZ2V0QmFzZVVybChjbGllbnRPcHRpb25zLmJhc2VVcmwpO1xuICBjb25zdCBjdXJyZW50VXNlcklkID0gbmV3IFNpZ25hbCh2b2lkIDApO1xuICBjb25zdCBhdXRoTWFuYWdlciA9IGNyZWF0ZUF1dGhNYW5hZ2VyKG9wdGlvbnMsICh0b2tlbikgPT4ge1xuICAgIGNvbnN0IHVzZXJJZCA9IHRva2VuLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8gPyB0b2tlbi5pZCA6IHRva2VuLnVpZDtcbiAgICBjdXJyZW50VXNlcklkLnNldCgoKSA9PiB1c2VySWQpO1xuICB9KTtcbiAgY29uc3QgZmV0Y2hQb2x5ZmlsbCA9IGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5mZXRjaCB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnbG9iYWxUaGlzLmZldGNoPy5iaW5kKGdsb2JhbFRoaXMpO1xuICBjb25zdCBodHRwQ2xpZW50ID0gY3JlYXRlQXBpQ2xpZW50KHtcbiAgICBiYXNlVXJsLFxuICAgIGZldGNoUG9seWZpbGwsXG4gICAgY3VycmVudFVzZXJJZCxcbiAgICBhdXRoTWFuYWdlclxuICB9KTtcbiAgY29uc3Qgcm9vbXNCeUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYWkgPSBjcmVhdGVBaSh7XG4gICAgdXNlcklkOiBjdXJyZW50VXNlcklkLmdldCgpLFxuICAgIGxvc3RDb25uZWN0aW9uVGltZW91dCxcbiAgICBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dDogZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQoXG4gICAgICBjbGllbnRPcHRpb25zLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XG4gICAgKSxcbiAgICBwb2x5ZmlsbHM6IGNsaWVudE9wdGlvbnMucG9seWZpbGxzLFxuICAgIGRlbGVnYXRlczoge1xuICAgICAgY3JlYXRlU29ja2V0OiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JBaShcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LldlYlNvY2tldFxuICAgICAgKSxcbiAgICAgIGF1dGhlbnRpY2F0ZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3AudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgICBcIkNhbm5vdCB1c2UgQUkgQ29waWxvdHMgd2l0aCBhIHB1YmxpYyBBUEkga2V5XCJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3AudG9rZW4ucGFyc2VkLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFwiQUkgQ29waWxvdHMgcmVxdWlyZXMgYW4gSUQgb3IgQWNjZXNzIHRva2VuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwO1xuICAgICAgfSxcbiAgICAgIGNhblpvbWJpZTogKCkgPT4gZmFsc2VcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiB0ZWFyZG93blJvb20ocm9vbSkge1xuICAgIHVubGlua0RldlRvb2xzKHJvb20uaWQpO1xuICAgIHJvb21zQnlJZC5kZWxldGUocm9vbS5pZCk7XG4gICAgcm9vbS5kZXN0cm95KCk7XG4gIH1cbiAgZnVuY3Rpb24gbGVhc2VSb29tKGRldGFpbHMpIHtcbiAgICBjb25zdCBsZWF2ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGYgPSBsZWF2ZTtcbiAgICAgIGlmICghZGV0YWlscy51bnN1YnMuZGVsZXRlKHNlbGYpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJUaGlzIGxlYXZlIGZ1bmN0aW9uIHdhcyBhbHJlYWR5IGNhbGxlZC4gQ2FsbGluZyBpdCBtb3JlIHRoYW4gb25jZSBoYXMgbm8gZWZmZWN0LlwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGV0YWlscy51bnN1YnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRlYXJkb3duUm9vbShkZXRhaWxzLnJvb20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBkZXRhaWxzLnVuc3Vicy5hZGQobGVhdmUpO1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiBkZXRhaWxzLnJvb20sXG4gICAgICBsZWF2ZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZW50ZXJSb29tKHJvb21JZCwgLi4uYXJncykge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gcm9vbXNCeUlkLmdldChyb29tSWQpO1xuICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVhc2VSb29tKGV4aXN0aW5nKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9uczIgPSBhcmdzWzBdID8/IHt9O1xuICAgIGNvbnN0IGluaXRpYWxQcmVzZW5jZSA9ICh0eXBlb2Ygb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2Uocm9vbUlkKSA6IG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSkgPz8ge307XG4gICAgY29uc3QgaW5pdGlhbFN0b3JhZ2UgPSAodHlwZW9mIG9wdGlvbnMyLmluaXRpYWxTdG9yYWdlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zMi5pbml0aWFsU3RvcmFnZShyb29tSWQpIDogb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2UpID8/IHt9O1xuICAgIGNvbnN0IG5ld1Jvb20gPSBjcmVhdGVSb29tKFxuICAgICAgeyBpbml0aWFsUHJlc2VuY2UsIGluaXRpYWxTdG9yYWdlIH0sXG4gICAgICB7XG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgdGhyb3R0bGVEZWxheSxcbiAgICAgICAgbG9zdENvbm5lY3Rpb25UaW1lb3V0LFxuICAgICAgICBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCxcbiAgICAgICAgcG9seWZpbGxzOiBjbGllbnRPcHRpb25zLnBvbHlmaWxscyxcbiAgICAgICAgZGVsZWdhdGVzOiBjbGllbnRPcHRpb25zLm1vY2tlZERlbGVnYXRlcyA/PyB7XG4gICAgICAgICAgY3JlYXRlU29ja2V0OiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgYmFzZVVybCxcbiAgICAgICAgICAgIGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5XZWJTb2NrZXRcbiAgICAgICAgICApLFxuICAgICAgICAgIGF1dGhlbnRpY2F0ZTogbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcilcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlRGVidWdMb2dnaW5nOiBjbGllbnRPcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZyxcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgZXJyb3JFdmVudFNvdXJjZTogbGl2ZWJsb2Nrc0Vycm9yU291cmNlLFxuICAgICAgICBsYXJnZU1lc3NhZ2VTdHJhdGVneTogY2xpZW50T3B0aW9ucy5sYXJnZU1lc3NhZ2VTdHJhdGVneSxcbiAgICAgICAgdW5zdGFibGVfc3RyZWFtRGF0YTogISFjbGllbnRPcHRpb25zLnVuc3RhYmxlX3N0cmVhbURhdGEsXG4gICAgICAgIHJvb21IdHRwQ2xpZW50OiBodHRwQ2xpZW50LFxuICAgICAgICBjcmVhdGVTeW5jU291cmNlXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBuZXdSb29tRGV0YWlscyA9IHtcbiAgICAgIHJvb206IG5ld1Jvb20sXG4gICAgICB1bnN1YnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICB9O1xuICAgIHJvb21zQnlJZC5zZXQocm9vbUlkLCBuZXdSb29tRGV0YWlscyk7XG4gICAgc2V0dXBEZXZUb29scygoKSA9PiBBcnJheS5mcm9tKHJvb21zQnlJZC5rZXlzKCkpKTtcbiAgICBsaW5rRGV2VG9vbHMocm9vbUlkLCBuZXdSb29tKTtcbiAgICBjb25zdCBzaG91bGRDb25uZWN0ID0gb3B0aW9uczIuYXV0b0Nvbm5lY3QgPz8gdHJ1ZTtcbiAgICBpZiAoc2hvdWxkQ29ubmVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBhdG9iID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uYXRvYiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJZb3UgbmVlZCB0byBwb2x5ZmlsbCBhdG9iIHRvIHVzZSB0aGUgY2xpZW50IGluIHlvdXIgZW52aXJvbm1lbnQuIFBsZWFzZSBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhdCBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1jbGllbnQvYXRvYi1wb2x5ZmlsbFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWwuYXRvYiA9IGNsaWVudE9wdGlvbnMucG9seWZpbGxzLmF0b2I7XG4gICAgICB9XG4gICAgICBuZXdSb29tLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYXNlUm9vbShuZXdSb29tRGV0YWlscyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Um9vbShyb29tSWQpIHtcbiAgICBjb25zdCByb29tID0gcm9vbXNCeUlkLmdldChyb29tSWQpPy5yb29tO1xuICAgIHJldHVybiByb29tID8gcm9vbSA6IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gbG9nb3V0KCkge1xuICAgIGF1dGhNYW5hZ2VyLnJlc2V0KCk7XG4gICAgY3VycmVudFVzZXJJZC5zZXQoKCkgPT4gdm9pZCAwKTtcbiAgICBmb3IgKGNvbnN0IHsgcm9vbSB9IG9mIHJvb21zQnlJZC52YWx1ZXMoKSkge1xuICAgICAgaWYgKCFpc0lkbGUocm9vbS5nZXRTdGF0dXMoKSkpIHtcbiAgICAgICAgcm9vbS5yZWNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzb2x2ZVVzZXJzID0gY2xpZW50T3B0aW9ucy5yZXNvbHZlVXNlcnM7XG4gIGNvbnN0IGJhdGNoZWRSZXNvbHZlVXNlcnMgPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRVc2VySWRzKSA9PiB7XG4gICAgICBjb25zdCB1c2VySWRzID0gYmF0Y2hlZFVzZXJJZHMuZmxhdCgpO1xuICAgICAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnM/Lih7IHVzZXJJZHMgfSk7XG4gICAgICB3YXJuT25jZUlmKFxuICAgICAgICAhcmVzb2x2ZVVzZXJzLFxuICAgICAgICBcIlNldCB0aGUgcmVzb2x2ZVVzZXJzIG9wdGlvbiBpbiBjcmVhdGVDbGllbnQgdG8gc3BlY2lmeSB1c2VyIGluZm8uXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gdXNlcnMgPz8gdXNlcklkcy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICB9LFxuICAgIHsgZGVsYXk6IFJFU09MVkVfVVNFUlNfQkFUQ0hfREVMQVkgfVxuICApO1xuICBjb25zdCB1c2Vyc1N0b3JlID0gY3JlYXRlQmF0Y2hTdG9yZShiYXRjaGVkUmVzb2x2ZVVzZXJzKTtcbiAgZnVuY3Rpb24gaW52YWxpZGF0ZVJlc29sdmVkVXNlcnModXNlcklkcykge1xuICAgIHVzZXJzU3RvcmUuaW52YWxpZGF0ZSh1c2VySWRzKTtcbiAgfVxuICBjb25zdCByZXNvbHZlUm9vbXNJbmZvID0gY2xpZW50T3B0aW9ucy5yZXNvbHZlUm9vbXNJbmZvO1xuICBjb25zdCBiYXRjaGVkUmVzb2x2ZVJvb21zSW5mbyA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZFJvb21JZHMpID0+IHtcbiAgICAgIGNvbnN0IHJvb21JZHMgPSBiYXRjaGVkUm9vbUlkcy5mbGF0KCk7XG4gICAgICBjb25zdCByb29tc0luZm8gPSBhd2FpdCByZXNvbHZlUm9vbXNJbmZvPy4oeyByb29tSWRzIH0pO1xuICAgICAgd2Fybk9uY2VJZihcbiAgICAgICAgIXJlc29sdmVSb29tc0luZm8sXG4gICAgICAgIFwiU2V0IHRoZSByZXNvbHZlUm9vbXNJbmZvIG9wdGlvbiBpbiBjcmVhdGVDbGllbnQgdG8gc3BlY2lmeSByb29tIGluZm8uXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gcm9vbXNJbmZvID8/IHJvb21JZHMubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgfVxuICApO1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2hlZFJlc29sdmVSb29tc0luZm8pO1xuICBmdW5jdGlvbiBpbnZhbGlkYXRlUmVzb2x2ZWRSb29tc0luZm8ocm9vbUlkcykge1xuICAgIHJvb21zSW5mb1N0b3JlLmludmFsaWRhdGUocm9vbUlkcyk7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZUdyb3Vwc0luZm8gPSBjbGllbnRPcHRpb25zLnJlc29sdmVHcm91cHNJbmZvO1xuICBjb25zdCBiYXRjaGVkUmVzb2x2ZUdyb3Vwc0luZm8gPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRHcm91cElkcykgPT4ge1xuICAgICAgY29uc3QgZ3JvdXBJZHMgPSBiYXRjaGVkR3JvdXBJZHMuZmxhdCgpO1xuICAgICAgY29uc3QgZ3JvdXBzSW5mbyA9IGF3YWl0IHJlc29sdmVHcm91cHNJbmZvPy4oeyBncm91cElkcyB9KTtcbiAgICAgIHdhcm5PbmNlSWYoXG4gICAgICAgICFyZXNvbHZlR3JvdXBzSW5mbyxcbiAgICAgICAgXCJTZXQgdGhlIHJlc29sdmVHcm91cHNJbmZvIG9wdGlvbiBpbiBjcmVhdGVDbGllbnQgdG8gc3BlY2lmeSBncm91cCBpbmZvLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdyb3Vwc0luZm8gPz8gZ3JvdXBJZHMubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBSRVNPTFZFX0dST1VQU19JTkZPX0JBVENIX0RFTEFZIH1cbiAgKTtcbiAgY29uc3QgZ3JvdXBzSW5mb1N0b3JlID0gY3JlYXRlQmF0Y2hTdG9yZShiYXRjaGVkUmVzb2x2ZUdyb3Vwc0luZm8pO1xuICBmdW5jdGlvbiBpbnZhbGlkYXRlUmVzb2x2ZWRHcm91cHNJbmZvKGdyb3VwSWRzKSB7XG4gICAgZ3JvdXBzSW5mb1N0b3JlLmludmFsaWRhdGUoZ3JvdXBJZHMpO1xuICB9XG4gIGNvbnN0IG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gaW52YWxpZGF0ZVJlc29sdmVkTWVudGlvblN1Z2dlc3Rpb25zKCkge1xuICAgIG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlLmNsZWFyKCk7XG4gIH1cbiAgY29uc3Qgc3luY1N0YXR1c1NvdXJjZXMgPSBbXTtcbiAgY29uc3Qgc3luY1N0YXR1c1NpZ25hbCA9IG5ldyBTaWduYWwoXCJzeW5jaHJvbml6ZWRcIik7XG4gIGNvbnN0IGxpdmVibG9ja3NFcnJvclNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBnZXRTeW5jU3RhdHVzKCkge1xuICAgIGNvbnN0IHN0YXR1cyA9IHN5bmNTdGF0dXNTaWduYWwuZ2V0KCk7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gXCJzeW5jaHJvbml6aW5nXCIgPyBzdGF0dXMgOiBcInN5bmNocm9uaXplZFwiO1xuICB9XG4gIGZ1bmN0aW9uIHJlY29tcHV0ZSgpIHtcbiAgICBzeW5jU3RhdHVzU2lnbmFsLnNldChcbiAgICAgIHN5bmNTdGF0dXNTb3VyY2VzLnNvbWUoKHNyYykgPT4gc3JjLmdldCgpID09PSBcInN5bmNocm9uaXppbmdcIikgPyBcInN5bmNocm9uaXppbmdcIiA6IHN5bmNTdGF0dXNTb3VyY2VzLnNvbWUoKHNyYykgPT4gc3JjLmdldCgpID09PSBcImhhcy1sb2NhbC1jaGFuZ2VzXCIpID8gXCJoYXMtbG9jYWwtY2hhbmdlc1wiIDogXCJzeW5jaHJvbml6ZWRcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlU3luY1NvdXJjZSgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBuZXcgU2lnbmFsKFwic3luY2hyb25pemVkXCIpO1xuICAgIHN5bmNTdGF0dXNTb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICBjb25zdCB1bnN1YiA9IHNvdXJjZS5zdWJzY3JpYmUoKCkgPT4gcmVjb21wdXRlKCkpO1xuICAgIGZ1bmN0aW9uIHNldFN5bmNTdGF0dXMoc3RhdHVzKSB7XG4gICAgICBzb3VyY2Uuc2V0KHN0YXR1cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB1bnN1YigpO1xuICAgICAgY29uc3QgaW5kZXggPSBzeW5jU3RhdHVzU291cmNlcy5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0gPT09IHNvdXJjZSk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBjb25zdCBbcmVmXSA9IHN5bmNTdGF0dXNTb3VyY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGNvbnN0IHdhc1N0aWxsUGVuZGluZyA9IHJlZi5nZXQoKSAhPT0gXCJzeW5jaHJvbml6ZWRcIjtcbiAgICAgICAgaWYgKHdhc1N0aWxsUGVuZGluZykge1xuICAgICAgICAgIHJlY29tcHV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHNldFN5bmNTdGF0dXMsIGRlc3Ryb3kgfTtcbiAgfVxuICB7XG4gICAgY29uc3QgbWF5YmVQcmV2ZW50Q2xvc2UgPSAoZSkgPT4ge1xuICAgICAgaWYgKGNsaWVudE9wdGlvbnMucHJldmVudFVuc2F2ZWRDaGFuZ2VzICYmIHN5bmNTdGF0dXNTaWduYWwuZ2V0KCkgIT09IFwic3luY2hyb25pemVkXCIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHZvaWQgMDtcbiAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgbWF5YmVQcmV2ZW50Q2xvc2UpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldE5vdGlmaWNhdGlvblNldHRpbmdzKG9wdGlvbnMyKSB7XG4gICAgY29uc3QgcGxhaW5TZXR0aW5ncyA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3Mob3B0aW9uczIpO1xuICAgIGNvbnN0IHNldHRpbmdzID0gY3JlYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MocGxhaW5TZXR0aW5ncyk7XG4gICAgcmV0dXJuIHNldHRpbmdzO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgY29uc3QgcGxhaW5TZXR0aW5ncyA9IGF3YWl0IGh0dHBDbGllbnQudXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIGNvbnN0IHNldHRpbmdzT2JqZWN0ID0gY3JlYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MocGxhaW5TZXR0aW5ncyk7XG4gICAgcmV0dXJuIHNldHRpbmdzT2JqZWN0O1xuICB9XG4gIGNvbnN0IGNsaWVudCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICBlbnRlclJvb20sXG4gICAgICBnZXRSb29tLFxuICAgICAgbG9nb3V0LFxuICAgICAgLy8gUHVibGljIGluYm94IG5vdGlmaWNhdGlvbnMgQVBJXG4gICAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnM6IGh0dHBDbGllbnQuZ2V0SW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgZ2V0SW5ib3hOb3RpZmljYXRpb25zU2luY2U6IGh0dHBDbGllbnQuZ2V0SW5ib3hOb3RpZmljYXRpb25zU2luY2UsXG4gICAgICBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudDogaHR0cENsaWVudC5nZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICAgIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQ6IGh0dHBDbGllbnQubWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDogaHR0cENsaWVudC5tYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gICAgICBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnM6IGh0dHBDbGllbnQuZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgZGVsZXRlSW5ib3hOb3RpZmljYXRpb246IGh0dHBDbGllbnQuZGVsZXRlSW5ib3hOb3RpZmljYXRpb24sXG4gICAgICAvLyBQdWJsaWMgbm90aWZpY2F0aW9uIHNldHRpbmdzIEFQSVxuICAgICAgZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIC8vIEFkdmFuY2VkIHJlc29sdmVycyBBUElzXG4gICAgICByZXNvbHZlcnM6IHtcbiAgICAgICAgaW52YWxpZGF0ZVVzZXJzOiBpbnZhbGlkYXRlUmVzb2x2ZWRVc2VycyxcbiAgICAgICAgaW52YWxpZGF0ZVJvb21zSW5mbzogaW52YWxpZGF0ZVJlc29sdmVkUm9vbXNJbmZvLFxuICAgICAgICBpbnZhbGlkYXRlR3JvdXBzSW5mbzogaW52YWxpZGF0ZVJlc29sdmVkR3JvdXBzSW5mbyxcbiAgICAgICAgaW52YWxpZGF0ZU1lbnRpb25TdWdnZXN0aW9uczogaW52YWxpZGF0ZVJlc29sdmVkTWVudGlvblN1Z2dlc3Rpb25zXG4gICAgICB9LFxuICAgICAgZ2V0U3luY1N0YXR1cyxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBlcnJvcjogbGl2ZWJsb2Nrc0Vycm9yU291cmNlLFxuICAgICAgICBzeW5jU3RhdHVzOiBzeW5jU3RhdHVzU2lnbmFsXG4gICAgICB9LFxuICAgICAgLy8gSW50ZXJuYWxcbiAgICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICAgIGN1cnJlbnRVc2VySWQsXG4gICAgICAgIG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlLFxuICAgICAgICBhaSxcbiAgICAgICAgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uczogY2xpZW50T3B0aW9ucy5yZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zLFxuICAgICAgICB1c2Vyc1N0b3JlLFxuICAgICAgICByb29tc0luZm9TdG9yZSxcbiAgICAgICAgZ3JvdXBzSW5mb1N0b3JlLFxuICAgICAgICBnZXRSb29tSWRzKCkge1xuICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHJvb21zQnlJZC5rZXlzKCkpO1xuICAgICAgICB9LFxuICAgICAgICBodHRwQ2xpZW50LFxuICAgICAgICAvLyBUeXBlLWxldmVsIGhlbHBlciBvbmx5LCBpdCdzIGVmZmVjdGl2ZWx5IG9ubHkgYW4gaWRlbnRpdHktZnVuY3Rpb24gYXQgcnVudGltZVxuICAgICAgICBhczogKCkgPT4gY2xpZW50LFxuICAgICAgICBjcmVhdGVTeW5jU291cmNlLFxuICAgICAgICBlbWl0RXJyb3I6IChjb250ZXh0LCBjYXVzZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVycm9yMyA9IExpdmVibG9ja3NFcnJvci5mcm9tKGNvbnRleHQsIGNhdXNlKTtcbiAgICAgICAgICBjb25zdCBkaWROb3RpZnkgPSBsaXZlYmxvY2tzRXJyb3JTb3VyY2Uubm90aWZ5KGVycm9yMyk7XG4gICAgICAgICAgaWYgKCFkaWROb3RpZnkpIHtcbiAgICAgICAgICAgIGVycm9yMihlcnJvcjMubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBrSW50ZXJuYWwsXG4gICAge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9XG4gICk7XG4gIHJldHVybiBjbGllbnQ7XG59XG5mdW5jdGlvbiBjaGVja0JvdW5kcyhvcHRpb24sIHZhbHVlLCBtaW4sIG1heCwgcmVjb21tZW5kZWRNaW4pIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8IG1pbiB8fCBtYXggIT09IHZvaWQgMCAmJiB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIG1heCAhPT0gdm9pZCAwID8gYCR7b3B0aW9ufSBzaG91bGQgYmUgYmV0d2VlbiAke3JlY29tbWVuZGVkTWluID8/IG1pbn0gYW5kICR7bWF4fS5gIDogYCR7b3B0aW9ufSBzaG91bGQgYmUgYXQgbGVhc3QgJHtyZWNvbW1lbmRlZE1pbiA/PyBtaW59LmBcbiAgICApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gZ2V0VGhyb3R0bGUodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFwidGhyb3R0bGVcIiwgdmFsdWUsIE1JTl9USFJPVFRMRSwgTUFYX1RIUk9UVExFKTtcbn1cbmZ1bmN0aW9uIGdldExvc3RDb25uZWN0aW9uVGltZW91dCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJsb3N0Q29ubmVjdGlvblRpbWVvdXRcIixcbiAgICB2YWx1ZSxcbiAgICBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VULFxuICAgIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xufVxuXG4vLyBzcmMvY29tbWVudHMvY29tbWVudC1ib2R5LnRzXG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5UGFyYWdyYXBoKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcInBhcmFncmFwaFwiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keVRleHQoZWxlbWVudCkge1xuICByZXR1cm4gIShcInR5cGVcIiBpbiBlbGVtZW50KSAmJiBcInRleHRcIiBpbiBlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LnRleHQgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5TWVudGlvbihlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJtZW50aW9uXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5TGluayhlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJsaW5rXCI7XG59XG52YXIgY29tbWVudEJvZHlFbGVtZW50c0d1YXJkcyA9IHtcbiAgcGFyYWdyYXBoOiBpc0NvbW1lbnRCb2R5UGFyYWdyYXBoLFxuICB0ZXh0OiBpc0NvbW1lbnRCb2R5VGV4dCxcbiAgbGluazogaXNDb21tZW50Qm9keUxpbmssXG4gIG1lbnRpb246IGlzQ29tbWVudEJvZHlNZW50aW9uXG59O1xudmFyIGNvbW1lbnRCb2R5RWxlbWVudHNUeXBlcyA9IHtcbiAgcGFyYWdyYXBoOiBcImJsb2NrXCIsXG4gIHRleHQ6IFwiaW5saW5lXCIsXG4gIGxpbms6IFwiaW5saW5lXCIsXG4gIG1lbnRpb246IFwiaW5saW5lXCJcbn07XG5mdW5jdGlvbiB0cmF2ZXJzZUNvbW1lbnRCb2R5KGJvZHksIGVsZW1lbnRPclZpc2l0b3IsIHBvc3NpYmx5VmlzaXRvcikge1xuICBpZiAoIWJvZHkgfHwgIWJvZHk/LmNvbnRlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50T3JWaXNpdG9yID09PSBcInN0cmluZ1wiID8gZWxlbWVudE9yVmlzaXRvciA6IHZvaWQgMDtcbiAgY29uc3QgdHlwZSA9IGVsZW1lbnQgPyBjb21tZW50Qm9keUVsZW1lbnRzVHlwZXNbZWxlbWVudF0gOiBcImFsbFwiO1xuICBjb25zdCBndWFyZCA9IGVsZW1lbnQgPyBjb21tZW50Qm9keUVsZW1lbnRzR3VhcmRzW2VsZW1lbnRdIDogKCkgPT4gdHJ1ZTtcbiAgY29uc3QgdmlzaXRvciA9IHR5cGVvZiBlbGVtZW50T3JWaXNpdG9yID09PSBcImZ1bmN0aW9uXCIgPyBlbGVtZW50T3JWaXNpdG9yIDogcG9zc2libHlWaXNpdG9yO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGJvZHkuY29udGVudCkge1xuICAgIGlmICh0eXBlID09PSBcImFsbFwiIHx8IHR5cGUgPT09IFwiYmxvY2tcIikge1xuICAgICAgaWYgKGd1YXJkKGJsb2NrKSkge1xuICAgICAgICB2aXNpdG9yPy4oYmxvY2spO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJhbGxcIiB8fCB0eXBlID09PSBcImlubGluZVwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGlubGluZSBvZiBibG9jay5jaGlsZHJlbikge1xuICAgICAgICBpZiAoZ3VhcmQoaW5saW5lKSkge1xuICAgICAgICAgIHZpc2l0b3I/LihpbmxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRNZW50aW9uc0Zyb21Db21tZW50Qm9keShib2R5LCBwcmVkaWNhdGUpIHtcbiAgY29uc3QgbWVudGlvbklkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IG1lbnRpb25zID0gW107XG4gIHRyYXZlcnNlQ29tbWVudEJvZHkoYm9keSwgXCJtZW50aW9uXCIsIChtZW50aW9uKSA9PiB7XG4gICAgaWYgKFxuICAgICAgLy8gSWYgdGhpcyBtZW50aW9uIGlzbid0IGFscmVhZHkgaW4gdGhlIGxpc3RcbiAgICAgICFtZW50aW9uSWRzLmhhcyhtZW50aW9uLmlkKSAmJiAvLyBBbmQgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZSBpcyB0cnVlXG4gICAgICAocHJlZGljYXRlID8gcHJlZGljYXRlKG1lbnRpb24pIDogdHJ1ZSlcbiAgICApIHtcbiAgICAgIG1lbnRpb25JZHMuYWRkKG1lbnRpb24uaWQpO1xuICAgICAgbWVudGlvbnMucHVzaChtZW50aW9uKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWVudGlvbnM7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlTWVudGlvbnNJbkNvbW1lbnRCb2R5KGJvZHksIHJlc29sdmVVc2VycywgcmVzb2x2ZUdyb3Vwc0luZm8pIHtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHJlc29sdmVkR3JvdXBzSW5mbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGlmICghcmVzb2x2ZVVzZXJzICYmICFyZXNvbHZlR3JvdXBzSW5mbykge1xuICAgIHJldHVybiB7XG4gICAgICB1c2VyczogcmVzb2x2ZWRVc2VycyxcbiAgICAgIGdyb3VwczogcmVzb2x2ZWRHcm91cHNJbmZvXG4gICAgfTtcbiAgfVxuICBjb25zdCBtZW50aW9ucyA9IGdldE1lbnRpb25zRnJvbUNvbW1lbnRCb2R5KGJvZHkpO1xuICBjb25zdCB1c2VySWRzID0gbWVudGlvbnMuZmlsdGVyKChtZW50aW9uKSA9PiBtZW50aW9uLmtpbmQgPT09IFwidXNlclwiKS5tYXAoKG1lbnRpb24pID0+IG1lbnRpb24uaWQpO1xuICBjb25zdCBncm91cElkcyA9IG1lbnRpb25zLmZpbHRlcigobWVudGlvbikgPT4gbWVudGlvbi5raW5kID09PSBcImdyb3VwXCIpLm1hcCgobWVudGlvbikgPT4gbWVudGlvbi5pZCk7XG4gIGNvbnN0IFt1c2VycywgZ3JvdXBzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICByZXNvbHZlVXNlcnMgJiYgdXNlcklkcy5sZW5ndGggPiAwID8gcmVzb2x2ZVVzZXJzKHsgdXNlcklkcyB9KSA6IHZvaWQgMCxcbiAgICByZXNvbHZlR3JvdXBzSW5mbyAmJiBncm91cElkcy5sZW5ndGggPiAwID8gcmVzb2x2ZUdyb3Vwc0luZm8oeyBncm91cElkcyB9KSA6IHZvaWQgMFxuICBdKTtcbiAgaWYgKHVzZXJzKSB7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIHVzZXJJZF0gb2YgdXNlcklkcy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSB1c2Vyc1tpbmRleF07XG4gICAgICBpZiAodXNlcikge1xuICAgICAgICByZXNvbHZlZFVzZXJzLnNldCh1c2VySWQsIHVzZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGdyb3VwSWRdIG9mIGdyb3VwSWRzLmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNbaW5kZXhdO1xuICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgIHJlc29sdmVkR3JvdXBzSW5mby5zZXQoZ3JvdXBJZCwgZ3JvdXApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHVzZXJzOiByZXNvbHZlZFVzZXJzLFxuICAgIGdyb3VwczogcmVzb2x2ZWRHcm91cHNJbmZvXG4gIH07XG59XG52YXIgaHRtbEVzY2FwYWJsZXMgPSB7XG4gIFwiJlwiOiBcIiZhbXA7XCIsXG4gIFwiPFwiOiBcIiZsdDtcIixcbiAgXCI+XCI6IFwiJmd0O1wiLFxuICAnXCInOiBcIiZxdW90O1wiLFxuICBcIidcIjogXCImIzM5O1wiXG59O1xudmFyIGh0bWxFc2NhcGFibGVzUmVnZXggPSBuZXcgUmVnRXhwKFxuICBPYmplY3Qua2V5cyhodG1sRXNjYXBhYmxlcykubWFwKChlbnRpdHkpID0+IGBcXFxcJHtlbnRpdHl9YCkuam9pbihcInxcIiksXG4gIFwiZ1wiXG4pO1xuZnVuY3Rpb24gaHRtbFNhZmUodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhbU3RyaW5nKHZhbHVlKV0sIFtdKTtcbn1cbmZ1bmN0aW9uIGpvaW5IdG1sKHN0cmluZ3MpIHtcbiAgaWYgKHN0cmluZ3MubGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFtcIlwiXSwgW10pO1xuICB9XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoXG4gICAgW1wiXCIsIC4uLkFycmF5KHN0cmluZ3MubGVuZ3RoIC0gMSkuZmlsbChcIlwiKSwgXCJcIl0sXG4gICAgc3RyaW5nc1xuICApO1xufVxuZnVuY3Rpb24gZXNjYXBlSHRtbCh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBIdG1sU2FmZVN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBqb2luSHRtbCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKFxuICAgIGh0bWxFc2NhcGFibGVzUmVnZXgsXG4gICAgKGNoYXJhY3RlcikgPT4gaHRtbEVzY2FwYWJsZXNbY2hhcmFjdGVyXVxuICApO1xufVxudmFyIEh0bWxTYWZlU3RyaW5nID0gY2xhc3Mge1xuICAjc3RyaW5ncztcbiAgI3ZhbHVlcztcbiAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzMikge1xuICAgIHRoaXMuI3N0cmluZ3MgPSBzdHJpbmdzO1xuICAgIHRoaXMuI3ZhbHVlcyA9IHZhbHVlczI7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0cmluZ3MucmVkdWNlKChyZXN1bHQsIHN0ciwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZUh0bWwobm4odGhpcy4jdmFsdWVzW2kgLSAxXSkpICsgc3RyO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gaHRtbChzdHJpbmdzLCAuLi52YWx1ZXMyKSB7XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoc3RyaW5ncywgdmFsdWVzMik7XG59XG52YXIgbWFya2Rvd25Fc2NhcGFibGVzID0ge1xuICBfOiBcIlxcXFxfXCIsXG4gIFwiKlwiOiBcIlxcXFwqXCIsXG4gIFwiI1wiOiBcIlxcXFwjXCIsXG4gIFwiYFwiOiBcIlxcXFxgXCIsXG4gIFwiflwiOiBcIlxcXFx+XCIsXG4gIFwiIVwiOiBcIlxcXFwhXCIsXG4gIFwifFwiOiBcIlxcXFx8XCIsXG4gIFwiKFwiOiBcIlxcXFwoXCIsXG4gIFwiKVwiOiBcIlxcXFwpXCIsXG4gIFwie1wiOiBcIlxcXFx7XCIsXG4gIFwifVwiOiBcIlxcXFx9XCIsXG4gIFwiW1wiOiBcIlxcXFxbXCIsXG4gIFwiXVwiOiBcIlxcXFxdXCJcbn07XG52YXIgbWFya2Rvd25Fc2NhcGFibGVzUmVnZXggPSBuZXcgUmVnRXhwKFxuICBPYmplY3Qua2V5cyhtYXJrZG93bkVzY2FwYWJsZXMpLm1hcCgoZW50aXR5KSA9PiBgXFxcXCR7ZW50aXR5fWApLmpvaW4oXCJ8XCIpLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIGpvaW5NYXJrZG93bihzdHJpbmdzKSB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoXG4gICAgW1wiXCIsIC4uLkFycmF5KHN0cmluZ3MubGVuZ3RoIC0gMSkuZmlsbChcIlwiKSwgXCJcIl0sXG4gICAgc3RyaW5nc1xuICApO1xufVxuZnVuY3Rpb24gZXNjYXBlTWFya2Rvd24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFya2Rvd25TYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5NYXJrZG93bih2YWx1ZSkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKFxuICAgIG1hcmtkb3duRXNjYXBhYmxlc1JlZ2V4LFxuICAgIChjaGFyYWN0ZXIpID0+IG1hcmtkb3duRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgTWFya2Rvd25TYWZlU3RyaW5nID0gY2xhc3Mge1xuICAjc3RyaW5ncztcbiAgI3ZhbHVlcztcbiAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzMikge1xuICAgIHRoaXMuI3N0cmluZ3MgPSBzdHJpbmdzO1xuICAgIHRoaXMuI3ZhbHVlcyA9IHZhbHVlczI7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0cmluZ3MucmVkdWNlKChyZXN1bHQsIHN0ciwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZU1hcmtkb3duKG5uKHRoaXMuI3ZhbHVlc1tpIC0gMV0pKSArIHN0cjtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1hcmtkb3duKHN0cmluZ3MsIC4uLnZhbHVlczIpIHtcbiAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoc3RyaW5ncywgdmFsdWVzMik7XG59XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IGNoaWxkcmVuLFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudGV4dCxcbiAgbGluazogKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnRleHQgPz8gZWxlbWVudC51cmwsXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIsIGdyb3VwIH0pID0+IHtcbiAgICByZXR1cm4gYEAke3VzZXI/Lm5hbWUgPz8gZ3JvdXA/Lm5hbWUgPz8gZWxlbWVudC5pZH1gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICByZXR1cm4gY2hpbGRyZW4gPyBodG1sYDxwPiR7aHRtbFNhZmUoY2hpbGRyZW4pfTwvcD5gIDogY2hpbGRyZW47XG4gIH0sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4ge1xuICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gaHRtbGAke2NoaWxkcmVufWA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmJvbGQpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8c3Ryb25nPiR7Y2hpbGRyZW59PC9zdHJvbmc+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaXRhbGljKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPGVtPiR7Y2hpbGRyZW59PC9lbT5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zdHJpa2V0aHJvdWdoKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPHM+JHtjaGlsZHJlbn08L3M+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY29kZSkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxjb2RlPiR7Y2hpbGRyZW59PC9jb2RlPmA7XG4gICAgfVxuICAgIHJldHVybiBodG1sYCR7Y2hpbGRyZW59YDtcbiAgfSxcbiAgbGluazogKHsgZWxlbWVudCwgaHJlZiB9KSA9PiB7XG4gICAgcmV0dXJuIGh0bWxgPGEgaHJlZj1cIiR7aHJlZn1cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCI+JHtlbGVtZW50LnRleHQgPyBodG1sYCR7ZWxlbWVudC50ZXh0fWAgOiBlbGVtZW50LnVybH08L2E+YDtcbiAgfSxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciwgZ3JvdXAgfSkgPT4ge1xuICAgIHJldHVybiBodG1sYDxzcGFuIGRhdGEtbWVudGlvbj5AJHt1c2VyPy5uYW1lID8gaHRtbGAke3VzZXI/Lm5hbWV9YCA6IGdyb3VwPy5uYW1lID8gaHRtbGAke2dyb3VwPy5uYW1lfWAgOiBlbGVtZW50LmlkfTwvc3Bhbj5gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5TWFya2Rvd25FbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LnRleHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ib2xkKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYCoqJHtjaGlsZHJlbn0qKmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lml0YWxpYykge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmBfJHtjaGlsZHJlbn1fYDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc3RyaWtldGhyb3VnaCkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmB+fiR7Y2hpbGRyZW59fn5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYFxcYCR7Y2hpbGRyZW59XFxgYDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gWyR7ZWxlbWVudC50ZXh0ID8/IGVsZW1lbnQudXJsfV0oJHtocmVmfSlgO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyLCBncm91cCB9KSA9PiB7XG4gICAgcmV0dXJuIG1hcmtkb3duYEAke3VzZXI/Lm5hbWUgPz8gZ3JvdXA/Lm5hbWUgPz8gZWxlbWVudC5pZH1gO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gc3RyaW5naWZ5Q29tbWVudEJvZHkoYm9keSwgb3B0aW9ucykge1xuICBjb25zdCBmb3JtYXQgPSBvcHRpb25zPy5mb3JtYXQgPz8gXCJwbGFpblwiO1xuICBjb25zdCBzZXBhcmF0b3IgPSBvcHRpb25zPy5zZXBhcmF0b3IgPz8gKGZvcm1hdCA9PT0gXCJtYXJrZG93blwiID8gXCJcXG5cXG5cIiA6IFwiXFxuXCIpO1xuICBjb25zdCBlbGVtZW50cyA9IHtcbiAgICAuLi5mb3JtYXQgPT09IFwiaHRtbFwiID8gc3RyaW5naWZ5Q29tbWVudEJvZHlIdG1sRWxlbWVudHMgOiBmb3JtYXQgPT09IFwibWFya2Rvd25cIiA/IHN0cmluZ2lmeUNvbW1lbnRCb2R5TWFya2Rvd25FbGVtZW50cyA6IHN0cmluZ2lmeUNvbW1lbnRCb2R5UGxhaW5FbGVtZW50cyxcbiAgICAuLi5vcHRpb25zPy5lbGVtZW50c1xuICB9O1xuICBjb25zdCB7IHVzZXJzOiByZXNvbHZlZFVzZXJzLCBncm91cHM6IHJlc29sdmVkR3JvdXBzSW5mbyB9ID0gYXdhaXQgcmVzb2x2ZU1lbnRpb25zSW5Db21tZW50Qm9keShcbiAgICBib2R5LFxuICAgIG9wdGlvbnM/LnJlc29sdmVVc2VycyxcbiAgICBvcHRpb25zPy5yZXNvbHZlR3JvdXBzSW5mb1xuICApO1xuICBjb25zdCBibG9ja3MgPSBib2R5LmNvbnRlbnQuZmxhdE1hcCgoYmxvY2ssIGJsb2NrSW5kZXgpID0+IHtcbiAgICBzd2l0Y2ggKGJsb2NrLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJwYXJhZ3JhcGhcIjoge1xuICAgICAgICBjb25zdCBpbmxpbmVzID0gYmxvY2suY2hpbGRyZW4uZmxhdE1hcCgoaW5saW5lLCBpbmxpbmVJbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5TWVudGlvbihpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5saW5lLmlkID8gW1xuICAgICAgICAgICAgICBlbGVtZW50cy5tZW50aW9uKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGlubGluZSxcbiAgICAgICAgICAgICAgICAgIHVzZXI6IGlubGluZS5raW5kID09PSBcInVzZXJcIiA/IHJlc29sdmVkVXNlcnMuZ2V0KGlubGluZS5pZCkgOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICBncm91cDogaW5saW5lLmtpbmQgPT09IFwiZ3JvdXBcIiA/IHJlc29sdmVkR3JvdXBzSW5mby5nZXQoaW5saW5lLmlkKSA6IHZvaWQgMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSA6IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keUxpbmsoaW5saW5lKSkge1xuICAgICAgICAgICAgY29uc3QgaHJlZiA9IHNhbml0aXplVXJsKGlubGluZS51cmwpO1xuICAgICAgICAgICAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy50ZXh0KFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB7IHRleHQ6IGlubGluZS50ZXh0ID8/IGlubGluZS51cmwgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGlubGluZUluZGV4XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubGluayhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICBocmVmXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmxpbmVJbmRleFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keVRleHQoaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtlbGVtZW50cy50ZXh0KHsgZWxlbWVudDogaW5saW5lIH0sIGlubGluZUluZGV4KV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgZWxlbWVudHMucGFyYWdyYXBoKFxuICAgICAgICAgICAgeyBlbGVtZW50OiBibG9jaywgY2hpbGRyZW46IGlubGluZXMuam9pbihcIlwiKSB9LFxuICAgICAgICAgICAgYmxvY2tJbmRleFxuICAgICAgICAgIClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYmxvY2tzLmpvaW4oc2VwYXJhdG9yKTtcbn1cblxuLy8gc3JjL2NyZHRzL3V0aWxzLnRzXG5mdW5jdGlvbiB0b1BsYWluTHNvbihsc29uKSB7XG4gIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGxzb24udG9PYmplY3QoKSkuZmxhdE1hcChcbiAgICAgICAgICAoW2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwID8gW1trZXksIHRvUGxhaW5Mc29uKHZhbHVlKV1dIDogW11cbiAgICAgICAgKVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVNYXApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgZGF0YTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBbLi4ubHNvbl0ubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIHRvUGxhaW5Mc29uKHZhbHVlKV0pXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGRhdGE6IFsuLi5sc29uXS5tYXAoKGl0ZW0pID0+IHRvUGxhaW5Mc29uKGl0ZW0pKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxzb247XG4gIH1cbn1cblxuLy8gc3JjL2ltbXV0YWJsZS50c1xuZnVuY3Rpb24gbHNvbk9iamVjdFRvSnNvbihvYmopIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGNvbnN0IHZhbCA9IG9ialtrZXldO1xuICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsaXZlT2JqZWN0VG9Kc29uKGxpdmVPYmplY3QpIHtcbiAgcmV0dXJuIGxzb25PYmplY3RUb0pzb24obGl2ZU9iamVjdC50b09iamVjdCgpKTtcbn1cbmZ1bmN0aW9uIGxpdmVNYXBUb0pzb24obWFwKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbHNvbkxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hcChsc29uVG9Kc29uKTtcbn1cbmZ1bmN0aW9uIGxpdmVMaXN0VG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZS50b0FycmF5KCkpO1xufVxuZnVuY3Rpb24gbHNvblRvSnNvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIGxpdmVPYmplY3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gbGl2ZUxpc3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiBsaXZlTWFwVG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiB2YWx1ZS5kYXRhO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZGVlcExpdmVpZnkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdCh2YWx1ZS5tYXAoZGVlcExpdmVpZnkpKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGNvbnN0IGluaXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgdmFsID0gdmFsdWVba2V5XTtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGluaXRba2V5XSA9IGRlZXBMaXZlaWZ5KHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChpbml0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZUxpc3QobGl2ZUxpc3QsIHByZXYsIG5leHQpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgcHJldkVuZCA9IHByZXYubGVuZ3RoIC0gMTtcbiAgbGV0IG5leHRFbmQgPSBuZXh0Lmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2Tm9kZSA9IHByZXZbMF07XG4gIGxldCBuZXh0Tm9kZSA9IG5leHRbMF07XG4gIG91dGVyOiB7XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgKytpO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgIH1cbiAgICBwcmV2Tm9kZSA9IHByZXZbcHJldkVuZF07XG4gICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIHdoaWxlIChwcmV2Tm9kZSA9PT0gbmV4dE5vZGUpIHtcbiAgICAgIHByZXZFbmQtLTtcbiAgICAgIG5leHRFbmQtLTtcbiAgICAgIGlmIChpID4gcHJldkVuZCB8fCBpID4gbmV4dEVuZCkge1xuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtuZXh0RW5kXTtcbiAgICB9XG4gIH1cbiAgaWYgKGkgPiBwcmV2RW5kKSB7XG4gICAgaWYgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgICBsaXZlTGlzdC5pbnNlcnQoZGVlcExpdmVpZnkobmV4dFtpXSksIGkpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGkgPiBuZXh0RW5kKSB7XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGkgPD0gcHJldkVuZCAmJiBpIDw9IG5leHRFbmQpIHtcbiAgICAgIHByZXZOb2RlID0gcHJldltpXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtpXTtcbiAgICAgIGNvbnN0IGxpdmVMaXN0Tm9kZSA9IGxpdmVMaXN0LmdldChpKTtcbiAgICAgIGlmIChpc0xpdmVPYmplY3QobGl2ZUxpc3ROb2RlKSAmJiBpc1BsYWluT2JqZWN0KHByZXZOb2RlKSAmJiBpc1BsYWluT2JqZWN0KG5leHROb2RlKSkge1xuICAgICAgICBwYXRjaExpdmVPYmplY3QobGl2ZUxpc3ROb2RlLCBwcmV2Tm9kZSwgbmV4dE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGl2ZUxpc3Quc2V0KGksIGRlZXBMaXZlaWZ5KG5leHROb2RlKSk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IG5leHRFbmQpIHtcbiAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGxldCBsb2NhbEkgPSBpO1xuICAgIHdoaWxlIChsb2NhbEkgPD0gcHJldkVuZCkge1xuICAgICAgbGl2ZUxpc3QuZGVsZXRlKGkpO1xuICAgICAgbG9jYWxJKys7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3RLZXkobGl2ZU9iamVjdCwga2V5LCBwcmV2LCBuZXh0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBub25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXh0KTtcbiAgICBpZiAobm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgIGVycm9yMihcbiAgICAgICAgYE5ldyBzdGF0ZSBwYXRoOiAnJHtub25TZXJpYWxpemFibGVWYWx1ZS5wYXRofScgdmFsdWU6ICcke1N0cmluZyhcbiAgICAgICAgICBub25TZXJpYWxpemFibGVWYWx1ZS52YWx1ZVxuICAgICAgICApfScgaXMgbm90IHNlcmlhbGl6YWJsZS5cbk9ubHkgc2VyaWFsaXphYmxlIHZhbHVlIGNhbiBiZSBzeW5jZWQgd2l0aCBMaXZlYmxvY2tzLmBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IHZhbHVlID0gbGl2ZU9iamVjdC5nZXQoa2V5KTtcbiAgaWYgKG5leHQgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3QuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9IGVsc2UgaWYgKHByZXYgPT09IG5leHQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoaXNMaXZlTGlzdCh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheShwcmV2KSAmJiBBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgcGF0Y2hMaXZlTGlzdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSBpZiAoaXNMaXZlT2JqZWN0KHZhbHVlKSAmJiBpc1BsYWluT2JqZWN0KHByZXYpICYmIGlzUGxhaW5PYmplY3QobmV4dCkpIHtcbiAgICBwYXRjaExpdmVPYmplY3QodmFsdWUsIHByZXYsIG5leHQpO1xuICB9IGVsc2Uge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3Qocm9vdCwgcHJldiwgbmV4dCkge1xuICBjb25zdCB1cGRhdGVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICBwYXRjaExpdmVPYmplY3RLZXkocm9vdCwga2V5LCBwcmV2W2tleV0sIG5leHRba2V5XSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgIGlmIChuZXh0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgcm9vdC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICByb290LnVwZGF0ZSh1cGRhdGVzKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGFyZW50c1BhdGgobm9kZSkge1xuICBjb25zdCBwYXRoID0gW107XG4gIHdoaWxlIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgaWYgKGlzTGl2ZUxpc3Qobm9kZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5ub2RlLl9pbmRleE9mUG9zaXRpb24obm9kZS5wYXJlbnQua2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5rZXkpO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnQubm9kZTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdChzdGF0ZSwgdXBkYXRlcykge1xuICByZXR1cm4gdXBkYXRlcy5yZWR1Y2UoXG4gICAgKHN0YXRlMiwgdXBkYXRlKSA9PiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlMiwgdXBkYXRlKSxcbiAgICBzdGF0ZVxuICApO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0V2l0aFVwZGF0ZShzdGF0ZSwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGggPSBnZXRQYXJlbnRzUGF0aCh1cGRhdGUubm9kZSk7XG4gIHJldHVybiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShzdGF0ZSwgcGF0aCwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGhJdGVtID0gcGF0aC5wb3AoKTtcbiAgaWYgKHBhdGhJdGVtID09PSB2b2lkIDApIHtcbiAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIFwiTGl2ZU9iamVjdFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlT2JqZWN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZUxpc3RcIjoge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVMaXN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIGFycmF5XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHN0YXRlLm1hcCgoeCkgPT4geCk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdFVwZGF0ZSBvZiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUubWFwKFxuICAgICAgICAgICAgICAoaXRlbSwgaW5kZXgpID0+IGluZGV4ID09PSBsaXN0VXBkYXRlLmluZGV4ID8gbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pIDogaXRlbVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJpbnNlcnRcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUuaW5kZXggPT09IG5ld1N0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZS5wdXNoKGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleClcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUuc3BsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcIm1vdmVcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCA+IGxpc3RVcGRhdGUuaW5kZXgpIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5pbmRleCksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZS5pbmRleCArIDFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkxpdmVNYXBcIjoge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZU1hcCBidXQgc3RhdGUgd2FzIG5vdCBhbiBvYmplY3RcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICBjb25zdCBuZXdBcnJheSA9IFsuLi5zdGF0ZV07XG4gICAgbmV3QXJyYXlbcGF0aEl0ZW1dID0gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShcbiAgICAgIHN0YXRlW3BhdGhJdGVtXSxcbiAgICAgIHBhdGgsXG4gICAgICB1cGRhdGVcbiAgICApO1xuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSBlbHNlIGlmIChpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN0YXRlW3BhdGhJdGVtXTtcbiAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YXRlQXNPYmogPSBzdGF0ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlQXNPYmosXG4gICAgICAgIFtwYXRoSXRlbV06IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUobm9kZSwgcGF0aCwgdXBkYXRlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbi8vIHNyYy9saWIvYWJvcnRDb250cm9sbGVyLnRzXG5mdW5jdGlvbiBtYWtlQWJvcnRDb250cm9sbGVyKGV4dGVybmFsU2lnbmFsKSB7XG4gIGNvbnN0IGN0bCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgcmV0dXJuIHtcbiAgICBzaWduYWw6IGV4dGVybmFsU2lnbmFsID8gQWJvcnRTaWduYWwuYW55KFtjdGwuc2lnbmFsLCBleHRlcm5hbFNpZ25hbF0pIDogY3RsLnNpZ25hbCxcbiAgICBhYm9ydDogY3RsLmFib3J0LmJpbmQoY3RsKVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2RlcHJlY2F0aW9uLnRzXG52YXIgX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIV9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncy5oYXMoa2V5KSkge1xuICAgICAgX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzLmFkZChrZXkpO1xuICAgICAgZXJyb3JXaXRoVGl0bGUoXCJEZXByZWNhdGlvbiB3YXJuaW5nXCIsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVwcmVjYXRlSWYoY29uZGl0aW9uLCBtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICBkZXByZWNhdGUobWVzc2FnZSwga2V5KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRocm93VXNhZ2VFcnJvcihtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCB1c2FnZUVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIHVzYWdlRXJyb3IubmFtZSA9IFwiVXNhZ2UgZXJyb3JcIjtcbiAgICBlcnJvcldpdGhUaXRsZShcIlVzYWdlIGVycm9yXCIsIG1lc3NhZ2UpO1xuICAgIHRocm93IHVzYWdlRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9ySWYoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICB0aHJvd1VzYWdlRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9saWIvUG9sbGVyLnRzXG52YXIgQkFDS09GRl9ERUxBWVMyID0gWzFlMywgMmUzLCA0ZTMsIDhlMywgMWU0XTtcbmZ1bmN0aW9uIG1ha2VQb2xsZXIoY2FsbGJhY2ssIGludGVydmFsTXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICBjb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdm9pZCAwO1xuICBjb25zdCBtYXhTdGFsZVRpbWVNcyA9IG9wdGlvbnM/Lm1heFN0YWxlVGltZU1zID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBpbkZvcmVncm91bmQ6IGRvYz8udmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiLFxuICAgIGxhc3RTdWNjZXNzZnVsUG9sbEF0OiBzdGFydFRpbWUsXG4gICAgY291bnQ6IDAsXG4gICAgYmFja29mZjogMFxuICB9O1xuICBmdW5jdGlvbiBtYXlQb2xsKCkge1xuICAgIHJldHVybiBjb250ZXh0LmNvdW50ID4gMCAmJiBjb250ZXh0LmluRm9yZWdyb3VuZDtcbiAgfVxuICBjb25zdCBmc20gPSBuZXcgRlNNKHt9KS5hZGRTdGF0ZShcIkBpZGxlXCIpLmFkZFN0YXRlKFwiQGVuYWJsZWRcIikuYWRkU3RhdGUoXCJAcG9sbGluZ1wiKTtcbiAgZnNtLmFkZFRyYW5zaXRpb25zKFwiQGlkbGVcIiwgeyBTVEFSVDogXCJAZW5hYmxlZFwiIH0pO1xuICBmc20uYWRkVHJhbnNpdGlvbnMoXCJAZW5hYmxlZFwiLCB7IFNUT1A6IFwiQGlkbGVcIiwgUE9MTDogXCJAcG9sbGluZ1wiIH0pO1xuICBmc20uYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGVuYWJsZWRcIixcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBsYXN0UG9sbCA9IGNvbnRleHQubGFzdFN1Y2Nlc3NmdWxQb2xsQXQ7XG4gICAgICBjb25zdCBuZXh0UG9sbCA9IGxhc3RQb2xsICsgaW50ZXJ2YWxNcztcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBuZXh0UG9sbCAtIHBlcmZvcm1hbmNlLm5vdygpKSArIGNvbnRleHQuYmFja29mZjtcbiAgICB9LFxuICAgIFwiQHBvbGxpbmdcIlxuICApO1xuICBmc20ub25FbnRlckFzeW5jKFxuICAgIFwiQHBvbGxpbmdcIixcbiAgICBhc3luYyAoX2N0eCwgc2lnbmFsKSA9PiB7XG4gICAgICBhd2FpdCBjYWxsYmFjayhzaWduYWwpO1xuICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBjb250ZXh0Lmxhc3RTdWNjZXNzZnVsUG9sbEF0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBXaGVuIE9LXG4gICAgKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBtYXlQb2xsKCkgPyBcIkBlbmFibGVkXCIgOiBcIkBpZGxlXCIsXG4gICAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICAgIGNvbnRleHQuYmFja29mZiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBXaGVuIGVycm9yXG4gICAgKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBtYXlQb2xsKCkgPyBcIkBlbmFibGVkXCIgOiBcIkBpZGxlXCIsXG4gICAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICAgIGNvbnRleHQuYmFja29mZiA9IEJBQ0tPRkZfREVMQVlTMi5maW5kKChkZWxheSkgPT4gZGVsYXkgPiBjb250ZXh0LmJhY2tvZmYpID8/IEJBQ0tPRkZfREVMQVlTMltCQUNLT0ZGX0RFTEFZUzIubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAzZTRcbiAgICAvLyBBYm9ydCB0aGUgcG9sbCBpZiB0aGUgY2FsbGJhY2sgdGFrZXMgbW9yZSB0aGFuIDMwIHNlY29uZHMgdG8gY29tcGxldGVcbiAgKTtcbiAgZnVuY3Rpb24gc3RhcnRPclN0b3AoKSB7XG4gICAgaWYgKG1heVBvbGwoKSkge1xuICAgICAgZnNtLnNlbmQoeyB0eXBlOiBcIlNUQVJUXCIgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZzbS5zZW5kKHsgdHlwZTogXCJTVE9QXCIgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGluYygpIHtcbiAgICBjb250ZXh0LmNvdW50Kys7XG4gICAgc3RhcnRPclN0b3AoKTtcbiAgfVxuICBmdW5jdGlvbiBkZWMoKSB7XG4gICAgY29udGV4dC5jb3VudC0tO1xuICAgIGlmIChjb250ZXh0LmNvdW50IDwgMCkge1xuICAgICAgY29udGV4dC5jb3VudCA9IDA7XG4gICAgfVxuICAgIHN0YXJ0T3JTdG9wKCk7XG4gIH1cbiAgZnVuY3Rpb24gcG9sbE5vd0lmU3RhbGUoKSB7XG4gICAgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gY29udGV4dC5sYXN0U3VjY2Vzc2Z1bFBvbGxBdCA+IG1heFN0YWxlVGltZU1zKSB7XG4gICAgICBmc20uc2VuZCh7IHR5cGU6IFwiUE9MTFwiIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXJrQXNTdGFsZSgpIHtcbiAgICBjb250ZXh0Lmxhc3RTdWNjZXNzZnVsUG9sbEF0ID0gcGVyZm9ybWFuY2Uubm93KCkgLSBtYXhTdGFsZVRpbWVNcyAtIDE7XG4gIH1cbiAgZnVuY3Rpb24gc2V0SW5Gb3JlZ3JvdW5kKGluRm9yZWdyb3VuZCkge1xuICAgIGNvbnRleHQuaW5Gb3JlZ3JvdW5kID0gaW5Gb3JlZ3JvdW5kO1xuICAgIHN0YXJ0T3JTdG9wKCk7XG4gICAgcG9sbE5vd0lmU3RhbGUoKTtcbiAgfVxuICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgc2V0SW5Gb3JlZ3JvdW5kKGRvYz8udmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiKTtcbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBwb2xsTm93SWZTdGFsZSk7XG4gIGZzbS5zdGFydCgpO1xuICByZXR1cm4ge1xuICAgIGluYyxcbiAgICBkZWMsXG4gICAgcG9sbE5vd0lmU3RhbGUsXG4gICAgbWFya0FzU3RhbGUsXG4gICAgLy8gSW50ZXJuYWwgQVBJLCB1c2VkIGJ5IHVuaXQgdGVzdHMgb25seSB0byBzaW11bGF0ZSB2aXNpYmlsaXR5IGV2ZW50c1xuICAgIHNldEluRm9yZWdyb3VuZFxuICB9O1xufVxuXG4vLyBzcmMvcHJvdG9jb2wvU3Vic2NyaXB0aW9ucy50c1xuZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uS2V5KHN1YnNjcmlwdGlvbiwgc3ViamVjdElkKSB7XG4gIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGAke3N1YnNjcmlwdGlvbn06JHtzdWJqZWN0SWR9YDtcbiAgfVxuICByZXR1cm4gYCR7c3Vic2NyaXB0aW9uLmtpbmR9OiR7c3Vic2NyaXB0aW9uLnN1YmplY3RJZH1gO1xufVxuXG4vLyBzcmMvdHlwZXMvT3RoZXJzLnRzXG52YXIgVGV4dEVkaXRvclR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChUZXh0RWRpdG9yVHlwZTIpID0+IHtcbiAgVGV4dEVkaXRvclR5cGUyW1wiTGV4aWNhbFwiXSA9IFwibGV4aWNhbFwiO1xuICBUZXh0RWRpdG9yVHlwZTJbXCJUaXBUYXBcIl0gPSBcInRpcHRhcFwiO1xuICBUZXh0RWRpdG9yVHlwZTJbXCJCbG9ja05vdGVcIl0gPSBcImJsb2Nrbm90ZVwiO1xuICByZXR1cm4gVGV4dEVkaXRvclR5cGUyO1xufSkoVGV4dEVkaXRvclR5cGUgfHwge30pO1xuXG4vLyBzcmMvaW5kZXgudHNcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG5leHBvcnQge1xuICBDbGllbnRNc2dDb2RlLFxuICBDcmR0VHlwZSxcbiAgRGVmYXVsdE1hcCxcbiAgRGVxdWUsXG4gIERlcml2ZWRTaWduYWwsXG4gIEh0dHBFcnJvcixcbiAgTGl2ZUxpc3QsXG4gIExpdmVNYXAsXG4gIExpdmVPYmplY3QsXG4gIExpdmVibG9ja3NFcnJvcixcbiAgTUVOVElPTl9DSEFSQUNURVIsXG4gIE11dGFibGVTaWduYWwsXG4gIE9wQ29kZSxcbiAgUGVybWlzc2lvbixcbiAgUHJvbWlzZV93aXRoUmVzb2x2ZXJzLFxuICBTZXJ2ZXJNc2dDb2RlLFxuICBTaWduYWwsXG4gIFNvcnRlZExpc3QsXG4gIFRleHRFZGl0b3JUeXBlLFxuICBXZWJzb2NrZXRDbG9zZUNvZGVzLFxuICBhY2tPcCxcbiAgYXNQb3MsXG4gIGFzc2VydCxcbiAgYXNzZXJ0TmV2ZXIsXG4gIGF1dG9SZXRyeSxcbiAgYjY0ZGVjb2RlLFxuICBiYXRjaCxcbiAgY2hlY2tCb3VuZHMsXG4gIGNodW5rLFxuICBjbG9uZUxzb24sXG4gIGNvbXBhY3RPYmplY3QsXG4gIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyBhcyBjb25zb2xlLFxuICBjb252ZXJ0VG9Db21tZW50RGF0YSxcbiAgY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbixcbiAgY29udmVydFRvR3JvdXBEYXRhLFxuICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEsXG4gIGNvbnZlcnRUb1N1YnNjcmlwdGlvbkRhdGEsXG4gIGNvbnZlcnRUb1RocmVhZERhdGEsXG4gIGNvbnZlcnRUb1VzZXJTdWJzY3JpcHRpb25EYXRhLFxuICBjcmVhdGVDbGllbnQsXG4gIGNyZWF0ZUNvbW1lbnRBdHRhY2htZW50SWQsXG4gIGNyZWF0ZUNvbW1lbnRJZCxcbiAgY3JlYXRlSW5ib3hOb3RpZmljYXRpb25JZCxcbiAgY3JlYXRlTWFuYWdlZFBvb2wsXG4gIGNyZWF0ZU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICBjcmVhdGVUaHJlYWRJZCxcbiAgZGVmaW5lQWlUb29sLFxuICBkZXByZWNhdGUsXG4gIGRlcHJlY2F0ZUlmLFxuICBkZXRlY3REdXBlcyxcbiAgZW50cmllcyxcbiAgZXJyb3JJZixcbiAgZmluZExhc3RJbmRleCxcbiAgZnJlZXplLFxuICBnZW5lcmF0ZVVybCxcbiAgZ2V0TWVudGlvbnNGcm9tQ29tbWVudEJvZHksXG4gIGdldFN1YnNjcmlwdGlvbktleSxcbiAgaHRtbCxcbiAgaHRtbFNhZmUsXG4gIGlzQ2hpbGRDcmR0LFxuICBpc0NvbW1lbnRCb2R5TGluayxcbiAgaXNDb21tZW50Qm9keU1lbnRpb24sXG4gIGlzQ29tbWVudEJvZHlUZXh0LFxuICBpc0pzb25BcnJheSxcbiAgaXNKc29uT2JqZWN0LFxuICBpc0pzb25TY2FsYXIsXG4gIGlzTGl2ZU5vZGUsXG4gIGlzTm90aWZpY2F0aW9uQ2hhbm5lbEVuYWJsZWQsXG4gIGlzTnVtYmVyT3BlcmF0b3IsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzUm9vdENyZHQsXG4gIGlzU3RhcnRzV2l0aE9wZXJhdG9yLFxuICBpc1VybCxcbiAga0ludGVybmFsLFxuICBrZXlzLFxuICBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3QsXG4gIGxzb25Ub0pzb24sXG4gIG1ha2VBYm9ydENvbnRyb2xsZXIsXG4gIG1ha2VFdmVudFNvdXJjZSxcbiAgbWFrZVBvbGxlcixcbiAgbWFrZVBvc2l0aW9uLFxuICBtYXBWYWx1ZXMsXG4gIG1lbW9pemVPblN1Y2Nlc3MsXG4gIG5hbm9pZCxcbiAgbm4sXG4gIG9iamVjdFRvUXVlcnksXG4gIHBhdGNoTGl2ZU9iamVjdEtleSxcbiAgcGF0Y2hOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgcmFpc2UsXG4gIHJlc29sdmVNZW50aW9uc0luQ29tbWVudEJvZHksXG4gIHNhbml0aXplVXJsLFxuICBzaGFsbG93LFxuICBzaGFsbG93MixcbiAgc3RhYmxlU3RyaW5naWZ5LFxuICBzdHJpbmdpZnlDb21tZW50Qm9keSxcbiAgdGhyb3dVc2FnZUVycm9yLFxuICB0b1BsYWluTHNvbixcbiAgdHJ5UGFyc2VKc29uLFxuICB1cmwsXG4gIHVybGpvaW4sXG4gIHdhaXQsXG4gIHdhcm5PbmNlLFxuICB3YXJuT25jZUlmLFxuICB3aXRoVGltZW91dFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/chunk-32VPOOHH.js":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/chunk-32VPOOHH.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientSideSuspense: () => (/* binding */ ClientSideSuspense),\n/* harmony export */   PKG_FORMAT: () => (/* binding */ PKG_FORMAT),\n/* harmony export */   PKG_NAME: () => (/* binding */ PKG_NAME),\n/* harmony export */   PKG_VERSION: () => (/* binding */ PKG_VERSION)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/react\";\nvar PKG_VERSION = \"3.11.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/ClientSideSuspense.tsx\n\n\nfunction ClientSideSuspense(props) {\n  const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    setMounted(true);\n  }, []);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, { fallback: props.fallback, children: mounted ? typeof props.children === \"function\" ? props.children() : props.children : props.fallback });\n}\n\n\n//# sourceMappingURL=chunk-32VPOOHH.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9jaHVuay0zMlZQT09ISC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzRDtBQUNkO0FBQ3hDO0FBQ0EsZ0NBQWdDLCtDQUFRO0FBQ3hDLEVBQUUsZ0RBQVM7QUFDWDtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsc0RBQUcsQ0FBQywyQ0FBUSxJQUFJLHlJQUF5STtBQUNsTDs7QUFPRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvYXJ5YW5nb3lhbC9yZWFsLXRpbWUtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0L2Rpc3QvY2h1bmstMzJWUE9PSEguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3ZlcnNpb24udHNcbnZhciBQS0dfTkFNRSA9IFwiQGxpdmVibG9ja3MvcmVhY3RcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMy4xMS4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9DbGllbnRTaWRlU3VzcGVuc2UudHN4XG5pbXBvcnQgeyBTdXNwZW5zZSwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBDbGllbnRTaWRlU3VzcGVuc2UocHJvcHMpIHtcbiAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goU3VzcGVuc2UsIHsgZmFsbGJhY2s6IHByb3BzLmZhbGxiYWNrLCBjaGlsZHJlbjogbW91bnRlZCA/IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gcHJvcHMuY2hpbGRyZW4oKSA6IHByb3BzLmNoaWxkcmVuIDogcHJvcHMuZmFsbGJhY2sgfSk7XG59XG5cbmV4cG9ydCB7XG4gIFBLR19OQU1FLFxuICBQS0dfVkVSU0lPTixcbiAgUEtHX0ZPUk1BVCxcbiAgQ2xpZW50U2lkZVN1c3BlbnNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstMzJWUE9PSEguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/chunk-32VPOOHH.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/chunk-JOZ4BQWH.js":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/chunk-JOZ4BQWH.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientContext: () => (/* binding */ ClientContext),\n/* harmony export */   LiveblocksProvider: () => (/* binding */ LiveblocksProvider),\n/* harmony export */   RegisterAiKnowledge: () => (/* binding */ RegisterAiKnowledge),\n/* harmony export */   RegisterAiTool: () => (/* binding */ RegisterAiTool),\n/* harmony export */   RoomContext: () => (/* binding */ RoomContext),\n/* harmony export */   _RoomProvider: () => (/* binding */ _RoomProvider),\n/* harmony export */   _useAddReaction: () => (/* binding */ _useAddReaction),\n/* harmony export */   _useAiChat: () => (/* binding */ _useAiChat),\n/* harmony export */   _useAiChatMessages: () => (/* binding */ _useAiChatMessages),\n/* harmony export */   _useAiChatMessagesSuspense: () => (/* binding */ _useAiChatMessagesSuspense),\n/* harmony export */   _useAiChatSuspense: () => (/* binding */ _useAiChatSuspense),\n/* harmony export */   _useAiChats: () => (/* binding */ _useAiChats),\n/* harmony export */   _useAiChatsSuspense: () => (/* binding */ _useAiChatsSuspense),\n/* harmony export */   _useBroadcastEvent: () => (/* binding */ _useBroadcastEvent),\n/* harmony export */   _useCreateThread: () => (/* binding */ _useCreateThread),\n/* harmony export */   _useDeleteThread: () => (/* binding */ _useDeleteThread),\n/* harmony export */   _useEditThreadMetadata: () => (/* binding */ _useEditThreadMetadata),\n/* harmony export */   _useEventListener: () => (/* binding */ _useEventListener),\n/* harmony export */   _useHistoryVersions: () => (/* binding */ _useHistoryVersions),\n/* harmony export */   _useHistoryVersionsSuspense: () => (/* binding */ _useHistoryVersionsSuspense),\n/* harmony export */   _useInboxNotificationThread: () => (/* binding */ _useInboxNotificationThread),\n/* harmony export */   _useIsInsideRoom: () => (/* binding */ _useIsInsideRoom),\n/* harmony export */   _useMutation: () => (/* binding */ _useMutation),\n/* harmony export */   _useMyPresence: () => (/* binding */ _useMyPresence),\n/* harmony export */   _useOther: () => (/* binding */ _useOther),\n/* harmony export */   _useOtherSuspense: () => (/* binding */ _useOtherSuspense),\n/* harmony export */   _useOthers: () => (/* binding */ _useOthers),\n/* harmony export */   _useOthersListener: () => (/* binding */ _useOthersListener),\n/* harmony export */   _useOthersMapped: () => (/* binding */ _useOthersMapped),\n/* harmony export */   _useOthersMappedSuspense: () => (/* binding */ _useOthersMappedSuspense),\n/* harmony export */   _useOthersSuspense: () => (/* binding */ _useOthersSuspense),\n/* harmony export */   _useRoom: () => (/* binding */ _useRoom),\n/* harmony export */   _useRoomSubscriptionSettings: () => (/* binding */ _useRoomSubscriptionSettings),\n/* harmony export */   _useRoomSubscriptionSettingsSuspense: () => (/* binding */ _useRoomSubscriptionSettingsSuspense),\n/* harmony export */   _useSearchComments: () => (/* binding */ _useSearchComments),\n/* harmony export */   _useSelf: () => (/* binding */ _useSelf),\n/* harmony export */   _useSelfSuspense: () => (/* binding */ _useSelfSuspense),\n/* harmony export */   _useStorage: () => (/* binding */ _useStorage),\n/* harmony export */   _useStorageRoot: () => (/* binding */ _useStorageRoot),\n/* harmony export */   _useStorageSuspense: () => (/* binding */ _useStorageSuspense),\n/* harmony export */   _useThreads: () => (/* binding */ _useThreads),\n/* harmony export */   _useThreadsSuspense: () => (/* binding */ _useThreadsSuspense),\n/* harmony export */   _useUpdateMyPresence: () => (/* binding */ _useUpdateMyPresence),\n/* harmony export */   _useUrlMetadata: () => (/* binding */ _useUrlMetadata),\n/* harmony export */   _useUrlMetadataSuspense: () => (/* binding */ _useUrlMetadataSuspense),\n/* harmony export */   _useUser: () => (/* binding */ _useUser),\n/* harmony export */   _useUserSuspense: () => (/* binding */ _useUserSuspense),\n/* harmony export */   _useUserThreadsSuspense_experimental: () => (/* binding */ _useUserThreadsSuspense_experimental),\n/* harmony export */   _useUserThreads_experimental: () => (/* binding */ _useUserThreads_experimental),\n/* harmony export */   createLiveblocksContext: () => (/* binding */ createLiveblocksContext),\n/* harmony export */   createRoomContext: () => (/* binding */ createRoomContext),\n/* harmony export */   getUmbrellaStoreForClient: () => (/* binding */ getUmbrellaStoreForClient),\n/* harmony export */   useAddRoomCommentReaction: () => (/* binding */ useAddRoomCommentReaction),\n/* harmony export */   useAiChatStatus: () => (/* binding */ useAiChatStatus),\n/* harmony export */   useAttachmentUrl: () => (/* binding */ useAttachmentUrl),\n/* harmony export */   useAttachmentUrlSuspense: () => (/* binding */ useAttachmentUrlSuspense),\n/* harmony export */   useCanRedo: () => (/* binding */ useCanRedo),\n/* harmony export */   useCanUndo: () => (/* binding */ useCanUndo),\n/* harmony export */   useClient: () => (/* binding */ useClient),\n/* harmony export */   useClientOrNull: () => (/* binding */ useClientOrNull),\n/* harmony export */   useCreateAiChat: () => (/* binding */ useCreateAiChat),\n/* harmony export */   useCreateComment: () => (/* binding */ useCreateComment),\n/* harmony export */   useCreateRoomComment: () => (/* binding */ useCreateRoomComment),\n/* harmony export */   useCreateRoomThread: () => (/* binding */ useCreateRoomThread),\n/* harmony export */   useCreateTextMention: () => (/* binding */ useCreateTextMention),\n/* harmony export */   useDeleteAiChat: () => (/* binding */ useDeleteAiChat),\n/* harmony export */   useDeleteAllInboxNotifications: () => (/* binding */ useDeleteAllInboxNotifications),\n/* harmony export */   useDeleteComment: () => (/* binding */ useDeleteComment),\n/* harmony export */   useDeleteInboxNotification: () => (/* binding */ useDeleteInboxNotification),\n/* harmony export */   useDeleteRoomComment: () => (/* binding */ useDeleteRoomComment),\n/* harmony export */   useDeleteRoomThread: () => (/* binding */ useDeleteRoomThread),\n/* harmony export */   useDeleteTextMention: () => (/* binding */ useDeleteTextMention),\n/* harmony export */   useEditComment: () => (/* binding */ useEditComment),\n/* harmony export */   useEditRoomComment: () => (/* binding */ useEditRoomComment),\n/* harmony export */   useEditRoomThreadMetadata: () => (/* binding */ useEditRoomThreadMetadata),\n/* harmony export */   useErrorListener: () => (/* binding */ useErrorListener),\n/* harmony export */   useGroupInfo: () => (/* binding */ useGroupInfo),\n/* harmony export */   useGroupInfoSuspense: () => (/* binding */ useGroupInfoSuspense),\n/* harmony export */   useHistory: () => (/* binding */ useHistory),\n/* harmony export */   useHistoryVersionData: () => (/* binding */ useHistoryVersionData),\n/* harmony export */   useInboxNotifications: () => (/* binding */ useInboxNotifications),\n/* harmony export */   useInboxNotificationsSuspense: () => (/* binding */ useInboxNotificationsSuspense),\n/* harmony export */   useLatest: () => (/* binding */ useLatest),\n/* harmony export */   useLostConnectionListener: () => (/* binding */ useLostConnectionListener),\n/* harmony export */   useMarkAllInboxNotificationsAsRead: () => (/* binding */ useMarkAllInboxNotificationsAsRead),\n/* harmony export */   useMarkInboxNotificationAsRead: () => (/* binding */ useMarkInboxNotificationAsRead),\n/* harmony export */   useMarkRoomThreadAsRead: () => (/* binding */ useMarkRoomThreadAsRead),\n/* harmony export */   useMarkRoomThreadAsResolved: () => (/* binding */ useMarkRoomThreadAsResolved),\n/* harmony export */   useMarkRoomThreadAsUnresolved: () => (/* binding */ useMarkRoomThreadAsUnresolved),\n/* harmony export */   useMarkThreadAsRead: () => (/* binding */ useMarkThreadAsRead),\n/* harmony export */   useMarkThreadAsResolved: () => (/* binding */ useMarkThreadAsResolved),\n/* harmony export */   useMarkThreadAsUnresolved: () => (/* binding */ useMarkThreadAsUnresolved),\n/* harmony export */   useMentionSuggestionsCache: () => (/* binding */ useMentionSuggestionsCache),\n/* harmony export */   useNotificationSettings: () => (/* binding */ useNotificationSettings),\n/* harmony export */   useNotificationSettingsSuspense: () => (/* binding */ useNotificationSettingsSuspense),\n/* harmony export */   useOthersConnectionIds: () => (/* binding */ useOthersConnectionIds),\n/* harmony export */   useOthersConnectionIdsSuspense: () => (/* binding */ useOthersConnectionIdsSuspense),\n/* harmony export */   useRedo: () => (/* binding */ useRedo),\n/* harmony export */   useRemoveReaction: () => (/* binding */ useRemoveReaction),\n/* harmony export */   useRemoveRoomCommentReaction: () => (/* binding */ useRemoveRoomCommentReaction),\n/* harmony export */   useReportTextEditor: () => (/* binding */ useReportTextEditor),\n/* harmony export */   useResolveMentionSuggestions: () => (/* binding */ useResolveMentionSuggestions),\n/* harmony export */   useRoomAttachmentUrl: () => (/* binding */ useRoomAttachmentUrl),\n/* harmony export */   useRoomInfo: () => (/* binding */ useRoomInfo),\n/* harmony export */   useRoomInfoSuspense: () => (/* binding */ useRoomInfoSuspense),\n/* harmony export */   useRoomPermissions: () => (/* binding */ useRoomPermissions),\n/* harmony export */   useRoomThreadSubscription: () => (/* binding */ useRoomThreadSubscription),\n/* harmony export */   useSendAiMessage: () => (/* binding */ useSendAiMessage),\n/* harmony export */   useSignal: () => (/* binding */ useSignal),\n/* harmony export */   useStatus: () => (/* binding */ useStatus),\n/* harmony export */   useSubscribeToThread: () => (/* binding */ useSubscribeToThread),\n/* harmony export */   useSyncExternalStoreWithSelector: () => (/* binding */ useSyncExternalStoreWithSelector),\n/* harmony export */   useSyncStatus: () => (/* binding */ useSyncStatus),\n/* harmony export */   useThreadSubscription: () => (/* binding */ useThreadSubscription),\n/* harmony export */   useUndo: () => (/* binding */ useUndo),\n/* harmony export */   useUnreadInboxNotificationsCount: () => (/* binding */ useUnreadInboxNotificationsCount),\n/* harmony export */   useUnreadInboxNotificationsCountSuspense: () => (/* binding */ useUnreadInboxNotificationsCountSuspense),\n/* harmony export */   useUnsubscribeFromThread: () => (/* binding */ useUnsubscribeFromThread),\n/* harmony export */   useUpdateNotificationSettings: () => (/* binding */ useUpdateNotificationSettings),\n/* harmony export */   useUpdateRoomSubscriptionSettings: () => (/* binding */ useUpdateRoomSubscriptionSettings),\n/* harmony export */   useYjsProvider: () => (/* binding */ useYjsProvider)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n// src/contexts.ts\n\n\nvar ClientContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useClientOrNull() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ClientContext);\n}\nfunction useClient() {\n  return useClientOrNull() ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\"LiveblocksProvider is missing from the React tree.\");\n}\nvar RoomContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useRoomOrNull() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RoomContext);\n}\nfunction useIsInsideRoom() {\n  const room = useRoomOrNull();\n  return room !== null;\n}\n\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n\n// src/ai.tsx\n\n\nfunction useAi() {\n  return useClient()[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai;\n}\nfunction useRandom() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nanoid)[0];\n}\nvar RegisterAiKnowledge = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function RegisterAiKnowledge2(props) {\n  const layerId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n  const ai = useAi();\n  const { description, value, chatId } = props;\n  const [layerKey, setLayerKey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { layerKey: layerKey2, deregister } = ai.registerKnowledgeLayer(layerId, chatId);\n    setLayerKey(layerKey2);\n    return () => {\n      deregister();\n      setLayerKey(void 0);\n    };\n  }, [ai, layerId, chatId]);\n  const randomKey = useRandom();\n  const knowledgeKey = props.id ?? randomKey;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (layerKey !== void 0) {\n      ai.updateKnowledge(\n        layerKey,\n        { description, value },\n        knowledgeKey,\n        chatId\n      );\n    }\n  }, [ai, layerKey, knowledgeKey, description, value, chatId]);\n  return null;\n});\nvar RegisterAiTool = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function RegisterAiTool2({\n  chatId,\n  name,\n  tool,\n  enabled\n}) {\n  const client = useClient();\n  const ai = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const toolWithEnabled = enabled !== void 0 ? { ...tool, enabled } : tool;\n    return ai.registerTool(name, toolWithEnabled, chatId);\n  }, [ai, chatId, name, tool, enabled]);\n  return null;\n});\n\n// src/use-sync-external-store-with-selector.ts\n\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n}\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n  const instRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  let inst;\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n  const [getSelection, getServerSelection] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    let hasMemo = false;\n    let memoizedSnapshot;\n    let memoizedSelection;\n    const memoizedSelector = (nextSnapshot) => {\n      if (!hasMemo) {\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n        const nextSelection2 = selector(nextSnapshot);\n        if (isEqual !== void 0) {\n          if (inst.hasValue) {\n            const currentSelection = inst.value;\n            if (isEqual(currentSelection, nextSelection2)) {\n              memoizedSelection = currentSelection;\n              return currentSelection;\n            }\n          }\n        }\n        memoizedSelection = nextSelection2;\n        return nextSelection2;\n      }\n      const prevSnapshot = memoizedSnapshot;\n      const prevSelection = memoizedSelection;\n      if (is(prevSnapshot, nextSnapshot)) {\n        return prevSelection;\n      }\n      const nextSelection = selector(nextSnapshot);\n      if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {\n        memoizedSnapshot = nextSnapshot;\n        return prevSelection;\n      }\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    };\n    const maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;\n    const getSnapshotWithSelector = () => memoizedSelector(getSnapshot());\n    const getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : () => memoizedSelector(maybeGetServerSnapshot());\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]);\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    subscribe,\n    getSelection,\n    getServerSelection\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n  return value;\n}\n\n// src/use-signal.ts\n\nvar identity = (value) => value;\nfunction useSignal(signal, selector, isEqual) {\n  if (signal instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal) {\n    throw new Error(\n      \"Using a mutable Signal with useSignal will likely not work as expected.\"\n    );\n  }\n  return useSyncExternalStoreWithSelector(\n    signal.subscribe,\n    signal.get,\n    signal.get,\n    selector ?? identity,\n    isEqual\n  );\n}\n\n// src/liveblocks.tsx\n\n\n\n// src/config.ts\nvar SECONDS = 1e3;\nvar MINUTES = 60 * SECONDS;\nvar config = {\n  SMOOTH_DELAY: 1 * SECONDS,\n  NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,\n  ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,\n  ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,\n  USER_THREADS_POLL_INTERVAL: 1 * MINUTES,\n  USER_THREADS_MAX_STALE_TIME: 30 * SECONDS,\n  HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,\n  HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,\n  ROOM_SUBSCRIPTION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,\n  ROOM_SUBSCRIPTION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS,\n  USER_NOTIFICATION_SETTINGS_INTERVAL: 5 * MINUTES,\n  USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME: 1 * MINUTES\n};\n\n// src/lib/AsyncResult.ts\nvar ASYNC_LOADING = Object.freeze({ isLoading: true });\nvar ASYNC_ERR = (error) => Object.freeze({ isLoading: false, error });\nfunction ASYNC_OK(fieldOrData, data) {\n  if (arguments.length === 1) {\n    return Object.freeze({ isLoading: false, data: fieldOrData });\n  } else {\n    return Object.freeze({ isLoading: false, [fieldOrData]: data });\n  }\n}\n\n// src/lib/ssr.ts\nfunction ensureNotServerSide() {\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"You cannot use the Suspense version of Liveblocks hooks server side. Make sure to only call them client side by using a ClientSideSuspense wrapper.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#ClientSideSuspense\"\n    );\n  }\n}\n\n// src/lib/use-initial.ts\n\nfunction useInitial(value, roomId) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => value, [roomId]);\n}\nfunction useInitialUnlessFunction(latestValue, roomId) {\n  const frozenValue = useInitial(latestValue, roomId);\n  const ref = useLatest(latestValue);\n  const wrapper = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (...args) => ref.current(...args),\n    [ref]\n  );\n  if (typeof frozenValue === \"function\") {\n    return wrapper;\n  } else {\n    return frozenValue;\n  }\n}\n\n// src/lib/use-polyfill.ts\n\nvar reactUse = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[\" use \".trim().toString()];\nvar use = reactUse ?? ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\n\n// src/umbrella-store.ts\n\n\n// src/lib/autobind.ts\nfunction autobind(self) {\n  const seen = /* @__PURE__ */ new Set();\n  seen.add(\"constructor\");\n  let obj = self.constructor.prototype;\n  do {\n    for (const key of Reflect.ownKeys(obj)) {\n      if (seen.has(key)) continue;\n      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);\n      if (typeof descriptor?.value === \"function\") {\n        seen.add(key);\n        self[key] = self[key].bind(self);\n      }\n    }\n  } while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype);\n}\n\n// src/lib/itertools.ts\nfunction find(it, predicate) {\n  for (const item of it) {\n    if (predicate(item)) return item;\n  }\n  return void 0;\n}\n\n// src/lib/querying.ts\n\nfunction makeThreadsFilter(query, subscriptions) {\n  return (thread) => matchesThreadsQuery(thread, query, subscriptions) && matchesMetadata(thread, query);\n}\nfunction matchesThreadsQuery(thread, q, subscriptions) {\n  let subscription = void 0;\n  if (subscriptions) {\n    subscription = subscriptions?.[(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.getSubscriptionKey)(\"thread\", thread.id)];\n  }\n  return (q.resolved === void 0 || thread.resolved === q.resolved) && (q.subscribed === void 0 || q.subscribed === true && subscription !== void 0 || q.subscribed === false && subscription === void 0);\n}\nfunction matchesMetadata(thread, q) {\n  const metadata = thread.metadata;\n  return q.metadata === void 0 || Object.entries(q.metadata).every(\n    ([key, op]) => (\n      // Ignore explicit-undefined filters\n      // Boolean logic: op? => value matches the operator\n      op === void 0 || matchesOperator(metadata[key], op)\n    )\n  );\n}\nfunction matchesOperator(value, op) {\n  if (op === null) {\n    return value === void 0;\n  } else if ((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.isStartsWithOperator)(op)) {\n    return typeof value === \"string\" && value.startsWith(op.startsWith);\n  } else if ((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.isNumberOperator)(op)) {\n    return typeof value === \"number\" && matchesNumberOperator(value, op);\n  } else {\n    return value === op;\n  }\n}\nfunction matchesNumberOperator(value, op) {\n  return (op.lt === void 0 || value < op.lt) && (op.gt === void 0 || value > op.gt) && (op.lte === void 0 || value <= op.lte) && (op.gte === void 0 || value >= op.gte);\n}\nfunction makeInboxNotificationsFilter(query) {\n  return (inboxNotification) => matchesInboxNotificationsQuery(inboxNotification, query);\n}\nfunction matchesInboxNotificationsQuery(inboxNotification, q) {\n  return (q.roomId === void 0 || q.roomId === inboxNotification.roomId) && (q.kind === void 0 || q.kind === inboxNotification.kind);\n}\n\n// src/ThreadDB.ts\n\nfunction sanitizeThread(thread) {\n  if (thread.deletedAt) {\n    if (thread.comments.length > 0) {\n      return { ...thread, comments: [] };\n    }\n  }\n  const hasComment = thread.comments.some((c) => !c.deletedAt);\n  if (!hasComment) {\n    return { ...thread, deletedAt: /* @__PURE__ */ new Date(), comments: [] };\n  }\n  return thread;\n}\nvar ThreadDB = class _ThreadDB {\n  #byId;\n  #asc;\n  #desc;\n  // This signal will be notified on every mutation\n  signal;\n  constructor() {\n    this.#asc = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.SortedList.from([], (t1, t2) => {\n      const d1 = t1.createdAt;\n      const d2 = t2.createdAt;\n      return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;\n    });\n    this.#desc = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.SortedList.from([], (t1, t2) => {\n      const d2 = t2.updatedAt;\n      const d1 = t1.updatedAt;\n      return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;\n    });\n    this.#byId = /* @__PURE__ */ new Map();\n    this.signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(this);\n  }\n  //\n  // Public APIs\n  //\n  clone() {\n    const newPool = new _ThreadDB();\n    newPool.#byId = new Map(this.#byId);\n    newPool.#asc = this.#asc.clone();\n    newPool.#desc = this.#desc.clone();\n    return newPool;\n  }\n  /** Returns an existing thread by ID. Will never return a deleted thread. */\n  get(threadId) {\n    const thread = this.getEvenIfDeleted(threadId);\n    return thread?.deletedAt ? void 0 : thread;\n  }\n  /** Returns the (possibly deleted) thread by ID. */\n  getEvenIfDeleted(threadId) {\n    return this.#byId.get(threadId);\n  }\n  /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */\n  upsert(thread) {\n    this.signal.mutate(() => {\n      thread = sanitizeThread(thread);\n      const id = thread.id;\n      const toRemove = this.#byId.get(id);\n      if (toRemove) {\n        if (toRemove.deletedAt) return false;\n        this.#asc.remove(toRemove);\n        this.#desc.remove(toRemove);\n      }\n      if (!thread.deletedAt) {\n        this.#asc.add(thread);\n        this.#desc.add(thread);\n      }\n      this.#byId.set(id, thread);\n      return true;\n    });\n  }\n  /** Like .upsert(), except it won't update if a thread by this ID already exists. */\n  // TODO Consider renaming this to just .upsert(). I'm not sure if we really\n  // TODO need the raw .upsert(). Would be nice if this behavior was the default.\n  upsertIfNewer(thread) {\n    const existing = this.get(thread.id);\n    if (!existing || thread.updatedAt >= existing.updatedAt) {\n      this.upsert(thread);\n    }\n  }\n  applyDelta(newThreads, deletedThreads) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      for (const thread of newThreads) {\n        this.upsertIfNewer(thread);\n      }\n      for (const { id, deletedAt } of deletedThreads) {\n        const existing = this.getEvenIfDeleted(id);\n        if (!existing) continue;\n        this.delete(id, deletedAt);\n      }\n    });\n  }\n  /**\n   * Marks a thread as deleted. It will no longer pop up in .findMany()\n   * queries, but it can still be accessed via `.getEvenIfDeleted()`.\n   */\n  delete(threadId, deletedAt) {\n    const existing = this.#byId.get(threadId);\n    if (existing && !existing.deletedAt) {\n      this.upsert({ ...existing, deletedAt, updatedAt: deletedAt });\n    }\n  }\n  /**\n   * Returns all threads matching a given roomId and query. If roomId is not\n   * specified, it will return all threads matching the query, across all\n   * rooms.\n   *\n   * Returns the results in the requested order. Please note:\n   *   'asc'  means by createdAt ASC\n   *   'desc' means by updatedAt DESC\n   *\n   * Will never return deleted threads in the result.\n   *\n   * Subscriptions are needed to filter threads based on the user's subscriptions.\n   */\n  findMany(roomId, query, direction, subscriptions) {\n    const index = direction === \"desc\" ? this.#desc : this.#asc;\n    const crit = [];\n    if (roomId !== void 0) {\n      crit.push((t) => t.roomId === roomId);\n    }\n    if (query !== void 0) {\n      crit.push(makeThreadsFilter(query, subscriptions));\n    }\n    return Array.from(index.filter((t) => crit.every((pred) => pred(t))));\n  }\n};\n\n// src/umbrella-store.ts\nfunction makeRoomThreadsQueryKey(roomId, query) {\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.stableStringify)([roomId, query ?? {}]);\n}\nfunction makeUserThreadsQueryKey(query) {\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.stableStringify)(query ?? {});\n}\nfunction makeAiChatsQueryKey(query) {\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.stableStringify)(query ?? {});\n}\nfunction makeInboxNotificationsQueryKey(query) {\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.stableStringify)(query ?? {});\n}\nfunction usify(promise) {\n  if (\"status\" in promise) {\n    return promise;\n  }\n  const usable = promise;\n  usable.status = \"pending\";\n  usable.then(\n    (value) => {\n      usable.status = \"fulfilled\";\n      usable.value = value;\n    },\n    (err) => {\n      usable.status = \"rejected\";\n      usable.reason = err;\n    }\n  );\n  return usable;\n}\nvar noop = Promise.resolve();\nvar PaginatedResource = class {\n  #signal;\n  signal;\n  #fetchPage;\n  #pendingFetchMore;\n  constructor(fetchPage) {\n    this.#signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal(ASYNC_LOADING);\n    this.#fetchPage = fetchPage;\n    this.#pendingFetchMore = null;\n    this.signal = this.#signal.asReadonly();\n    autobind(this);\n  }\n  get() {\n    return this.#signal.get();\n  }\n  #patch(patch) {\n    const state = this.#signal.get();\n    if (state.data === void 0) return;\n    this.#signal.set(ASYNC_OK({ ...state.data, ...patch }));\n  }\n  async #fetchMore() {\n    const state = this.#signal.get();\n    if (!state.data?.cursor || state.data.isFetchingMore) {\n      return;\n    }\n    this.#patch({ isFetchingMore: true });\n    try {\n      const nextCursor = await this.#fetchPage(state.data.cursor);\n      this.#patch({\n        cursor: nextCursor,\n        hasFetchedAll: nextCursor === null,\n        fetchMoreError: void 0,\n        isFetchingMore: false\n      });\n    } catch (err) {\n      this.#patch({\n        isFetchingMore: false,\n        fetchMoreError: err\n      });\n    }\n  }\n  fetchMore() {\n    const state = this.#signal.get();\n    if (!state.data?.cursor) return noop;\n    if (!this.#pendingFetchMore) {\n      this.#pendingFetchMore = this.#fetchMore().finally(() => {\n        this.#pendingFetchMore = null;\n      });\n    }\n    return this.#pendingFetchMore;\n  }\n  #cachedPromise = null;\n  waitUntilLoaded() {\n    if (this.#cachedPromise) {\n      return this.#cachedPromise;\n    }\n    const initialPageFetch$ = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.autoRetry)(\n      () => this.#fetchPage(\n        /* cursor */\n        void 0\n      ),\n      5,\n      [5e3, 5e3, 1e4, 15e3]\n    );\n    const promise = usify(initialPageFetch$);\n    promise.then(\n      (cursor) => {\n        this.#signal.set(\n          ASYNC_OK({\n            cursor,\n            hasFetchedAll: cursor === null,\n            isFetchingMore: false,\n            fetchMoreError: void 0,\n            fetchMore: this.fetchMore\n          })\n        );\n      },\n      (err) => {\n        this.#signal.set(ASYNC_ERR(err));\n        setTimeout(() => {\n          this.#cachedPromise = null;\n          this.#signal.set(ASYNC_LOADING);\n        }, 5e3);\n      }\n    );\n    this.#cachedPromise = promise;\n    return this.#cachedPromise;\n  }\n};\nvar SinglePageResource = class {\n  #signal;\n  signal;\n  #fetchPage;\n  #autoRetry = true;\n  constructor(fetchPage, autoRetry2 = true) {\n    this.#signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal(ASYNC_LOADING);\n    this.signal = this.#signal.asReadonly();\n    this.#fetchPage = fetchPage;\n    this.#autoRetry = autoRetry2;\n    autobind(this);\n  }\n  get() {\n    return this.#signal.get();\n  }\n  #cachedPromise = null;\n  waitUntilLoaded() {\n    if (this.#cachedPromise) {\n      return this.#cachedPromise;\n    }\n    const initialFetcher$ = this.#autoRetry ? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.autoRetry)(() => this.#fetchPage(), 5, [5e3, 5e3, 1e4, 15e3]) : this.#fetchPage();\n    const promise = usify(initialFetcher$);\n    promise.then(\n      () => {\n        this.#signal.set(ASYNC_OK(void 0));\n      },\n      (err) => {\n        this.#signal.set(ASYNC_ERR(err));\n        if (this.#autoRetry) {\n          setTimeout(() => {\n            this.#cachedPromise = null;\n            this.#signal.set(ASYNC_LOADING);\n          }, 5e3);\n        }\n      }\n    );\n    this.#cachedPromise = promise;\n    return promise;\n  }\n};\nfunction createStore_forNotifications() {\n  const signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(/* @__PURE__ */ new Map());\n  function markRead(notificationId, readAt) {\n    signal.mutate((lut) => {\n      const existing = lut.get(notificationId);\n      if (!existing) {\n        return false;\n      }\n      lut.set(notificationId, { ...existing, readAt });\n      return true;\n    });\n  }\n  function markAllRead(readAt) {\n    signal.mutate((lut) => {\n      for (const n of lut.values()) {\n        n.readAt = readAt;\n      }\n    });\n  }\n  function deleteOne(inboxNotificationId) {\n    signal.mutate((lut) => lut.delete(inboxNotificationId));\n  }\n  function clear() {\n    signal.mutate((lut) => lut.clear());\n  }\n  function applyDelta(newNotifications, deletedNotifications) {\n    signal.mutate((lut) => {\n      let mutated = false;\n      for (const n of newNotifications) {\n        const existing = lut.get(n.id);\n        if (existing) {\n          const result = compareInboxNotifications(existing, n);\n          if (result === 1) continue;\n        }\n        lut.set(n.id, n);\n        mutated = true;\n      }\n      for (const n of deletedNotifications) {\n        lut.delete(n.id);\n        mutated = true;\n      }\n      return mutated;\n    });\n  }\n  function updateAssociatedNotification(newComment) {\n    signal.mutate((lut) => {\n      const existing = find(\n        lut.values(),\n        (notification) => notification.kind === \"thread\" && notification.threadId === newComment.threadId\n      );\n      if (!existing) return false;\n      lut.set(existing.id, {\n        ...existing,\n        notifiedAt: newComment.createdAt,\n        readAt: newComment.createdAt\n      });\n      return true;\n    });\n  }\n  function upsert(notification) {\n    signal.mutate((lut) => {\n      lut.set(notification.id, notification);\n    });\n  }\n  return {\n    signal: signal.asReadonly(),\n    // Mutations\n    markAllRead,\n    markRead,\n    delete: deleteOne,\n    applyDelta,\n    clear,\n    updateAssociatedNotification,\n    upsert\n  };\n}\nfunction createStore_forUnreadNotificationsCount() {\n  const baseSignal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(\n    /* @__PURE__ */ new Map()\n  );\n  function update(queryKey, count) {\n    baseSignal.mutate((lut) => {\n      lut.set(queryKey, count);\n    });\n  }\n  return {\n    signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(baseSignal, (c) => Object.fromEntries(c)),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forSubscriptions(updates, threads) {\n  const baseSignal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(/* @__PURE__ */ new Map());\n  function applyDelta(newSubscriptions, deletedSubscriptions) {\n    baseSignal.mutate((lut) => {\n      let mutated = false;\n      for (const s of newSubscriptions) {\n        lut.set((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.getSubscriptionKey)(s), s);\n        mutated = true;\n      }\n      for (const s of deletedSubscriptions) {\n        lut.delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.getSubscriptionKey)(s));\n        mutated = true;\n      }\n      return mutated;\n    });\n  }\n  function create(subscription) {\n    baseSignal.mutate((lut) => {\n      lut.set((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.getSubscriptionKey)(subscription), subscription);\n    });\n  }\n  function deleteOne(subscriptionKey) {\n    baseSignal.mutate((lut) => {\n      lut.delete(subscriptionKey);\n    });\n  }\n  return {\n    signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      baseSignal,\n      updates,\n      (base, updates2) => applyOptimisticUpdates_forSubscriptions(base, threads, updates2)\n    ),\n    // Mutations\n    applyDelta,\n    create,\n    delete: deleteOne\n  };\n}\nfunction createStore_forRoomSubscriptionSettings(updates) {\n  const baseSignal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(/* @__PURE__ */ new Map());\n  function update(roomId, settings) {\n    baseSignal.mutate((lut) => {\n      lut.set(roomId, settings);\n    });\n  }\n  return {\n    signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      baseSignal,\n      updates,\n      (base, updates2) => applyOptimisticUpdates_forRoomSubscriptionSettings(base, updates2)\n    ),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forHistoryVersions() {\n  const baseSignal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(\n    new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(() => /* @__PURE__ */ new Map())\n  );\n  function update(roomId, versions) {\n    baseSignal.mutate((lut) => {\n      const versionsById = lut.getOrCreate(roomId);\n      for (const version of versions) {\n        versionsById.set(version.id, version);\n      }\n    });\n  }\n  return {\n    signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      baseSignal,\n      (hv) => Object.fromEntries(\n        [...hv].map(([roomId, versions]) => [\n          roomId,\n          Object.fromEntries(versions)\n        ])\n      )\n    ),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forUrlsMetadata() {\n  const baseSignal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(/* @__PURE__ */ new Map());\n  function update(url, metadata) {\n    baseSignal.mutate((lut) => {\n      lut.set(url, metadata);\n    });\n  }\n  return {\n    signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(baseSignal, (m) => Object.fromEntries(m)),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forPermissionHints() {\n  const permissionsByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n    () => new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal(/* @__PURE__ */ new Set())\n  );\n  function update(newHints) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      for (const [roomId, permissions] of Object.entries(newHints)) {\n        const signal = permissionsByRoomId.getOrCreate(roomId);\n        const existingPermissions = new Set(signal.get());\n        for (const permission of permissions) {\n          existingPermissions.add(permission);\n        }\n        signal.set(existingPermissions);\n      }\n    });\n  }\n  function getPermissionForRoom\\u03A3(roomId) {\n    return permissionsByRoomId.getOrCreate(roomId);\n  }\n  return {\n    getPermissionForRoom\\u03A3,\n    // Mutations\n    update\n  };\n}\nfunction createStore_forNotificationSettings(updates) {\n  const signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal(\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createNotificationSettings)({})\n  );\n  function update(settings) {\n    signal.set(settings);\n  }\n  return {\n    signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      signal,\n      updates,\n      (base, updates2) => applyOptimisticUpdates_forNotificationSettings(base, updates2)\n    ),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forOptimistic(client) {\n  const signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal([]);\n  const syncSource = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].createSyncSource();\n  signal.subscribe(\n    () => syncSource.setSyncStatus(\n      signal.get().length > 0 ? \"synchronizing\" : \"synchronized\"\n    )\n  );\n  function add(optimisticUpdate) {\n    const id = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nanoid)();\n    const newUpdate = { ...optimisticUpdate, id };\n    signal.set((state) => [...state, newUpdate]);\n    return id;\n  }\n  function remove(optimisticId) {\n    signal.set((state) => state.filter((ou) => ou.id !== optimisticId));\n  }\n  return {\n    signal: signal.asReadonly(),\n    // Mutations\n    add,\n    remove\n  };\n}\nvar UmbrellaStore = class {\n  #client;\n  //\n  // Internally, the UmbrellaStore keeps track of a few source signals that can\n  // be set and mutated individually. When any of those are mutated then the\n  // clean \"external state\" is recomputed.\n  //\n  //   Mutate inputs...                                             ...observe clean/consistent output!\n  //\n  //            .-> Base ThreadDB ---------+                 +-------> Clean threads by ID         (Part 1)\n  //           /                           |                 |\n  //   mutate ----> Base Notifications --+ |                 | +-----> Clean notifications         (Part 1)\n  //          \\                          | |                 | |       & notifications by ID\n  //         | \\                         | |      Apply      | |\n  //         |   `-> OptimisticUpdates --+--+--> Optimistic -+-+-+-+-> Subscriptions               (Part 2)\n  //          \\                          |        Updates    |   | |\n  //           `------- etc etc ---------+                   |   | +-> History Versions            (Part 3)\n  //                       ^                                 |   |\n  //                       |                                 |   +---> Room Subscription Settings  (Part 4)\n  //                       |                                 |\n  //                       |                                 +-------> Notification Settings       (Part 5)\n  //                       |\n  //                       |\n  //                       |                        ^                  ^\n  //                    Signal                      |                  |\n  //                      or                   DerivedSignal      DerivedSignals\n  //                  MutableSignal\n  //\n  //\n  // Input signals.\n  // (Can be mutated directly.)\n  //\n  // XXX_vincent Now that we have createStore_forX, we should probably also change\n  // `threads` to this pattern, ie create a createStore_forThreads helper as\n  // well. It almost works like that already anyway!\n  threads;\n  // Exposes its signal under `.signal` prop\n  notifications;\n  subscriptions;\n  roomSubscriptionSettings;\n  // prettier-ignore\n  historyVersions;\n  unreadNotificationsCount;\n  urlsMetadata;\n  permissionHints;\n  notificationSettings;\n  optimisticUpdates;\n  //\n  // Output signals.\n  // (Readonly, clean, consistent. With optimistic updates applied.)\n  //\n  // Note that the output of threadifications signal is the same as the ones for\n  // threads and notifications separately, but the threadifications signal will\n  // be updated whenever either of them change.\n  //\n  outputs;\n  // Notifications\n  #notificationsLastRequestedAt = null;\n  // Keeps track of when we successfully requested an inbox notifications update for the last time. Will be `null` as long as the first successful fetch hasn't happened yet.\n  // Room Threads\n  #roomThreadsLastRequestedAtByRoom = /* @__PURE__ */ new Map();\n  // User Threads\n  #userThreadsLastRequestedAt = null;\n  // Room versions\n  #roomVersionsLastRequestedAtByRoom = /* @__PURE__ */ new Map();\n  // Notification Settings\n  #notificationSettings;\n  constructor(client) {\n    this.#client = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].as();\n    this.optimisticUpdates = createStore_forOptimistic(this.#client);\n    this.permissionHints = createStore_forPermissionHints();\n    const notificationSettingsFetcher = async () => {\n      const result = await this.#client.getNotificationSettings();\n      this.notificationSettings.update(result);\n    };\n    this.notificationSettings = createStore_forNotificationSettings(\n      this.optimisticUpdates.signal\n    );\n    this.#notificationSettings = new SinglePageResource(\n      notificationSettingsFetcher\n    );\n    this.threads = new ThreadDB();\n    this.subscriptions = createStore_forSubscriptions(\n      this.optimisticUpdates.signal,\n      this.threads\n    );\n    this.notifications = createStore_forNotifications();\n    this.roomSubscriptionSettings = createStore_forRoomSubscriptionSettings(\n      this.optimisticUpdates.signal\n    );\n    this.historyVersions = createStore_forHistoryVersions();\n    this.unreadNotificationsCount = createStore_forUnreadNotificationsCount();\n    this.urlsMetadata = createStore_forUrlsMetadata();\n    const threadifications = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      this.threads.signal,\n      this.notifications.signal,\n      this.optimisticUpdates.signal,\n      (ts, ns, updates) => applyOptimisticUpdates_forThreadifications(ts, ns, updates)\n    );\n    const threads = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(threadifications, (s) => s.threadsDB);\n    const notifications = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      threadifications,\n      (s) => ({\n        sortedNotifications: s.sortedNotifications,\n        notificationsById: s.notificationsById\n      }),\n      _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n    );\n    const threadSubscriptions = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      notifications,\n      this.subscriptions.signal,\n      (n, s) => ({\n        subscriptions: s,\n        notifications: n.sortedNotifications\n      })\n    );\n    const loadingUserThreads = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (queryKey) => {\n        const query = JSON.parse(queryKey);\n        const resource = new PaginatedResource(async (cursor) => {\n          const result = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getUserThreads_experimental({\n            cursor,\n            query\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications,\n            result.subscriptions\n          );\n          this.permissionHints.update(result.permissionHints);\n          if (this.#userThreadsLastRequestedAt === null) {\n            this.#userThreadsLastRequestedAt = result.requestedAt;\n          }\n          return result.nextCursor;\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n          const subscriptions = threadSubscriptions.get().subscriptions;\n          const threads2 = this.outputs.threads.get().findMany(\n            void 0,\n            // Do _not_ filter by roomId\n            query ?? {},\n            \"desc\",\n            subscriptions\n          );\n          const page = result.data;\n          return {\n            isLoading: false,\n            threads: threads2,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore\n          };\n        }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow2);\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n    const loadingRoomThreads = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (queryKey) => {\n        const [roomId, query] = JSON.parse(queryKey);\n        const resource = new PaginatedResource(async (cursor) => {\n          const result = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getThreads({\n            roomId,\n            cursor,\n            query\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications,\n            result.subscriptions\n          );\n          this.permissionHints.update(result.permissionHints);\n          const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);\n          if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {\n            this.#roomThreadsLastRequestedAtByRoom.set(\n              roomId,\n              result.requestedAt\n            );\n          }\n          return result.nextCursor;\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n          const subscriptions = threadSubscriptions.get().subscriptions;\n          const threads2 = this.outputs.threads.get().findMany(roomId, query ?? {}, \"asc\", subscriptions);\n          const page = result.data;\n          return {\n            isLoading: false,\n            threads: threads2,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore\n          };\n        }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow2);\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n    const loadingNotifications = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (queryKey) => {\n        const query = JSON.parse(queryKey);\n        const resource = new PaginatedResource(async (cursor) => {\n          const result = await this.#client.getInboxNotifications({\n            cursor,\n            query\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications,\n            result.subscriptions\n          );\n          if (this.#notificationsLastRequestedAt === null) {\n            this.#notificationsLastRequestedAt = result.requestedAt;\n          }\n          const nextCursor = result.nextCursor;\n          return nextCursor;\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n          const crit = [];\n          if (query !== void 0) {\n            crit.push(makeInboxNotificationsFilter(query));\n          }\n          const inboxNotifications = this.outputs.notifications.get().sortedNotifications.filter(\n            (inboxNotification) => crit.every((pred) => pred(inboxNotification))\n          );\n          const page = result.data;\n          return {\n            isLoading: false,\n            inboxNotifications,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore\n          };\n        }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow2);\n        return {\n          signal,\n          waitUntilLoaded: resource.waitUntilLoaded\n        };\n      }\n    );\n    const unreadNotificationsCount = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (queryKey) => {\n        const query = JSON.parse(queryKey);\n        const resource = new SinglePageResource(async () => {\n          const result = await this.#client.getUnreadInboxNotificationsCount({\n            query\n          });\n          this.unreadNotificationsCount.update(queryKey, result);\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n          () => {\n            const result = resource.get();\n            if (result.isLoading || result.error) {\n              return result;\n            } else {\n              return ASYNC_OK(\n                \"count\",\n                (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(this.unreadNotificationsCount.signal.get()[queryKey])\n              );\n            }\n          },\n          _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n        );\n        return {\n          signal,\n          waitUntilLoaded: resource.waitUntilLoaded\n        };\n      }\n    );\n    const roomSubscriptionSettingsByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (roomId) => {\n        const resource = new SinglePageResource(async () => {\n          const room = this.#client.getRoom(roomId);\n          if (room === null) {\n            throw new Error(`Room '${roomId}' is not available on client`);\n          }\n          const result = await room.getSubscriptionSettings();\n          this.roomSubscriptionSettings.update(roomId, result);\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          } else {\n            return ASYNC_OK(\n              \"settings\",\n              (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(this.roomSubscriptionSettings.signal.get()[roomId])\n            );\n          }\n        }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n    const versionsByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (roomId) => {\n        const resource = new SinglePageResource(async () => {\n          const room = this.#client.getRoom(roomId);\n          if (room === null) {\n            throw new Error(`Room '${roomId}' is not available on client`);\n          }\n          const result = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].listTextVersions();\n          this.historyVersions.update(roomId, result.versions);\n          const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);\n          if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {\n            this.#roomVersionsLastRequestedAtByRoom.set(\n              roomId,\n              result.requestedAt\n            );\n          }\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          } else {\n            return ASYNC_OK(\n              \"versions\",\n              Object.values(this.historyVersions.signal.get()[roomId] ?? {})\n            );\n          }\n        }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n    const notificationSettings = {\n      signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n        const result = this.#notificationSettings.get();\n        if (result.isLoading || result.error) {\n          return result;\n        }\n        return ASYNC_OK(\n          \"settings\",\n          (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(this.notificationSettings.signal.get())\n        );\n      }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow),\n      waitUntilLoaded: this.#notificationSettings.waitUntilLoaded\n    };\n    const aiChats = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (queryKey) => {\n        const query = JSON.parse(queryKey);\n        const resource = new PaginatedResource(async (cursor) => {\n          const result = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.getChats({\n            cursor,\n            query\n          });\n          return result.nextCursor;\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n          const chats = this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.queryChats(query);\n          return {\n            isLoading: false,\n            chats,\n            hasFetchedAll: result.data.hasFetchedAll,\n            isFetchingMore: result.data.isFetchingMore,\n            fetchMore: result.data.fetchMore,\n            fetchMoreError: result.data.fetchMoreError\n          };\n        }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n    const messagesByChatId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap((chatId) => {\n      const resource\\u03A3 = new SinglePageResource(async () => {\n        await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.getMessageTree(chatId);\n      });\n      return new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n        (branch) => {\n          const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n            const result = resource\\u03A3.get();\n            if (result.isLoading || result.error) {\n              return result;\n            }\n            return ASYNC_OK(\n              \"messages\",\n              this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.signals.getChatMessagesForBranch\\u03A3(chatId, branch ?? void 0).get()\n            );\n          });\n          return { signal, waitUntilLoaded: resource\\u03A3.waitUntilLoaded };\n        }\n      );\n    });\n    const aiChatById = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap((chatId) => {\n      const resource = new SinglePageResource(async () => {\n        await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.getOrCreateChat(chatId);\n      });\n      const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n        const chat = this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.getChatById(chatId);\n        if (chat === void 0) {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          } else {\n            return ASYNC_OK(\n              \"chat\",\n              (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.getChatById(chatId))\n            );\n          }\n        } else {\n          return ASYNC_OK(\n            \"chat\",\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.getChatById(chatId))\n          );\n        }\n      }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n      return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n    });\n    const urlMetadataByUrl = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (url) => {\n        const resource = new SinglePageResource(async () => {\n          const metadata = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getUrlMetadata(url);\n          this.urlsMetadata.update(url, metadata);\n        }, false);\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n          return ASYNC_OK(\"metadata\", (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(this.urlsMetadata.signal.get()[url]));\n        }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n    this.outputs = {\n      threadifications,\n      threads,\n      loadingRoomThreads,\n      loadingUserThreads,\n      notifications,\n      loadingNotifications,\n      unreadNotificationsCount,\n      roomSubscriptionSettingsByRoomId,\n      versionsByRoomId,\n      notificationSettings,\n      threadSubscriptions,\n      aiChats,\n      messagesByChatId,\n      aiChatById,\n      urlMetadataByUrl\n    };\n    autobind(this);\n  }\n  /**\n   * Updates an existing inbox notification with a new value, replacing the\n   * corresponding optimistic update.\n   *\n   * This will not update anything if the inbox notification ID isn't found.\n   */\n  markInboxNotificationRead(inboxNotificationId, readAt, optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.markRead(inboxNotificationId, readAt);\n    });\n  }\n  markAllInboxNotificationsRead(optimisticId, readAt) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.markAllRead(readAt);\n    });\n  }\n  /**\n   * Deletes an existing inbox notification, replacing the corresponding\n   * optimistic update.\n   */\n  deleteInboxNotification(inboxNotificationId, optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.delete(inboxNotificationId);\n    });\n  }\n  /**\n   * Deletes *all* inbox notifications, replacing the corresponding optimistic\n   * update.\n   */\n  deleteAllInboxNotifications(optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.clear();\n    });\n  }\n  /**\n   * Creates an existing subscription, replacing the corresponding\n   * optimistic update.\n   */\n  createSubscription(subscription, optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.subscriptions.create(subscription);\n    });\n  }\n  /**\n   * Deletes an existing subscription, replacing the corresponding\n   * optimistic update.\n   */\n  deleteSubscription(subscriptionKey, optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.subscriptions.delete(subscriptionKey);\n    });\n  }\n  /**\n   * Creates an new thread, replacing the corresponding optimistic update.\n   */\n  createThread(optimisticId, thread) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.threads.upsert(thread);\n    });\n  }\n  /**\n   * Updates an existing thread with a new value, replacing the corresponding\n   * optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found; or\n   * - The thread ID was already deleted; or\n   * - The thread ID was updated more recently than the optimistic update's\n   *   timestamp (if given)\n   */\n  #updateThread(threadId, optimisticId, callback, updatedAt) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      if (optimisticId !== null) {\n        this.optimisticUpdates.remove(optimisticId);\n      }\n      const db = this.threads;\n      const existing = db.get(threadId);\n      if (!existing) return;\n      if (!!updatedAt && existing.updatedAt > updatedAt) return;\n      db.upsert(callback(existing));\n    });\n  }\n  patchThread(threadId, optimisticId, patch, updatedAt) {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => ({ ...thread, ...(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.compactObject)(patch) }),\n      updatedAt\n    );\n  }\n  addReaction(threadId, optimisticId, commentId, reaction, createdAt) {\n    this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyAddReaction(thread, commentId, reaction),\n      createdAt\n    );\n  }\n  removeReaction(threadId, optimisticId, commentId, emoji, userId, removedAt) {\n    this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyRemoveReaction(thread, commentId, emoji, userId, removedAt),\n      removedAt\n    );\n  }\n  /**\n   * Soft-deletes an existing thread by setting its `deletedAt` value,\n   * replacing the corresponding optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found; or\n   * - The thread ID was already deleted\n   */\n  deleteThread(threadId, optimisticId) {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      // A deletion is actually an update of the deletedAt property internally\n      (thread) => ({ ...thread, updatedAt: /* @__PURE__ */ new Date(), deletedAt: /* @__PURE__ */ new Date() })\n    );\n  }\n  /**\n   * Creates an existing comment and ensures the associated notification is\n   * updated correctly, replacing the corresponding optimistic update.\n   */\n  createComment(newComment, optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      const existingThread = this.threads.get(newComment.threadId);\n      if (!existingThread) {\n        return;\n      }\n      this.threads.upsert(applyUpsertComment(existingThread, newComment));\n      this.notifications.updateAssociatedNotification(newComment);\n    });\n  }\n  editComment(threadId, optimisticId, editedComment) {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyUpsertComment(thread, editedComment)\n    );\n  }\n  deleteComment(threadId, optimisticId, commentId, deletedAt) {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyDeleteComment(thread, commentId, deletedAt),\n      deletedAt\n    );\n  }\n  updateThreadifications(threads, notifications, subscriptions, deletedThreads = [], deletedNotifications = [], deletedSubscriptions = []) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.threads.applyDelta(threads, deletedThreads);\n      this.notifications.applyDelta(notifications, deletedNotifications);\n      this.subscriptions.applyDelta(subscriptions, deletedSubscriptions);\n    });\n  }\n  /**\n   * Updates existing subscription settings for a room with a new value,\n   * replacing the corresponding optimistic update.\n   */\n  updateRoomSubscriptionSettings(roomId, optimisticId, settings) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.roomSubscriptionSettings.update(roomId, settings);\n    });\n  }\n  async fetchNotificationsDeltaUpdate(signal) {\n    const lastRequestedAt = this.#notificationsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n    const result = await this.#client.getInboxNotificationsSince({\n      since: lastRequestedAt,\n      signal\n    });\n    if (lastRequestedAt < result.requestedAt) {\n      this.#notificationsLastRequestedAt = result.requestedAt;\n    }\n    this.updateThreadifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.subscriptions.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted,\n      result.subscriptions.deleted\n    );\n  }\n  async fetchUnreadNotificationsCount(queryKey, signal) {\n    const query = JSON.parse(queryKey);\n    const result = await this.#client.getUnreadInboxNotificationsCount({\n      query,\n      signal\n    });\n    this.unreadNotificationsCount.update(queryKey, result);\n  }\n  async fetchRoomThreadsDeltaUpdate(roomId, signal) {\n    const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === void 0) {\n      return;\n    }\n    const updates = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getThreadsSince({\n      roomId,\n      since: lastRequestedAt,\n      signal\n    });\n    this.updateThreadifications(\n      updates.threads.updated,\n      updates.inboxNotifications.updated,\n      updates.subscriptions.updated,\n      updates.threads.deleted,\n      updates.inboxNotifications.deleted,\n      updates.subscriptions.deleted\n    );\n    this.permissionHints.update(updates.permissionHints);\n    if (lastRequestedAt < updates.requestedAt) {\n      this.#roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n  async fetchUserThreadsDeltaUpdate(signal) {\n    const lastRequestedAt = this.#userThreadsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n    const result = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getUserThreadsSince_experimental({\n      since: lastRequestedAt,\n      signal\n    });\n    if (lastRequestedAt < result.requestedAt) {\n      this.#notificationsLastRequestedAt = result.requestedAt;\n    }\n    this.updateThreadifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.subscriptions.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted,\n      result.subscriptions.deleted\n    );\n    this.permissionHints.update(result.permissionHints);\n  }\n  async fetchRoomVersionsDeltaUpdate(roomId, signal) {\n    const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === void 0) {\n      return;\n    }\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n      this.#client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const updates = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].listTextVersionsSince({\n      since: lastRequestedAt,\n      signal\n    });\n    this.historyVersions.update(roomId, updates.versions);\n    if (lastRequestedAt < updates.requestedAt) {\n      this.#roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n  async refreshRoomSubscriptionSettings(roomId, signal) {\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n      this.#client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const result = await room.getSubscriptionSettings({ signal });\n    this.roomSubscriptionSettings.update(roomId, result);\n  }\n  /**\n   * Refresh notification settings from poller\n   */\n  async refreshNotificationSettings(signal) {\n    const result = await this.#client.getNotificationSettings({\n      signal\n    });\n    this.notificationSettings.update(result);\n  }\n  /**\n   * Updates notification settings with a new value, replacing the\n   * corresponding optimistic update.\n   */\n  updateNotificationSettings_confirmOptimisticUpdate(settings, optimisticUpdateId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticUpdateId);\n      this.notificationSettings.update(settings);\n    });\n  }\n};\nfunction applyOptimisticUpdates_forThreadifications(baseThreadsDB, notificationsLUT, optimisticUpdates) {\n  const threadsDB = baseThreadsDB.clone();\n  let notificationsById = Object.fromEntries(notificationsLUT);\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        threadsDB.upsert(optimisticUpdate.thread);\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        if (thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        threadsDB.upsert({\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        });\n        break;\n      }\n      case \"mark-thread-as-resolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({ ...thread, resolved: true });\n        break;\n      }\n      case \"mark-thread-as-unresolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({ ...thread, resolved: false });\n        break;\n      }\n      case \"create-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        const inboxNotification = Object.values(notificationsById).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        notificationsById[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyDeleteComment(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.deletedAt\n          )\n        );\n        break;\n      }\n      case \"delete-thread\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({\n          ...thread,\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: []\n        });\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyAddReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.reaction\n          )\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyRemoveReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.emoji,\n            optimisticUpdate.userId,\n            optimisticUpdate.removedAt\n          )\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        const ibn = notificationsById[optimisticUpdate.inboxNotificationId];\n        if (ibn === void 0) {\n          break;\n        }\n        notificationsById[optimisticUpdate.inboxNotificationId] = {\n          ...ibn,\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-all-inbox-notifications-as-read\": {\n        for (const id in notificationsById) {\n          const ibn = notificationsById[id];\n          if (ibn === void 0) {\n            break;\n          }\n          notificationsById[id] = {\n            ...ibn,\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"delete-inbox-notification\": {\n        delete notificationsById[optimisticUpdate.inboxNotificationId];\n        break;\n      }\n      case \"delete-all-inbox-notifications\": {\n        notificationsById = {};\n        break;\n      }\n    }\n  }\n  const sortedNotifications = (\n    // Sort so that the most recent notifications are first\n    Object.values(notificationsById).filter(\n      (ibn) => ibn.kind === \"thread\" ? threadsDB.get(ibn.threadId) !== void 0 : true\n    ).sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime())\n  );\n  return {\n    sortedNotifications,\n    notificationsById,\n    threadsDB\n  };\n}\nfunction applyOptimisticUpdates_forRoomSubscriptionSettings(settingsLUT, optimisticUpdates) {\n  const roomSubscriptionSettingsByRoomId = Object.fromEntries(settingsLUT);\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"update-room-subscription-settings\": {\n        const settings = roomSubscriptionSettingsByRoomId[optimisticUpdate.roomId];\n        if (settings === void 0) {\n          break;\n        }\n        roomSubscriptionSettingsByRoomId[optimisticUpdate.roomId] = {\n          ...settings,\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  return roomSubscriptionSettingsByRoomId;\n}\nfunction applyOptimisticUpdates_forSubscriptions(subscriptionsLUT, threads, optimisticUpdates) {\n  const subscriptions = Object.fromEntries(subscriptionsLUT);\n  for (const update of optimisticUpdates) {\n    switch (update.type) {\n      case \"update-room-subscription-settings\": {\n        if (!update.settings.threads) {\n          continue;\n        }\n        const roomThreads = threads.findMany(\n          update.roomId,\n          void 0,\n          \"desc\",\n          void 0\n        );\n        for (const thread of roomThreads) {\n          const subscriptionKey = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.getSubscriptionKey)(\"thread\", thread.id);\n          switch (update.settings.threads) {\n            // Create subscriptions for all existing threads in the room\n            case \"all\": {\n              subscriptions[subscriptionKey] = {\n                kind: \"thread\",\n                subjectId: thread.id,\n                createdAt: /* @__PURE__ */ new Date()\n              };\n              break;\n            }\n            // Delete subscriptions for all existing threads in the room\n            case \"none\": {\n              delete subscriptions[subscriptionKey];\n              break;\n            }\n            case \"replies_and_mentions\": {\n              break;\n            }\n            default:\n              (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assertNever)(\n                update.settings.threads,\n                \"Unexpected thread subscription settings.\"\n              );\n          }\n        }\n      }\n    }\n  }\n  return subscriptions;\n}\nfunction applyOptimisticUpdates_forNotificationSettings(settings, optimisticUpdates) {\n  let outcoming = settings;\n  for (const update of optimisticUpdates) {\n    if (update.type === \"update-notification-settings\") {\n      outcoming = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.patchNotificationSettings)(outcoming, update.settings);\n    }\n  }\n  return outcoming;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction applyUpsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt.getTime(),\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction applyDeleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      // We optimistically remove the comment body and attachments when marking it as deleted\n      body: void 0,\n      attachments: []\n    } : comment\n  );\n  if (updatedComments.every((comment) => comment.deletedAt !== void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction applyAddReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments\n  };\n}\nfunction applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/liveblocks.tsx\n\nfunction missingUserError(userId) {\n  return new Error(`resolveUsers didn't return anything for user '${userId}'`);\n}\nfunction missingRoomInfoError(roomId) {\n  return new Error(\n    `resolveRoomsInfo didn't return anything for room '${roomId}'`\n  );\n}\nfunction missingGroupInfoError(groupId) {\n  return new Error(\n    `resolveGroupsInfo didn't return anything for group '${groupId}'`\n  );\n}\nfunction identity2(x) {\n  return x;\n}\nvar _umbrellaStores = /* @__PURE__ */ new WeakMap();\nvar _extras = /* @__PURE__ */ new WeakMap();\nvar _bundles = /* @__PURE__ */ new WeakMap();\nfunction selectorFor_useUnreadInboxNotificationsCount(result) {\n  if (!(\"count\" in result) || result.count === void 0) {\n    return result;\n  }\n  return ASYNC_OK(\"count\", result.count);\n}\nfunction selectorFor_useUser(state, userId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingUserError(userId)\n    };\n  }\n  return {\n    isLoading: false,\n    user: state.data\n  };\n}\nfunction selectorFor_useRoomInfo(state, roomId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingRoomInfoError(roomId)\n    };\n  }\n  return {\n    isLoading: false,\n    info: state.data\n  };\n}\nfunction selectorFor_useGroupInfo(state, groupId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingGroupInfoError(groupId)\n    };\n  }\n  return {\n    isLoading: false,\n    info: state.data\n  };\n}\nfunction getOrCreateContextBundle(client) {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeLiveblocksContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getUmbrellaStoreForClient(client) {\n  let store = _umbrellaStores.get(client);\n  if (!store) {\n    store = new UmbrellaStore(client);\n    _umbrellaStores.set(client, store);\n  }\n  return store;\n}\nfunction getLiveblocksExtrasForClient(client) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeLiveblocksExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n  return extras;\n}\nfunction useEnsureAiConnection(client) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.connectInitially();\n  }, [client]);\n}\nfunction makeLiveblocksExtrasForClient(client) {\n  const store = getUmbrellaStoreForClient(client);\n  const notificationsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.fetchNotificationsDeltaUpdate(signal);\n      } catch (err) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(`Polling new inbox notifications failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.NOTIFICATIONS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }\n  );\n  const unreadNotificationsCountPollersByQueryKey = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n    (queryKey) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n      async (signal) => {\n        try {\n          return await store.fetchUnreadNotificationsCount(queryKey, signal);\n        } catch (err) {\n          _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n            `Polling unread inbox notifications countfailed: ${String(err)}`\n          );\n          throw err;\n        }\n      },\n      config.NOTIFICATIONS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }\n    )\n  );\n  const userThreadsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.fetchUserThreadsDeltaUpdate(signal);\n      } catch (err) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(`Polling new user threads failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.USER_THREADS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME }\n  );\n  const notificationSettingsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.refreshNotificationSettings(signal);\n      } catch (err) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n          `Polling new notification settings failed: ${String(err)}`\n        );\n        throw err;\n      }\n    },\n    config.USER_NOTIFICATION_SETTINGS_INTERVAL,\n    { maxStaleTimeMs: config.USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME }\n  );\n  return {\n    store,\n    notificationsPoller,\n    userThreadsPoller,\n    notificationSettingsPoller,\n    unreadNotificationsCountPollersByQueryKey\n  };\n}\nfunction makeLiveblocksContextBundle(client) {\n  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);\n  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);\n  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);\n  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);\n  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);\n  const useUpdateNotificationSettings2 = () => useUpdateNotificationSettings_withClient(client);\n  function LiveblocksProvider2(props) {\n    useEnsureNoLiveblocksProvider();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ClientContext.Provider, { value: client, children: props.children });\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    LiveblocksProvider: LiveblocksProvider2,\n    useInboxNotifications: (options) => useInboxNotifications_withClient(client, identity2, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow, options),\n    useUnreadInboxNotificationsCount: (options) => useUnreadInboxNotificationsCount_withClient(client, options),\n    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n    useDeleteInboxNotification: useDeleteInboxNotification2,\n    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n    useNotificationSettings: () => useNotificationSettings_withClient(client),\n    useUpdateNotificationSettings: useUpdateNotificationSettings2,\n    useInboxNotificationThread: useInboxNotificationThread2,\n    useUserThreads_experimental,\n    useAiChats,\n    useAiChat,\n    useAiChatMessages,\n    useAiChatStatus,\n    useCreateAiChat,\n    useDeleteAiChat,\n    useSendAiMessage,\n    useUrlMetadata,\n    ...shared.classic,\n    suspense: {\n      LiveblocksProvider: LiveblocksProvider2,\n      useInboxNotifications: (options) => useInboxNotificationsSuspense_withClient(client, options),\n      useUnreadInboxNotificationsCount: (options) => useUnreadInboxNotificationsCountSuspense_withClient(client, options),\n      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n      useDeleteInboxNotification: useDeleteInboxNotification2,\n      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n      useInboxNotificationThread: useInboxNotificationThread2,\n      useNotificationSettings: () => useNotificationSettingsSuspense_withClient(client),\n      useUpdateNotificationSettings: useUpdateNotificationSettings2,\n      useUserThreads_experimental: useUserThreadsSuspense_experimental,\n      useAiChats: useAiChatsSuspense,\n      useAiChat: useAiChatSuspense,\n      useAiChatMessages: useAiChatMessagesSuspense,\n      useAiChatStatus,\n      useCreateAiChat,\n      useDeleteAiChat,\n      useSendAiMessage,\n      useUrlMetadata: useUrlMetadataSuspense,\n      ...shared.suspense\n    }\n  };\n  return bundle;\n}\nfunction useInboxNotifications_withClient(client, selector, isEqual, options) {\n  const { store, notificationsPoller: poller } = getLiveblocksExtrasForClient(client);\n  const queryKey = makeInboxNotificationsQueryKey(options?.query);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  return useSignal(\n    store.outputs.loadingNotifications.getOrCreate(queryKey).signal,\n    selector,\n    isEqual\n  );\n}\nfunction useInboxNotificationsSuspense_withClient(client, options) {\n  ensureNotServerSide();\n  const store = getLiveblocksExtrasForClient(client).store;\n  const queryKey = makeInboxNotificationsQueryKey(options?.query);\n  use(\n    store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded()\n  );\n  const result = useInboxNotifications_withClient(\n    client,\n    identity2,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow,\n    options\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUnreadInboxNotificationsCount_withClient(client, options) {\n  const { store, unreadNotificationsCountPollersByQueryKey: pollers } = getLiveblocksExtrasForClient(client);\n  const queryKey = makeInboxNotificationsQueryKey(options?.query);\n  const poller = pollers.getOrCreate(queryKey);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.unreadNotificationsCount.getOrCreate(queryKey).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  return useSignal(\n    store.outputs.unreadNotificationsCount.getOrCreate(queryKey).signal,\n    selectorFor_useUnreadInboxNotificationsCount,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n}\nfunction useUnreadInboxNotificationsCountSuspense_withClient(client, options) {\n  ensureNotServerSide();\n  const store = getLiveblocksExtrasForClient(client).store;\n  const queryKey = makeInboxNotificationsQueryKey(options?.query);\n  use(\n    store.outputs.unreadNotificationsCount.getOrCreate(queryKey).waitUntilLoaded()\n  );\n  const result = useUnreadInboxNotificationsCount_withClient(client, options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  return result;\n}\nfunction useMarkInboxNotificationAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store, unreadNotificationsCountPollersByQueryKey } = getLiveblocksExtrasForClient(client);\n      const readAt = /* @__PURE__ */ new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId,\n        readAt\n      });\n      client.markInboxNotificationAsRead(inboxNotificationId).then(\n        () => {\n          store.markInboxNotificationRead(\n            inboxNotificationId,\n            readAt,\n            optimisticId\n          );\n          for (const poller of unreadNotificationsCountPollersByQueryKey.values()) {\n            poller.markAsStale();\n            poller.pollNowIfStale();\n          }\n        },\n        (err) => {\n          store.optimisticUpdates.remove(optimisticId);\n          client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n            {\n              type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\",\n              inboxNotificationId\n            },\n            err\n          );\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store, unreadNotificationsCountPollersByQueryKey } = getLiveblocksExtrasForClient(client);\n    const readAt = /* @__PURE__ */ new Date();\n    const optimisticId = store.optimisticUpdates.add({\n      type: \"mark-all-inbox-notifications-as-read\",\n      readAt\n    });\n    client.markAllInboxNotificationsAsRead().then(\n      () => {\n        store.markAllInboxNotificationsRead(optimisticId, readAt);\n        for (const poller of unreadNotificationsCountPollersByQueryKey.values()) {\n          poller.markAsStale();\n          poller.pollNowIfStale();\n        }\n      },\n      (err) => {\n        store.optimisticUpdates.remove(optimisticId);\n        client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n          // No roomId, threadId, commentId to include for this error\n          { type: \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\" },\n          err\n        );\n      }\n    );\n  }, [client]);\n}\nfunction useDeleteInboxNotification_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store, unreadNotificationsCountPollersByQueryKey } = getLiveblocksExtrasForClient(client);\n      const deletedAt = /* @__PURE__ */ new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-inbox-notification\",\n        inboxNotificationId,\n        deletedAt\n      });\n      client.deleteInboxNotification(inboxNotificationId).then(\n        () => {\n          store.deleteInboxNotification(inboxNotificationId, optimisticId);\n          for (const poller of unreadNotificationsCountPollersByQueryKey.values()) {\n            poller.markAsStale();\n            poller.pollNowIfStale();\n          }\n        },\n        (err) => {\n          store.optimisticUpdates.remove(optimisticId);\n          client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n            { type: \"DELETE_INBOX_NOTIFICATION_ERROR\", inboxNotificationId },\n            err\n          );\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useDeleteAllInboxNotifications_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store, unreadNotificationsCountPollersByQueryKey } = getLiveblocksExtrasForClient(client);\n    const deletedAt = /* @__PURE__ */ new Date();\n    const optimisticId = store.optimisticUpdates.add({\n      type: \"delete-all-inbox-notifications\",\n      deletedAt\n    });\n    client.deleteAllInboxNotifications().then(\n      () => {\n        store.deleteAllInboxNotifications(optimisticId);\n        for (const poller of unreadNotificationsCountPollersByQueryKey.values()) {\n          poller.markAsStale();\n          poller.pollNowIfStale();\n        }\n      },\n      (err) => {\n        store.optimisticUpdates.remove(optimisticId);\n        client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n          { type: \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\" },\n          err\n        );\n      }\n    );\n  }, [client]);\n}\nfunction useInboxNotificationThread_withClient(client, inboxNotificationId) {\n  const { store } = getLiveblocksExtrasForClient(client);\n  return useSignal(\n    store.outputs.threadifications,\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (state) => {\n        const inboxNotification = state.notificationsById[inboxNotificationId] ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\n          `Inbox notification with ID \"${inboxNotificationId}\" not found`\n        );\n        if (inboxNotification.kind !== \"thread\") {\n          (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\n            `Inbox notification with ID \"${inboxNotificationId}\" is not of kind \"thread\"`\n          );\n        }\n        const thread = state.threadsDB.get(inboxNotification.threadId) ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\n          `Thread with ID \"${inboxNotification.threadId}\" not found, this inbox notification might not be of kind \"thread\"`\n        );\n        return thread;\n      },\n      [inboxNotificationId]\n    )\n  );\n}\nfunction useUpdateNotificationSettings_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (settings) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const optimisticUpdateId = store.optimisticUpdates.add({\n        type: \"update-notification-settings\",\n        settings\n      });\n      client.updateNotificationSettings(settings).then(\n        (settings2) => {\n          store.updateNotificationSettings_confirmOptimisticUpdate(\n            settings2,\n            optimisticUpdateId\n          );\n        },\n        (err) => {\n          store.optimisticUpdates.remove(optimisticUpdateId);\n          if (err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.HttpError) {\n            if (err.status === 422) {\n              const msg = [err.details?.error, err.details?.reason].filter(Boolean).join(\"\\n\");\n              _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(msg);\n            }\n            client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n              {\n                type: \"UPDATE_NOTIFICATION_SETTINGS_ERROR\"\n              },\n              err\n            );\n          } else {\n            throw err;\n          }\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useNotificationSettings_withClient(client) {\n  const updateNotificationSettings = useUpdateNotificationSettings_withClient(client);\n  const { store, notificationSettingsPoller: poller } = getLiveblocksExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void store.outputs.notificationSettings.waitUntilLoaded();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  const result = useSignal(store.outputs.notificationSettings.signal);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [result, updateNotificationSettings];\n  }, [result, updateNotificationSettings]);\n}\nfunction useNotificationSettingsSuspense_withClient(client) {\n  ensureNotServerSide();\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.outputs.notificationSettings.waitUntilLoaded());\n  const [result, updateNotificationSettings] = useNotificationSettings_withClient(client);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [result, updateNotificationSettings];\n  }, [result, updateNotificationSettings]);\n}\nfunction useUser_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getItemState(userId),\n    [usersStore, userId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useUser(state, userId),\n    [userId]\n  );\n  const result = useSyncExternalStoreWithSelector(\n    usersStore.subscribe,\n    getUserState,\n    getUserState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void usersStore.enqueue(userId)\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call usersStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the userId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the userId gets invalidated, the user would be fetched again.\n  );\n  return result;\n}\nfunction useUserSuspense_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getItemState(userId),\n    [usersStore, userId]\n  );\n  const userState = getUserState();\n  if (!userState || userState.isLoading) {\n    throw usersStore.enqueue(userId);\n  }\n  if (userState.error) {\n    throw userState.error;\n  }\n  if (!userState.data) {\n    throw missingUserError(userId);\n  }\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    usersStore.subscribe,\n    getUserState,\n    getUserState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    user: state.data,\n    error: void 0\n  };\n}\nfunction useRoomInfo_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getItemState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useRoomInfo(state, roomId),\n    [roomId]\n  );\n  const result = useSyncExternalStoreWithSelector(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void roomsInfoStore.enqueue(roomId)\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call roomsInfoStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the roomId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the roomId gets invalidated, the room info would be fetched again.\n  );\n  return result;\n}\nfunction useRoomInfoSuspense_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getItemState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const roomInfoState = getRoomInfoState();\n  if (!roomInfoState || roomInfoState.isLoading) {\n    throw roomsInfoStore.enqueue(roomId);\n  }\n  if (roomInfoState.error) {\n    throw roomInfoState.error;\n  }\n  if (!roomInfoState.data) {\n    throw missingRoomInfoError(roomId);\n  }\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state.data !== void 0, \"Unexpected missing room info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: void 0\n  };\n}\nfunction useGroupInfo_withClient(client, groupId) {\n  const groupsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].groupsInfoStore;\n  const getGroupInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => groupsInfoStore.getItemState(groupId),\n    [groupsInfoStore, groupId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useGroupInfo(state, groupId),\n    [groupId]\n  );\n  const result = useSyncExternalStoreWithSelector(\n    groupsInfoStore.subscribe,\n    getGroupInfoState,\n    getGroupInfoState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void groupsInfoStore.enqueue(groupId)\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call groupsInfoStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the groupId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the groupId gets invalidated, the group info would be fetched again.\n  );\n  return result;\n}\nfunction useGroupInfoSuspense_withClient(client, groupId) {\n  const groupsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].groupsInfoStore;\n  const getGroupInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => groupsInfoStore.getItemState(groupId),\n    [groupsInfoStore, groupId]\n  );\n  const groupInfoState = getGroupInfoState();\n  if (!groupInfoState || groupInfoState.isLoading) {\n    throw groupsInfoStore.enqueue(groupId);\n  }\n  if (groupInfoState.error) {\n    throw groupInfoState.error;\n  }\n  if (!groupInfoState.data) {\n    throw missingGroupInfoError(groupId);\n  }\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    groupsInfoStore.subscribe,\n    getGroupInfoState,\n    getGroupInfoState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state.data !== void 0, \"Unexpected missing group info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: void 0\n  };\n}\nfunction useAiChats(options) {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n  const queryKey = makeAiChatsQueryKey(options?.query);\n  useEnsureAiConnection(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.aiChats.getOrCreate(queryKey).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  return useSignal(\n    store.outputs.aiChats.getOrCreate(queryKey).signal,\n    identity2,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n}\nfunction useAiChatsSuspense(options) {\n  ensureNotServerSide();\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n  useEnsureAiConnection(client);\n  const queryKey = makeAiChatsQueryKey(options?.query);\n  use(store.outputs.aiChats.getOrCreate(queryKey).waitUntilLoaded());\n  const result = useAiChats(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useAiChatMessages(chatId, options) {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n  useEnsureAiConnection(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(options?.branchId ?? null).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  return useSignal(\n    store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(options?.branchId ?? null).signal\n  );\n}\nfunction useAiChatMessagesSuspense(chatId, options) {\n  ensureNotServerSide();\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n  useEnsureAiConnection(client);\n  use(\n    store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(options?.branchId ?? null).waitUntilLoaded()\n  );\n  const result = useAiChatMessages(chatId, options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useAiChat(chatId) {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n  useEnsureAiConnection(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.aiChatById.getOrCreate(chatId).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  return useSignal(store.outputs.aiChatById.getOrCreate(chatId).signal);\n}\nfunction useAiChatSuspense(chatId) {\n  ensureNotServerSide();\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n  useEnsureAiConnection(client);\n  use(store.outputs.aiChatById.getOrCreate(chatId).waitUntilLoaded());\n  const result = useAiChat(chatId);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUrlMetadata(url) {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.urlMetadataByUrl.getOrCreate(url).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  return useSignal(store.outputs.urlMetadataByUrl.getOrCreate(url).signal);\n}\nfunction useUrlMetadataSuspense(url) {\n  ensureNotServerSide();\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n  use(store.outputs.urlMetadataByUrl.getOrCreate(url).waitUntilLoaded());\n  const result = useUrlMetadata(url);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useCreateAiChat() {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (options) => {\n      if (typeof options === \"string\") {\n        options = { id: options };\n      }\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.getOrCreateChat(options.id, {\n        title: options.title,\n        metadata: options.metadata\n      }).catch((err) => {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(\n          `Failed to create chat with ID \"${options.id}\": ${String(err)}`\n        );\n      });\n    },\n    [client]\n  );\n}\nfunction useDeleteAiChat() {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (chatId) => {\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.deleteChat(chatId).catch((err) => {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(\n          `Failed to delete chat with ID \"${chatId}\": ${String(err)}`\n        );\n      });\n    },\n    [client]\n  );\n}\nvar DISCONNECTED = Object.freeze({ status: \"disconnected\" });\nvar LOADING = Object.freeze({ status: \"loading\" });\nvar IDLE = Object.freeze({ status: \"idle\" });\nfunction useAiChatStatus(chatId, branchId) {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n  useEnsureAiConnection(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(branchId ?? null).waitUntilLoaded()\n  );\n  const isAvailable = useSignal(\n    // Subscribe to connection status signal\n    client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.signals.status\\u03A3,\n    // \"Disconnected\" means the AI service is not available\n    // as it represents a final error status.\n    (status) => status !== \"disconnected\"\n  );\n  const chatStatus = useSignal(\n    // Signal\n    store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(branchId ?? null).signal,\n    // Selector\n    (result) => {\n      if (result.isLoading) return LOADING;\n      if (result.error) return IDLE;\n      const messages = result.messages;\n      const lastMessage = messages[messages.length - 1];\n      if (lastMessage?.role !== \"assistant\") return IDLE;\n      if (lastMessage.status !== \"generating\" && lastMessage.status !== \"awaiting-tool\")\n        return IDLE;\n      const contentSoFar = lastMessage.contentSoFar;\n      const lastPart = contentSoFar[contentSoFar.length - 1];\n      if (lastPart?.type === \"tool-invocation\") {\n        return {\n          status: \"generating\",\n          partType: \"tool-invocation\",\n          toolName: lastPart.name\n        };\n      } else {\n        return {\n          status: \"generating\",\n          partType: lastPart?.type\n        };\n      }\n    },\n    // Consider { status: \"generating\", partType: \"text\" } and { status: \"generating\", partType: \"text\" } equal\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n  if (!isAvailable) {\n    return DISCONNECTED;\n  }\n  return chatStatus;\n}\nfunction useSendAiMessage(chatId, options) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (message) => {\n      const {\n        text: messageText,\n        chatId: messageOptionsChatId,\n        copilotId: messageOptionsCopilotId,\n        ...messageOptions\n      } = typeof message === \"string\" ? { text: message } : message;\n      const resolvedChatId = messageOptionsChatId ?? chatId ?? // The `useSendAiMessage` overloads prevent this scenario from happening\n      // at the type level, and this error prevents it from happening at runtime.\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\n        \"chatId must be provided to either `useSendAiMessage` or its returned function.\"\n      );\n      const messages = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.signals.getChatMessagesForBranch\\u03A3(resolvedChatId).get();\n      if ( true && !messageOptionsCopilotId && !options?.copilotId) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n          `No copilot ID was provided to useSendAiMessage when sending the message \"${messageText.slice(\n            0,\n            20\n          )}\\u2026\". As a result, the message will use the chat's previous copilot ID, which could lead to unexpected behavior.\nTo ensure the correct copilot ID is used, specify it either through the hook as 'useSendAiMessage(\"${resolvedChatId}\", { copilotId: \"co_xxx\" })' or via the function as 'sendAiMessage({ text: \"${messageText.slice(\n            0,\n            20\n          )}\\u2026\", copilotId: \"co_xxx\" })'`\n        );\n      }\n      const resolvedCopilotId = messageOptionsCopilotId ?? options?.copilotId ?? client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.getLastUsedCopilotId(resolvedChatId);\n      const lastMessageId = messages[messages.length - 1]?.id ?? null;\n      const content = [{ type: \"text\", text: messageText }];\n      const newMessageId = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].context.messagesStore.createOptimistically(\n        resolvedChatId,\n        \"user\",\n        lastMessageId,\n        content\n      );\n      const newMessage = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].context.messagesStore.getMessageById(newMessageId);\n      const targetMessageId = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].context.messagesStore.createOptimistically(\n        resolvedChatId,\n        \"assistant\",\n        newMessageId,\n        resolvedCopilotId\n      );\n      void client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.askUserMessageInChat(\n        resolvedChatId,\n        { id: newMessageId, parentMessageId: lastMessageId, content },\n        targetMessageId,\n        {\n          stream: messageOptions.stream ?? options?.stream,\n          copilotId: resolvedCopilotId,\n          timeout: messageOptions.timeout ?? options?.timeout\n        }\n      );\n      return newMessage;\n    },\n    [client, chatId, options?.copilotId, options?.stream, options?.timeout]\n  );\n}\nfunction createSharedContext(client) {\n  const useClient2 = () => client;\n  function useSyncStatus2(options) {\n    return useSyncStatus_withClient(client, options);\n  }\n  return {\n    classic: {\n      useClient: useClient2,\n      useUser: (userId) => useUser_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId),\n      useGroupInfo: (groupId) => useGroupInfo_withClient(client, groupId),\n      useIsInsideRoom,\n      useErrorListener,\n      useSyncStatus: useSyncStatus2,\n      RegisterAiKnowledge,\n      RegisterAiTool\n    },\n    suspense: {\n      useClient: useClient2,\n      useUser: (userId) => useUserSuspense_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId),\n      useGroupInfo: (groupId) => useGroupInfoSuspense_withClient(client, groupId),\n      useIsInsideRoom,\n      useErrorListener,\n      useSyncStatus: useSyncStatus2,\n      RegisterAiKnowledge,\n      RegisterAiTool\n    }\n  };\n}\nfunction useEnsureNoLiveblocksProvider(options) {\n  const existing = useClientOrNull();\n  if (!options?.allowNesting && existing !== null) {\n    throw new Error(\n      \"You cannot nest multiple LiveblocksProvider instances in the same React tree.\"\n    );\n  }\n}\nfunction LiveblocksProviderWithClient(props) {\n  useEnsureNoLiveblocksProvider(props);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ClientContext.Provider, { value: props.client, children: props.children });\n}\nfunction LiveblocksProvider(props) {\n  const { children, ...o } = props;\n  const options = {\n    publicApiKey: useInitial(o.publicApiKey),\n    throttle: useInitial(o.throttle),\n    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),\n    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),\n    polyfills: useInitial(o.polyfills),\n    largeMessageStrategy: useInitial(o.largeMessageStrategy),\n    unstable_streamData: useInitial(o.unstable_streamData),\n    preventUnsavedChanges: useInitial(o.preventUnsavedChanges),\n    authEndpoint: useInitialUnlessFunction(o.authEndpoint),\n    resolveMentionSuggestions: useInitialUnlessFunction(\n      o.resolveMentionSuggestions\n    ),\n    resolveUsers: useInitialUnlessFunction(o.resolveUsers),\n    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),\n    resolveGroupsInfo: useInitialUnlessFunction(o.resolveGroupsInfo),\n    baseUrl: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.baseUrl\n    ),\n    enableDebugLogging: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.enableDebugLogging\n    )\n  };\n  const client = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createClient)(options), []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return () => {\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].ai.disconnect();\n    };\n  }, [client]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LiveblocksProviderWithClient, { client, children });\n}\nfunction createLiveblocksContext(client) {\n  return getOrCreateContextBundle(client);\n}\nfunction useUserThreads_experimental(options = {}) {\n  const client = useClient();\n  const { store, userThreadsPoller: poller } = getLiveblocksExtrasForClient(client);\n  const queryKey = makeUserThreadsQueryKey(options.query);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  return useSignal(\n    store.outputs.loadingUserThreads.getOrCreate(queryKey).signal\n  );\n}\nfunction useUserThreadsSuspense_experimental(options = {}) {\n  ensureNotServerSide();\n  const client = useClient();\n  const { store } = getLiveblocksExtrasForClient(client);\n  const queryKey = makeUserThreadsQueryKey(options.query);\n  use(store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded());\n  const result = useUserThreads_experimental(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useInboxNotifications(options) {\n  return useInboxNotifications_withClient(\n    useClient(),\n    identity2,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow,\n    options\n  );\n}\nfunction useInboxNotificationsSuspense(options) {\n  return useInboxNotificationsSuspense_withClient(useClient(), options);\n}\nfunction useInboxNotificationThread(inboxNotificationId) {\n  return useInboxNotificationThread_withClient(\n    useClient(),\n    inboxNotificationId\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead() {\n  return useMarkAllInboxNotificationsAsRead_withClient(useClient());\n}\nfunction useMarkInboxNotificationAsRead() {\n  return useMarkInboxNotificationAsRead_withClient(useClient());\n}\nfunction useDeleteAllInboxNotifications() {\n  return useDeleteAllInboxNotifications_withClient(useClient());\n}\nfunction useDeleteInboxNotification() {\n  return useDeleteInboxNotification_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCount(options) {\n  return useUnreadInboxNotificationsCount_withClient(useClient(), options);\n}\nfunction useUnreadInboxNotificationsCountSuspense(options) {\n  return useUnreadInboxNotificationsCountSuspense_withClient(\n    useClient(),\n    options\n  );\n}\nfunction useNotificationSettings() {\n  return useNotificationSettings_withClient(useClient());\n}\nfunction useNotificationSettingsSuspense() {\n  return useNotificationSettingsSuspense_withClient(useClient());\n}\nfunction useUpdateNotificationSettings() {\n  return useUpdateNotificationSettings_withClient(useClient());\n}\nfunction useUser(userId) {\n  const client = useClient();\n  return useUser_withClient(client, userId);\n}\nfunction useUserSuspense(userId) {\n  const client = useClient();\n  return useUserSuspense_withClient(client, userId);\n}\nfunction useRoomInfo(roomId) {\n  return useRoomInfo_withClient(useClient(), roomId);\n}\nfunction useRoomInfoSuspense(roomId) {\n  return useRoomInfoSuspense_withClient(useClient(), roomId);\n}\nfunction useGroupInfo(groupId) {\n  return useGroupInfo_withClient(useClient(), groupId);\n}\nfunction useGroupInfoSuspense(groupId) {\n  return useGroupInfoSuspense_withClient(useClient(), groupId);\n}\nvar _useInboxNotificationThread = useInboxNotificationThread;\nvar _useUser = useUser;\nvar _useUserSuspense = useUserSuspense;\nvar _useUserThreads_experimental = useUserThreads_experimental;\nvar _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;\nvar _useAiChats = useAiChats;\nvar _useAiChatsSuspense = useAiChatsSuspense;\nvar _useAiChat = useAiChat;\nvar _useAiChatSuspense = useAiChatSuspense;\nvar _useAiChatMessages = useAiChatMessages;\nvar _useAiChatMessagesSuspense = useAiChatMessagesSuspense;\nvar _useUrlMetadata = useUrlMetadata;\nvar _useUrlMetadataSuspense = useUrlMetadataSuspense;\nfunction useSyncStatus_withClient(client, options) {\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useSyncStatusSmooth_withClient(client);\n  } else {\n    return useSyncStatusImmediate_withClient(client);\n  }\n}\nfunction useSyncStatusImmediate_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    client.events.syncStatus.subscribe,\n    client.getSyncStatus,\n    client.getSyncStatus\n  );\n}\nfunction useSyncStatusSmooth_withClient(client) {\n  const getter = client.getSyncStatus;\n  const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getter);\n  const oldStatus = useLatest(getter());\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    let timeoutId;\n    const unsub = client.events.syncStatus.subscribe(() => {\n      const newStatus = getter();\n      if (oldStatus.current === \"synchronizing\" && newStatus === \"synchronized\") {\n        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [client, getter, oldStatus]);\n  return status;\n}\nfunction useSyncStatus(options) {\n  return useSyncStatus_withClient(useClient(), options);\n}\nfunction useErrorListener(callback) {\n  const client = useClient();\n  const savedCallback = useLatest(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => client.events.error.subscribe((e) => savedCallback.current(e)),\n    [client, savedCallback]\n  );\n}\n\n// src/room.tsx\n\n\n\n\n// src/use-scroll-to-comment-on-load-effect.ts\n\nfunction handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {\n  if (shouldScrollOnLoad === false) return;\n  if (!state.threads) return;\n  const isWindowDefined = typeof window !== \"undefined\";\n  if (!isWindowDefined) return;\n  const hash = window.location.hash;\n  const commentId = hash.slice(1);\n  if (!commentId.startsWith(\"cm_\")) return;\n  const comment = document.getElementById(commentId);\n  if (comment === null) return;\n  const comments = state.threads.flatMap((thread) => thread.comments);\n  const isCommentInThreads = comments.some(\n    (comment2) => comment2.id === commentId\n  );\n  if (!isCommentInThreads) return;\n  comment.scrollIntoView();\n}\nfunction useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => {\n      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n    [state.isLoading]\n  );\n}\n\n// src/room.tsx\n\nvar noop2 = () => {\n};\nvar identity3 = (x) => x;\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n  return null;\n}\nfunction selectorFor_useOthersConnectionIds(others) {\n  return others.map((user) => user.connectionId);\n}\nfunction makeMutationContext(room) {\n  const cannotUseUntil = \"This mutation cannot be used until\";\n  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;\n  const needsStorage = `${cannotUseUntil} storage has been loaded`;\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(needsStorage);\n      }\n      return mutableRoot;\n    },\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(needsPresence);\n      }\n      return self;\n    },\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(needsPresence);\n      }\n      return others;\n    },\n    setMyPresence: room.updatePresence\n  };\n}\nfunction getCurrentUserId(client) {\n  const userId = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].currentUserId.get();\n  if (userId === void 0) {\n    return \"anonymous\";\n  }\n  return userId;\n}\nvar _extras2 = /* @__PURE__ */ new WeakMap();\nvar _bundles2 = /* @__PURE__ */ new WeakMap();\nfunction getOrCreateRoomContextBundle(client) {\n  let bundle = _bundles2.get(client);\n  if (!bundle) {\n    bundle = makeRoomContextBundle(client);\n    _bundles2.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getRoomExtrasForClient(client) {\n  let extras = _extras2.get(client);\n  if (!extras) {\n    extras = makeRoomExtrasForClient(client);\n    _extras2.set(client, extras);\n  }\n  return extras;\n}\nfunction makeRoomExtrasForClient(client) {\n  const store = getUmbrellaStoreForClient(client);\n  function onMutationFailure(optimisticId, context, innerError) {\n    store.optimisticUpdates.remove(optimisticId);\n    if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.HttpError) {\n      if (innerError.status === 403) {\n        const detailedMessage = [\n          innerError.message,\n          innerError.details?.suggestion,\n          innerError.details?.docs\n        ].filter(Boolean).join(\"\\n\");\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(detailedMessage);\n      }\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(context, innerError);\n    } else {\n      throw innerError;\n    }\n  }\n  const threadsPollersByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n    (roomId) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n      async (signal) => {\n        try {\n          return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);\n        } catch (err) {\n          _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`);\n          throw err;\n        }\n      },\n      config.ROOM_THREADS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME }\n    )\n  );\n  const versionsPollersByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n    (roomId) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n      async (signal) => {\n        try {\n          return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);\n        } catch (err) {\n          _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`);\n          throw err;\n        }\n      },\n      config.HISTORY_VERSIONS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME }\n    )\n  );\n  const roomSubscriptionSettingsPollersByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n    (roomId) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n      async (signal) => {\n        try {\n          return await store.refreshRoomSubscriptionSettings(roomId, signal);\n        } catch (err) {\n          _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(`Polling subscription settings for '${roomId}' failed: ${String(err)}`);\n          throw err;\n        }\n      },\n      config.ROOM_SUBSCRIPTION_SETTINGS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.ROOM_SUBSCRIPTION_SETTINGS_MAX_STALE_TIME }\n    )\n  );\n  return {\n    store,\n    onMutationFailure,\n    pollThreadsForRoomId: (roomId) => {\n      const threadsPoller = threadsPollersByRoomId.getOrCreate(roomId);\n      if (threadsPoller) {\n        threadsPoller.markAsStale();\n        threadsPoller.pollNowIfStale();\n      }\n    },\n    getOrCreateThreadsPollerForRoomId: threadsPollersByRoomId.getOrCreate.bind(\n      threadsPollersByRoomId\n    ),\n    getOrCreateVersionsPollerForRoomId: versionsPollersByRoomId.getOrCreate.bind(versionsPollersByRoomId),\n    getOrCreateSubscriptionSettingsPollerForRoomId: roomSubscriptionSettingsPollersByRoomId.getOrCreate.bind(\n      roomSubscriptionSettingsPollersByRoomId\n    )\n  };\n}\nfunction makeRoomContextBundle(client) {\n  function RoomProvider_withImplicitLiveblocksProvider(props) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LiveblocksProviderWithClient, { client, allowNesting: true, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RoomProvider, { ...props }) });\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    RoomContext,\n    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n    useRoom,\n    useStatus,\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useEventListener,\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n    useStorageRoot,\n    useStorage,\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n    useMutation,\n    useThreads,\n    useSearchComments,\n    useCreateThread,\n    useDeleteThread,\n    useEditThreadMetadata,\n    useMarkThreadAsResolved,\n    useMarkThreadAsUnresolved,\n    useSubscribeToThread,\n    useUnsubscribeFromThread,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n    useMarkThreadAsRead,\n    useThreadSubscription,\n    useAttachmentUrl,\n    useHistoryVersions,\n    useHistoryVersionData,\n    useRoomSubscriptionSettings,\n    useUpdateRoomSubscriptionSettings,\n    ...shared.classic,\n    suspense: {\n      RoomContext,\n      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n      useRoom,\n      useStatus,\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useEventListener,\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n      useMutation,\n      useThreads: useThreadsSuspense,\n      useCreateThread,\n      useDeleteThread,\n      useEditThreadMetadata,\n      useMarkThreadAsResolved,\n      useMarkThreadAsUnresolved,\n      useSubscribeToThread,\n      useUnsubscribeFromThread,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n      useMarkThreadAsRead,\n      useThreadSubscription,\n      useAttachmentUrl: useAttachmentUrlSuspense,\n      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,\n      useHistoryVersions: useHistoryVersionsSuspense,\n      useRoomSubscriptionSettings: useRoomSubscriptionSettingsSuspense,\n      useUpdateRoomSubscriptionSettings,\n      ...shared.suspense\n    }\n  };\n  return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal, {\n    enumerable: false\n  });\n}\nfunction RoomProvider(props) {\n  const client = useClient();\n  const [cache] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => /* @__PURE__ */ new Map()\n  );\n  const stableEnterRoom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (roomId, options) => {\n      const cached = cache.get(roomId);\n      if (cached) return cached;\n      const rv = client.enterRoom(roomId, options);\n      const origLeave = rv.leave;\n      rv.leave = () => {\n        origLeave();\n        cache.delete(roomId);\n      };\n      cache.set(roomId, rv);\n      return rv;\n    },\n    [client, cache]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\n    RoomProviderInner,\n    {\n      ...props,\n      stableEnterRoom\n    }\n  );\n}\nfunction RoomProviderInner(props) {\n  const client = useClient();\n  const { id: roomId, stableEnterRoom } = props;\n  if (true) {\n    if (!roomId) {\n      throw new Error(\n        \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n      );\n    }\n    if (typeof roomId !== \"string\") {\n      throw new Error(\"RoomProvider id property should be a string.\");\n    }\n    const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n    const requiredVersion = 18;\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.errorIf)(\n      majorReactVersion < requiredVersion,\n      `React ${requiredVersion} or higher is required (you\\u2019re on ${react__WEBPACK_IMPORTED_MODULE_0__.version})`\n    );\n  }\n  const frozenProps = useInitial(\n    {\n      initialPresence: props.initialPresence,\n      initialStorage: props.initialStorage,\n      autoConnect: props.autoConnect ?? typeof window !== \"undefined\"\n    },\n    roomId\n  );\n  const [{ room }, setRoomLeavePair] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => stableEnterRoom(roomId, {\n      ...frozenProps,\n      autoConnect: false\n      // Deliberately using false here on the first render, see below\n    })\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { store } = getRoomExtrasForClient(client);\n    async function handleCommentEvent(message) {\n      if (message.type === _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.THREAD_DELETED) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const info = await room.getThread(message.threadId);\n      if (!info.thread) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const {\n        thread,\n        inboxNotification: maybeNotification,\n        subscription: maybeSubscription\n      } = info;\n      const existingThread = store.outputs.threads.get().getEvenIfDeleted(message.threadId);\n      switch (message.type) {\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_EDITED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.THREAD_METADATA_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.THREAD_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_REACTION_ADDED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_DELETED:\n          if (!existingThread) break;\n          store.updateThreadifications(\n            [thread],\n            maybeNotification ? [maybeNotification] : [],\n            maybeSubscription ? [maybeSubscription] : []\n          );\n          break;\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_CREATED:\n          store.updateThreadifications(\n            [thread],\n            maybeNotification ? [maybeNotification] : [],\n            maybeSubscription ? [maybeSubscription] : []\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return room.events.comments.subscribe(\n      (message) => void handleCommentEvent(message)\n    );\n  }, [client, room]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const pair = stableEnterRoom(roomId, frozenProps);\n    setRoomLeavePair(pair);\n    const { room: room2, leave } = pair;\n    if (frozenProps.autoConnect) {\n      room2.connect();\n    }\n    return () => {\n      leave();\n    };\n  }, [roomId, frozenProps, stableEnterRoom]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RoomContext.Provider, { value: room, children: props.children });\n}\nfunction useRoom(options) {\n  const room = useRoomOrNull();\n  if (room === null && !options?.allowOutsideRoom) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return room;\n}\nfunction useStatus() {\n  const room = useRoom();\n  const subscribe = room.events.status.subscribe;\n  const getSnapshot = room.getStatus;\n  const getServerSnapshot = room.getStatus;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useReportTextEditor(editor, rootKey) {\n  const isReported = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const room = useRoom();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (isReported.current) {\n      return;\n    }\n    const unsubscribe = room.events.status.subscribe((status) => {\n      if (status === \"connected\" && !isReported.current) {\n        isReported.current = true;\n        void room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].reportTextEditor(editor, rootKey);\n      }\n    });\n    return unsubscribe;\n  }, [room, editor, rootKey]);\n}\nfunction useYjsProvider() {\n  const room = useRoom();\n  const subscribe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (onStoreChange) => {\n      return room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].yjsProviderDidChange.subscribe(onStoreChange);\n    },\n    [room]\n  );\n  const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    return room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].getYjsProvider();\n  }, [room]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);\n}\nfunction useCreateTextMention() {\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (mentionId, mention) => {\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].createTextMention(mentionId, mention).catch((err) => {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(\n          `Cannot create text mention for mention '${mentionId}'`,\n          err\n        );\n      });\n    },\n    [room]\n  );\n}\nfunction useDeleteTextMention() {\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (mentionId) => {\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].deleteTextMention(mentionId).catch((err) => {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(`Cannot delete text mention '${mentionId}'`, err);\n      });\n    },\n    [room]\n  );\n}\nfunction useResolveMentionSuggestions() {\n  const client = useClient();\n  return client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].resolveMentionSuggestions;\n}\nfunction useMentionSuggestionsCache() {\n  const client = useClient();\n  return client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].mentionSuggestionsCache;\n}\nfunction useBroadcastEvent() {\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (event, options = { shouldQueueEventIfNotReady: false }) => {\n      room.broadcastEvent(event, options);\n    },\n    [room]\n  );\n}\nfunction useOthersListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => room.events.others.subscribe((event) => savedCallback.current(event)),\n    [room, savedCallback]\n  );\n}\nfunction useLostConnectionListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => room.events.lostConnection.subscribe(\n      (event) => savedCallback.current(event)\n    ),\n    [room, savedCallback]\n  );\n}\nfunction useEventListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const listener = (eventData) => {\n      savedCallback.current(eventData);\n    };\n    return room.events.customEvent.subscribe(listener);\n  }, [room, savedCallback]);\n}\nfunction useHistory() {\n  return useRoom().history;\n}\nfunction useUndo() {\n  return useHistory().undo;\n}\nfunction useRedo() {\n  return useHistory().redo;\n}\nfunction useCanUndo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canUndo = room.history.canUndo;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, canUndo, canUndo);\n}\nfunction useCanRedo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canRedo = room.history.canRedo;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, canRedo, canRedo);\n}\nfunction useSelf(maybeSelector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.self.subscribe;\n  const getSnapshot = room.getSelf;\n  const selector = maybeSelector ?? identity3;\n  const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (me) => me !== null ? selector(me) : null,\n    [selector]\n  );\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMyPresence() {\n  const room = useRoom();\n  const subscribe = room.events.myPresence.subscribe;\n  const getSnapshot = room.getPresence;\n  const presence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);\n  const setPresence = room.updatePresence;\n  return [presence, setPresence];\n}\nfunction useUpdateMyPresence() {\n  return useRoom().updatePresence;\n}\nfunction useOthers(selector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.others.subscribe;\n  const getSnapshot = room.getOthers;\n  const getServerSnapshot = alwaysEmptyList;\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    selector ?? identity3,\n    isEqual\n  );\n}\nfunction useOthersMapped(itemSelector, itemIsEqual) {\n  const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),\n    [itemSelector]\n  );\n  const wrappedIsEqual = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (a, b) => {\n      const eq = itemIsEqual ?? Object.is;\n      return a.length === b.length && a.every((atuple, index) => {\n        const btuple = b[index];\n        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n      });\n    },\n    [itemIsEqual]\n  );\n  return useOthers(wrappedSelector, wrappedIsEqual);\n}\nfunction useOthersConnectionIds() {\n  return useOthers(selectorFor_useOthersConnectionIds, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n}\nvar NOT_FOUND = Symbol();\nfunction useOther(connectionId, selector, isEqual) {\n  const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (others) => {\n      const other2 = others.find((other3) => other3.connectionId === connectionId);\n      return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n    },\n    [connectionId, selector]\n  );\n  const wrappedIsEqual = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (prev, curr) => {\n      if (prev === NOT_FOUND || curr === NOT_FOUND) {\n        return prev === curr;\n      }\n      const eq = isEqual ?? Object.is;\n      return eq(prev, curr);\n    },\n    [isEqual]\n  );\n  const other = useOthers(wrappedSelector, wrappedIsEqual);\n  if (other === NOT_FOUND) {\n    throw new Error(\n      `No such other user with connection id ${connectionId} exists`\n    );\n  }\n  return other;\n}\nfunction useMutableStorageRoot() {\n  const room = useRoom();\n  const subscribe = room.events.storageDidLoad.subscribeOnce;\n  const getSnapshot = room.getStorageSnapshot;\n  const getServerSnapshot = alwaysNull;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageRoot() {\n  return [useMutableStorageRoot()];\n}\nfunction useStorage(selector, isEqual) {\n  const room = useRoom();\n  const rootOrNull = useMutableStorageRoot();\n  const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,\n    [selector]\n  );\n  const subscribe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop2,\n    [room, rootOrNull]\n  );\n  const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      const root = rootOrNull;\n      const imm = root.toImmutable();\n      return imm;\n    }\n  }, [rootOrNull]);\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMutation(callback, deps) {\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => {\n      return (...args) => (\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        room.batch(\n          () => (\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            callback(\n              makeMutationContext(room),\n              ...args\n            )\n          )\n        )\n      );\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [room, ...deps]\n  );\n}\nfunction useThreads(options = {}) {\n  const { scrollOnLoad = true } = options;\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateThreadsPollerForRoomId } = getRoomExtrasForClient(client);\n  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);\n  const poller = getOrCreateThreadsPollerForRoomId(room.id);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n  const result = useSignal(\n    store.outputs.loadingRoomThreads.getOrCreate(queryKey).signal\n  );\n  useScrollToCommentOnLoadEffect(scrollOnLoad, result);\n  return result;\n}\nfunction useSearchComments(options) {\n  const [result, setResult] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n    isLoading: true\n  });\n  const currentRequestInfo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const timeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const client = useClient();\n  const room = useRoom();\n  const queryKey = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.stableStringify)([room.id, options.query]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const currentRequestId = (currentRequestInfo.current?.id ?? 0) + 1;\n    const controller = new AbortController();\n    currentRequestInfo.current = { id: currentRequestId, controller };\n    setResult((result2) => {\n      if (result2.isLoading) return result2;\n      return { isLoading: true };\n    });\n    timeout.current = window.setTimeout(\n      () => {\n        client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.searchComments(\n          {\n            roomId: room.id,\n            query: options.query\n          },\n          { signal: controller.signal }\n        ).then(({ data }) => {\n          if (controller.signal.aborted) return;\n          if (currentRequestInfo.current?.id !== currentRequestId) return;\n          setResult({ isLoading: false, results: data });\n          currentRequestInfo.current = null;\n        }).catch((err) => {\n          if (controller.signal.aborted) return;\n          if (currentRequestInfo.current?.id !== currentRequestId) return;\n          setResult({ isLoading: false, error: err });\n          currentRequestInfo.current = null;\n        });\n      },\n      300\n      /* debounce time */\n    );\n    return () => {\n      if (timeout.current !== null) {\n        window.clearTimeout(timeout.current);\n      }\n      if (currentRequestInfo.current !== null) {\n        currentRequestInfo.current.controller.abort();\n      }\n    };\n  }, [queryKey, client, room.id]);\n  return result;\n}\nfunction useCreateThread() {\n  return useCreateRoomThread(useRoom().id);\n}\nfunction useCreateRoomThread(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (options) => {\n      const body = options.body;\n      const metadata = options.metadata ?? {};\n      const attachments = options.attachments;\n      const threadId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createThreadId)();\n      const commentId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createCommentId)();\n      const createdAt = /* @__PURE__ */ new Date();\n      const newComment = {\n        id: commentId,\n        threadId,\n        roomId,\n        createdAt,\n        type: \"comment\",\n        userId: getCurrentUserId(client),\n        body,\n        reactions: [],\n        attachments: attachments ?? []\n      };\n      const newThread = {\n        id: threadId,\n        type: \"thread\",\n        createdAt,\n        updatedAt: createdAt,\n        roomId,\n        metadata,\n        comments: [newComment],\n        resolved: false\n      };\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"create-thread\",\n        thread: newThread,\n        roomId\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.createThread({\n        roomId,\n        threadId,\n        commentId,\n        body,\n        metadata,\n        attachmentIds\n      }).then(\n        (thread) => {\n          store.createThread(optimisticId, thread);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"CREATE_THREAD_ERROR\",\n            roomId,\n            threadId,\n            commentId,\n            body,\n            metadata\n          },\n          err\n        )\n      );\n      return newThread;\n    },\n    [client, roomId]\n  );\n}\nfunction useDeleteThread() {\n  return useDeleteRoomThread(useRoom().id);\n}\nfunction useDeleteRoomThread(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const userId = getCurrentUserId(client);\n      const existing = store.outputs.threads.get().get(threadId);\n      if (existing?.comments?.[0]?.userId !== userId) {\n        throw new Error(\"Only the thread creator can delete the thread\");\n      }\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-thread\",\n        roomId,\n        threadId,\n        deletedAt: /* @__PURE__ */ new Date()\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.deleteThread({ roomId, threadId }).then(\n        () => {\n          store.deleteThread(threadId, optimisticId);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"DELETE_THREAD_ERROR\", roomId, threadId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useEditThreadMetadata() {\n  return useEditRoomThreadMetadata(useRoom().id);\n}\nfunction useEditRoomThreadMetadata(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (options) => {\n      if (!options.metadata) {\n        return;\n      }\n      const threadId = options.threadId;\n      const metadata = options.metadata;\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-thread-metadata\",\n        metadata,\n        threadId,\n        updatedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.editThreadMetadata({ roomId, threadId, metadata }).then(\n        (metadata2) => (\n          // Replace the optimistic update by the real thing\n          store.patchThread(threadId, optimisticId, { metadata: metadata2 }, updatedAt)\n        ),\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"EDIT_THREAD_METADATA_ERROR\",\n            roomId,\n            threadId,\n            metadata\n          },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useCreateComment() {\n  return useCreateRoomComment(useRoom().id);\n}\nfunction useCreateRoomComment(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, body, attachments }) => {\n      const commentId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createCommentId)();\n      const createdAt = /* @__PURE__ */ new Date();\n      const comment = {\n        id: commentId,\n        threadId,\n        roomId,\n        type: \"comment\",\n        createdAt,\n        userId: getCurrentUserId(client),\n        body,\n        reactions: [],\n        attachments: attachments ?? []\n      };\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"create-comment\",\n        comment\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.createComment({ roomId, threadId, commentId, body, attachmentIds }).then(\n        (newComment) => {\n          store.createComment(newComment, optimisticId);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"CREATE_COMMENT_ERROR\",\n            roomId,\n            threadId,\n            commentId,\n            body\n          },\n          err\n        )\n      );\n      return comment;\n    },\n    [client, roomId]\n  );\n}\nfunction useEditComment() {\n  return useEditRoomComment(useRoom().id);\n}\nfunction useEditRoomComment(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, commentId, body, attachments }) => {\n      const editedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const existing = store.outputs.threads.get().getEvenIfDeleted(threadId);\n      if (existing === void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`\n        );\n        return;\n      }\n      const comment = existing.comments.find(\n        (comment2) => comment2.id === commentId\n      );\n      if (comment === void 0 || comment.deletedAt !== void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`\n        );\n        return;\n      }\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-comment\",\n        comment: {\n          ...comment,\n          editedAt,\n          body,\n          attachments: attachments ?? []\n        }\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.editComment({ roomId, threadId, commentId, body, attachmentIds }).then(\n        (editedComment) => {\n          store.editComment(threadId, optimisticId, editedComment);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"EDIT_COMMENT_ERROR\", roomId, threadId, commentId, body },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useDeleteComment() {\n  return useDeleteRoomComment(useRoom().id);\n}\nfunction useDeleteRoomComment(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, commentId }) => {\n      const deletedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-comment\",\n        threadId,\n        commentId,\n        deletedAt,\n        roomId\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.deleteComment({ roomId, threadId, commentId }).then(\n        () => {\n          store.deleteComment(threadId, optimisticId, commentId, deletedAt);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"DELETE_COMMENT_ERROR\", roomId, threadId, commentId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useAddReaction() {\n  return useAddRoomCommentReaction(useRoom().id);\n}\nfunction useAddRoomCommentReaction(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, commentId, emoji }) => {\n      const createdAt = /* @__PURE__ */ new Date();\n      const userId = getCurrentUserId(client);\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"add-reaction\",\n        threadId,\n        commentId,\n        reaction: {\n          emoji,\n          userId,\n          createdAt\n        }\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.addReaction({ roomId, threadId, commentId, emoji }).then(\n        (addedReaction) => {\n          store.addReaction(\n            threadId,\n            optimisticId,\n            commentId,\n            addedReaction,\n            createdAt\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"ADD_REACTION_ERROR\",\n            roomId,\n            threadId,\n            commentId,\n            emoji\n          },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useRemoveReaction() {\n  return useRemoveRoomCommentReaction(useRoom().id);\n}\nfunction useRemoveRoomCommentReaction(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, commentId, emoji }) => {\n      const userId = getCurrentUserId(client);\n      const removedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"remove-reaction\",\n        threadId,\n        commentId,\n        emoji,\n        userId,\n        removedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.removeReaction({ roomId, threadId, commentId, emoji }).then(\n        () => {\n          store.removeReaction(\n            threadId,\n            optimisticId,\n            commentId,\n            emoji,\n            userId,\n            removedAt\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"REMOVE_REACTION_ERROR\",\n            roomId,\n            threadId,\n            commentId,\n            emoji\n          },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useMarkThreadAsRead() {\n  return useMarkRoomThreadAsRead(useRoom().id);\n}\nfunction useMarkRoomThreadAsRead(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const inboxNotification = Object.values(\n        store.outputs.notifications.get().notificationsById\n      ).find(\n        (inboxNotification2) => inboxNotification2.kind === \"thread\" && inboxNotification2.threadId === threadId\n      );\n      if (!inboxNotification) return;\n      const now = /* @__PURE__ */ new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId: inboxNotification.id,\n        readAt: now\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.markRoomInboxNotificationAsRead({\n        roomId,\n        inboxNotificationId: inboxNotification.id\n      }).then(\n        () => {\n          store.markInboxNotificationRead(\n            inboxNotification.id,\n            now,\n            optimisticId\n          );\n        },\n        (err) => {\n          onMutationFailure(\n            optimisticId,\n            {\n              type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\",\n              roomId,\n              inboxNotificationId: inboxNotification.id\n            },\n            err\n          );\n          return;\n        }\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useMarkThreadAsResolved() {\n  return useMarkRoomThreadAsResolved(useRoom().id);\n}\nfunction useMarkRoomThreadAsResolved(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-thread-as-resolved\",\n        threadId,\n        updatedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.markThreadAsResolved({ roomId, threadId }).then(\n        () => {\n          store.patchThread(\n            threadId,\n            optimisticId,\n            { resolved: true },\n            updatedAt\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"MARK_THREAD_AS_RESOLVED_ERROR\", roomId, threadId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useMarkThreadAsUnresolved() {\n  return useMarkRoomThreadAsUnresolved(useRoom().id);\n}\nfunction useMarkRoomThreadAsUnresolved(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-thread-as-unresolved\",\n        threadId,\n        updatedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.markThreadAsUnresolved({ roomId, threadId }).then(\n        () => {\n          store.patchThread(\n            threadId,\n            optimisticId,\n            { resolved: false },\n            updatedAt\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"MARK_THREAD_AS_UNRESOLVED_ERROR\", roomId, threadId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useSubscribeToThread() {\n  return useSubscribeToRoomThread(useRoom().id);\n}\nfunction useSubscribeToRoomThread(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const subscribedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"subscribe-to-thread\",\n        threadId,\n        subscribedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.subscribeToThread({ roomId, threadId }).then(\n        (subscription) => {\n          store.createSubscription(subscription, optimisticId);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"SUBSCRIBE_TO_THREAD_ERROR\", roomId, threadId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useUnsubscribeFromThread() {\n  return useUnsubscribeFromRoomThread(useRoom().id);\n}\nfunction useUnsubscribeFromRoomThread(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const unsubscribedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"unsubscribe-from-thread\",\n        threadId,\n        unsubscribedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.unsubscribeFromThread({ roomId, threadId }).then(\n        () => {\n          store.deleteSubscription(\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.getSubscriptionKey)(\"thread\", threadId),\n            optimisticId\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"UNSUBSCRIBE_FROM_THREAD_ERROR\", roomId, threadId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useThreadSubscription(threadId) {\n  return useRoomThreadSubscription(useRoom().id, threadId);\n}\nfunction useRoomThreadSubscription(roomId, threadId) {\n  const client = useClient();\n  const { store } = getRoomExtrasForClient(client);\n  const subscriptionKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.getSubscriptionKey)(\"thread\", threadId),\n    [threadId]\n  );\n  const subscribeToThread = useSubscribeToRoomThread(roomId);\n  const unsubscribeFromThread = useUnsubscribeFromRoomThread(roomId);\n  const subscribe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => subscribeToThread(threadId),\n    [subscribeToThread, threadId]\n  );\n  const unsubscribe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => unsubscribeFromThread(threadId),\n    [unsubscribeFromThread, threadId]\n  );\n  const signal = store.outputs.threadSubscriptions;\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => {\n      const subscription = state.subscriptions[subscriptionKey];\n      const notification = state.notifications.find(\n        (inboxNotification) => inboxNotification.kind === \"thread\" && inboxNotification.threadId === threadId\n      );\n      if (subscription === void 0) {\n        return { status: \"not-subscribed\", subscribe, unsubscribe };\n      }\n      return {\n        status: \"subscribed\",\n        unreadSince: notification?.readAt ?? null,\n        subscribe,\n        unsubscribe\n      };\n    },\n    [subscriptionKey, threadId, subscribe, unsubscribe]\n  );\n  return useSignal(signal, selector, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n}\nfunction useRoomSubscriptionSettings() {\n  const updateRoomSubscriptionSettings = useUpdateRoomSubscriptionSettings();\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateSubscriptionSettingsPollerForRoomId } = getRoomExtrasForClient(client);\n  const poller = getOrCreateSubscriptionSettingsPollerForRoomId(room.id);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  const settings = useSignal(\n    store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).signal\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [settings, updateRoomSubscriptionSettings];\n  }, [settings, updateRoomSubscriptionSettings]);\n}\nfunction useRoomSubscriptionSettingsSuspense() {\n  ensureNotServerSide();\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  const room = useRoom();\n  use(\n    store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).waitUntilLoaded()\n  );\n  const [settings, updateRoomSubscriptionSettings] = useRoomSubscriptionSettings();\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!settings.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!settings.isLoading, \"Did not expect loading\");\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [settings, updateRoomSubscriptionSettings];\n  }, [settings, updateRoomSubscriptionSettings]);\n}\nfunction useHistoryVersionData(versionId) {\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n    isLoading: true\n  });\n  const room = useRoom();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    setState({ isLoading: true });\n    const load = async () => {\n      try {\n        const response = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].getTextVersion(versionId);\n        const buffer = await response.arrayBuffer();\n        const data = new Uint8Array(buffer);\n        setState({\n          isLoading: false,\n          data\n        });\n      } catch (error) {\n        setState({\n          isLoading: false,\n          error: error instanceof Error ? error : new Error(\n            \"An unknown error occurred while loading this version\"\n          )\n        });\n      }\n    };\n    void load();\n  }, [room, versionId]);\n  return state;\n}\nfunction useHistoryVersions() {\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateVersionsPollerForRoomId } = getRoomExtrasForClient(client);\n  const poller = getOrCreateVersionsPollerForRoomId(room.id);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  return useSignal(store.outputs.versionsByRoomId.getOrCreate(room.id).signal);\n}\nfunction useHistoryVersionsSuspense() {\n  ensureNotServerSide();\n  const client = useClient();\n  const room = useRoom();\n  const store = getRoomExtrasForClient(client).store;\n  use(store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded());\n  const result = useHistoryVersions();\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUpdateRoomSubscriptionSettings() {\n  const client = useClient();\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (settings) => {\n      const { store, onMutationFailure, pollThreadsForRoomId } = getRoomExtrasForClient(client);\n      const userId = getCurrentUserId(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"update-room-subscription-settings\",\n        roomId: room.id,\n        userId,\n        settings\n      });\n      room.updateSubscriptionSettings(settings).then(\n        (udpatedSettings) => {\n          store.updateRoomSubscriptionSettings(\n            room.id,\n            optimisticId,\n            udpatedSettings\n          );\n          if (settings.threads) {\n            pollThreadsForRoomId(room.id);\n          }\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR\",\n            roomId: room.id\n          },\n          err\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useSuspendUntilPresenceReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilPresenceReady());\n}\nfunction useSelfSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useSelf(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthers(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersConnectionIdsSuspense() {\n  useSuspendUntilPresenceReady();\n  return useOthersConnectionIds();\n}\nfunction useOthersMappedSuspense(itemSelector, itemIsEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthersMapped(itemSelector, itemIsEqual);\n}\nfunction useOtherSuspense(connectionId, selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOther(connectionId, selector, isEqual);\n}\nfunction useSuspendUntilStorageReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilStorageReady());\n}\nfunction useStorageSuspense(selector, isEqual) {\n  useSuspendUntilStorageReady();\n  return useStorage(\n    selector,\n    isEqual\n  );\n}\nfunction useThreadsSuspense(options = {}) {\n  ensureNotServerSide();\n  const client = useClient();\n  const room = useRoom();\n  const { store } = getRoomExtrasForClient(client);\n  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);\n  use(store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded());\n  const result = useThreads(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction selectorFor_useAttachmentUrl(state) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state.data !== void 0, \"Unexpected missing attachment URL\");\n  return {\n    isLoading: false,\n    url: state.data\n  };\n}\nfunction useAttachmentUrl(attachmentId) {\n  const room = useRoom();\n  return useRoomAttachmentUrl(attachmentId, room.id);\n}\nfunction useRoomAttachmentUrl(attachmentId, roomId) {\n  const client = useClient();\n  const store = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getOrCreateAttachmentUrlsStore(roomId);\n  const getAttachmentUrlState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => store.getItemState(attachmentId),\n    [store, attachmentId]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void store.enqueue(attachmentId);\n  }, [store, attachmentId]);\n  return useSyncExternalStoreWithSelector(\n    store.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState,\n    selectorFor_useAttachmentUrl,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n}\nfunction useAttachmentUrlSuspense(attachmentId) {\n  const room = useRoom();\n  const { attachmentUrlsStore } = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal];\n  const getAttachmentUrlState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => attachmentUrlsStore.getItemState(attachmentId),\n    [attachmentUrlsStore, attachmentId]\n  );\n  const attachmentUrlState = getAttachmentUrlState();\n  if (!attachmentUrlState || attachmentUrlState.isLoading) {\n    throw attachmentUrlsStore.enqueue(attachmentId);\n  }\n  if (attachmentUrlState.error) {\n    throw attachmentUrlState.error;\n  }\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    attachmentUrlsStore.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    url: state.data,\n    error: void 0\n  };\n}\nfunction useRoomPermissions(roomId) {\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  return useSignal(store.permissionHints.getPermissionForRoom\\u03A3(roomId));\n}\nfunction createRoomContext(client) {\n  return getOrCreateRoomContextBundle(client);\n}\nvar _RoomProvider = RoomProvider;\nvar _useBroadcastEvent = useBroadcastEvent;\nvar _useOthersListener = useOthersListener;\nvar _useRoom = useRoom;\nvar _useIsInsideRoom = useIsInsideRoom;\nvar _useAddReaction = useAddReaction;\nvar _useMutation = useMutation;\nvar _useCreateThread = useCreateThread;\nvar _useDeleteThread = useDeleteThread;\nvar _useEditThreadMetadata = useEditThreadMetadata;\nvar _useEventListener = useEventListener;\nvar _useMyPresence = useMyPresence;\nvar _useOthersMapped = useOthersMapped;\nvar _useOthersMappedSuspense = useOthersMappedSuspense;\nvar _useThreads = useThreads;\nvar _useSearchComments = useSearchComments;\nvar _useThreadsSuspense = useThreadsSuspense;\nvar _useRoomSubscriptionSettings = useRoomSubscriptionSettings;\nvar _useRoomSubscriptionSettingsSuspense = useRoomSubscriptionSettingsSuspense;\nvar _useHistoryVersions = useHistoryVersions;\nvar _useHistoryVersionsSuspense = useHistoryVersionsSuspense;\nvar _useOther = useOther;\nfunction _useOthers(...args) {\n  return useOthers(...args);\n}\nvar _useOtherSuspense = useOtherSuspense;\nfunction _useOthersSuspense(...args) {\n  return useOthersSuspense(...args);\n}\nvar _useStorage = useStorage;\nvar _useStorageSuspense = useStorageSuspense;\nfunction _useSelf(...args) {\n  return useSelf(...args);\n}\nfunction _useSelfSuspense(...args) {\n  return useSelfSuspense(...args);\n}\nvar _useStorageRoot = useStorageRoot;\nvar _useUpdateMyPresence = useUpdateMyPresence;\n\n\n//# sourceMappingURL=chunk-JOZ4BQWH.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9jaHVuay1KT1o0QlFXSC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3lDO0FBQ1M7QUFDbEQsb0JBQW9CLG9EQUFhO0FBQ2pDO0FBQ0EsU0FBUyxpREFBVTtBQUNuQjtBQUNBO0FBQ0EsOEJBQThCLHVEQUFLO0FBQ25DO0FBQ0Esa0JBQWtCLG9EQUFhO0FBQy9CO0FBQ0EsU0FBUyxpREFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBDO0FBQzFDO0FBQ0EsY0FBYyw2Q0FBTTtBQUNwQixFQUFFLGdEQUFTO0FBQ1g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNxRDtBQUNrQjtBQUN2RTtBQUNBLHFCQUFxQix1REFBUztBQUM5QjtBQUNBO0FBQ0EsU0FBUywrQ0FBUSxDQUFDLG9EQUFNO0FBQ3hCO0FBQ0EsMEJBQTBCLDJDQUFJO0FBQzlCLGtCQUFrQiw0Q0FBSztBQUN2QjtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDLGtDQUFrQywrQ0FBUTtBQUMxQyxFQUFFLGdEQUFVO0FBQ1osWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELHFCQUFxQiwyQ0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQix1REFBUztBQUM3QixFQUFFLGdEQUFVO0FBQ1osbURBQW1ELG1C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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBNEhFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnlhbmdveWFsL3JlYWwtdGltZS10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9jaHVuay1KT1o0QlFXSC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29udGV4dHMudHNcbmltcG9ydCB7IHJhaXNlIH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBDbGllbnRDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZUNsaWVudE9yTnVsbCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoQ2xpZW50Q29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VDbGllbnQoKSB7XG4gIHJldHVybiB1c2VDbGllbnRPck51bGwoKSA/PyByYWlzZShcIkxpdmVibG9ja3NQcm92aWRlciBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCIpO1xufVxudmFyIFJvb21Db250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZVJvb21Pck51bGwoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KFJvb21Db250ZXh0KTtcbn1cbmZ1bmN0aW9uIHVzZUlzSW5zaWRlUm9vbSgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb21Pck51bGwoKTtcbiAgcmV0dXJuIHJvb20gIT09IG51bGw7XG59XG5cbi8vIHNyYy9saWIvdXNlLWxhdGVzdC50c1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUxhdGVzdCh2YWx1ZSkge1xuICBjb25zdCByZWYgPSB1c2VSZWYodmFsdWUpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gcmVmO1xufVxuXG4vLyBzcmMvYWkudHN4XG5pbXBvcnQgeyBrSW50ZXJuYWwsIG5hbm9pZCB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgeyBtZW1vLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlSWQsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VBaSgpIHtcbiAgcmV0dXJuIHVzZUNsaWVudCgpW2tJbnRlcm5hbF0uYWk7XG59XG5mdW5jdGlvbiB1c2VSYW5kb20oKSB7XG4gIHJldHVybiB1c2VTdGF0ZShuYW5vaWQpWzBdO1xufVxudmFyIFJlZ2lzdGVyQWlLbm93bGVkZ2UgPSBtZW1vKGZ1bmN0aW9uIFJlZ2lzdGVyQWlLbm93bGVkZ2UyKHByb3BzKSB7XG4gIGNvbnN0IGxheWVySWQgPSB1c2VJZCgpO1xuICBjb25zdCBhaSA9IHVzZUFpKCk7XG4gIGNvbnN0IHsgZGVzY3JpcHRpb24sIHZhbHVlLCBjaGF0SWQgfSA9IHByb3BzO1xuICBjb25zdCBbbGF5ZXJLZXksIHNldExheWVyS2V5XSA9IHVzZVN0YXRlKCk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGNvbnN0IHsgbGF5ZXJLZXk6IGxheWVyS2V5MiwgZGVyZWdpc3RlciB9ID0gYWkucmVnaXN0ZXJLbm93bGVkZ2VMYXllcihsYXllcklkLCBjaGF0SWQpO1xuICAgIHNldExheWVyS2V5KGxheWVyS2V5Mik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlcmVnaXN0ZXIoKTtcbiAgICAgIHNldExheWVyS2V5KHZvaWQgMCk7XG4gICAgfTtcbiAgfSwgW2FpLCBsYXllcklkLCBjaGF0SWRdKTtcbiAgY29uc3QgcmFuZG9tS2V5ID0gdXNlUmFuZG9tKCk7XG4gIGNvbnN0IGtub3dsZWRnZUtleSA9IHByb3BzLmlkID8/IHJhbmRvbUtleTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKGxheWVyS2V5ICE9PSB2b2lkIDApIHtcbiAgICAgIGFpLnVwZGF0ZUtub3dsZWRnZShcbiAgICAgICAgbGF5ZXJLZXksXG4gICAgICAgIHsgZGVzY3JpcHRpb24sIHZhbHVlIH0sXG4gICAgICAgIGtub3dsZWRnZUtleSxcbiAgICAgICAgY2hhdElkXG4gICAgICApO1xuICAgIH1cbiAgfSwgW2FpLCBsYXllcktleSwga25vd2xlZGdlS2V5LCBkZXNjcmlwdGlvbiwgdmFsdWUsIGNoYXRJZF0pO1xuICByZXR1cm4gbnVsbDtcbn0pO1xudmFyIFJlZ2lzdGVyQWlUb29sID0gbWVtbyhmdW5jdGlvbiBSZWdpc3RlckFpVG9vbDIoe1xuICBjaGF0SWQsXG4gIG5hbWUsXG4gIHRvb2wsXG4gIGVuYWJsZWRcbn0pIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IGFpID0gY2xpZW50W2tJbnRlcm5hbF0uYWk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGNvbnN0IHRvb2xXaXRoRW5hYmxlZCA9IGVuYWJsZWQgIT09IHZvaWQgMCA/IHsgLi4udG9vbCwgZW5hYmxlZCB9IDogdG9vbDtcbiAgICByZXR1cm4gYWkucmVnaXN0ZXJUb29sKG5hbWUsIHRvb2xXaXRoRW5hYmxlZCwgY2hhdElkKTtcbiAgfSwgW2FpLCBjaGF0SWQsIG5hbWUsIHRvb2wsIGVuYWJsZWRdKTtcbiAgcmV0dXJuIG51bGw7XG59KTtcblxuLy8gc3JjL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IudHNcbmltcG9ydCB7XG4gIHVzZURlYnVnVmFsdWUsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzLFxuICB1c2VNZW1vLFxuICB1c2VSZWYgYXMgdXNlUmVmMixcbiAgdXNlU3luY0V4dGVybmFsU3RvcmVcbn0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5O1xufVxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3Ioc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IGluc3RSZWYgPSB1c2VSZWYyKG51bGwpO1xuICBsZXQgaW5zdDtcbiAgaWYgKGluc3RSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgIGluc3QgPSB7XG4gICAgICBoYXNWYWx1ZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH07XG4gICAgaW5zdFJlZi5jdXJyZW50ID0gaW5zdDtcbiAgfSBlbHNlIHtcbiAgICBpbnN0ID0gaW5zdFJlZi5jdXJyZW50O1xuICB9XG4gIGNvbnN0IFtnZXRTZWxlY3Rpb24sIGdldFNlcnZlclNlbGVjdGlvbl0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgaGFzTWVtbyA9IGZhbHNlO1xuICAgIGxldCBtZW1vaXplZFNuYXBzaG90O1xuICAgIGxldCBtZW1vaXplZFNlbGVjdGlvbjtcbiAgICBjb25zdCBtZW1vaXplZFNlbGVjdG9yID0gKG5leHRTbmFwc2hvdCkgPT4ge1xuICAgICAgaWYgKCFoYXNNZW1vKSB7XG4gICAgICAgIGhhc01lbW8gPSB0cnVlO1xuICAgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgICBjb25zdCBuZXh0U2VsZWN0aW9uMiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7XG4gICAgICAgIGlmIChpc0VxdWFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBpZiAoaW5zdC5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGluc3QudmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uMikpIHtcbiAgICAgICAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBuZXh0U2VsZWN0aW9uMjtcbiAgICAgICAgcmV0dXJuIG5leHRTZWxlY3Rpb24yO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldlNuYXBzaG90ID0gbWVtb2l6ZWRTbmFwc2hvdDtcbiAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBtZW1vaXplZFNlbGVjdGlvbjtcbiAgICAgIGlmIChpcyhwcmV2U25hcHNob3QsIG5leHRTbmFwc2hvdCkpIHtcbiAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTtcbiAgICAgIGlmIChpc0VxdWFsICE9PSB2b2lkIDAgJiYgaXNFcXVhbChwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgICByZXR1cm4gcHJldlNlbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG4gICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTZWxlY3Rpb247XG4gICAgICByZXR1cm4gbmV4dFNlbGVjdGlvbjtcbiAgICB9O1xuICAgIGNvbnN0IG1heWJlR2V0U2VydmVyU25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdm9pZCAwID8gbnVsbCA6IGdldFNlcnZlclNuYXBzaG90O1xuICAgIGNvbnN0IGdldFNuYXBzaG90V2l0aFNlbGVjdG9yID0gKCkgPT4gbWVtb2l6ZWRTZWxlY3RvcihnZXRTbmFwc2hvdCgpKTtcbiAgICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3RvciA9IG1heWJlR2V0U2VydmVyU25hcHNob3QgPT09IG51bGwgPyB2b2lkIDAgOiAoKSA9PiBtZW1vaXplZFNlbGVjdG9yKG1heWJlR2V0U2VydmVyU25hcHNob3QoKSk7XG4gICAgcmV0dXJuIFtnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciwgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3JdO1xuICB9LCBbZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbF0pO1xuICBjb25zdCB2YWx1ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgIHN1YnNjcmliZSxcbiAgICBnZXRTZWxlY3Rpb24sXG4gICAgZ2V0U2VydmVyU2VsZWN0aW9uXG4gICk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGluc3QuaGFzVmFsdWUgPSB0cnVlO1xuICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy91c2Utc2lnbmFsLnRzXG5pbXBvcnQgeyBNdXRhYmxlU2lnbmFsIH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBpZGVudGl0eSA9ICh2YWx1ZSkgPT4gdmFsdWU7XG5mdW5jdGlvbiB1c2VTaWduYWwoc2lnbmFsLCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICBpZiAoc2lnbmFsIGluc3RhbmNlb2YgTXV0YWJsZVNpZ25hbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVXNpbmcgYSBtdXRhYmxlIFNpZ25hbCB3aXRoIHVzZVNpZ25hbCB3aWxsIGxpa2VseSBub3Qgd29yayBhcyBleHBlY3RlZC5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHNpZ25hbC5zdWJzY3JpYmUsXG4gICAgc2lnbmFsLmdldCxcbiAgICBzaWduYWwuZ2V0LFxuICAgIHNlbGVjdG9yID8/IGlkZW50aXR5LFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG5pbXBvcnQge1xuICBhc3NlcnQsXG4gIGNvbnNvbGUgYXMgY29uc29sZTIsXG4gIGNyZWF0ZUNsaWVudCxcbiAgRGVmYXVsdE1hcCBhcyBEZWZhdWx0TWFwMixcbiAgSHR0cEVycm9yLFxuICBrSW50ZXJuYWwgYXMga0ludGVybmFsMyxcbiAgbWFrZVBvbGxlcixcbiAgcmFpc2UgYXMgcmFpc2UyLFxuICBzaGFsbG93IGFzIHNoYWxsb3czXG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQge1xuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8zLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlMlxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2NvbmZpZy50c1xudmFyIFNFQ09ORFMgPSAxZTM7XG52YXIgTUlOVVRFUyA9IDYwICogU0VDT05EUztcbnZhciBjb25maWcgPSB7XG4gIFNNT09USF9ERUxBWTogMSAqIFNFQ09ORFMsXG4gIE5PVElGSUNBVElPTlNfUE9MTF9JTlRFUlZBTDogMSAqIE1JTlVURVMsXG4gIE5PVElGSUNBVElPTlNfTUFYX1NUQUxFX1RJTUU6IDUgKiBTRUNPTkRTLFxuICBST09NX1RIUkVBRFNfUE9MTF9JTlRFUlZBTDogNSAqIE1JTlVURVMsXG4gIFJPT01fVEhSRUFEU19NQVhfU1RBTEVfVElNRTogNSAqIFNFQ09ORFMsXG4gIFVTRVJfVEhSRUFEU19QT0xMX0lOVEVSVkFMOiAxICogTUlOVVRFUyxcbiAgVVNFUl9USFJFQURTX01BWF9TVEFMRV9USU1FOiAzMCAqIFNFQ09ORFMsXG4gIEhJU1RPUllfVkVSU0lPTlNfUE9MTF9JTlRFUlZBTDogMSAqIE1JTlVURVMsXG4gIEhJU1RPUllfVkVSU0lPTlNfTUFYX1NUQUxFX1RJTUU6IDUgKiBTRUNPTkRTLFxuICBST09NX1NVQlNDUklQVElPTl9TRVRUSU5HU19QT0xMX0lOVEVSVkFMOiAxICogTUlOVVRFUyxcbiAgUk9PTV9TVUJTQ1JJUFRJT05fU0VUVElOR1NfTUFYX1NUQUxFX1RJTUU6IDUgKiBTRUNPTkRTLFxuICBVU0VSX05PVElGSUNBVElPTl9TRVRUSU5HU19JTlRFUlZBTDogNSAqIE1JTlVURVMsXG4gIFVTRVJfTk9USUZJQ0FUSU9OX1NFVFRJTkdTX01BWF9TVEFMRV9USU1FOiAxICogTUlOVVRFU1xufTtcblxuLy8gc3JjL2xpYi9Bc3luY1Jlc3VsdC50c1xudmFyIEFTWU5DX0xPQURJTkcgPSBPYmplY3QuZnJlZXplKHsgaXNMb2FkaW5nOiB0cnVlIH0pO1xudmFyIEFTWU5DX0VSUiA9IChlcnJvcikgPT4gT2JqZWN0LmZyZWV6ZSh7IGlzTG9hZGluZzogZmFsc2UsIGVycm9yIH0pO1xuZnVuY3Rpb24gQVNZTkNfT0soZmllbGRPckRhdGEsIGRhdGEpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGlzTG9hZGluZzogZmFsc2UsIGRhdGE6IGZpZWxkT3JEYXRhIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgaXNMb2FkaW5nOiBmYWxzZSwgW2ZpZWxkT3JEYXRhXTogZGF0YSB9KTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL3Nzci50c1xuZnVuY3Rpb24gZW5zdXJlTm90U2VydmVyU2lkZSgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3QgdXNlIHRoZSBTdXNwZW5zZSB2ZXJzaW9uIG9mIExpdmVibG9ja3MgaG9va3Mgc2VydmVyIHNpZGUuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgdGhlbSBjbGllbnQgc2lkZSBieSB1c2luZyBhIENsaWVudFNpZGVTdXNwZW5zZSB3cmFwcGVyLlxcbkZvciB0aXBzLCBzZWUgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLXJlYWN0I0NsaWVudFNpZGVTdXNwZW5zZVwiXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL3VzZS1pbml0aWFsLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyBhcyB1c2VNZW1vMiB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlSW5pdGlhbCh2YWx1ZSwgcm9vbUlkKSB7XG4gIHJldHVybiB1c2VNZW1vMigoKSA9PiB2YWx1ZSwgW3Jvb21JZF0pO1xufVxuZnVuY3Rpb24gdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKGxhdGVzdFZhbHVlLCByb29tSWQpIHtcbiAgY29uc3QgZnJvemVuVmFsdWUgPSB1c2VJbml0aWFsKGxhdGVzdFZhbHVlLCByb29tSWQpO1xuICBjb25zdCByZWYgPSB1c2VMYXRlc3QobGF0ZXN0VmFsdWUpO1xuICBjb25zdCB3cmFwcGVyID0gdXNlQ2FsbGJhY2soXG4gICAgKC4uLmFyZ3MpID0+IHJlZi5jdXJyZW50KC4uLmFyZ3MpLFxuICAgIFtyZWZdXG4gICk7XG4gIGlmICh0eXBlb2YgZnJvemVuVmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB3cmFwcGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm96ZW5WYWx1ZTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL3VzZS1wb2x5ZmlsbC50c1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG52YXIgcmVhY3RVc2UgPSBSZWFjdFtcIiB1c2UgXCIudHJpbSgpLnRvU3RyaW5nKCldO1xudmFyIHVzZSA9IHJlYWN0VXNlID8/ICgocHJvbWlzZSkgPT4ge1xuICBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgIHJldHVybiBwcm9taXNlLnZhbHVlO1xuICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICB0aHJvdyBwcm9taXNlLnJlYXNvbjtcbiAgfSBlbHNlIHtcbiAgICBwcm9taXNlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIHByb21pc2UudGhlbihcbiAgICAgICh2KSA9PiB7XG4gICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHY7XG4gICAgICB9LFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgIHByb21pc2UucmVhc29uID0gZTtcbiAgICAgIH1cbiAgICApO1xuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn0pO1xuXG4vLyBzcmMvdW1icmVsbGEtc3RvcmUudHNcbmltcG9ydCB7XG4gIGFzc2VydE5ldmVyLFxuICBhdXRvUmV0cnksXG4gIGJhdGNoIGFzIGJhdGNoMixcbiAgY29tcGFjdE9iamVjdCxcbiAgY29uc29sZSxcbiAgY3JlYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIERlZmF1bHRNYXAsXG4gIERlcml2ZWRTaWduYWwsXG4gIGdldFN1YnNjcmlwdGlvbktleSBhcyBnZXRTdWJzY3JpcHRpb25LZXkyLFxuICBrSW50ZXJuYWwgYXMga0ludGVybmFsMixcbiAgTXV0YWJsZVNpZ25hbCBhcyBNdXRhYmxlU2lnbmFsMyxcbiAgbmFub2lkIGFzIG5hbm9pZDIsXG4gIG5uLFxuICBwYXRjaE5vdGlmaWNhdGlvblNldHRpbmdzLFxuICBzaGFsbG93LFxuICBzaGFsbG93MixcbiAgU2lnbmFsLFxuICBzdGFibGVTdHJpbmdpZnlcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcblxuLy8gc3JjL2xpYi9hdXRvYmluZC50c1xuZnVuY3Rpb24gYXV0b2JpbmQoc2VsZikge1xuICBjb25zdCBzZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgc2Vlbi5hZGQoXCJjb25zdHJ1Y3RvclwiKTtcbiAgbGV0IG9iaiA9IHNlbGYuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICBkbyB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdC5vd25LZXlzKG9iaikpIHtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3I/LnZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgc2VsZltrZXldID0gc2VsZltrZXldLmJpbmQoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgob2JqID0gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihvYmopKSAmJiBvYmogIT09IE9iamVjdC5wcm90b3R5cGUpO1xufVxuXG4vLyBzcmMvbGliL2l0ZXJ0b29scy50c1xuZnVuY3Rpb24gZmluZChpdCwgcHJlZGljYXRlKSB7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBpdCkge1xuICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHJldHVybiBpdGVtO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHNyYy9saWIvcXVlcnlpbmcudHNcbmltcG9ydCB7XG4gIGdldFN1YnNjcmlwdGlvbktleSxcbiAgaXNOdW1iZXJPcGVyYXRvcixcbiAgaXNTdGFydHNXaXRoT3BlcmF0b3Jcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmZ1bmN0aW9uIG1ha2VUaHJlYWRzRmlsdGVyKHF1ZXJ5LCBzdWJzY3JpcHRpb25zKSB7XG4gIHJldHVybiAodGhyZWFkKSA9PiBtYXRjaGVzVGhyZWFkc1F1ZXJ5KHRocmVhZCwgcXVlcnksIHN1YnNjcmlwdGlvbnMpICYmIG1hdGNoZXNNZXRhZGF0YSh0aHJlYWQsIHF1ZXJ5KTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNUaHJlYWRzUXVlcnkodGhyZWFkLCBxLCBzdWJzY3JpcHRpb25zKSB7XG4gIGxldCBzdWJzY3JpcHRpb24gPSB2b2lkIDA7XG4gIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9ucz8uW2dldFN1YnNjcmlwdGlvbktleShcInRocmVhZFwiLCB0aHJlYWQuaWQpXTtcbiAgfVxuICByZXR1cm4gKHEucmVzb2x2ZWQgPT09IHZvaWQgMCB8fCB0aHJlYWQucmVzb2x2ZWQgPT09IHEucmVzb2x2ZWQpICYmIChxLnN1YnNjcmliZWQgPT09IHZvaWQgMCB8fCBxLnN1YnNjcmliZWQgPT09IHRydWUgJiYgc3Vic2NyaXB0aW9uICE9PSB2b2lkIDAgfHwgcS5zdWJzY3JpYmVkID09PSBmYWxzZSAmJiBzdWJzY3JpcHRpb24gPT09IHZvaWQgMCk7XG59XG5mdW5jdGlvbiBtYXRjaGVzTWV0YWRhdGEodGhyZWFkLCBxKSB7XG4gIGNvbnN0IG1ldGFkYXRhID0gdGhyZWFkLm1ldGFkYXRhO1xuICByZXR1cm4gcS5tZXRhZGF0YSA9PT0gdm9pZCAwIHx8IE9iamVjdC5lbnRyaWVzKHEubWV0YWRhdGEpLmV2ZXJ5KFxuICAgIChba2V5LCBvcF0pID0+IChcbiAgICAgIC8vIElnbm9yZSBleHBsaWNpdC11bmRlZmluZWQgZmlsdGVyc1xuICAgICAgLy8gQm9vbGVhbiBsb2dpYzogb3A/ID0+IHZhbHVlIG1hdGNoZXMgdGhlIG9wZXJhdG9yXG4gICAgICBvcCA9PT0gdm9pZCAwIHx8IG1hdGNoZXNPcGVyYXRvcihtZXRhZGF0YVtrZXldLCBvcClcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBtYXRjaGVzT3BlcmF0b3IodmFsdWUsIG9wKSB7XG4gIGlmIChvcCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwO1xuICB9IGVsc2UgaWYgKGlzU3RhcnRzV2l0aE9wZXJhdG9yKG9wKSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChvcC5zdGFydHNXaXRoKTtcbiAgfSBlbHNlIGlmIChpc051bWJlck9wZXJhdG9yKG9wKSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgbWF0Y2hlc051bWJlck9wZXJhdG9yKHZhbHVlLCBvcCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBvcDtcbiAgfVxufVxuZnVuY3Rpb24gbWF0Y2hlc051bWJlck9wZXJhdG9yKHZhbHVlLCBvcCkge1xuICByZXR1cm4gKG9wLmx0ID09PSB2b2lkIDAgfHwgdmFsdWUgPCBvcC5sdCkgJiYgKG9wLmd0ID09PSB2b2lkIDAgfHwgdmFsdWUgPiBvcC5ndCkgJiYgKG9wLmx0ZSA9PT0gdm9pZCAwIHx8IHZhbHVlIDw9IG9wLmx0ZSkgJiYgKG9wLmd0ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID49IG9wLmd0ZSk7XG59XG5mdW5jdGlvbiBtYWtlSW5ib3hOb3RpZmljYXRpb25zRmlsdGVyKHF1ZXJ5KSB7XG4gIHJldHVybiAoaW5ib3hOb3RpZmljYXRpb24pID0+IG1hdGNoZXNJbmJveE5vdGlmaWNhdGlvbnNRdWVyeShpbmJveE5vdGlmaWNhdGlvbiwgcXVlcnkpO1xufVxuZnVuY3Rpb24gbWF0Y2hlc0luYm94Tm90aWZpY2F0aW9uc1F1ZXJ5KGluYm94Tm90aWZpY2F0aW9uLCBxKSB7XG4gIHJldHVybiAocS5yb29tSWQgPT09IHZvaWQgMCB8fCBxLnJvb21JZCA9PT0gaW5ib3hOb3RpZmljYXRpb24ucm9vbUlkKSAmJiAocS5raW5kID09PSB2b2lkIDAgfHwgcS5raW5kID09PSBpbmJveE5vdGlmaWNhdGlvbi5raW5kKTtcbn1cblxuLy8gc3JjL1RocmVhZERCLnRzXG5pbXBvcnQgeyBiYXRjaCwgTXV0YWJsZVNpZ25hbCBhcyBNdXRhYmxlU2lnbmFsMiwgU29ydGVkTGlzdCB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5mdW5jdGlvbiBzYW5pdGl6ZVRocmVhZCh0aHJlYWQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQpIHtcbiAgICBpZiAodGhyZWFkLmNvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7IC4uLnRocmVhZCwgY29tbWVudHM6IFtdIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhc0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuc29tZSgoYykgPT4gIWMuZGVsZXRlZEF0KTtcbiAgaWYgKCFoYXNDb21tZW50KSB7XG4gICAgcmV0dXJuIHsgLi4udGhyZWFkLCBkZWxldGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBjb21tZW50czogW10gfTtcbiAgfVxuICByZXR1cm4gdGhyZWFkO1xufVxudmFyIFRocmVhZERCID0gY2xhc3MgX1RocmVhZERCIHtcbiAgI2J5SWQ7XG4gICNhc2M7XG4gICNkZXNjO1xuICAvLyBUaGlzIHNpZ25hbCB3aWxsIGJlIG5vdGlmaWVkIG9uIGV2ZXJ5IG11dGF0aW9uXG4gIHNpZ25hbDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy4jYXNjID0gU29ydGVkTGlzdC5mcm9tKFtdLCAodDEsIHQyKSA9PiB7XG4gICAgICBjb25zdCBkMSA9IHQxLmNyZWF0ZWRBdDtcbiAgICAgIGNvbnN0IGQyID0gdDIuY3JlYXRlZEF0O1xuICAgICAgcmV0dXJuIGQxIDwgZDIgPyB0cnVlIDogZDEgPT09IGQyID8gdDEuaWQgPCB0Mi5pZCA6IGZhbHNlO1xuICAgIH0pO1xuICAgIHRoaXMuI2Rlc2MgPSBTb3J0ZWRMaXN0LmZyb20oW10sICh0MSwgdDIpID0+IHtcbiAgICAgIGNvbnN0IGQyID0gdDIudXBkYXRlZEF0O1xuICAgICAgY29uc3QgZDEgPSB0MS51cGRhdGVkQXQ7XG4gICAgICByZXR1cm4gZDIgPCBkMSA/IHRydWUgOiBkMiA9PT0gZDEgPyB0Mi5pZCA8IHQxLmlkIDogZmFsc2U7XG4gICAgfSk7XG4gICAgdGhpcy4jYnlJZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5zaWduYWwgPSBuZXcgTXV0YWJsZVNpZ25hbDIodGhpcyk7XG4gIH1cbiAgLy9cbiAgLy8gUHVibGljIEFQSXNcbiAgLy9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbmV3UG9vbCA9IG5ldyBfVGhyZWFkREIoKTtcbiAgICBuZXdQb29sLiNieUlkID0gbmV3IE1hcCh0aGlzLiNieUlkKTtcbiAgICBuZXdQb29sLiNhc2MgPSB0aGlzLiNhc2MuY2xvbmUoKTtcbiAgICBuZXdQb29sLiNkZXNjID0gdGhpcy4jZGVzYy5jbG9uZSgpO1xuICAgIHJldHVybiBuZXdQb29sO1xuICB9XG4gIC8qKiBSZXR1cm5zIGFuIGV4aXN0aW5nIHRocmVhZCBieSBJRC4gV2lsbCBuZXZlciByZXR1cm4gYSBkZWxldGVkIHRocmVhZC4gKi9cbiAgZ2V0KHRocmVhZElkKSB7XG4gICAgY29uc3QgdGhyZWFkID0gdGhpcy5nZXRFdmVuSWZEZWxldGVkKHRocmVhZElkKTtcbiAgICByZXR1cm4gdGhyZWFkPy5kZWxldGVkQXQgPyB2b2lkIDAgOiB0aHJlYWQ7XG4gIH1cbiAgLyoqIFJldHVybnMgdGhlIChwb3NzaWJseSBkZWxldGVkKSB0aHJlYWQgYnkgSUQuICovXG4gIGdldEV2ZW5JZkRlbGV0ZWQodGhyZWFkSWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYnlJZC5nZXQodGhyZWFkSWQpO1xuICB9XG4gIC8qKiBBZGRzIG9yIHVwZGF0ZXMgYSB0aHJlYWQgaW4gdGhlIERCLiBJZiB0aGUgbmV3bHkgZ2l2ZW4gdGhyZWFkIGlzIGEgZGVsZXRlZCBvbmUsIGl0IHdpbGwgZ2V0IGRlbGV0ZWQuICovXG4gIHVwc2VydCh0aHJlYWQpIHtcbiAgICB0aGlzLnNpZ25hbC5tdXRhdGUoKCkgPT4ge1xuICAgICAgdGhyZWFkID0gc2FuaXRpemVUaHJlYWQodGhyZWFkKTtcbiAgICAgIGNvbnN0IGlkID0gdGhyZWFkLmlkO1xuICAgICAgY29uc3QgdG9SZW1vdmUgPSB0aGlzLiNieUlkLmdldChpZCk7XG4gICAgICBpZiAodG9SZW1vdmUpIHtcbiAgICAgICAgaWYgKHRvUmVtb3ZlLmRlbGV0ZWRBdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLiNhc2MucmVtb3ZlKHRvUmVtb3ZlKTtcbiAgICAgICAgdGhpcy4jZGVzYy5yZW1vdmUodG9SZW1vdmUpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aHJlYWQuZGVsZXRlZEF0KSB7XG4gICAgICAgIHRoaXMuI2FzYy5hZGQodGhyZWFkKTtcbiAgICAgICAgdGhpcy4jZGVzYy5hZGQodGhyZWFkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2J5SWQuc2V0KGlkLCB0aHJlYWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgLyoqIExpa2UgLnVwc2VydCgpLCBleGNlcHQgaXQgd29uJ3QgdXBkYXRlIGlmIGEgdGhyZWFkIGJ5IHRoaXMgSUQgYWxyZWFkeSBleGlzdHMuICovXG4gIC8vIFRPRE8gQ29uc2lkZXIgcmVuYW1pbmcgdGhpcyB0byBqdXN0IC51cHNlcnQoKS4gSSdtIG5vdCBzdXJlIGlmIHdlIHJlYWxseVxuICAvLyBUT0RPIG5lZWQgdGhlIHJhdyAudXBzZXJ0KCkuIFdvdWxkIGJlIG5pY2UgaWYgdGhpcyBiZWhhdmlvciB3YXMgdGhlIGRlZmF1bHQuXG4gIHVwc2VydElmTmV3ZXIodGhyZWFkKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmdldCh0aHJlYWQuaWQpO1xuICAgIGlmICghZXhpc3RpbmcgfHwgdGhyZWFkLnVwZGF0ZWRBdCA+PSBleGlzdGluZy51cGRhdGVkQXQpIHtcbiAgICAgIHRoaXMudXBzZXJ0KHRocmVhZCk7XG4gICAgfVxuICB9XG4gIGFwcGx5RGVsdGEobmV3VGhyZWFkcywgZGVsZXRlZFRocmVhZHMpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHRocmVhZCBvZiBuZXdUaHJlYWRzKSB7XG4gICAgICAgIHRoaXMudXBzZXJ0SWZOZXdlcih0aHJlYWQpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB7IGlkLCBkZWxldGVkQXQgfSBvZiBkZWxldGVkVGhyZWFkcykge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZ2V0RXZlbklmRGVsZXRlZChpZCk7XG4gICAgICAgIGlmICghZXhpc3RpbmcpIGNvbnRpbnVlO1xuICAgICAgICB0aGlzLmRlbGV0ZShpZCwgZGVsZXRlZEF0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTWFya3MgYSB0aHJlYWQgYXMgZGVsZXRlZC4gSXQgd2lsbCBubyBsb25nZXIgcG9wIHVwIGluIC5maW5kTWFueSgpXG4gICAqIHF1ZXJpZXMsIGJ1dCBpdCBjYW4gc3RpbGwgYmUgYWNjZXNzZWQgdmlhIGAuZ2V0RXZlbklmRGVsZXRlZCgpYC5cbiAgICovXG4gIGRlbGV0ZSh0aHJlYWRJZCwgZGVsZXRlZEF0KSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLiNieUlkLmdldCh0aHJlYWRJZCk7XG4gICAgaWYgKGV4aXN0aW5nICYmICFleGlzdGluZy5kZWxldGVkQXQpIHtcbiAgICAgIHRoaXMudXBzZXJ0KHsgLi4uZXhpc3RpbmcsIGRlbGV0ZWRBdCwgdXBkYXRlZEF0OiBkZWxldGVkQXQgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCB0aHJlYWRzIG1hdGNoaW5nIGEgZ2l2ZW4gcm9vbUlkIGFuZCBxdWVyeS4gSWYgcm9vbUlkIGlzIG5vdFxuICAgKiBzcGVjaWZpZWQsIGl0IHdpbGwgcmV0dXJuIGFsbCB0aHJlYWRzIG1hdGNoaW5nIHRoZSBxdWVyeSwgYWNyb3NzIGFsbFxuICAgKiByb29tcy5cbiAgICpcbiAgICogUmV0dXJucyB0aGUgcmVzdWx0cyBpbiB0aGUgcmVxdWVzdGVkIG9yZGVyLiBQbGVhc2Ugbm90ZTpcbiAgICogICAnYXNjJyAgbWVhbnMgYnkgY3JlYXRlZEF0IEFTQ1xuICAgKiAgICdkZXNjJyBtZWFucyBieSB1cGRhdGVkQXQgREVTQ1xuICAgKlxuICAgKiBXaWxsIG5ldmVyIHJldHVybiBkZWxldGVkIHRocmVhZHMgaW4gdGhlIHJlc3VsdC5cbiAgICpcbiAgICogU3Vic2NyaXB0aW9ucyBhcmUgbmVlZGVkIHRvIGZpbHRlciB0aHJlYWRzIGJhc2VkIG9uIHRoZSB1c2VyJ3Mgc3Vic2NyaXB0aW9ucy5cbiAgICovXG4gIGZpbmRNYW55KHJvb21JZCwgcXVlcnksIGRpcmVjdGlvbiwgc3Vic2NyaXB0aW9ucykge1xuICAgIGNvbnN0IGluZGV4ID0gZGlyZWN0aW9uID09PSBcImRlc2NcIiA/IHRoaXMuI2Rlc2MgOiB0aGlzLiNhc2M7XG4gICAgY29uc3QgY3JpdCA9IFtdO1xuICAgIGlmIChyb29tSWQgIT09IHZvaWQgMCkge1xuICAgICAgY3JpdC5wdXNoKCh0KSA9PiB0LnJvb21JZCA9PT0gcm9vbUlkKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5ICE9PSB2b2lkIDApIHtcbiAgICAgIGNyaXQucHVzaChtYWtlVGhyZWFkc0ZpbHRlcihxdWVyeSwgc3Vic2NyaXB0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShpbmRleC5maWx0ZXIoKHQpID0+IGNyaXQuZXZlcnkoKHByZWQpID0+IHByZWQodCkpKSk7XG4gIH1cbn07XG5cbi8vIHNyYy91bWJyZWxsYS1zdG9yZS50c1xuZnVuY3Rpb24gbWFrZVJvb21UaHJlYWRzUXVlcnlLZXkocm9vbUlkLCBxdWVyeSkge1xuICByZXR1cm4gc3RhYmxlU3RyaW5naWZ5KFtyb29tSWQsIHF1ZXJ5ID8/IHt9XSk7XG59XG5mdW5jdGlvbiBtYWtlVXNlclRocmVhZHNRdWVyeUtleShxdWVyeSkge1xuICByZXR1cm4gc3RhYmxlU3RyaW5naWZ5KHF1ZXJ5ID8/IHt9KTtcbn1cbmZ1bmN0aW9uIG1ha2VBaUNoYXRzUXVlcnlLZXkocXVlcnkpIHtcbiAgcmV0dXJuIHN0YWJsZVN0cmluZ2lmeShxdWVyeSA/PyB7fSk7XG59XG5mdW5jdGlvbiBtYWtlSW5ib3hOb3RpZmljYXRpb25zUXVlcnlLZXkocXVlcnkpIHtcbiAgcmV0dXJuIHN0YWJsZVN0cmluZ2lmeShxdWVyeSA/PyB7fSk7XG59XG5mdW5jdGlvbiB1c2lmeShwcm9taXNlKSB7XG4gIGlmIChcInN0YXR1c1wiIGluIHByb21pc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBjb25zdCB1c2FibGUgPSBwcm9taXNlO1xuICB1c2FibGUuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gIHVzYWJsZS50aGVuKFxuICAgICh2YWx1ZSkgPT4ge1xuICAgICAgdXNhYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICB1c2FibGUudmFsdWUgPSB2YWx1ZTtcbiAgICB9LFxuICAgIChlcnIpID0+IHtcbiAgICAgIHVzYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICB1c2FibGUucmVhc29uID0gZXJyO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHVzYWJsZTtcbn1cbnZhciBub29wID0gUHJvbWlzZS5yZXNvbHZlKCk7XG52YXIgUGFnaW5hdGVkUmVzb3VyY2UgPSBjbGFzcyB7XG4gICNzaWduYWw7XG4gIHNpZ25hbDtcbiAgI2ZldGNoUGFnZTtcbiAgI3BlbmRpbmdGZXRjaE1vcmU7XG4gIGNvbnN0cnVjdG9yKGZldGNoUGFnZSkge1xuICAgIHRoaXMuI3NpZ25hbCA9IG5ldyBTaWduYWwoQVNZTkNfTE9BRElORyk7XG4gICAgdGhpcy4jZmV0Y2hQYWdlID0gZmV0Y2hQYWdlO1xuICAgIHRoaXMuI3BlbmRpbmdGZXRjaE1vcmUgPSBudWxsO1xuICAgIHRoaXMuc2lnbmFsID0gdGhpcy4jc2lnbmFsLmFzUmVhZG9ubHkoKTtcbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NpZ25hbC5nZXQoKTtcbiAgfVxuICAjcGF0Y2gocGF0Y2gpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI3NpZ25hbC5nZXQoKTtcbiAgICBpZiAoc3RhdGUuZGF0YSA9PT0gdm9pZCAwKSByZXR1cm47XG4gICAgdGhpcy4jc2lnbmFsLnNldChBU1lOQ19PSyh7IC4uLnN0YXRlLmRhdGEsIC4uLnBhdGNoIH0pKTtcbiAgfVxuICBhc3luYyAjZmV0Y2hNb3JlKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jc2lnbmFsLmdldCgpO1xuICAgIGlmICghc3RhdGUuZGF0YT8uY3Vyc29yIHx8IHN0YXRlLmRhdGEuaXNGZXRjaGluZ01vcmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcGF0Y2goeyBpc0ZldGNoaW5nTW9yZTogdHJ1ZSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV4dEN1cnNvciA9IGF3YWl0IHRoaXMuI2ZldGNoUGFnZShzdGF0ZS5kYXRhLmN1cnNvcik7XG4gICAgICB0aGlzLiNwYXRjaCh7XG4gICAgICAgIGN1cnNvcjogbmV4dEN1cnNvcixcbiAgICAgICAgaGFzRmV0Y2hlZEFsbDogbmV4dEN1cnNvciA9PT0gbnVsbCxcbiAgICAgICAgZmV0Y2hNb3JlRXJyb3I6IHZvaWQgMCxcbiAgICAgICAgaXNGZXRjaGluZ01vcmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuI3BhdGNoKHtcbiAgICAgICAgaXNGZXRjaGluZ01vcmU6IGZhbHNlLFxuICAgICAgICBmZXRjaE1vcmVFcnJvcjogZXJyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZmV0Y2hNb3JlKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jc2lnbmFsLmdldCgpO1xuICAgIGlmICghc3RhdGUuZGF0YT8uY3Vyc29yKSByZXR1cm4gbm9vcDtcbiAgICBpZiAoIXRoaXMuI3BlbmRpbmdGZXRjaE1vcmUpIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdGZXRjaE1vcmUgPSB0aGlzLiNmZXRjaE1vcmUoKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0ZldGNoTW9yZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI3BlbmRpbmdGZXRjaE1vcmU7XG4gIH1cbiAgI2NhY2hlZFByb21pc2UgPSBudWxsO1xuICB3YWl0VW50aWxMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsUGFnZUZldGNoJCA9IGF1dG9SZXRyeShcbiAgICAgICgpID0+IHRoaXMuI2ZldGNoUGFnZShcbiAgICAgICAgLyogY3Vyc29yICovXG4gICAgICAgIHZvaWQgMFxuICAgICAgKSxcbiAgICAgIDUsXG4gICAgICBbNWUzLCA1ZTMsIDFlNCwgMTVlM11cbiAgICApO1xuICAgIGNvbnN0IHByb21pc2UgPSB1c2lmeShpbml0aWFsUGFnZUZldGNoJCk7XG4gICAgcHJvbWlzZS50aGVuKFxuICAgICAgKGN1cnNvcikgPT4ge1xuICAgICAgICB0aGlzLiNzaWduYWwuc2V0KFxuICAgICAgICAgIEFTWU5DX09LKHtcbiAgICAgICAgICAgIGN1cnNvcixcbiAgICAgICAgICAgIGhhc0ZldGNoZWRBbGw6IGN1cnNvciA9PT0gbnVsbCxcbiAgICAgICAgICAgIGlzRmV0Y2hpbmdNb3JlOiBmYWxzZSxcbiAgICAgICAgICAgIGZldGNoTW9yZUVycm9yOiB2b2lkIDAsXG4gICAgICAgICAgICBmZXRjaE1vcmU6IHRoaXMuZmV0Y2hNb3JlXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuI3NpZ25hbC5zZXQoQVNZTkNfRVJSKGVycikpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLiNjYWNoZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiNzaWduYWwuc2V0KEFTWU5DX0xPQURJTkcpO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy4jY2FjaGVkUHJvbWlzZSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlZFByb21pc2U7XG4gIH1cbn07XG52YXIgU2luZ2xlUGFnZVJlc291cmNlID0gY2xhc3Mge1xuICAjc2lnbmFsO1xuICBzaWduYWw7XG4gICNmZXRjaFBhZ2U7XG4gICNhdXRvUmV0cnkgPSB0cnVlO1xuICBjb25zdHJ1Y3RvcihmZXRjaFBhZ2UsIGF1dG9SZXRyeTIgPSB0cnVlKSB7XG4gICAgdGhpcy4jc2lnbmFsID0gbmV3IFNpZ25hbChBU1lOQ19MT0FESU5HKTtcbiAgICB0aGlzLnNpZ25hbCA9IHRoaXMuI3NpZ25hbC5hc1JlYWRvbmx5KCk7XG4gICAgdGhpcy4jZmV0Y2hQYWdlID0gZmV0Y2hQYWdlO1xuICAgIHRoaXMuI2F1dG9SZXRyeSA9IGF1dG9SZXRyeTI7XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLiNzaWduYWwuZ2V0KCk7XG4gIH1cbiAgI2NhY2hlZFByb21pc2UgPSBudWxsO1xuICB3YWl0VW50aWxMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsRmV0Y2hlciQgPSB0aGlzLiNhdXRvUmV0cnkgPyBhdXRvUmV0cnkoKCkgPT4gdGhpcy4jZmV0Y2hQYWdlKCksIDUsIFs1ZTMsIDVlMywgMWU0LCAxNWUzXSkgOiB0aGlzLiNmZXRjaFBhZ2UoKTtcbiAgICBjb25zdCBwcm9taXNlID0gdXNpZnkoaW5pdGlhbEZldGNoZXIkKTtcbiAgICBwcm9taXNlLnRoZW4oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuI3NpZ25hbC5zZXQoQVNZTkNfT0sodm9pZCAwKSk7XG4gICAgICB9LFxuICAgICAgKGVycikgPT4ge1xuICAgICAgICB0aGlzLiNzaWduYWwuc2V0KEFTWU5DX0VSUihlcnIpKTtcbiAgICAgICAgaWYgKHRoaXMuI2F1dG9SZXRyeSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jY2FjaGVkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLiNzaWduYWwuc2V0KEFTWU5DX0xPQURJTkcpO1xuICAgICAgICAgIH0sIDVlMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuI2NhY2hlZFByb21pc2UgPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlU3RvcmVfZm9yTm90aWZpY2F0aW9ucygpIHtcbiAgY29uc3Qgc2lnbmFsID0gbmV3IE11dGFibGVTaWduYWwzKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICBmdW5jdGlvbiBtYXJrUmVhZChub3RpZmljYXRpb25JZCwgcmVhZEF0KSB7XG4gICAgc2lnbmFsLm11dGF0ZSgobHV0KSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IGx1dC5nZXQobm90aWZpY2F0aW9uSWQpO1xuICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsdXQuc2V0KG5vdGlmaWNhdGlvbklkLCB7IC4uLmV4aXN0aW5nLCByZWFkQXQgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBtYXJrQWxsUmVhZChyZWFkQXQpIHtcbiAgICBzaWduYWwubXV0YXRlKChsdXQpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbiBvZiBsdXQudmFsdWVzKCkpIHtcbiAgICAgICAgbi5yZWFkQXQgPSByZWFkQXQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVsZXRlT25lKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBzaWduYWwubXV0YXRlKChsdXQpID0+IGx1dC5kZWxldGUoaW5ib3hOb3RpZmljYXRpb25JZCkpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHNpZ25hbC5tdXRhdGUoKGx1dCkgPT4gbHV0LmNsZWFyKCkpO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5RGVsdGEobmV3Tm90aWZpY2F0aW9ucywgZGVsZXRlZE5vdGlmaWNhdGlvbnMpIHtcbiAgICBzaWduYWwubXV0YXRlKChsdXQpID0+IHtcbiAgICAgIGxldCBtdXRhdGVkID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IG4gb2YgbmV3Tm90aWZpY2F0aW9ucykge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IGx1dC5nZXQobi5pZCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmVJbmJveE5vdGlmaWNhdGlvbnMoZXhpc3RpbmcsIG4pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IDEpIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGx1dC5zZXQobi5pZCwgbik7XG4gICAgICAgIG11dGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBuIG9mIGRlbGV0ZWROb3RpZmljYXRpb25zKSB7XG4gICAgICAgIGx1dC5kZWxldGUobi5pZCk7XG4gICAgICAgIG11dGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG11dGF0ZWQ7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlQXNzb2NpYXRlZE5vdGlmaWNhdGlvbihuZXdDb21tZW50KSB7XG4gICAgc2lnbmFsLm11dGF0ZSgobHV0KSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IGZpbmQoXG4gICAgICAgIGx1dC52YWx1ZXMoKSxcbiAgICAgICAgKG5vdGlmaWNhdGlvbikgPT4gbm90aWZpY2F0aW9uLmtpbmQgPT09IFwidGhyZWFkXCIgJiYgbm90aWZpY2F0aW9uLnRocmVhZElkID09PSBuZXdDb21tZW50LnRocmVhZElkXG4gICAgICApO1xuICAgICAgaWYgKCFleGlzdGluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgbHV0LnNldChleGlzdGluZy5pZCwge1xuICAgICAgICAuLi5leGlzdGluZyxcbiAgICAgICAgbm90aWZpZWRBdDogbmV3Q29tbWVudC5jcmVhdGVkQXQsXG4gICAgICAgIHJlYWRBdDogbmV3Q29tbWVudC5jcmVhdGVkQXRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0KG5vdGlmaWNhdGlvbikge1xuICAgIHNpZ25hbC5tdXRhdGUoKGx1dCkgPT4ge1xuICAgICAgbHV0LnNldChub3RpZmljYXRpb24uaWQsIG5vdGlmaWNhdGlvbik7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzaWduYWw6IHNpZ25hbC5hc1JlYWRvbmx5KCksXG4gICAgLy8gTXV0YXRpb25zXG4gICAgbWFya0FsbFJlYWQsXG4gICAgbWFya1JlYWQsXG4gICAgZGVsZXRlOiBkZWxldGVPbmUsXG4gICAgYXBwbHlEZWx0YSxcbiAgICBjbGVhcixcbiAgICB1cGRhdGVBc3NvY2lhdGVkTm90aWZpY2F0aW9uLFxuICAgIHVwc2VydFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RvcmVfZm9yVW5yZWFkTm90aWZpY2F0aW9uc0NvdW50KCkge1xuICBjb25zdCBiYXNlU2lnbmFsID0gbmV3IE11dGFibGVTaWduYWwzKFxuICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgKTtcbiAgZnVuY3Rpb24gdXBkYXRlKHF1ZXJ5S2V5LCBjb3VudCkge1xuICAgIGJhc2VTaWduYWwubXV0YXRlKChsdXQpID0+IHtcbiAgICAgIGx1dC5zZXQocXVlcnlLZXksIGNvdW50KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNpZ25hbDogRGVyaXZlZFNpZ25hbC5mcm9tKGJhc2VTaWduYWwsIChjKSA9PiBPYmplY3QuZnJvbUVudHJpZXMoYykpLFxuICAgIC8vIE11dGF0aW9uc1xuICAgIHVwZGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RvcmVfZm9yU3Vic2NyaXB0aW9ucyh1cGRhdGVzLCB0aHJlYWRzKSB7XG4gIGNvbnN0IGJhc2VTaWduYWwgPSBuZXcgTXV0YWJsZVNpZ25hbDMoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIGZ1bmN0aW9uIGFwcGx5RGVsdGEobmV3U3Vic2NyaXB0aW9ucywgZGVsZXRlZFN1YnNjcmlwdGlvbnMpIHtcbiAgICBiYXNlU2lnbmFsLm11dGF0ZSgobHV0KSA9PiB7XG4gICAgICBsZXQgbXV0YXRlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBzIG9mIG5ld1N1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgbHV0LnNldChnZXRTdWJzY3JpcHRpb25LZXkyKHMpLCBzKTtcbiAgICAgICAgbXV0YXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgZGVsZXRlZFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgbHV0LmRlbGV0ZShnZXRTdWJzY3JpcHRpb25LZXkyKHMpKTtcbiAgICAgICAgbXV0YXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbXV0YXRlZDtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGUoc3Vic2NyaXB0aW9uKSB7XG4gICAgYmFzZVNpZ25hbC5tdXRhdGUoKGx1dCkgPT4ge1xuICAgICAgbHV0LnNldChnZXRTdWJzY3JpcHRpb25LZXkyKHN1YnNjcmlwdGlvbiksIHN1YnNjcmlwdGlvbik7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVsZXRlT25lKHN1YnNjcmlwdGlvbktleSkge1xuICAgIGJhc2VTaWduYWwubXV0YXRlKChsdXQpID0+IHtcbiAgICAgIGx1dC5kZWxldGUoc3Vic2NyaXB0aW9uS2V5KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNpZ25hbDogRGVyaXZlZFNpZ25hbC5mcm9tKFxuICAgICAgYmFzZVNpZ25hbCxcbiAgICAgIHVwZGF0ZXMsXG4gICAgICAoYmFzZSwgdXBkYXRlczIpID0+IGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXNfZm9yU3Vic2NyaXB0aW9ucyhiYXNlLCB0aHJlYWRzLCB1cGRhdGVzMilcbiAgICApLFxuICAgIC8vIE11dGF0aW9uc1xuICAgIGFwcGx5RGVsdGEsXG4gICAgY3JlYXRlLFxuICAgIGRlbGV0ZTogZGVsZXRlT25lXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdG9yZV9mb3JSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3ModXBkYXRlcykge1xuICBjb25zdCBiYXNlU2lnbmFsID0gbmV3IE11dGFibGVTaWduYWwzKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICBmdW5jdGlvbiB1cGRhdGUocm9vbUlkLCBzZXR0aW5ncykge1xuICAgIGJhc2VTaWduYWwubXV0YXRlKChsdXQpID0+IHtcbiAgICAgIGx1dC5zZXQocm9vbUlkLCBzZXR0aW5ncyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzaWduYWw6IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICAgIGJhc2VTaWduYWwsXG4gICAgICB1cGRhdGVzLFxuICAgICAgKGJhc2UsIHVwZGF0ZXMyKSA9PiBhcHBseU9wdGltaXN0aWNVcGRhdGVzX2ZvclJvb21TdWJzY3JpcHRpb25TZXR0aW5ncyhiYXNlLCB1cGRhdGVzMilcbiAgICApLFxuICAgIC8vIE11dGF0aW9uc1xuICAgIHVwZGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RvcmVfZm9ySGlzdG9yeVZlcnNpb25zKCkge1xuICBjb25zdCBiYXNlU2lnbmFsID0gbmV3IE11dGFibGVTaWduYWwzKFxuICAgIG5ldyBEZWZhdWx0TWFwKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpXG4gICk7XG4gIGZ1bmN0aW9uIHVwZGF0ZShyb29tSWQsIHZlcnNpb25zKSB7XG4gICAgYmFzZVNpZ25hbC5tdXRhdGUoKGx1dCkgPT4ge1xuICAgICAgY29uc3QgdmVyc2lvbnNCeUlkID0gbHV0LmdldE9yQ3JlYXRlKHJvb21JZCk7XG4gICAgICBmb3IgKGNvbnN0IHZlcnNpb24gb2YgdmVyc2lvbnMpIHtcbiAgICAgICAgdmVyc2lvbnNCeUlkLnNldCh2ZXJzaW9uLmlkLCB2ZXJzaW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNpZ25hbDogRGVyaXZlZFNpZ25hbC5mcm9tKFxuICAgICAgYmFzZVNpZ25hbCxcbiAgICAgIChodikgPT4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBbLi4uaHZdLm1hcCgoW3Jvb21JZCwgdmVyc2lvbnNdKSA9PiBbXG4gICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgIE9iamVjdC5mcm9tRW50cmllcyh2ZXJzaW9ucylcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApLFxuICAgIC8vIE11dGF0aW9uc1xuICAgIHVwZGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RvcmVfZm9yVXJsc01ldGFkYXRhKCkge1xuICBjb25zdCBiYXNlU2lnbmFsID0gbmV3IE11dGFibGVTaWduYWwzKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICBmdW5jdGlvbiB1cGRhdGUodXJsLCBtZXRhZGF0YSkge1xuICAgIGJhc2VTaWduYWwubXV0YXRlKChsdXQpID0+IHtcbiAgICAgIGx1dC5zZXQodXJsLCBtZXRhZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzaWduYWw6IERlcml2ZWRTaWduYWwuZnJvbShiYXNlU2lnbmFsLCAobSkgPT4gT2JqZWN0LmZyb21FbnRyaWVzKG0pKSxcbiAgICAvLyBNdXRhdGlvbnNcbiAgICB1cGRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlX2ZvclBlcm1pc3Npb25IaW50cygpIHtcbiAgY29uc3QgcGVybWlzc2lvbnNCeVJvb21JZCA9IG5ldyBEZWZhdWx0TWFwKFxuICAgICgpID0+IG5ldyBTaWduYWwoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSlcbiAgKTtcbiAgZnVuY3Rpb24gdXBkYXRlKG5ld0hpbnRzKSB7XG4gICAgYmF0Y2gyKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgW3Jvb21JZCwgcGVybWlzc2lvbnNdIG9mIE9iamVjdC5lbnRyaWVzKG5ld0hpbnRzKSkge1xuICAgICAgICBjb25zdCBzaWduYWwgPSBwZXJtaXNzaW9uc0J5Um9vbUlkLmdldE9yQ3JlYXRlKHJvb21JZCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUGVybWlzc2lvbnMgPSBuZXcgU2V0KHNpZ25hbC5nZXQoKSk7XG4gICAgICAgIGZvciAoY29uc3QgcGVybWlzc2lvbiBvZiBwZXJtaXNzaW9ucykge1xuICAgICAgICAgIGV4aXN0aW5nUGVybWlzc2lvbnMuYWRkKHBlcm1pc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbC5zZXQoZXhpc3RpbmdQZXJtaXNzaW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UGVybWlzc2lvbkZvclJvb21cXHUwM0EzKHJvb21JZCkge1xuICAgIHJldHVybiBwZXJtaXNzaW9uc0J5Um9vbUlkLmdldE9yQ3JlYXRlKHJvb21JZCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRQZXJtaXNzaW9uRm9yUm9vbVxcdTAzQTMsXG4gICAgLy8gTXV0YXRpb25zXG4gICAgdXBkYXRlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdG9yZV9mb3JOb3RpZmljYXRpb25TZXR0aW5ncyh1cGRhdGVzKSB7XG4gIGNvbnN0IHNpZ25hbCA9IG5ldyBTaWduYWwoXG4gICAgY3JlYXRlTm90aWZpY2F0aW9uU2V0dGluZ3Moe30pXG4gICk7XG4gIGZ1bmN0aW9uIHVwZGF0ZShzZXR0aW5ncykge1xuICAgIHNpZ25hbC5zZXQoc2V0dGluZ3MpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2lnbmFsOiBEZXJpdmVkU2lnbmFsLmZyb20oXG4gICAgICBzaWduYWwsXG4gICAgICB1cGRhdGVzLFxuICAgICAgKGJhc2UsIHVwZGF0ZXMyKSA9PiBhcHBseU9wdGltaXN0aWNVcGRhdGVzX2Zvck5vdGlmaWNhdGlvblNldHRpbmdzKGJhc2UsIHVwZGF0ZXMyKVxuICAgICksXG4gICAgLy8gTXV0YXRpb25zXG4gICAgdXBkYXRlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdG9yZV9mb3JPcHRpbWlzdGljKGNsaWVudCkge1xuICBjb25zdCBzaWduYWwgPSBuZXcgU2lnbmFsKFtdKTtcbiAgY29uc3Qgc3luY1NvdXJjZSA9IGNsaWVudFtrSW50ZXJuYWwyXS5jcmVhdGVTeW5jU291cmNlKCk7XG4gIHNpZ25hbC5zdWJzY3JpYmUoXG4gICAgKCkgPT4gc3luY1NvdXJjZS5zZXRTeW5jU3RhdHVzKFxuICAgICAgc2lnbmFsLmdldCgpLmxlbmd0aCA+IDAgPyBcInN5bmNocm9uaXppbmdcIiA6IFwic3luY2hyb25pemVkXCJcbiAgICApXG4gICk7XG4gIGZ1bmN0aW9uIGFkZChvcHRpbWlzdGljVXBkYXRlKSB7XG4gICAgY29uc3QgaWQgPSBuYW5vaWQyKCk7XG4gICAgY29uc3QgbmV3VXBkYXRlID0geyAuLi5vcHRpbWlzdGljVXBkYXRlLCBpZCB9O1xuICAgIHNpZ25hbC5zZXQoKHN0YXRlKSA9PiBbLi4uc3RhdGUsIG5ld1VwZGF0ZV0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmUob3B0aW1pc3RpY0lkKSB7XG4gICAgc2lnbmFsLnNldCgoc3RhdGUpID0+IHN0YXRlLmZpbHRlcigob3UpID0+IG91LmlkICE9PSBvcHRpbWlzdGljSWQpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNpZ25hbDogc2lnbmFsLmFzUmVhZG9ubHkoKSxcbiAgICAvLyBNdXRhdGlvbnNcbiAgICBhZGQsXG4gICAgcmVtb3ZlXG4gIH07XG59XG52YXIgVW1icmVsbGFTdG9yZSA9IGNsYXNzIHtcbiAgI2NsaWVudDtcbiAgLy9cbiAgLy8gSW50ZXJuYWxseSwgdGhlIFVtYnJlbGxhU3RvcmUga2VlcHMgdHJhY2sgb2YgYSBmZXcgc291cmNlIHNpZ25hbHMgdGhhdCBjYW5cbiAgLy8gYmUgc2V0IGFuZCBtdXRhdGVkIGluZGl2aWR1YWxseS4gV2hlbiBhbnkgb2YgdGhvc2UgYXJlIG11dGF0ZWQgdGhlbiB0aGVcbiAgLy8gY2xlYW4gXCJleHRlcm5hbCBzdGF0ZVwiIGlzIHJlY29tcHV0ZWQuXG4gIC8vXG4gIC8vICAgTXV0YXRlIGlucHV0cy4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9ic2VydmUgY2xlYW4vY29uc2lzdGVudCBvdXRwdXQhXG4gIC8vXG4gIC8vICAgICAgICAgICAgLi0+IEJhc2UgVGhyZWFkREIgLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgKy0tLS0tLS0+IENsZWFuIHRocmVhZHMgYnkgSUQgICAgICAgICAoUGFydCAxKVxuICAvLyAgICAgICAgICAgLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbiAgLy8gICBtdXRhdGUgLS0tLT4gQmFzZSBOb3RpZmljYXRpb25zIC0tKyB8ICAgICAgICAgICAgICAgICB8ICstLS0tLT4gQ2xlYW4gbm90aWZpY2F0aW9ucyAgICAgICAgIChQYXJ0IDEpXG4gIC8vICAgICAgICAgIFxcICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgIHwgfCAgICAgICAmIG5vdGlmaWNhdGlvbnMgYnkgSURcbiAgLy8gICAgICAgICB8IFxcICAgICAgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgIEFwcGx5ICAgICAgfCB8XG4gIC8vICAgICAgICAgfCAgIGAtPiBPcHRpbWlzdGljVXBkYXRlcyAtLSstLSstLT4gT3B0aW1pc3RpYyAtKy0rLSstKy0+IFN1YnNjcmlwdGlvbnMgICAgICAgICAgICAgICAoUGFydCAyKVxuICAvLyAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgVXBkYXRlcyAgICB8ICAgfCB8XG4gIC8vICAgICAgICAgICBgLS0tLS0tLSBldGMgZXRjIC0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgfCAgIHwgKy0+IEhpc3RvcnkgVmVyc2lvbnMgICAgICAgICAgICAoUGFydCAzKVxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgXiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICB8XG4gIC8vICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0+IFJvb20gU3Vic2NyaXB0aW9uIFNldHRpbmdzICAoUGFydCA0KVxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLT4gTm90aWZpY2F0aW9uIFNldHRpbmdzICAgICAgIChQYXJ0IDUpXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICB8XG4gIC8vICAgICAgICAgICAgICAgICAgICAgICB8XG4gIC8vICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgXiAgICAgICAgICAgICAgICAgIF5cbiAgLy8gICAgICAgICAgICAgICAgICAgIFNpZ25hbCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgfFxuICAvLyAgICAgICAgICAgICAgICAgICAgICBvciAgICAgICAgICAgICAgICAgICBEZXJpdmVkU2lnbmFsICAgICAgRGVyaXZlZFNpZ25hbHNcbiAgLy8gICAgICAgICAgICAgICAgICBNdXRhYmxlU2lnbmFsXG4gIC8vXG4gIC8vXG4gIC8vIElucHV0IHNpZ25hbHMuXG4gIC8vIChDYW4gYmUgbXV0YXRlZCBkaXJlY3RseS4pXG4gIC8vXG4gIC8vIFhYWF92aW5jZW50IE5vdyB0aGF0IHdlIGhhdmUgY3JlYXRlU3RvcmVfZm9yWCwgd2Ugc2hvdWxkIHByb2JhYmx5IGFsc28gY2hhbmdlXG4gIC8vIGB0aHJlYWRzYCB0byB0aGlzIHBhdHRlcm4sIGllIGNyZWF0ZSBhIGNyZWF0ZVN0b3JlX2ZvclRocmVhZHMgaGVscGVyIGFzXG4gIC8vIHdlbGwuIEl0IGFsbW9zdCB3b3JrcyBsaWtlIHRoYXQgYWxyZWFkeSBhbnl3YXkhXG4gIHRocmVhZHM7XG4gIC8vIEV4cG9zZXMgaXRzIHNpZ25hbCB1bmRlciBgLnNpZ25hbGAgcHJvcFxuICBub3RpZmljYXRpb25zO1xuICBzdWJzY3JpcHRpb25zO1xuICByb29tU3Vic2NyaXB0aW9uU2V0dGluZ3M7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBoaXN0b3J5VmVyc2lvbnM7XG4gIHVucmVhZE5vdGlmaWNhdGlvbnNDb3VudDtcbiAgdXJsc01ldGFkYXRhO1xuICBwZXJtaXNzaW9uSGludHM7XG4gIG5vdGlmaWNhdGlvblNldHRpbmdzO1xuICBvcHRpbWlzdGljVXBkYXRlcztcbiAgLy9cbiAgLy8gT3V0cHV0IHNpZ25hbHMuXG4gIC8vIChSZWFkb25seSwgY2xlYW4sIGNvbnNpc3RlbnQuIFdpdGggb3B0aW1pc3RpYyB1cGRhdGVzIGFwcGxpZWQuKVxuICAvL1xuICAvLyBOb3RlIHRoYXQgdGhlIG91dHB1dCBvZiB0aHJlYWRpZmljYXRpb25zIHNpZ25hbCBpcyB0aGUgc2FtZSBhcyB0aGUgb25lcyBmb3JcbiAgLy8gdGhyZWFkcyBhbmQgbm90aWZpY2F0aW9ucyBzZXBhcmF0ZWx5LCBidXQgdGhlIHRocmVhZGlmaWNhdGlvbnMgc2lnbmFsIHdpbGxcbiAgLy8gYmUgdXBkYXRlZCB3aGVuZXZlciBlaXRoZXIgb2YgdGhlbSBjaGFuZ2UuXG4gIC8vXG4gIG91dHB1dHM7XG4gIC8vIE5vdGlmaWNhdGlvbnNcbiAgI25vdGlmaWNhdGlvbnNMYXN0UmVxdWVzdGVkQXQgPSBudWxsO1xuICAvLyBLZWVwcyB0cmFjayBvZiB3aGVuIHdlIHN1Y2Nlc3NmdWxseSByZXF1ZXN0ZWQgYW4gaW5ib3ggbm90aWZpY2F0aW9ucyB1cGRhdGUgZm9yIHRoZSBsYXN0IHRpbWUuIFdpbGwgYmUgYG51bGxgIGFzIGxvbmcgYXMgdGhlIGZpcnN0IHN1Y2Nlc3NmdWwgZmV0Y2ggaGFzbid0IGhhcHBlbmVkIHlldC5cbiAgLy8gUm9vbSBUaHJlYWRzXG4gICNyb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8vIFVzZXIgVGhyZWFkc1xuICAjdXNlclRocmVhZHNMYXN0UmVxdWVzdGVkQXQgPSBudWxsO1xuICAvLyBSb29tIHZlcnNpb25zXG4gICNyb29tVmVyc2lvbnNMYXN0UmVxdWVzdGVkQXRCeVJvb20gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvLyBOb3RpZmljYXRpb24gU2V0dGluZ3NcbiAgI25vdGlmaWNhdGlvblNldHRpbmdzO1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnRba0ludGVybmFsMl0uYXMoKTtcbiAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzID0gY3JlYXRlU3RvcmVfZm9yT3B0aW1pc3RpYyh0aGlzLiNjbGllbnQpO1xuICAgIHRoaXMucGVybWlzc2lvbkhpbnRzID0gY3JlYXRlU3RvcmVfZm9yUGVybWlzc2lvbkhpbnRzKCk7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uU2V0dGluZ3NGZXRjaGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jY2xpZW50LmdldE5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvblNldHRpbmdzLnVwZGF0ZShyZXN1bHQpO1xuICAgIH07XG4gICAgdGhpcy5ub3RpZmljYXRpb25TZXR0aW5ncyA9IGNyZWF0ZVN0b3JlX2Zvck5vdGlmaWNhdGlvblNldHRpbmdzKFxuICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5zaWduYWxcbiAgICApO1xuICAgIHRoaXMuI25vdGlmaWNhdGlvblNldHRpbmdzID0gbmV3IFNpbmdsZVBhZ2VSZXNvdXJjZShcbiAgICAgIG5vdGlmaWNhdGlvblNldHRpbmdzRmV0Y2hlclxuICAgICk7XG4gICAgdGhpcy50aHJlYWRzID0gbmV3IFRocmVhZERCKCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gY3JlYXRlU3RvcmVfZm9yU3Vic2NyaXB0aW9ucyhcbiAgICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMuc2lnbmFsLFxuICAgICAgdGhpcy50aHJlYWRzXG4gICAgKTtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBjcmVhdGVTdG9yZV9mb3JOb3RpZmljYXRpb25zKCk7XG4gICAgdGhpcy5yb29tU3Vic2NyaXB0aW9uU2V0dGluZ3MgPSBjcmVhdGVTdG9yZV9mb3JSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3MoXG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnNpZ25hbFxuICAgICk7XG4gICAgdGhpcy5oaXN0b3J5VmVyc2lvbnMgPSBjcmVhdGVTdG9yZV9mb3JIaXN0b3J5VmVyc2lvbnMoKTtcbiAgICB0aGlzLnVucmVhZE5vdGlmaWNhdGlvbnNDb3VudCA9IGNyZWF0ZVN0b3JlX2ZvclVucmVhZE5vdGlmaWNhdGlvbnNDb3VudCgpO1xuICAgIHRoaXMudXJsc01ldGFkYXRhID0gY3JlYXRlU3RvcmVfZm9yVXJsc01ldGFkYXRhKCk7XG4gICAgY29uc3QgdGhyZWFkaWZpY2F0aW9ucyA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICAgIHRoaXMudGhyZWFkcy5zaWduYWwsXG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMuc2lnbmFsLFxuICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5zaWduYWwsXG4gICAgICAodHMsIG5zLCB1cGRhdGVzKSA9PiBhcHBseU9wdGltaXN0aWNVcGRhdGVzX2ZvclRocmVhZGlmaWNhdGlvbnModHMsIG5zLCB1cGRhdGVzKVxuICAgICk7XG4gICAgY29uc3QgdGhyZWFkcyA9IERlcml2ZWRTaWduYWwuZnJvbSh0aHJlYWRpZmljYXRpb25zLCAocykgPT4gcy50aHJlYWRzREIpO1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBEZXJpdmVkU2lnbmFsLmZyb20oXG4gICAgICB0aHJlYWRpZmljYXRpb25zLFxuICAgICAgKHMpID0+ICh7XG4gICAgICAgIHNvcnRlZE5vdGlmaWNhdGlvbnM6IHMuc29ydGVkTm90aWZpY2F0aW9ucyxcbiAgICAgICAgbm90aWZpY2F0aW9uc0J5SWQ6IHMubm90aWZpY2F0aW9uc0J5SWRcbiAgICAgIH0pLFxuICAgICAgc2hhbGxvd1xuICAgICk7XG4gICAgY29uc3QgdGhyZWFkU3Vic2NyaXB0aW9ucyA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICAgIG5vdGlmaWNhdGlvbnMsXG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuc2lnbmFsLFxuICAgICAgKG4sIHMpID0+ICh7XG4gICAgICAgIHN1YnNjcmlwdGlvbnM6IHMsXG4gICAgICAgIG5vdGlmaWNhdGlvbnM6IG4uc29ydGVkTm90aWZpY2F0aW9uc1xuICAgICAgfSlcbiAgICApO1xuICAgIGNvbnN0IGxvYWRpbmdVc2VyVGhyZWFkcyA9IG5ldyBEZWZhdWx0TWFwKFxuICAgICAgKHF1ZXJ5S2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gSlNPTi5wYXJzZShxdWVyeUtleSk7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFBhZ2luYXRlZFJlc291cmNlKGFzeW5jIChjdXJzb3IpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnRba0ludGVybmFsMl0uaHR0cENsaWVudC5nZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWwoe1xuICAgICAgICAgICAgY3Vyc29yLFxuICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICAgICAgICByZXN1bHQudGhyZWFkcyxcbiAgICAgICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICByZXN1bHQuc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5wZXJtaXNzaW9uSGludHMudXBkYXRlKHJlc3VsdC5wZXJtaXNzaW9uSGludHMpO1xuICAgICAgICAgIGlmICh0aGlzLiN1c2VyVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdXNlclRocmVhZHNMYXN0UmVxdWVzdGVkQXQgPSByZXN1bHQucmVxdWVzdGVkQXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQubmV4dEN1cnNvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb3VyY2UuZ2V0KCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc0xvYWRpbmcgfHwgcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhyZWFkU3Vic2NyaXB0aW9ucy5nZXQoKS5zdWJzY3JpcHRpb25zO1xuICAgICAgICAgIGNvbnN0IHRocmVhZHMyID0gdGhpcy5vdXRwdXRzLnRocmVhZHMuZ2V0KCkuZmluZE1hbnkoXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAvLyBEbyBfbm90XyBmaWx0ZXIgYnkgcm9vbUlkXG4gICAgICAgICAgICBxdWVyeSA/PyB7fSxcbiAgICAgICAgICAgIFwiZGVzY1wiLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcGFnZSA9IHJlc3VsdC5kYXRhO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgdGhyZWFkczogdGhyZWFkczIsXG4gICAgICAgICAgICBoYXNGZXRjaGVkQWxsOiBwYWdlLmhhc0ZldGNoZWRBbGwsXG4gICAgICAgICAgICBpc0ZldGNoaW5nTW9yZTogcGFnZS5pc0ZldGNoaW5nTW9yZSxcbiAgICAgICAgICAgIGZldGNoTW9yZUVycm9yOiBwYWdlLmZldGNoTW9yZUVycm9yLFxuICAgICAgICAgICAgZmV0Y2hNb3JlOiBwYWdlLmZldGNoTW9yZVxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHNoYWxsb3cyKTtcbiAgICAgICAgcmV0dXJuIHsgc2lnbmFsLCB3YWl0VW50aWxMb2FkZWQ6IHJlc291cmNlLndhaXRVbnRpbExvYWRlZCB9O1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgbG9hZGluZ1Jvb21UaHJlYWRzID0gbmV3IERlZmF1bHRNYXAoXG4gICAgICAocXVlcnlLZXkpID0+IHtcbiAgICAgICAgY29uc3QgW3Jvb21JZCwgcXVlcnldID0gSlNPTi5wYXJzZShxdWVyeUtleSk7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFBhZ2luYXRlZFJlc291cmNlKGFzeW5jIChjdXJzb3IpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnRba0ludGVybmFsMl0uaHR0cENsaWVudC5nZXRUaHJlYWRzKHtcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIGN1cnNvcixcbiAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy51cGRhdGVUaHJlYWRpZmljYXRpb25zKFxuICAgICAgICAgICAgcmVzdWx0LnRocmVhZHMsXG4gICAgICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgICAgcmVzdWx0LnN1YnNjcmlwdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkhpbnRzLnVwZGF0ZShyZXN1bHQucGVybWlzc2lvbkhpbnRzKTtcbiAgICAgICAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLiNyb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5nZXQocm9vbUlkKTtcbiAgICAgICAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSB2b2lkIDAgfHwgbGFzdFJlcXVlc3RlZEF0ID4gcmVzdWx0LnJlcXVlc3RlZEF0KSB7XG4gICAgICAgICAgICB0aGlzLiNyb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQoXG4gICAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgICAgcmVzdWx0LnJlcXVlc3RlZEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0Lm5leHRDdXJzb3I7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBEZXJpdmVkU2lnbmFsLmZyb20oKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc291cmNlLmdldCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQuaXNMb2FkaW5nIHx8IHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRocmVhZFN1YnNjcmlwdGlvbnMuZ2V0KCkuc3Vic2NyaXB0aW9ucztcbiAgICAgICAgICBjb25zdCB0aHJlYWRzMiA9IHRoaXMub3V0cHV0cy50aHJlYWRzLmdldCgpLmZpbmRNYW55KHJvb21JZCwgcXVlcnkgPz8ge30sIFwiYXNjXCIsIHN1YnNjcmlwdGlvbnMpO1xuICAgICAgICAgIGNvbnN0IHBhZ2UgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHRocmVhZHM6IHRocmVhZHMyLFxuICAgICAgICAgICAgaGFzRmV0Y2hlZEFsbDogcGFnZS5oYXNGZXRjaGVkQWxsLFxuICAgICAgICAgICAgaXNGZXRjaGluZ01vcmU6IHBhZ2UuaXNGZXRjaGluZ01vcmUsXG4gICAgICAgICAgICBmZXRjaE1vcmVFcnJvcjogcGFnZS5mZXRjaE1vcmVFcnJvcixcbiAgICAgICAgICAgIGZldGNoTW9yZTogcGFnZS5mZXRjaE1vcmVcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBzaGFsbG93Mik7XG4gICAgICAgIHJldHVybiB7IHNpZ25hbCwgd2FpdFVudGlsTG9hZGVkOiByZXNvdXJjZS53YWl0VW50aWxMb2FkZWQgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IGxvYWRpbmdOb3RpZmljYXRpb25zID0gbmV3IERlZmF1bHRNYXAoXG4gICAgICAocXVlcnlLZXkpID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBKU09OLnBhcnNlKHF1ZXJ5S2V5KTtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgUGFnaW5hdGVkUmVzb3VyY2UoYXN5bmMgKGN1cnNvcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnMoe1xuICAgICAgICAgICAgY3Vyc29yLFxuICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICAgICAgICByZXN1bHQudGhyZWFkcyxcbiAgICAgICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICByZXN1bHQuc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHRoaXMuI25vdGlmaWNhdGlvbnNMYXN0UmVxdWVzdGVkQXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI25vdGlmaWNhdGlvbnNMYXN0UmVxdWVzdGVkQXQgPSByZXN1bHQucmVxdWVzdGVkQXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5leHRDdXJzb3IgPSByZXN1bHQubmV4dEN1cnNvcjtcbiAgICAgICAgICByZXR1cm4gbmV4dEN1cnNvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb3VyY2UuZ2V0KCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc0xvYWRpbmcgfHwgcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjcml0ID0gW107XG4gICAgICAgICAgaWYgKHF1ZXJ5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNyaXQucHVzaChtYWtlSW5ib3hOb3RpZmljYXRpb25zRmlsdGVyKHF1ZXJ5KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9ucyA9IHRoaXMub3V0cHV0cy5ub3RpZmljYXRpb25zLmdldCgpLnNvcnRlZE5vdGlmaWNhdGlvbnMuZmlsdGVyKFxuICAgICAgICAgICAgKGluYm94Tm90aWZpY2F0aW9uKSA9PiBjcml0LmV2ZXJ5KChwcmVkKSA9PiBwcmVkKGluYm94Tm90aWZpY2F0aW9uKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHBhZ2UgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICAgIGhhc0ZldGNoZWRBbGw6IHBhZ2UuaGFzRmV0Y2hlZEFsbCxcbiAgICAgICAgICAgIGlzRmV0Y2hpbmdNb3JlOiBwYWdlLmlzRmV0Y2hpbmdNb3JlLFxuICAgICAgICAgICAgZmV0Y2hNb3JlRXJyb3I6IHBhZ2UuZmV0Y2hNb3JlRXJyb3IsXG4gICAgICAgICAgICBmZXRjaE1vcmU6IHBhZ2UuZmV0Y2hNb3JlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgc2hhbGxvdzIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICB3YWl0VW50aWxMb2FkZWQ6IHJlc291cmNlLndhaXRVbnRpbExvYWRlZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgdW5yZWFkTm90aWZpY2F0aW9uc0NvdW50ID0gbmV3IERlZmF1bHRNYXAoXG4gICAgICAocXVlcnlLZXkpID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBKU09OLnBhcnNlKHF1ZXJ5S2V5KTtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgU2luZ2xlUGFnZVJlc291cmNlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnQuZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoe1xuICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnVucmVhZE5vdGlmaWNhdGlvbnNDb3VudC51cGRhdGUocXVlcnlLZXksIHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBEZXJpdmVkU2lnbmFsLmZyb20oXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb3VyY2UuZ2V0KCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmlzTG9hZGluZyB8fCByZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBBU1lOQ19PSyhcbiAgICAgICAgICAgICAgICBcImNvdW50XCIsXG4gICAgICAgICAgICAgICAgbm4odGhpcy51bnJlYWROb3RpZmljYXRpb25zQ291bnQuc2lnbmFsLmdldCgpW3F1ZXJ5S2V5XSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNoYWxsb3dcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgd2FpdFVudGlsTG9hZGVkOiByZXNvdXJjZS53YWl0VW50aWxMb2FkZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHJvb21TdWJzY3JpcHRpb25TZXR0aW5nc0J5Um9vbUlkID0gbmV3IERlZmF1bHRNYXAoXG4gICAgICAocm9vbUlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFNpbmdsZVBhZ2VSZXNvdXJjZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgcm9vbSA9IHRoaXMuI2NsaWVudC5nZXRSb29tKHJvb21JZCk7XG4gICAgICAgICAgaWYgKHJvb20gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUm9vbSAnJHtyb29tSWR9JyBpcyBub3QgYXZhaWxhYmxlIG9uIGNsaWVudGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByb29tLmdldFN1YnNjcmlwdGlvblNldHRpbmdzKCk7XG4gICAgICAgICAgdGhpcy5yb29tU3Vic2NyaXB0aW9uU2V0dGluZ3MudXBkYXRlKHJvb21JZCwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb3VyY2UuZ2V0KCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc0xvYWRpbmcgfHwgcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQVNZTkNfT0soXG4gICAgICAgICAgICAgIFwic2V0dGluZ3NcIixcbiAgICAgICAgICAgICAgbm4odGhpcy5yb29tU3Vic2NyaXB0aW9uU2V0dGluZ3Muc2lnbmFsLmdldCgpW3Jvb21JZF0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgc2hhbGxvdyk7XG4gICAgICAgIHJldHVybiB7IHNpZ25hbCwgd2FpdFVudGlsTG9hZGVkOiByZXNvdXJjZS53YWl0VW50aWxMb2FkZWQgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHZlcnNpb25zQnlSb29tSWQgPSBuZXcgRGVmYXVsdE1hcChcbiAgICAgIChyb29tSWQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgU2luZ2xlUGFnZVJlc291cmNlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCByb29tID0gdGhpcy4jY2xpZW50LmdldFJvb20ocm9vbUlkKTtcbiAgICAgICAgICBpZiAocm9vbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb29tICcke3Jvb21JZH0nIGlzIG5vdCBhdmFpbGFibGUgb24gY2xpZW50YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJvb21ba0ludGVybmFsMl0ubGlzdFRleHRWZXJzaW9ucygpO1xuICAgICAgICAgIHRoaXMuaGlzdG9yeVZlcnNpb25zLnVwZGF0ZShyb29tSWQsIHJlc3VsdC52ZXJzaW9ucyk7XG4gICAgICAgICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gdGhpcy4jcm9vbVZlcnNpb25zTGFzdFJlcXVlc3RlZEF0QnlSb29tLmdldChyb29tSWQpO1xuICAgICAgICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPT09IHZvaWQgMCB8fCBsYXN0UmVxdWVzdGVkQXQgPiByZXN1bHQucmVxdWVzdGVkQXQpIHtcbiAgICAgICAgICAgIHRoaXMuI3Jvb21WZXJzaW9uc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQoXG4gICAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgICAgcmVzdWx0LnJlcXVlc3RlZEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb3VyY2UuZ2V0KCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc0xvYWRpbmcgfHwgcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQVNZTkNfT0soXG4gICAgICAgICAgICAgIFwidmVyc2lvbnNcIixcbiAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLmhpc3RvcnlWZXJzaW9ucy5zaWduYWwuZ2V0KClbcm9vbUlkXSA/PyB7fSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBzaGFsbG93KTtcbiAgICAgICAgcmV0dXJuIHsgc2lnbmFsLCB3YWl0VW50aWxMb2FkZWQ6IHJlc291cmNlLndhaXRVbnRpbExvYWRlZCB9O1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uU2V0dGluZ3MgPSB7XG4gICAgICBzaWduYWw6IERlcml2ZWRTaWduYWwuZnJvbSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI25vdGlmaWNhdGlvblNldHRpbmdzLmdldCgpO1xuICAgICAgICBpZiAocmVzdWx0LmlzTG9hZGluZyB8fCByZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBU1lOQ19PSyhcbiAgICAgICAgICBcInNldHRpbmdzXCIsXG4gICAgICAgICAgbm4odGhpcy5ub3RpZmljYXRpb25TZXR0aW5ncy5zaWduYWwuZ2V0KCkpXG4gICAgICAgICk7XG4gICAgICB9LCBzaGFsbG93KSxcbiAgICAgIHdhaXRVbnRpbExvYWRlZDogdGhpcy4jbm90aWZpY2F0aW9uU2V0dGluZ3Mud2FpdFVudGlsTG9hZGVkXG4gICAgfTtcbiAgICBjb25zdCBhaUNoYXRzID0gbmV3IERlZmF1bHRNYXAoXG4gICAgICAocXVlcnlLZXkpID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBKU09OLnBhcnNlKHF1ZXJ5S2V5KTtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgUGFnaW5hdGVkUmVzb3VyY2UoYXN5bmMgKGN1cnNvcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NsaWVudFtrSW50ZXJuYWwyXS5haS5nZXRDaGF0cyh7XG4gICAgICAgICAgICBjdXJzb3IsXG4gICAgICAgICAgICBxdWVyeVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQubmV4dEN1cnNvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb3VyY2UuZ2V0KCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc0xvYWRpbmcgfHwgcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjaGF0cyA9IHRoaXMuI2NsaWVudFtrSW50ZXJuYWwyXS5haS5xdWVyeUNoYXRzKHF1ZXJ5KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGNoYXRzLFxuICAgICAgICAgICAgaGFzRmV0Y2hlZEFsbDogcmVzdWx0LmRhdGEuaGFzRmV0Y2hlZEFsbCxcbiAgICAgICAgICAgIGlzRmV0Y2hpbmdNb3JlOiByZXN1bHQuZGF0YS5pc0ZldGNoaW5nTW9yZSxcbiAgICAgICAgICAgIGZldGNoTW9yZTogcmVzdWx0LmRhdGEuZmV0Y2hNb3JlLFxuICAgICAgICAgICAgZmV0Y2hNb3JlRXJyb3I6IHJlc3VsdC5kYXRhLmZldGNoTW9yZUVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgc2hhbGxvdyk7XG4gICAgICAgIHJldHVybiB7IHNpZ25hbCwgd2FpdFVudGlsTG9hZGVkOiByZXNvdXJjZS53YWl0VW50aWxMb2FkZWQgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IG1lc3NhZ2VzQnlDaGF0SWQgPSBuZXcgRGVmYXVsdE1hcCgoY2hhdElkKSA9PiB7XG4gICAgICBjb25zdCByZXNvdXJjZVxcdTAzQTMgPSBuZXcgU2luZ2xlUGFnZVJlc291cmNlKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy4jY2xpZW50W2tJbnRlcm5hbDJdLmFpLmdldE1lc3NhZ2VUcmVlKGNoYXRJZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdE1hcChcbiAgICAgICAgKGJyYW5jaCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNvdXJjZVxcdTAzQTMuZ2V0KCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmlzTG9hZGluZyB8fCByZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBU1lOQ19PSyhcbiAgICAgICAgICAgICAgXCJtZXNzYWdlc1wiLFxuICAgICAgICAgICAgICB0aGlzLiNjbGllbnRba0ludGVybmFsMl0uYWkuc2lnbmFscy5nZXRDaGF0TWVzc2FnZXNGb3JCcmFuY2hcXHUwM0EzKGNoYXRJZCwgYnJhbmNoID8/IHZvaWQgMCkuZ2V0KClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgc2lnbmFsLCB3YWl0VW50aWxMb2FkZWQ6IHJlc291cmNlXFx1MDNBMy53YWl0VW50aWxMb2FkZWQgfTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBjb25zdCBhaUNoYXRCeUlkID0gbmV3IERlZmF1bHRNYXAoKGNoYXRJZCkgPT4ge1xuICAgICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgU2luZ2xlUGFnZVJlc291cmNlKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy4jY2xpZW50W2tJbnRlcm5hbDJdLmFpLmdldE9yQ3JlYXRlQ2hhdChjaGF0SWQpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBzaWduYWwgPSBEZXJpdmVkU2lnbmFsLmZyb20oKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGF0ID0gdGhpcy4jY2xpZW50W2tJbnRlcm5hbDJdLmFpLmdldENoYXRCeUlkKGNoYXRJZCk7XG4gICAgICAgIGlmIChjaGF0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNvdXJjZS5nZXQoKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmlzTG9hZGluZyB8fCByZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBBU1lOQ19PSyhcbiAgICAgICAgICAgICAgXCJjaGF0XCIsXG4gICAgICAgICAgICAgIG5uKHRoaXMuI2NsaWVudFtrSW50ZXJuYWwyXS5haS5nZXRDaGF0QnlJZChjaGF0SWQpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIEFTWU5DX09LKFxuICAgICAgICAgICAgXCJjaGF0XCIsXG4gICAgICAgICAgICBubih0aGlzLiNjbGllbnRba0ludGVybmFsMl0uYWkuZ2V0Q2hhdEJ5SWQoY2hhdElkKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LCBzaGFsbG93KTtcbiAgICAgIHJldHVybiB7IHNpZ25hbCwgd2FpdFVudGlsTG9hZGVkOiByZXNvdXJjZS53YWl0VW50aWxMb2FkZWQgfTtcbiAgICB9KTtcbiAgICBjb25zdCB1cmxNZXRhZGF0YUJ5VXJsID0gbmV3IERlZmF1bHRNYXAoXG4gICAgICAodXJsKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFNpbmdsZVBhZ2VSZXNvdXJjZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLiNjbGllbnRba0ludGVybmFsMl0uaHR0cENsaWVudC5nZXRVcmxNZXRhZGF0YSh1cmwpO1xuICAgICAgICAgIHRoaXMudXJsc01ldGFkYXRhLnVwZGF0ZSh1cmwsIG1ldGFkYXRhKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBEZXJpdmVkU2lnbmFsLmZyb20oKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc291cmNlLmdldCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQuaXNMb2FkaW5nIHx8IHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEFTWU5DX09LKFwibWV0YWRhdGFcIiwgbm4odGhpcy51cmxzTWV0YWRhdGEuc2lnbmFsLmdldCgpW3VybF0pKTtcbiAgICAgICAgfSwgc2hhbGxvdyk7XG4gICAgICAgIHJldHVybiB7IHNpZ25hbCwgd2FpdFVudGlsTG9hZGVkOiByZXNvdXJjZS53YWl0VW50aWxMb2FkZWQgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMub3V0cHV0cyA9IHtcbiAgICAgIHRocmVhZGlmaWNhdGlvbnMsXG4gICAgICB0aHJlYWRzLFxuICAgICAgbG9hZGluZ1Jvb21UaHJlYWRzLFxuICAgICAgbG9hZGluZ1VzZXJUaHJlYWRzLFxuICAgICAgbm90aWZpY2F0aW9ucyxcbiAgICAgIGxvYWRpbmdOb3RpZmljYXRpb25zLFxuICAgICAgdW5yZWFkTm90aWZpY2F0aW9uc0NvdW50LFxuICAgICAgcm9vbVN1YnNjcmlwdGlvblNldHRpbmdzQnlSb29tSWQsXG4gICAgICB2ZXJzaW9uc0J5Um9vbUlkLFxuICAgICAgbm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICB0aHJlYWRTdWJzY3JpcHRpb25zLFxuICAgICAgYWlDaGF0cyxcbiAgICAgIG1lc3NhZ2VzQnlDaGF0SWQsXG4gICAgICBhaUNoYXRCeUlkLFxuICAgICAgdXJsTWV0YWRhdGFCeVVybFxuICAgIH07XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgaW5ib3ggbm90aWZpY2F0aW9uIHdpdGggYSBuZXcgdmFsdWUsIHJlcGxhY2luZyB0aGVcbiAgICogY29ycmVzcG9uZGluZyBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCB1cGRhdGUgYW55dGhpbmcgaWYgdGhlIGluYm94IG5vdGlmaWNhdGlvbiBJRCBpc24ndCBmb3VuZC5cbiAgICovXG4gIG1hcmtJbmJveE5vdGlmaWNhdGlvblJlYWQoaW5ib3hOb3RpZmljYXRpb25JZCwgcmVhZEF0LCBvcHRpbWlzdGljSWQpIHtcbiAgICBiYXRjaDIoKCkgPT4ge1xuICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY0lkKTtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucy5tYXJrUmVhZChpbmJveE5vdGlmaWNhdGlvbklkLCByZWFkQXQpO1xuICAgIH0pO1xuICB9XG4gIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNSZWFkKG9wdGltaXN0aWNJZCwgcmVhZEF0KSB7XG4gICAgYmF0Y2gyKCgpID0+IHtcbiAgICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNJZCk7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMubWFya0FsbFJlYWQocmVhZEF0KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbiBleGlzdGluZyBpbmJveCBub3RpZmljYXRpb24sIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZ1xuICAgKiBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICovXG4gIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uKGluYm94Tm90aWZpY2F0aW9uSWQsIG9wdGltaXN0aWNJZCkge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zLmRlbGV0ZShpbmJveE5vdGlmaWNhdGlvbklkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyAqYWxsKiBpbmJveCBub3RpZmljYXRpb25zLCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpY1xuICAgKiB1cGRhdGUuXG4gICAqL1xuICBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMob3B0aW1pc3RpY0lkKSB7XG4gICAgYmF0Y2gyKCgpID0+IHtcbiAgICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNJZCk7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMuY2xlYXIoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBleGlzdGluZyBzdWJzY3JpcHRpb24sIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZ1xuICAgKiBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICovXG4gIGNyZWF0ZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24sIG9wdGltaXN0aWNJZCkge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmNyZWF0ZShzdWJzY3JpcHRpb24pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGV4aXN0aW5nIHN1YnNjcmlwdGlvbiwgcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nXG4gICAqIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKi9cbiAgZGVsZXRlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbktleSwgb3B0aW1pc3RpY0lkKSB7XG4gICAgYmF0Y2gyKCgpID0+IHtcbiAgICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNJZCk7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbktleSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gbmV3IHRocmVhZCwgcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKi9cbiAgY3JlYXRlVGhyZWFkKG9wdGltaXN0aWNJZCwgdGhyZWFkKSB7XG4gICAgYmF0Y2gyKCgpID0+IHtcbiAgICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNJZCk7XG4gICAgICB0aGlzLnRocmVhZHMudXBzZXJ0KHRocmVhZCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgdGhyZWFkIHdpdGggYSBuZXcgdmFsdWUsIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZ1xuICAgKiBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCB1cGRhdGUgYW55dGhpbmcgaWY6XG4gICAqIC0gVGhlIHRocmVhZCBJRCBpc24ndCBmb3VuZDsgb3JcbiAgICogLSBUaGUgdGhyZWFkIElEIHdhcyBhbHJlYWR5IGRlbGV0ZWQ7IG9yXG4gICAqIC0gVGhlIHRocmVhZCBJRCB3YXMgdXBkYXRlZCBtb3JlIHJlY2VudGx5IHRoYW4gdGhlIG9wdGltaXN0aWMgdXBkYXRlJ3NcbiAgICogICB0aW1lc3RhbXAgKGlmIGdpdmVuKVxuICAgKi9cbiAgI3VwZGF0ZVRocmVhZCh0aHJlYWRJZCwgb3B0aW1pc3RpY0lkLCBjYWxsYmFjaywgdXBkYXRlZEF0KSB7XG4gICAgYmF0Y2gyKCgpID0+IHtcbiAgICAgIGlmIChvcHRpbWlzdGljSWQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY0lkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRiID0gdGhpcy50aHJlYWRzO1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBkYi5nZXQodGhyZWFkSWQpO1xuICAgICAgaWYgKCFleGlzdGluZykgcmV0dXJuO1xuICAgICAgaWYgKCEhdXBkYXRlZEF0ICYmIGV4aXN0aW5nLnVwZGF0ZWRBdCA+IHVwZGF0ZWRBdCkgcmV0dXJuO1xuICAgICAgZGIudXBzZXJ0KGNhbGxiYWNrKGV4aXN0aW5nKSk7XG4gICAgfSk7XG4gIH1cbiAgcGF0Y2hUaHJlYWQodGhyZWFkSWQsIG9wdGltaXN0aWNJZCwgcGF0Y2gsIHVwZGF0ZWRBdCkge1xuICAgIHJldHVybiB0aGlzLiN1cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICh0aHJlYWQpID0+ICh7IC4uLnRocmVhZCwgLi4uY29tcGFjdE9iamVjdChwYXRjaCkgfSksXG4gICAgICB1cGRhdGVkQXRcbiAgICApO1xuICB9XG4gIGFkZFJlYWN0aW9uKHRocmVhZElkLCBvcHRpbWlzdGljSWQsIGNvbW1lbnRJZCwgcmVhY3Rpb24sIGNyZWF0ZWRBdCkge1xuICAgIHRoaXMuI3VwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgKHRocmVhZCkgPT4gYXBwbHlBZGRSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgcmVhY3Rpb24pLFxuICAgICAgY3JlYXRlZEF0XG4gICAgKTtcbiAgfVxuICByZW1vdmVSZWFjdGlvbih0aHJlYWRJZCwgb3B0aW1pc3RpY0lkLCBjb21tZW50SWQsIGVtb2ppLCB1c2VySWQsIHJlbW92ZWRBdCkge1xuICAgIHRoaXMuI3VwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgKHRocmVhZCkgPT4gYXBwbHlSZW1vdmVSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgZW1vamksIHVzZXJJZCwgcmVtb3ZlZEF0KSxcbiAgICAgIHJlbW92ZWRBdFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFNvZnQtZGVsZXRlcyBhbiBleGlzdGluZyB0aHJlYWQgYnkgc2V0dGluZyBpdHMgYGRlbGV0ZWRBdGAgdmFsdWUsXG4gICAqIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZyBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCB1cGRhdGUgYW55dGhpbmcgaWY6XG4gICAqIC0gVGhlIHRocmVhZCBJRCBpc24ndCBmb3VuZDsgb3JcbiAgICogLSBUaGUgdGhyZWFkIElEIHdhcyBhbHJlYWR5IGRlbGV0ZWRcbiAgICovXG4gIGRlbGV0ZVRocmVhZCh0aHJlYWRJZCwgb3B0aW1pc3RpY0lkKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgLy8gQSBkZWxldGlvbiBpcyBhY3R1YWxseSBhbiB1cGRhdGUgb2YgdGhlIGRlbGV0ZWRBdCBwcm9wZXJ0eSBpbnRlcm5hbGx5XG4gICAgICAodGhyZWFkKSA9PiAoeyAuLi50aHJlYWQsIHVwZGF0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGRlbGV0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV4aXN0aW5nIGNvbW1lbnQgYW5kIGVuc3VyZXMgdGhlIGFzc29jaWF0ZWQgbm90aWZpY2F0aW9uIGlzXG4gICAqIHVwZGF0ZWQgY29ycmVjdGx5LCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICBjcmVhdGVDb21tZW50KG5ld0NvbW1lbnQsIG9wdGltaXN0aWNJZCkge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSB0aGlzLnRocmVhZHMuZ2V0KG5ld0NvbW1lbnQudGhyZWFkSWQpO1xuICAgICAgaWYgKCFleGlzdGluZ1RocmVhZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRocmVhZHMudXBzZXJ0KGFwcGx5VXBzZXJ0Q29tbWVudChleGlzdGluZ1RocmVhZCwgbmV3Q29tbWVudCkpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zLnVwZGF0ZUFzc29jaWF0ZWROb3RpZmljYXRpb24obmV3Q29tbWVudCk7XG4gICAgfSk7XG4gIH1cbiAgZWRpdENvbW1lbnQodGhyZWFkSWQsIG9wdGltaXN0aWNJZCwgZWRpdGVkQ29tbWVudCkge1xuICAgIHJldHVybiB0aGlzLiN1cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICh0aHJlYWQpID0+IGFwcGx5VXBzZXJ0Q29tbWVudCh0aHJlYWQsIGVkaXRlZENvbW1lbnQpXG4gICAgKTtcbiAgfVxuICBkZWxldGVDb21tZW50KHRocmVhZElkLCBvcHRpbWlzdGljSWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KSB7XG4gICAgcmV0dXJuIHRoaXMuI3VwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgKHRocmVhZCkgPT4gYXBwbHlEZWxldGVDb21tZW50KHRocmVhZCwgY29tbWVudElkLCBkZWxldGVkQXQpLFxuICAgICAgZGVsZXRlZEF0XG4gICAgKTtcbiAgfVxuICB1cGRhdGVUaHJlYWRpZmljYXRpb25zKHRocmVhZHMsIG5vdGlmaWNhdGlvbnMsIHN1YnNjcmlwdGlvbnMsIGRlbGV0ZWRUaHJlYWRzID0gW10sIGRlbGV0ZWROb3RpZmljYXRpb25zID0gW10sIGRlbGV0ZWRTdWJzY3JpcHRpb25zID0gW10pIHtcbiAgICBiYXRjaDIoKCkgPT4ge1xuICAgICAgdGhpcy50aHJlYWRzLmFwcGx5RGVsdGEodGhyZWFkcywgZGVsZXRlZFRocmVhZHMpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zLmFwcGx5RGVsdGEobm90aWZpY2F0aW9ucywgZGVsZXRlZE5vdGlmaWNhdGlvbnMpO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFwcGx5RGVsdGEoc3Vic2NyaXB0aW9ucywgZGVsZXRlZFN1YnNjcmlwdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGV4aXN0aW5nIHN1YnNjcmlwdGlvbiBzZXR0aW5ncyBmb3IgYSByb29tIHdpdGggYSBuZXcgdmFsdWUsXG4gICAqIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZyBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZVJvb21TdWJzY3JpcHRpb25TZXR0aW5ncyhyb29tSWQsIG9wdGltaXN0aWNJZCwgc2V0dGluZ3MpIHtcbiAgICBiYXRjaDIoKCkgPT4ge1xuICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY0lkKTtcbiAgICAgIHRoaXMucm9vbVN1YnNjcmlwdGlvblNldHRpbmdzLnVwZGF0ZShyb29tSWQsIHNldHRpbmdzKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmZXRjaE5vdGlmaWNhdGlvbnNEZWx0YVVwZGF0ZShzaWduYWwpIHtcbiAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLiNub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0O1xuICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jY2xpZW50LmdldEluYm94Tm90aWZpY2F0aW9uc1NpbmNlKHtcbiAgICAgIHNpbmNlOiBsYXN0UmVxdWVzdGVkQXQsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0IDwgcmVzdWx0LnJlcXVlc3RlZEF0KSB7XG4gICAgICB0aGlzLiNub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0ID0gcmVzdWx0LnJlcXVlc3RlZEF0O1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICByZXN1bHQudGhyZWFkcy51cGRhdGVkLFxuICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy51cGRhdGVkLFxuICAgICAgcmVzdWx0LnN1YnNjcmlwdGlvbnMudXBkYXRlZCxcbiAgICAgIHJlc3VsdC50aHJlYWRzLmRlbGV0ZWQsXG4gICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLmRlbGV0ZWQsXG4gICAgICByZXN1bHQuc3Vic2NyaXB0aW9ucy5kZWxldGVkXG4gICAgKTtcbiAgfVxuICBhc3luYyBmZXRjaFVucmVhZE5vdGlmaWNhdGlvbnNDb3VudChxdWVyeUtleSwgc2lnbmFsKSB7XG4gICAgY29uc3QgcXVlcnkgPSBKU09OLnBhcnNlKHF1ZXJ5S2V5KTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnQuZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoe1xuICAgICAgcXVlcnksXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLnVucmVhZE5vdGlmaWNhdGlvbnNDb3VudC51cGRhdGUocXVlcnlLZXksIHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgZmV0Y2hSb29tVGhyZWFkc0RlbHRhVXBkYXRlKHJvb21JZCwgc2lnbmFsKSB7XG4gICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gdGhpcy4jcm9vbVRocmVhZHNMYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb21JZCk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZXMgPSBhd2FpdCB0aGlzLiNjbGllbnRba0ludGVybmFsMl0uaHR0cENsaWVudC5nZXRUaHJlYWRzU2luY2Uoe1xuICAgICAgcm9vbUlkLFxuICAgICAgc2luY2U6IGxhc3RSZXF1ZXN0ZWRBdCxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlVGhyZWFkaWZpY2F0aW9ucyhcbiAgICAgIHVwZGF0ZXMudGhyZWFkcy51cGRhdGVkLFxuICAgICAgdXBkYXRlcy5pbmJveE5vdGlmaWNhdGlvbnMudXBkYXRlZCxcbiAgICAgIHVwZGF0ZXMuc3Vic2NyaXB0aW9ucy51cGRhdGVkLFxuICAgICAgdXBkYXRlcy50aHJlYWRzLmRlbGV0ZWQsXG4gICAgICB1cGRhdGVzLmluYm94Tm90aWZpY2F0aW9ucy5kZWxldGVkLFxuICAgICAgdXBkYXRlcy5zdWJzY3JpcHRpb25zLmRlbGV0ZWRcbiAgICApO1xuICAgIHRoaXMucGVybWlzc2lvbkhpbnRzLnVwZGF0ZSh1cGRhdGVzLnBlcm1pc3Npb25IaW50cyk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA8IHVwZGF0ZXMucmVxdWVzdGVkQXQpIHtcbiAgICAgIHRoaXMuI3Jvb21UaHJlYWRzTGFzdFJlcXVlc3RlZEF0QnlSb29tLnNldChyb29tSWQsIHVwZGF0ZXMucmVxdWVzdGVkQXQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmZXRjaFVzZXJUaHJlYWRzRGVsdGFVcGRhdGUoc2lnbmFsKSB7XG4gICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gdGhpcy4jdXNlclRocmVhZHNMYXN0UmVxdWVzdGVkQXQ7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnRba0ludGVybmFsMl0uaHR0cENsaWVudC5nZXRVc2VyVGhyZWFkc1NpbmNlX2V4cGVyaW1lbnRhbCh7XG4gICAgICBzaW5jZTogbGFzdFJlcXVlc3RlZEF0LFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA8IHJlc3VsdC5yZXF1ZXN0ZWRBdCkge1xuICAgICAgdGhpcy4jbm90aWZpY2F0aW9uc0xhc3RSZXF1ZXN0ZWRBdCA9IHJlc3VsdC5yZXF1ZXN0ZWRBdDtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVUaHJlYWRpZmljYXRpb25zKFxuICAgICAgcmVzdWx0LnRocmVhZHMudXBkYXRlZCxcbiAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMudXBkYXRlZCxcbiAgICAgIHJlc3VsdC5zdWJzY3JpcHRpb25zLnVwZGF0ZWQsXG4gICAgICByZXN1bHQudGhyZWFkcy5kZWxldGVkLFxuICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy5kZWxldGVkLFxuICAgICAgcmVzdWx0LnN1YnNjcmlwdGlvbnMuZGVsZXRlZFxuICAgICk7XG4gICAgdGhpcy5wZXJtaXNzaW9uSGludHMudXBkYXRlKHJlc3VsdC5wZXJtaXNzaW9uSGludHMpO1xuICB9XG4gIGFzeW5jIGZldGNoUm9vbVZlcnNpb25zRGVsdGFVcGRhdGUocm9vbUlkLCBzaWduYWwpIHtcbiAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLiNyb29tVmVyc2lvbnNMYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb21JZCk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvb20gPSBubihcbiAgICAgIHRoaXMuI2NsaWVudC5nZXRSb29tKHJvb21JZCksXG4gICAgICBgUm9vbSB3aXRoIGlkICR7cm9vbUlkfSBpcyBub3QgYXZhaWxhYmxlIG9uIGNsaWVudGBcbiAgICApO1xuICAgIGNvbnN0IHVwZGF0ZXMgPSBhd2FpdCByb29tW2tJbnRlcm5hbDJdLmxpc3RUZXh0VmVyc2lvbnNTaW5jZSh7XG4gICAgICBzaW5jZTogbGFzdFJlcXVlc3RlZEF0LFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5oaXN0b3J5VmVyc2lvbnMudXBkYXRlKHJvb21JZCwgdXBkYXRlcy52ZXJzaW9ucyk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA8IHVwZGF0ZXMucmVxdWVzdGVkQXQpIHtcbiAgICAgIHRoaXMuI3Jvb21WZXJzaW9uc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQocm9vbUlkLCB1cGRhdGVzLnJlcXVlc3RlZEF0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVmcmVzaFJvb21TdWJzY3JpcHRpb25TZXR0aW5ncyhyb29tSWQsIHNpZ25hbCkge1xuICAgIGNvbnN0IHJvb20gPSBubihcbiAgICAgIHRoaXMuI2NsaWVudC5nZXRSb29tKHJvb21JZCksXG4gICAgICBgUm9vbSB3aXRoIGlkICR7cm9vbUlkfSBpcyBub3QgYXZhaWxhYmxlIG9uIGNsaWVudGBcbiAgICApO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJvb20uZ2V0U3Vic2NyaXB0aW9uU2V0dGluZ3MoeyBzaWduYWwgfSk7XG4gICAgdGhpcy5yb29tU3Vic2NyaXB0aW9uU2V0dGluZ3MudXBkYXRlKHJvb21JZCwgcmVzdWx0KTtcbiAgfVxuICAvKipcbiAgICogUmVmcmVzaCBub3RpZmljYXRpb24gc2V0dGluZ3MgZnJvbSBwb2xsZXJcbiAgICovXG4gIGFzeW5jIHJlZnJlc2hOb3RpZmljYXRpb25TZXR0aW5ncyhzaWduYWwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnQuZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3Moe1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5ub3RpZmljYXRpb25TZXR0aW5ncy51cGRhdGUocmVzdWx0KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBub3RpZmljYXRpb24gc2V0dGluZ3Mgd2l0aCBhIG5ldyB2YWx1ZSwgcmVwbGFjaW5nIHRoZVxuICAgKiBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NfY29uZmlybU9wdGltaXN0aWNVcGRhdGUoc2V0dGluZ3MsIG9wdGltaXN0aWNVcGRhdGVJZCkge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25TZXR0aW5ncy51cGRhdGUoc2V0dGluZ3MpO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gYXBwbHlPcHRpbWlzdGljVXBkYXRlc19mb3JUaHJlYWRpZmljYXRpb25zKGJhc2VUaHJlYWRzREIsIG5vdGlmaWNhdGlvbnNMVVQsIG9wdGltaXN0aWNVcGRhdGVzKSB7XG4gIGNvbnN0IHRocmVhZHNEQiA9IGJhc2VUaHJlYWRzREIuY2xvbmUoKTtcbiAgbGV0IG5vdGlmaWNhdGlvbnNCeUlkID0gT2JqZWN0LmZyb21FbnRyaWVzKG5vdGlmaWNhdGlvbnNMVVQpO1xuICBmb3IgKGNvbnN0IG9wdGltaXN0aWNVcGRhdGUgb2Ygb3B0aW1pc3RpY1VwZGF0ZXMpIHtcbiAgICBzd2l0Y2ggKG9wdGltaXN0aWNVcGRhdGUudHlwZSkge1xuICAgICAgY2FzZSBcImNyZWF0ZS10aHJlYWRcIjoge1xuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZWRpdC10aHJlYWQtbWV0YWRhdGFcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkSWQpO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgICBpZiAodGhyZWFkLnVwZGF0ZWRBdCA+IG9wdGltaXN0aWNVcGRhdGUudXBkYXRlZEF0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydCh7XG4gICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgIHVwZGF0ZWRBdDogb3B0aW1pc3RpY1VwZGF0ZS51cGRhdGVkQXQsXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIC4uLnRocmVhZC5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLm9wdGltaXN0aWNVcGRhdGUubWV0YWRhdGFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLXRocmVhZC1hcy1yZXNvbHZlZFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZHNEQi5nZXQob3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoeyAuLi50aHJlYWQsIHJlc29sdmVkOiB0cnVlIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLXRocmVhZC1hcy11bnJlc29sdmVkXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydCh7IC4uLnRocmVhZCwgcmVzb2x2ZWQ6IGZhbHNlIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJjcmVhdGUtY29tbWVudFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZHNEQi5nZXQob3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChhcHBseVVwc2VydENvbW1lbnQodGhyZWFkLCBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQpKTtcbiAgICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKG5vdGlmaWNhdGlvbnNCeUlkKS5maW5kKFxuICAgICAgICAgIChub3RpZmljYXRpb24pID0+IG5vdGlmaWNhdGlvbi5raW5kID09PSBcInRocmVhZFwiICYmIG5vdGlmaWNhdGlvbi50aHJlYWRJZCA9PT0gdGhyZWFkLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpbmJveE5vdGlmaWNhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZpY2F0aW9uc0J5SWRbaW5ib3hOb3RpZmljYXRpb24uaWRdID0ge1xuICAgICAgICAgIC4uLmluYm94Tm90aWZpY2F0aW9uLFxuICAgICAgICAgIG5vdGlmaWVkQXQ6IG9wdGltaXN0aWNVcGRhdGUuY29tbWVudC5jcmVhdGVkQXQsXG4gICAgICAgICAgcmVhZEF0OiBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQuY3JlYXRlZEF0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImVkaXQtY29tbWVudFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZHNEQi5nZXQob3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChhcHBseVVwc2VydENvbW1lbnQodGhyZWFkLCBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkSWQpO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KFxuICAgICAgICAgIGFwcGx5RGVsZXRlQ29tbWVudChcbiAgICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5kZWxldGVkQXRcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS10aHJlYWRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkSWQpO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KHtcbiAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgZGVsZXRlZEF0OiBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG9wdGltaXN0aWNVcGRhdGUuZGVsZXRlZEF0LFxuICAgICAgICAgIGNvbW1lbnRzOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYWRkLXJlYWN0aW9uXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChcbiAgICAgICAgICBhcHBseUFkZFJlYWN0aW9uKFxuICAgICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50SWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLnJlYWN0aW9uXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJyZW1vdmUtcmVhY3Rpb25cIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkSWQpO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KFxuICAgICAgICAgIGFwcGx5UmVtb3ZlUmVhY3Rpb24oXG4gICAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuZW1vamksXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLnVzZXJJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUucmVtb3ZlZEF0XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLWluYm94LW5vdGlmaWNhdGlvbi1hcy1yZWFkXCI6IHtcbiAgICAgICAgY29uc3QgaWJuID0gbm90aWZpY2F0aW9uc0J5SWRbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXTtcbiAgICAgICAgaWYgKGlibiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZpY2F0aW9uc0J5SWRbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXSA9IHtcbiAgICAgICAgICAuLi5pYm4sXG4gICAgICAgICAgcmVhZEF0OiBvcHRpbWlzdGljVXBkYXRlLnJlYWRBdFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLWFsbC1pbmJveC1ub3RpZmljYXRpb25zLWFzLXJlYWRcIjoge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIG5vdGlmaWNhdGlvbnNCeUlkKSB7XG4gICAgICAgICAgY29uc3QgaWJuID0gbm90aWZpY2F0aW9uc0J5SWRbaWRdO1xuICAgICAgICAgIGlmIChpYm4gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vdGlmaWNhdGlvbnNCeUlkW2lkXSA9IHtcbiAgICAgICAgICAgIC4uLmlibixcbiAgICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5yZWFkQXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1pbmJveC1ub3RpZmljYXRpb25cIjoge1xuICAgICAgICBkZWxldGUgbm90aWZpY2F0aW9uc0J5SWRbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLWFsbC1pbmJveC1ub3RpZmljYXRpb25zXCI6IHtcbiAgICAgICAgbm90aWZpY2F0aW9uc0J5SWQgPSB7fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHNvcnRlZE5vdGlmaWNhdGlvbnMgPSAoXG4gICAgLy8gU29ydCBzbyB0aGF0IHRoZSBtb3N0IHJlY2VudCBub3RpZmljYXRpb25zIGFyZSBmaXJzdFxuICAgIE9iamVjdC52YWx1ZXMobm90aWZpY2F0aW9uc0J5SWQpLmZpbHRlcihcbiAgICAgIChpYm4pID0+IGlibi5raW5kID09PSBcInRocmVhZFwiID8gdGhyZWFkc0RCLmdldChpYm4udGhyZWFkSWQpICE9PSB2b2lkIDAgOiB0cnVlXG4gICAgKS5zb3J0KChhLCBiKSA9PiBiLm5vdGlmaWVkQXQuZ2V0VGltZSgpIC0gYS5ub3RpZmllZEF0LmdldFRpbWUoKSlcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBzb3J0ZWROb3RpZmljYXRpb25zLFxuICAgIG5vdGlmaWNhdGlvbnNCeUlkLFxuICAgIHRocmVhZHNEQlxuICB9O1xufVxuZnVuY3Rpb24gYXBwbHlPcHRpbWlzdGljVXBkYXRlc19mb3JSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3Moc2V0dGluZ3NMVVQsIG9wdGltaXN0aWNVcGRhdGVzKSB7XG4gIGNvbnN0IHJvb21TdWJzY3JpcHRpb25TZXR0aW5nc0J5Um9vbUlkID0gT2JqZWN0LmZyb21FbnRyaWVzKHNldHRpbmdzTFVUKTtcbiAgZm9yIChjb25zdCBvcHRpbWlzdGljVXBkYXRlIG9mIG9wdGltaXN0aWNVcGRhdGVzKSB7XG4gICAgc3dpdGNoIChvcHRpbWlzdGljVXBkYXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJ1cGRhdGUtcm9vbS1zdWJzY3JpcHRpb24tc2V0dGluZ3NcIjoge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHJvb21TdWJzY3JpcHRpb25TZXR0aW5nc0J5Um9vbUlkW29wdGltaXN0aWNVcGRhdGUucm9vbUlkXTtcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByb29tU3Vic2NyaXB0aW9uU2V0dGluZ3NCeVJvb21JZFtvcHRpbWlzdGljVXBkYXRlLnJvb21JZF0gPSB7XG4gICAgICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICAgICAgLi4ub3B0aW1pc3RpY1VwZGF0ZS5zZXR0aW5nc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcm9vbVN1YnNjcmlwdGlvblNldHRpbmdzQnlSb29tSWQ7XG59XG5mdW5jdGlvbiBhcHBseU9wdGltaXN0aWNVcGRhdGVzX2ZvclN1YnNjcmlwdGlvbnMoc3Vic2NyaXB0aW9uc0xVVCwgdGhyZWFkcywgb3B0aW1pc3RpY1VwZGF0ZXMpIHtcbiAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IE9iamVjdC5mcm9tRW50cmllcyhzdWJzY3JpcHRpb25zTFVUKTtcbiAgZm9yIChjb25zdCB1cGRhdGUgb2Ygb3B0aW1pc3RpY1VwZGF0ZXMpIHtcbiAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIFwidXBkYXRlLXJvb20tc3Vic2NyaXB0aW9uLXNldHRpbmdzXCI6IHtcbiAgICAgICAgaWYgKCF1cGRhdGUuc2V0dGluZ3MudGhyZWFkcykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb21UaHJlYWRzID0gdGhyZWFkcy5maW5kTWFueShcbiAgICAgICAgICB1cGRhdGUucm9vbUlkLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICBcImRlc2NcIixcbiAgICAgICAgICB2b2lkIDBcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCB0aHJlYWQgb2Ygcm9vbVRocmVhZHMpIHtcbiAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25LZXkgPSBnZXRTdWJzY3JpcHRpb25LZXkyKFwidGhyZWFkXCIsIHRocmVhZC5pZCk7XG4gICAgICAgICAgc3dpdGNoICh1cGRhdGUuc2V0dGluZ3MudGhyZWFkcykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHN1YnNjcmlwdGlvbnMgZm9yIGFsbCBleGlzdGluZyB0aHJlYWRzIGluIHRoZSByb29tXG4gICAgICAgICAgICBjYXNlIFwiYWxsXCI6IHtcbiAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uc1tzdWJzY3JpcHRpb25LZXldID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwidGhyZWFkXCIsXG4gICAgICAgICAgICAgICAgc3ViamVjdElkOiB0aHJlYWQuaWQsXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlbGV0ZSBzdWJzY3JpcHRpb25zIGZvciBhbGwgZXhpc3RpbmcgdGhyZWFkcyBpbiB0aGUgcm9vbVxuICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjoge1xuICAgICAgICAgICAgICBkZWxldGUgc3Vic2NyaXB0aW9uc1tzdWJzY3JpcHRpb25LZXldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZXBsaWVzX2FuZF9tZW50aW9uc1wiOiB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYXNzZXJ0TmV2ZXIoXG4gICAgICAgICAgICAgICAgdXBkYXRlLnNldHRpbmdzLnRocmVhZHMsXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHRocmVhZCBzdWJzY3JpcHRpb24gc2V0dGluZ3MuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1YnNjcmlwdGlvbnM7XG59XG5mdW5jdGlvbiBhcHBseU9wdGltaXN0aWNVcGRhdGVzX2Zvck5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzLCBvcHRpbWlzdGljVXBkYXRlcykge1xuICBsZXQgb3V0Y29taW5nID0gc2V0dGluZ3M7XG4gIGZvciAoY29uc3QgdXBkYXRlIG9mIG9wdGltaXN0aWNVcGRhdGVzKSB7XG4gICAgaWYgKHVwZGF0ZS50eXBlID09PSBcInVwZGF0ZS1ub3RpZmljYXRpb24tc2V0dGluZ3NcIikge1xuICAgICAgb3V0Y29taW5nID0gcGF0Y2hOb3RpZmljYXRpb25TZXR0aW5ncyhvdXRjb21pbmcsIHVwZGF0ZS5zZXR0aW5ncyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRjb21pbmc7XG59XG5mdW5jdGlvbiBjb21wYXJlSW5ib3hOb3RpZmljYXRpb25zKGluYm94Tm90aWZpY2F0aW9uQSwgaW5ib3hOb3RpZmljYXRpb25CKSB7XG4gIGlmIChpbmJveE5vdGlmaWNhdGlvbkEubm90aWZpZWRBdCA+IGluYm94Tm90aWZpY2F0aW9uQi5ub3RpZmllZEF0KSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoaW5ib3hOb3RpZmljYXRpb25BLm5vdGlmaWVkQXQgPCBpbmJveE5vdGlmaWNhdGlvbkIubm90aWZpZWRBdCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCAmJiBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0KSB7XG4gICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgPiBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0ID8gMSA6IGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgPCBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0ID8gLTEgOiAwO1xuICB9IGVsc2UgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgfHwgaW5ib3hOb3RpZmljYXRpb25CLnJlYWRBdCkge1xuICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0ID8gMSA6IC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gYXBwbHlVcHNlcnRDb21tZW50KHRocmVhZCwgY29tbWVudCkge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoY29tbWVudC50aHJlYWRJZCAhPT0gdGhyZWFkLmlkKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYENvbW1lbnQgJHtjb21tZW50LmlkfSBkb2VzIG5vdCBiZWxvbmcgdG8gdGhyZWFkICR7dGhyZWFkLmlkfWBcbiAgICApO1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGV4aXN0aW5nQ29tbWVudDIpID0+IGV4aXN0aW5nQ29tbWVudDIuaWQgPT09IGNvbW1lbnQuaWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoXG4gICAgICBNYXRoLm1heCh0aHJlYWQudXBkYXRlZEF0LmdldFRpbWUoKSwgY29tbWVudC5jcmVhdGVkQXQuZ2V0VGltZSgpKVxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlZFRocmVhZCA9IHtcbiAgICAgIC4uLnRocmVhZCxcbiAgICAgIHVwZGF0ZWRBdCxcbiAgICAgIGNvbW1lbnRzOiBbLi4udGhyZWFkLmNvbW1lbnRzLCBjb21tZW50XVxuICAgIH07XG4gICAgcmV0dXJuIHVwZGF0ZWRUaHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5lZGl0ZWRBdCA9PT0gdm9pZCAwIHx8IGNvbW1lbnQuZWRpdGVkQXQgPT09IHZvaWQgMCB8fCBleGlzdGluZ0NvbW1lbnQuZWRpdGVkQXQgPD0gY29tbWVudC5lZGl0ZWRBdCkge1xuICAgIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgICAoZXhpc3RpbmdDb21tZW50MikgPT4gZXhpc3RpbmdDb21tZW50Mi5pZCA9PT0gY29tbWVudC5pZCA/IGNvbW1lbnQgOiBleGlzdGluZ0NvbW1lbnQyXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGVkVGhyZWFkID0ge1xuICAgICAgLi4udGhyZWFkLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgdGhyZWFkLnVwZGF0ZWRBdC5nZXRUaW1lKCksXG4gICAgICAgICAgY29tbWVudC5lZGl0ZWRBdD8uZ2V0VGltZSgpIHx8IGNvbW1lbnQuY3JlYXRlZEF0LmdldFRpbWUoKVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICAgIH07XG4gICAgcmV0dXJuIHVwZGF0ZWRUaHJlYWQ7XG4gIH1cbiAgcmV0dXJuIHRocmVhZDtcbn1cbmZ1bmN0aW9uIGFwcGx5RGVsZXRlQ29tbWVudCh0aHJlYWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWQgPyB7XG4gICAgICAuLi5jb21tZW50LFxuICAgICAgZGVsZXRlZEF0LFxuICAgICAgLy8gV2Ugb3B0aW1pc3RpY2FsbHkgcmVtb3ZlIHRoZSBjb21tZW50IGJvZHkgYW5kIGF0dGFjaG1lbnRzIHdoZW4gbWFya2luZyBpdCBhcyBkZWxldGVkXG4gICAgICBib2R5OiB2b2lkIDAsXG4gICAgICBhdHRhY2htZW50czogW11cbiAgICB9IDogY29tbWVudFxuICApO1xuICBpZiAodXBkYXRlZENvbW1lbnRzLmV2ZXJ5KChjb21tZW50KSA9PiBjb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICBkZWxldGVkQXQsXG4gICAgICB1cGRhdGVkQXQ6IGRlbGV0ZWRBdFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBkZWxldGVkQXQsXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gYXBwbHlBZGRSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgcmVhY3Rpb24pIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICByZWFjdGlvbnM6IHVwc2VydFJlYWN0aW9uKGNvbW1lbnQucmVhY3Rpb25zLCByZWFjdGlvbilcbiAgICB9IDogY29tbWVudFxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgocmVhY3Rpb24uY3JlYXRlZEF0LmdldFRpbWUoKSwgdGhyZWFkLnVwZGF0ZWRBdC5nZXRUaW1lKCkpXG4gICAgKSxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBhcHBseVJlbW92ZVJlYWN0aW9uKHRocmVhZCwgY29tbWVudElkLCBlbW9qaSwgdXNlcklkLCByZW1vdmVkQXQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICByZWFjdGlvbnM6IGNvbW1lbnQucmVhY3Rpb25zLm1hcChcbiAgICAgICAgKHJlYWN0aW9uKSA9PiByZWFjdGlvbi5lbW9qaSA9PT0gZW1vamkgPyB7XG4gICAgICAgICAgLi4ucmVhY3Rpb24sXG4gICAgICAgICAgdXNlcnM6IHJlYWN0aW9uLnVzZXJzLmZpbHRlcigodXNlcikgPT4gdXNlci5pZCAhPT0gdXNlcklkKVxuICAgICAgICB9IDogcmVhY3Rpb25cbiAgICAgICkuZmlsdGVyKChyZWFjdGlvbikgPT4gcmVhY3Rpb24udXNlcnMubGVuZ3RoID4gMClcbiAgICAgIC8vIFJlbW92ZSByZWFjdGlvbnMgd2l0aCBubyB1c2VycyBsZWZ0XG4gICAgfSA6IGNvbW1lbnRcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHJlbW92ZWRBdC5nZXRUaW1lKCksIHRocmVhZC51cGRhdGVkQXQuZ2V0VGltZSgpKVxuICAgICksXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gdXBzZXJ0UmVhY3Rpb24ocmVhY3Rpb25zLCByZWFjdGlvbikge1xuICBjb25zdCBleGlzdGluZ1JlYWN0aW9uID0gcmVhY3Rpb25zLmZpbmQoXG4gICAgKGV4aXN0aW5nUmVhY3Rpb24yKSA9PiBleGlzdGluZ1JlYWN0aW9uMi5lbW9qaSA9PT0gcmVhY3Rpb24uZW1vamlcbiAgKTtcbiAgaWYgKGV4aXN0aW5nUmVhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5yZWFjdGlvbnMsXG4gICAgICB7XG4gICAgICAgIGVtb2ppOiByZWFjdGlvbi5lbW9qaSxcbiAgICAgICAgY3JlYXRlZEF0OiByZWFjdGlvbi5jcmVhdGVkQXQsXG4gICAgICAgIHVzZXJzOiBbeyBpZDogcmVhY3Rpb24udXNlcklkIH1dXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBpZiAoZXhpc3RpbmdSZWFjdGlvbi51c2Vycy5zb21lKCh1c2VyKSA9PiB1c2VyLmlkID09PSByZWFjdGlvbi51c2VySWQpID09PSBmYWxzZSkge1xuICAgIHJldHVybiByZWFjdGlvbnMubWFwKFxuICAgICAgKGV4aXN0aW5nUmVhY3Rpb24yKSA9PiBleGlzdGluZ1JlYWN0aW9uMi5lbW9qaSA9PT0gcmVhY3Rpb24uZW1vamkgPyB7XG4gICAgICAgIC4uLmV4aXN0aW5nUmVhY3Rpb24yLFxuICAgICAgICB1c2VyczogWy4uLmV4aXN0aW5nUmVhY3Rpb24yLnVzZXJzLCB7IGlkOiByZWFjdGlvbi51c2VySWQgfV1cbiAgICAgIH0gOiBleGlzdGluZ1JlYWN0aW9uMlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlYWN0aW9ucztcbn1cblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIG1pc3NpbmdVc2VyRXJyb3IodXNlcklkKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoYHJlc29sdmVVc2VycyBkaWRuJ3QgcmV0dXJuIGFueXRoaW5nIGZvciB1c2VyICcke3VzZXJJZH0nYCk7XG59XG5mdW5jdGlvbiBtaXNzaW5nUm9vbUluZm9FcnJvcihyb29tSWQpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICBgcmVzb2x2ZVJvb21zSW5mbyBkaWRuJ3QgcmV0dXJuIGFueXRoaW5nIGZvciByb29tICcke3Jvb21JZH0nYFxuICApO1xufVxuZnVuY3Rpb24gbWlzc2luZ0dyb3VwSW5mb0Vycm9yKGdyb3VwSWQpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICBgcmVzb2x2ZUdyb3Vwc0luZm8gZGlkbid0IHJldHVybiBhbnl0aGluZyBmb3IgZ3JvdXAgJyR7Z3JvdXBJZH0nYFxuICApO1xufVxuZnVuY3Rpb24gaWRlbnRpdHkyKHgpIHtcbiAgcmV0dXJuIHg7XG59XG52YXIgX3VtYnJlbGxhU3RvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgX2V4dHJhcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIF9idW5kbGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudChyZXN1bHQpIHtcbiAgaWYgKCEoXCJjb3VudFwiIGluIHJlc3VsdCkgfHwgcmVzdWx0LmNvdW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiBBU1lOQ19PSyhcImNvdW50XCIsIHJlc3VsdC5jb3VudCk7XG59XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VVc2VyKHN0YXRlLCB1c2VySWQpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDAgfHwgc3RhdGU/LmlzTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZSA/PyB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICB9XG4gIGlmIChzdGF0ZS5lcnJvcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAoIXN0YXRlLmRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGVycm9yOiBtaXNzaW5nVXNlckVycm9yKHVzZXJJZClcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICB1c2VyOiBzdGF0ZS5kYXRhXG4gIH07XG59XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VSb29tSW5mbyhzdGF0ZSwgcm9vbUlkKSB7XG4gIGlmIChzdGF0ZSA9PT0gdm9pZCAwIHx8IHN0YXRlPy5pc0xvYWRpbmcpIHtcbiAgICByZXR1cm4gc3RhdGUgPz8geyBpc0xvYWRpbmc6IHRydWUgfTtcbiAgfVxuICBpZiAoc3RhdGUuZXJyb3IpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgaWYgKCFzdGF0ZS5kYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBlcnJvcjogbWlzc2luZ1Jvb21JbmZvRXJyb3Iocm9vbUlkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIGluZm86IHN0YXRlLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yRm9yX3VzZUdyb3VwSW5mbyhzdGF0ZSwgZ3JvdXBJZCkge1xuICBpZiAoc3RhdGUgPT09IHZvaWQgMCB8fCBzdGF0ZT8uaXNMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHN0YXRlID8/IHsgaXNMb2FkaW5nOiB0cnVlIH07XG4gIH1cbiAgaWYgKHN0YXRlLmVycm9yKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGlmICghc3RhdGUuZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG1pc3NpbmdHcm91cEluZm9FcnJvcihncm91cElkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIGluZm86IHN0YXRlLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlQ29udGV4dEJ1bmRsZShjbGllbnQpIHtcbiAgbGV0IGJ1bmRsZSA9IF9idW5kbGVzLmdldChjbGllbnQpO1xuICBpZiAoIWJ1bmRsZSkge1xuICAgIGJ1bmRsZSA9IG1ha2VMaXZlYmxvY2tzQ29udGV4dEJ1bmRsZShjbGllbnQpO1xuICAgIF9idW5kbGVzLnNldChjbGllbnQsIGJ1bmRsZSk7XG4gIH1cbiAgcmV0dXJuIGJ1bmRsZTtcbn1cbmZ1bmN0aW9uIGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQoY2xpZW50KSB7XG4gIGxldCBzdG9yZSA9IF91bWJyZWxsYVN0b3Jlcy5nZXQoY2xpZW50KTtcbiAgaWYgKCFzdG9yZSkge1xuICAgIHN0b3JlID0gbmV3IFVtYnJlbGxhU3RvcmUoY2xpZW50KTtcbiAgICBfdW1icmVsbGFTdG9yZXMuc2V0KGNsaWVudCwgc3RvcmUpO1xuICB9XG4gIHJldHVybiBzdG9yZTtcbn1cbmZ1bmN0aW9uIGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KSB7XG4gIGxldCBleHRyYXMgPSBfZXh0cmFzLmdldChjbGllbnQpO1xuICBpZiAoIWV4dHJhcykge1xuICAgIGV4dHJhcyA9IG1ha2VMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgX2V4dHJhcy5zZXQoY2xpZW50LCBleHRyYXMpO1xuICB9XG4gIHJldHVybiBleHRyYXM7XG59XG5mdW5jdGlvbiB1c2VFbnN1cmVBaUNvbm5lY3Rpb24oY2xpZW50KSB7XG4gIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgIGNsaWVudFtrSW50ZXJuYWwzXS5haS5jb25uZWN0SW5pdGlhbGx5KCk7XG4gIH0sIFtjbGllbnRdKTtcbn1cbmZ1bmN0aW9uIG1ha2VMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCBzdG9yZSA9IGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3Qgbm90aWZpY2F0aW9uc1BvbGxlciA9IG1ha2VQb2xsZXIoXG4gICAgYXN5bmMgKHNpZ25hbCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLmZldGNoTm90aWZpY2F0aW9uc0RlbHRhVXBkYXRlKHNpZ25hbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZTIud2FybihgUG9sbGluZyBuZXcgaW5ib3ggbm90aWZpY2F0aW9ucyBmYWlsZWQ6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbmZpZy5OT1RJRklDQVRJT05TX1BPTExfSU5URVJWQUwsXG4gICAgeyBtYXhTdGFsZVRpbWVNczogY29uZmlnLk5PVElGSUNBVElPTlNfTUFYX1NUQUxFX1RJTUUgfVxuICApO1xuICBjb25zdCB1bnJlYWROb3RpZmljYXRpb25zQ291bnRQb2xsZXJzQnlRdWVyeUtleSA9IG5ldyBEZWZhdWx0TWFwMihcbiAgICAocXVlcnlLZXkpID0+IG1ha2VQb2xsZXIoXG4gICAgICBhc3luYyAoc2lnbmFsKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLmZldGNoVW5yZWFkTm90aWZpY2F0aW9uc0NvdW50KHF1ZXJ5S2V5LCBzaWduYWwpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlMi53YXJuKFxuICAgICAgICAgICAgYFBvbGxpbmcgdW5yZWFkIGluYm94IG5vdGlmaWNhdGlvbnMgY291bnRmYWlsZWQ6ICR7U3RyaW5nKGVycil9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29uZmlnLk5PVElGSUNBVElPTlNfUE9MTF9JTlRFUlZBTCxcbiAgICAgIHsgbWF4U3RhbGVUaW1lTXM6IGNvbmZpZy5OT1RJRklDQVRJT05TX01BWF9TVEFMRV9USU1FIH1cbiAgICApXG4gICk7XG4gIGNvbnN0IHVzZXJUaHJlYWRzUG9sbGVyID0gbWFrZVBvbGxlcihcbiAgICBhc3luYyAoc2lnbmFsKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgc3RvcmUuZmV0Y2hVc2VyVGhyZWFkc0RlbHRhVXBkYXRlKHNpZ25hbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZTIud2FybihgUG9sbGluZyBuZXcgdXNlciB0aHJlYWRzIGZhaWxlZDogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29uZmlnLlVTRVJfVEhSRUFEU19QT0xMX0lOVEVSVkFMLFxuICAgIHsgbWF4U3RhbGVUaW1lTXM6IGNvbmZpZy5VU0VSX1RIUkVBRFNfTUFYX1NUQUxFX1RJTUUgfVxuICApO1xuICBjb25zdCBub3RpZmljYXRpb25TZXR0aW5nc1BvbGxlciA9IG1ha2VQb2xsZXIoXG4gICAgYXN5bmMgKHNpZ25hbCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLnJlZnJlc2hOb3RpZmljYXRpb25TZXR0aW5ncyhzaWduYWwpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUyLndhcm4oXG4gICAgICAgICAgYFBvbGxpbmcgbmV3IG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmYWlsZWQ6ICR7U3RyaW5nKGVycil9YFxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb25maWcuVVNFUl9OT1RJRklDQVRJT05fU0VUVElOR1NfSU5URVJWQUwsXG4gICAgeyBtYXhTdGFsZVRpbWVNczogY29uZmlnLlVTRVJfTk9USUZJQ0FUSU9OX1NFVFRJTkdTX01BWF9TVEFMRV9USU1FIH1cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBzdG9yZSxcbiAgICBub3RpZmljYXRpb25zUG9sbGVyLFxuICAgIHVzZXJUaHJlYWRzUG9sbGVyLFxuICAgIG5vdGlmaWNhdGlvblNldHRpbmdzUG9sbGVyLFxuICAgIHVucmVhZE5vdGlmaWNhdGlvbnNDb3VudFBvbGxlcnNCeVF1ZXJ5S2V5XG4gIH07XG59XG5mdW5jdGlvbiBtYWtlTGl2ZWJsb2Nrc0NvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGNvbnN0IHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkMiA9IChpbmJveE5vdGlmaWNhdGlvbklkKSA9PiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZF93aXRoQ2xpZW50KGNsaWVudCwgaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIGNvbnN0IHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDIgPSAoKSA9PiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRfd2l0aENsaWVudChjbGllbnQpO1xuICBjb25zdCB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkMiA9ICgpID0+IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWRfd2l0aENsaWVudChjbGllbnQpO1xuICBjb25zdCB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbjIgPSAoKSA9PiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbl93aXRoQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczIgPSAoKSA9PiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQpO1xuICBjb25zdCB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nczIgPSAoKSA9PiB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc193aXRoQ2xpZW50KGNsaWVudCk7XG4gIGZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcjIocHJvcHMpIHtcbiAgICB1c2VFbnN1cmVOb0xpdmVibG9ja3NQcm92aWRlcigpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KENsaWVudENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNsaWVudCwgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pO1xuICB9XG4gIGNvbnN0IHNoYXJlZCA9IGNyZWF0ZVNoYXJlZENvbnRleHQoY2xpZW50KTtcbiAgY29uc3QgYnVuZGxlID0ge1xuICAgIExpdmVibG9ja3NQcm92aWRlcjogTGl2ZWJsb2Nrc1Byb3ZpZGVyMixcbiAgICB1c2VJbmJveE5vdGlmaWNhdGlvbnM6IChvcHRpb25zKSA9PiB1c2VJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQsIGlkZW50aXR5Miwgc2hhbGxvdzMsIG9wdGlvbnMpLFxuICAgIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiAob3B0aW9ucykgPT4gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRfd2l0aENsaWVudChjbGllbnQsIG9wdGlvbnMpLFxuICAgIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDogdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkMixcbiAgICB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkOiB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkMixcbiAgICB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbjogdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb24yLFxuICAgIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczogdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zMixcbiAgICB1c2VOb3RpZmljYXRpb25TZXR0aW5nczogKCkgPT4gdXNlTm90aWZpY2F0aW9uU2V0dGluZ3Nfd2l0aENsaWVudChjbGllbnQpLFxuICAgIHVzZVVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzOiB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nczIsXG4gICAgdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQ6IHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkMixcbiAgICB1c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWwsXG4gICAgdXNlQWlDaGF0cyxcbiAgICB1c2VBaUNoYXQsXG4gICAgdXNlQWlDaGF0TWVzc2FnZXMsXG4gICAgdXNlQWlDaGF0U3RhdHVzLFxuICAgIHVzZUNyZWF0ZUFpQ2hhdCxcbiAgICB1c2VEZWxldGVBaUNoYXQsXG4gICAgdXNlU2VuZEFpTWVzc2FnZSxcbiAgICB1c2VVcmxNZXRhZGF0YSxcbiAgICAuLi5zaGFyZWQuY2xhc3NpYyxcbiAgICBzdXNwZW5zZToge1xuICAgICAgTGl2ZWJsb2Nrc1Byb3ZpZGVyOiBMaXZlYmxvY2tzUHJvdmlkZXIyLFxuICAgICAgdXNlSW5ib3hOb3RpZmljYXRpb25zOiAob3B0aW9ucykgPT4gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIG9wdGlvbnMpLFxuICAgICAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQ6IChvcHRpb25zKSA9PiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCBvcHRpb25zKSxcbiAgICAgIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDogdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkMixcbiAgICAgIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQ6IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQyLFxuICAgICAgdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb246IHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uMixcbiAgICAgIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczogdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zMixcbiAgICAgIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkOiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZDIsXG4gICAgICB1c2VOb3RpZmljYXRpb25TZXR0aW5nczogKCkgPT4gdXNlTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCksXG4gICAgICB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nczogdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MyLFxuICAgICAgdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsOiB1c2VVc2VyVGhyZWFkc1N1c3BlbnNlX2V4cGVyaW1lbnRhbCxcbiAgICAgIHVzZUFpQ2hhdHM6IHVzZUFpQ2hhdHNTdXNwZW5zZSxcbiAgICAgIHVzZUFpQ2hhdDogdXNlQWlDaGF0U3VzcGVuc2UsXG4gICAgICB1c2VBaUNoYXRNZXNzYWdlczogdXNlQWlDaGF0TWVzc2FnZXNTdXNwZW5zZSxcbiAgICAgIHVzZUFpQ2hhdFN0YXR1cyxcbiAgICAgIHVzZUNyZWF0ZUFpQ2hhdCxcbiAgICAgIHVzZURlbGV0ZUFpQ2hhdCxcbiAgICAgIHVzZVNlbmRBaU1lc3NhZ2UsXG4gICAgICB1c2VVcmxNZXRhZGF0YTogdXNlVXJsTWV0YWRhdGFTdXNwZW5zZSxcbiAgICAgIC4uLnNoYXJlZC5zdXNwZW5zZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGJ1bmRsZTtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KGNsaWVudCwgc2VsZWN0b3IsIGlzRXF1YWwsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBzdG9yZSwgbm90aWZpY2F0aW9uc1BvbGxlcjogcG9sbGVyIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZUluYm94Tm90aWZpY2F0aW9uc1F1ZXJ5S2V5KG9wdGlvbnM/LnF1ZXJ5KTtcbiAgdXNlRWZmZWN0NChcbiAgICAoKSA9PiB2b2lkIHN0b3JlLm91dHB1dHMubG9hZGluZ05vdGlmaWNhdGlvbnMuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLndhaXRVbnRpbExvYWRlZCgpXG4gICAgLy8gTk9URTogRGVsaWJlcmF0ZWx5ICpub3QqIHVzaW5nIGEgZGVwZW5kZW5jeSBhcnJheSBoZXJlIVxuICAgIC8vXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNhbGwgd2FpdFVudGlsIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIHRoZSBpbml0aWFsIHBhZ2UgZmV0Y2guXG4gICAgLy8gMi4gQWxsIG90aGVyIHN1YnNlcXVlbnQgcmVuZGVycyBub3cgXCJqdXN0XCIgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UgKGEgcXVpY2sgb3BlcmF0aW9uKS5cbiAgICAvLyAzLiBJZiBldmVyIHRoZSBwcm9taXNlIHdvdWxkIGZhaWwsIHRoZW4gYWZ0ZXIgNSBzZWNvbmRzIGl0IHdvdWxkIHJlc2V0LCBhbmQgb24gdGhlIHZlcnlcbiAgICAvLyAgICAqbmV4dCogcmVuZGVyIGFmdGVyIHRoYXQsIGEgKm5ldyogZmV0Y2gvcHJvbWlzZSB3aWxsIGdldCBjcmVhdGVkLlxuICApO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBwb2xsZXIuaW5jKCk7XG4gICAgcG9sbGVyLnBvbGxOb3dJZlN0YWxlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvbGxlci5kZWMoKTtcbiAgICB9O1xuICB9LCBbcG9sbGVyXSk7XG4gIHJldHVybiB1c2VTaWduYWwoXG4gICAgc3RvcmUub3V0cHV0cy5sb2FkaW5nTm90aWZpY2F0aW9ucy5nZXRPckNyZWF0ZShxdWVyeUtleSkuc2lnbmFsLFxuICAgIHNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCBvcHRpb25zKSB7XG4gIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkuc3RvcmU7XG4gIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZUluYm94Tm90aWZpY2F0aW9uc1F1ZXJ5S2V5KG9wdGlvbnM/LnF1ZXJ5KTtcbiAgdXNlKFxuICAgIHN0b3JlLm91dHB1dHMubG9hZGluZ05vdGlmaWNhdGlvbnMuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLndhaXRVbnRpbExvYWRlZCgpXG4gICk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZUluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KFxuICAgIGNsaWVudCxcbiAgICBpZGVudGl0eTIsXG4gICAgc2hhbGxvdzMsXG4gICAgb3B0aW9uc1xuICApO1xuICBhc3NlcnQoIXJlc3VsdC5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudF93aXRoQ2xpZW50KGNsaWVudCwgb3B0aW9ucykge1xuICBjb25zdCB7IHN0b3JlLCB1bnJlYWROb3RpZmljYXRpb25zQ291bnRQb2xsZXJzQnlRdWVyeUtleTogcG9sbGVycyB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBxdWVyeUtleSA9IG1ha2VJbmJveE5vdGlmaWNhdGlvbnNRdWVyeUtleShvcHRpb25zPy5xdWVyeSk7XG4gIGNvbnN0IHBvbGxlciA9IHBvbGxlcnMuZ2V0T3JDcmVhdGUocXVlcnlLZXkpO1xuICB1c2VFZmZlY3Q0KFxuICAgICgpID0+IHZvaWQgc3RvcmUub3V0cHV0cy51bnJlYWROb3RpZmljYXRpb25zQ291bnQuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLndhaXRVbnRpbExvYWRlZCgpXG4gICAgLy8gTk9URTogRGVsaWJlcmF0ZWx5ICpub3QqIHVzaW5nIGEgZGVwZW5kZW5jeSBhcnJheSBoZXJlIVxuICAgIC8vXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNhbGwgd2FpdFVudGlsIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIHRoZSBpbml0aWFsIHBhZ2UgZmV0Y2guXG4gICAgLy8gMi4gQWxsIG90aGVyIHN1YnNlcXVlbnQgcmVuZGVycyBub3cgXCJqdXN0XCIgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UgKGEgcXVpY2sgb3BlcmF0aW9uKS5cbiAgICAvLyAzLiBJZiBldmVyIHRoZSBwcm9taXNlIHdvdWxkIGZhaWwsIHRoZW4gYWZ0ZXIgNSBzZWNvbmRzIGl0IHdvdWxkIHJlc2V0LCBhbmQgb24gdGhlIHZlcnlcbiAgICAvLyAgICAqbmV4dCogcmVuZGVyIGFmdGVyIHRoYXQsIGEgKm5ldyogZmV0Y2gvcHJvbWlzZSB3aWxsIGdldCBjcmVhdGVkLlxuICApO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBwb2xsZXIuaW5jKCk7XG4gICAgcG9sbGVyLnBvbGxOb3dJZlN0YWxlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvbGxlci5kZWMoKTtcbiAgICB9O1xuICB9LCBbcG9sbGVyXSk7XG4gIHJldHVybiB1c2VTaWduYWwoXG4gICAgc3RvcmUub3V0cHV0cy51bnJlYWROb3RpZmljYXRpb25zQ291bnQuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLnNpZ25hbCxcbiAgICBzZWxlY3RvckZvcl91c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBzaGFsbG93M1xuICApO1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgb3B0aW9ucykge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpLnN0b3JlO1xuICBjb25zdCBxdWVyeUtleSA9IG1ha2VJbmJveE5vdGlmaWNhdGlvbnNRdWVyeUtleShvcHRpb25zPy5xdWVyeSk7XG4gIHVzZShcbiAgICBzdG9yZS5vdXRwdXRzLnVucmVhZE5vdGlmaWNhdGlvbnNDb3VudC5nZXRPckNyZWF0ZShxdWVyeUtleSkud2FpdFVudGlsTG9hZGVkKClcbiAgKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRfd2l0aENsaWVudChjbGllbnQsIG9wdGlvbnMpO1xuICBhc3NlcnQoIXJlc3VsdC5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMihcbiAgICAoaW5ib3hOb3RpZmljYXRpb25JZCkgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSwgdW5yZWFkTm90aWZpY2F0aW9uc0NvdW50UG9sbGVyc0J5UXVlcnlLZXkgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IHJlYWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLWluYm94LW5vdGlmaWNhdGlvbi1hcy1yZWFkXCIsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQsXG4gICAgICAgIHJlYWRBdFxuICAgICAgfSk7XG4gICAgICBjbGllbnQubWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5tYXJrSW5ib3hOb3RpZmljYXRpb25SZWFkKFxuICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZCxcbiAgICAgICAgICAgIHJlYWRBdCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZFxuICAgICAgICAgICk7XG4gICAgICAgICAgZm9yIChjb25zdCBwb2xsZXIgb2YgdW5yZWFkTm90aWZpY2F0aW9uc0NvdW50UG9sbGVyc0J5UXVlcnlLZXkudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHBvbGxlci5tYXJrQXNTdGFsZSgpO1xuICAgICAgICAgICAgcG9sbGVyLnBvbGxOb3dJZlN0YWxlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNJZCk7XG4gICAgICAgICAgY2xpZW50W2tJbnRlcm5hbDNdLmVtaXRFcnJvcihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJNQVJLX0lOQk9YX05PVElGSUNBVElPTl9BU19SRUFEX0VSUk9SXCIsXG4gICAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWRfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMigoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSwgdW5yZWFkTm90aWZpY2F0aW9uc0NvdW50UG9sbGVyc0J5UXVlcnlLZXkgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCByZWFkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgdHlwZTogXCJtYXJrLWFsbC1pbmJveC1ub3RpZmljYXRpb25zLWFzLXJlYWRcIixcbiAgICAgIHJlYWRBdFxuICAgIH0pO1xuICAgIGNsaWVudC5tYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKCkudGhlbihcbiAgICAgICgpID0+IHtcbiAgICAgICAgc3RvcmUubWFya0FsbEluYm94Tm90aWZpY2F0aW9uc1JlYWQob3B0aW1pc3RpY0lkLCByZWFkQXQpO1xuICAgICAgICBmb3IgKGNvbnN0IHBvbGxlciBvZiB1bnJlYWROb3RpZmljYXRpb25zQ291bnRQb2xsZXJzQnlRdWVyeUtleS52YWx1ZXMoKSkge1xuICAgICAgICAgIHBvbGxlci5tYXJrQXNTdGFsZSgpO1xuICAgICAgICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgKGVycikgPT4ge1xuICAgICAgICBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY0lkKTtcbiAgICAgICAgY2xpZW50W2tJbnRlcm5hbDNdLmVtaXRFcnJvcihcbiAgICAgICAgICAvLyBObyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQgdG8gaW5jbHVkZSBmb3IgdGhpcyBlcnJvclxuICAgICAgICAgIHsgdHlwZTogXCJNQVJLX0FMTF9JTkJPWF9OT1RJRklDQVRJT05TX0FTX1JFQURfRVJST1JcIiB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG4gIH0sIFtjbGllbnRdKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoXG4gICAgKGluYm94Tm90aWZpY2F0aW9uSWQpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIHVucmVhZE5vdGlmaWNhdGlvbnNDb3VudFBvbGxlcnNCeVF1ZXJ5S2V5IH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBkZWxldGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwiZGVsZXRlLWluYm94LW5vdGlmaWNhdGlvblwiLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkLFxuICAgICAgICBkZWxldGVkQXRcbiAgICAgIH0pO1xuICAgICAgY2xpZW50LmRlbGV0ZUluYm94Tm90aWZpY2F0aW9uKGluYm94Tm90aWZpY2F0aW9uSWQpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5kZWxldGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkLCBvcHRpbWlzdGljSWQpO1xuICAgICAgICAgIGZvciAoY29uc3QgcG9sbGVyIG9mIHVucmVhZE5vdGlmaWNhdGlvbnNDb3VudFBvbGxlcnNCeVF1ZXJ5S2V5LnZhbHVlcygpKSB7XG4gICAgICAgICAgICBwb2xsZXIubWFya0FzU3RhbGUoKTtcbiAgICAgICAgICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgIHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgICAgIGNsaWVudFtrSW50ZXJuYWwzXS5lbWl0RXJyb3IoXG4gICAgICAgICAgICB7IHR5cGU6IFwiREVMRVRFX0lOQk9YX05PVElGSUNBVElPTl9FUlJPUlwiLCBpbmJveE5vdGlmaWNhdGlvbklkIH0sXG4gICAgICAgICAgICBlcnJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KGNsaWVudCkge1xuICByZXR1cm4gdXNlQ2FsbGJhY2syKCgpID0+IHtcbiAgICBjb25zdCB7IHN0b3JlLCB1bnJlYWROb3RpZmljYXRpb25zQ291bnRQb2xsZXJzQnlRdWVyeUtleSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgIGNvbnN0IGRlbGV0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICB0eXBlOiBcImRlbGV0ZS1hbGwtaW5ib3gtbm90aWZpY2F0aW9uc1wiLFxuICAgICAgZGVsZXRlZEF0XG4gICAgfSk7XG4gICAgY2xpZW50LmRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucygpLnRoZW4oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHN0b3JlLmRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyhvcHRpbWlzdGljSWQpO1xuICAgICAgICBmb3IgKGNvbnN0IHBvbGxlciBvZiB1bnJlYWROb3RpZmljYXRpb25zQ291bnRQb2xsZXJzQnlRdWVyeUtleS52YWx1ZXMoKSkge1xuICAgICAgICAgIHBvbGxlci5tYXJrQXNTdGFsZSgpO1xuICAgICAgICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgKGVycikgPT4ge1xuICAgICAgICBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY0lkKTtcbiAgICAgICAgY2xpZW50W2tJbnRlcm5hbDNdLmVtaXRFcnJvcihcbiAgICAgICAgICB7IHR5cGU6IFwiREVMRVRFX0FMTF9JTkJPWF9OT1RJRklDQVRJT05TX0VSUk9SXCIgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuICB9LCBbY2xpZW50XSk7XG59XG5mdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZF93aXRoQ2xpZW50KGNsaWVudCwgaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICBjb25zdCB7IHN0b3JlIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIHJldHVybiB1c2VTaWduYWwoXG4gICAgc3RvcmUub3V0cHV0cy50aHJlYWRpZmljYXRpb25zLFxuICAgIHVzZUNhbGxiYWNrMihcbiAgICAgIChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbiA9IHN0YXRlLm5vdGlmaWNhdGlvbnNCeUlkW2luYm94Tm90aWZpY2F0aW9uSWRdID8/IHJhaXNlMihcbiAgICAgICAgICBgSW5ib3ggbm90aWZpY2F0aW9uIHdpdGggSUQgXCIke2luYm94Tm90aWZpY2F0aW9uSWR9XCIgbm90IGZvdW5kYFxuICAgICAgICApO1xuICAgICAgICBpZiAoaW5ib3hOb3RpZmljYXRpb24ua2luZCAhPT0gXCJ0aHJlYWRcIikge1xuICAgICAgICAgIHJhaXNlMihcbiAgICAgICAgICAgIGBJbmJveCBub3RpZmljYXRpb24gd2l0aCBJRCBcIiR7aW5ib3hOb3RpZmljYXRpb25JZH1cIiBpcyBub3Qgb2Yga2luZCBcInRocmVhZFwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhyZWFkID0gc3RhdGUudGhyZWFkc0RCLmdldChpbmJveE5vdGlmaWNhdGlvbi50aHJlYWRJZCkgPz8gcmFpc2UyKFxuICAgICAgICAgIGBUaHJlYWQgd2l0aCBJRCBcIiR7aW5ib3hOb3RpZmljYXRpb24udGhyZWFkSWR9XCIgbm90IGZvdW5kLCB0aGlzIGluYm94IG5vdGlmaWNhdGlvbiBtaWdodCBub3QgYmUgb2Yga2luZCBcInRocmVhZFwiYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhyZWFkO1xuICAgICAgfSxcbiAgICAgIFtpbmJveE5vdGlmaWNhdGlvbklkXVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoXG4gICAgKHNldHRpbmdzKSA9PiB7XG4gICAgICBjb25zdCB7IHN0b3JlIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgICB0eXBlOiBcInVwZGF0ZS1ub3RpZmljYXRpb24tc2V0dGluZ3NcIixcbiAgICAgICAgc2V0dGluZ3NcbiAgICAgIH0pO1xuICAgICAgY2xpZW50LnVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKS50aGVuKFxuICAgICAgICAoc2V0dGluZ3MyKSA9PiB7XG4gICAgICAgICAgc3RvcmUudXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NfY29uZmlybU9wdGltaXN0aWNVcGRhdGUoXG4gICAgICAgICAgICBzZXR0aW5nczIsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEh0dHBFcnJvcikge1xuICAgICAgICAgICAgaWYgKGVyci5zdGF0dXMgPT09IDQyMikge1xuICAgICAgICAgICAgICBjb25zdCBtc2cgPSBbZXJyLmRldGFpbHM/LmVycm9yLCBlcnIuZGV0YWlscz8ucmVhc29uXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgY29uc29sZTIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsaWVudFtrSW50ZXJuYWwzXS5lbWl0RXJyb3IoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlVQREFURV9OT1RJRklDQVRJT05fU0VUVElOR1NfRVJST1JcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50XVxuICApO1xufVxuZnVuY3Rpb24gdXNlTm90aWZpY2F0aW9uU2V0dGluZ3Nfd2l0aENsaWVudChjbGllbnQpIHtcbiAgY29uc3QgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MgPSB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc193aXRoQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHsgc3RvcmUsIG5vdGlmaWNhdGlvblNldHRpbmdzUG9sbGVyOiBwb2xsZXIgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgdm9pZCBzdG9yZS5vdXRwdXRzLm5vdGlmaWNhdGlvblNldHRpbmdzLndhaXRVbnRpbExvYWRlZCgpO1xuICB9KTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgcG9sbGVyLmluYygpO1xuICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb2xsZXIuZGVjKCk7XG4gICAgfTtcbiAgfSwgW3BvbGxlcl0pO1xuICBjb25zdCByZXN1bHQgPSB1c2VTaWduYWwoc3RvcmUub3V0cHV0cy5ub3RpZmljYXRpb25TZXR0aW5ncy5zaWduYWwpO1xuICByZXR1cm4gdXNlTWVtbzMoKCkgPT4ge1xuICAgIHJldHVybiBbcmVzdWx0LCB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc107XG4gIH0sIFtyZXN1bHQsIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzXSk7XG59XG5mdW5jdGlvbiB1c2VOb3RpZmljYXRpb25TZXR0aW5nc1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkuc3RvcmU7XG4gIHVzZShzdG9yZS5vdXRwdXRzLm5vdGlmaWNhdGlvblNldHRpbmdzLndhaXRVbnRpbExvYWRlZCgpKTtcbiAgY29uc3QgW3Jlc3VsdCwgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NdID0gdXNlTm90aWZpY2F0aW9uU2V0dGluZ3Nfd2l0aENsaWVudChjbGllbnQpO1xuICBhc3NlcnQoIXJlc3VsdC5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiB1c2VNZW1vMygoKSA9PiB7XG4gICAgcmV0dXJuIFtyZXN1bHQsIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzXTtcbiAgfSwgW3Jlc3VsdCwgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NdKTtcbn1cbmZ1bmN0aW9uIHVzZVVzZXJfd2l0aENsaWVudChjbGllbnQsIHVzZXJJZCkge1xuICBjb25zdCB1c2Vyc1N0b3JlID0gY2xpZW50W2tJbnRlcm5hbDNdLnVzZXJzU3RvcmU7XG4gIGNvbnN0IGdldFVzZXJTdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAoKSA9PiB1c2Vyc1N0b3JlLmdldEl0ZW1TdGF0ZSh1c2VySWQpLFxuICAgIFt1c2Vyc1N0b3JlLCB1c2VySWRdXG4gICk7XG4gIGNvbnN0IHNlbGVjdG9yID0gdXNlQ2FsbGJhY2syKFxuICAgIChzdGF0ZSkgPT4gc2VsZWN0b3JGb3JfdXNlVXNlcihzdGF0ZSwgdXNlcklkKSxcbiAgICBbdXNlcklkXVxuICApO1xuICBjb25zdCByZXN1bHQgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICB1c2Vyc1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRVc2VyU3RhdGUsXG4gICAgZ2V0VXNlclN0YXRlLFxuICAgIHNlbGVjdG9yLFxuICAgIHNoYWxsb3czXG4gICk7XG4gIHVzZUVmZmVjdDQoXG4gICAgKCkgPT4gdm9pZCB1c2Vyc1N0b3JlLmVucXVldWUodXNlcklkKVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIHVzZXJzU3RvcmUuZW5xdWV1ZSBvbiAqZXZlcnkqIHJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGhhcm1sZXNzIHRob3VnaCwgb24gbW9zdCByZW5kZXJzLCBleGNlcHQ6XG4gICAgLy8gMS4gVGhlIHZlcnkgZmlyc3QgcmVuZGVyLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gdHJpZ2dlciBldmFsdWF0aW9uXG4gICAgLy8gICAgb2YgdGhlIHVzZXJJZC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBhcmUgYSBuby1vcCAoZnJvbSB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAvLyAgICBvZiAuZW5xdWV1ZSlcbiAgICAvLyAzLiBJZiBldmVyIHRoZSB1c2VySWQgZ2V0cyBpbnZhbGlkYXRlZCwgdGhlIHVzZXIgd291bGQgYmUgZmV0Y2hlZCBhZ2Fpbi5cbiAgKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVzZVVzZXJTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKSB7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjbGllbnRba0ludGVybmFsM10udXNlcnNTdG9yZTtcbiAgY29uc3QgZ2V0VXNlclN0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IHVzZXJzU3RvcmUuZ2V0SXRlbVN0YXRlKHVzZXJJZCksXG4gICAgW3VzZXJzU3RvcmUsIHVzZXJJZF1cbiAgKTtcbiAgY29uc3QgdXNlclN0YXRlID0gZ2V0VXNlclN0YXRlKCk7XG4gIGlmICghdXNlclN0YXRlIHx8IHVzZXJTdGF0ZS5pc0xvYWRpbmcpIHtcbiAgICB0aHJvdyB1c2Vyc1N0b3JlLmVucXVldWUodXNlcklkKTtcbiAgfVxuICBpZiAodXNlclN0YXRlLmVycm9yKSB7XG4gICAgdGhyb3cgdXNlclN0YXRlLmVycm9yO1xuICB9XG4gIGlmICghdXNlclN0YXRlLmRhdGEpIHtcbiAgICB0aHJvdyBtaXNzaW5nVXNlckVycm9yKHVzZXJJZCk7XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgdXNlcnNTdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0VXNlclN0YXRlLFxuICAgIGdldFVzZXJTdGF0ZVxuICApO1xuICBhc3NlcnQoc3RhdGUgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3Npbmcgc3RhdGVcIik7XG4gIGFzc2VydCghc3RhdGUuaXNMb2FkaW5nLCBcIlVuZXhwZWN0ZWQgbG9hZGluZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0KCFzdGF0ZS5lcnJvciwgXCJVbmV4cGVjdGVkIGVycm9yIHN0YXRlXCIpO1xuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgdXNlcjogc3RhdGUuZGF0YSxcbiAgICBlcnJvcjogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiB1c2VSb29tSW5mb193aXRoQ2xpZW50KGNsaWVudCwgcm9vbUlkKSB7XG4gIGNvbnN0IHJvb21zSW5mb1N0b3JlID0gY2xpZW50W2tJbnRlcm5hbDNdLnJvb21zSW5mb1N0b3JlO1xuICBjb25zdCBnZXRSb29tSW5mb1N0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IHJvb21zSW5mb1N0b3JlLmdldEl0ZW1TdGF0ZShyb29tSWQpLFxuICAgIFtyb29tc0luZm9TdG9yZSwgcm9vbUlkXVxuICApO1xuICBjb25zdCBzZWxlY3RvciA9IHVzZUNhbGxiYWNrMihcbiAgICAoc3RhdGUpID0+IHNlbGVjdG9yRm9yX3VzZVJvb21JbmZvKHN0YXRlLCByb29tSWQpLFxuICAgIFtyb29tSWRdXG4gICk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHJvb21zSW5mb1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRSb29tSW5mb1N0YXRlLFxuICAgIGdldFJvb21JbmZvU3RhdGUsXG4gICAgc2VsZWN0b3IsXG4gICAgc2hhbGxvdzNcbiAgKTtcbiAgdXNlRWZmZWN0NChcbiAgICAoKSA9PiB2b2lkIHJvb21zSW5mb1N0b3JlLmVucXVldWUocm9vbUlkKVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIHJvb21zSW5mb1N0b3JlLmVucXVldWUgb24gKmV2ZXJ5KiByZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBoYXJtbGVzcyB0aG91Z2gsIG9uIG1vc3QgcmVuZGVycywgZXhjZXB0OlxuICAgIC8vIDEuIFRoZSB2ZXJ5IGZpcnN0IHJlbmRlciwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHRyaWdnZXIgZXZhbHVhdGlvblxuICAgIC8vICAgIG9mIHRoZSByb29tSWQuXG4gICAgLy8gMi4gQWxsIG90aGVyIHN1YnNlcXVlbnQgcmVuZGVycyBub3cgYXJlIGEgbm8tb3AgKGZyb20gdGhlIGltcGxlbWVudGF0aW9uXG4gICAgLy8gICAgb2YgLmVucXVldWUpXG4gICAgLy8gMy4gSWYgZXZlciB0aGUgcm9vbUlkIGdldHMgaW52YWxpZGF0ZWQsIHRoZSByb29tIGluZm8gd291bGQgYmUgZmV0Y2hlZCBhZ2Fpbi5cbiAgKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIHJvb21JZCkge1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwzXS5yb29tc0luZm9TdG9yZTtcbiAgY29uc3QgZ2V0Um9vbUluZm9TdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAoKSA9PiByb29tc0luZm9TdG9yZS5nZXRJdGVtU3RhdGUocm9vbUlkKSxcbiAgICBbcm9vbXNJbmZvU3RvcmUsIHJvb21JZF1cbiAgKTtcbiAgY29uc3Qgcm9vbUluZm9TdGF0ZSA9IGdldFJvb21JbmZvU3RhdGUoKTtcbiAgaWYgKCFyb29tSW5mb1N0YXRlIHx8IHJvb21JbmZvU3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgdGhyb3cgcm9vbXNJbmZvU3RvcmUuZW5xdWV1ZShyb29tSWQpO1xuICB9XG4gIGlmIChyb29tSW5mb1N0YXRlLmVycm9yKSB7XG4gICAgdGhyb3cgcm9vbUluZm9TdGF0ZS5lcnJvcjtcbiAgfVxuICBpZiAoIXJvb21JbmZvU3RhdGUuZGF0YSkge1xuICAgIHRocm93IG1pc3NpbmdSb29tSW5mb0Vycm9yKHJvb21JZCk7XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgcm9vbXNJbmZvU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldFJvb21JbmZvU3RhdGUsXG4gICAgZ2V0Um9vbUluZm9TdGF0ZVxuICApO1xuICBhc3NlcnQoc3RhdGUgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3Npbmcgc3RhdGVcIik7XG4gIGFzc2VydCghc3RhdGUuaXNMb2FkaW5nLCBcIlVuZXhwZWN0ZWQgbG9hZGluZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0KCFzdGF0ZS5lcnJvciwgXCJVbmV4cGVjdGVkIGVycm9yIHN0YXRlXCIpO1xuICBhc3NlcnQoc3RhdGUuZGF0YSAhPT0gdm9pZCAwLCBcIlVuZXhwZWN0ZWQgbWlzc2luZyByb29tIGluZm8gZGF0YVwiKTtcbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIGluZm86IHN0YXRlLmRhdGEsXG4gICAgZXJyb3I6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gdXNlR3JvdXBJbmZvX3dpdGhDbGllbnQoY2xpZW50LCBncm91cElkKSB7XG4gIGNvbnN0IGdyb3Vwc0luZm9TdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwzXS5ncm91cHNJbmZvU3RvcmU7XG4gIGNvbnN0IGdldEdyb3VwSW5mb1N0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IGdyb3Vwc0luZm9TdG9yZS5nZXRJdGVtU3RhdGUoZ3JvdXBJZCksXG4gICAgW2dyb3Vwc0luZm9TdG9yZSwgZ3JvdXBJZF1cbiAgKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSB1c2VDYWxsYmFjazIoXG4gICAgKHN0YXRlKSA9PiBzZWxlY3RvckZvcl91c2VHcm91cEluZm8oc3RhdGUsIGdyb3VwSWQpLFxuICAgIFtncm91cElkXVxuICApO1xuICBjb25zdCByZXN1bHQgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICBncm91cHNJbmZvU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldEdyb3VwSW5mb1N0YXRlLFxuICAgIGdldEdyb3VwSW5mb1N0YXRlLFxuICAgIHNlbGVjdG9yLFxuICAgIHNoYWxsb3czXG4gICk7XG4gIHVzZUVmZmVjdDQoXG4gICAgKCkgPT4gdm9pZCBncm91cHNJbmZvU3RvcmUuZW5xdWV1ZShncm91cElkKVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIGdyb3Vwc0luZm9TdG9yZS5lbnF1ZXVlIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIGV2YWx1YXRpb25cbiAgICAvLyAgICBvZiB0aGUgZ3JvdXBJZC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBhcmUgYSBuby1vcCAoZnJvbSB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAvLyAgICBvZiAuZW5xdWV1ZSlcbiAgICAvLyAzLiBJZiBldmVyIHRoZSBncm91cElkIGdldHMgaW52YWxpZGF0ZWQsIHRoZSBncm91cCBpbmZvIHdvdWxkIGJlIGZldGNoZWQgYWdhaW4uXG4gICk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VHcm91cEluZm9TdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgZ3JvdXBJZCkge1xuICBjb25zdCBncm91cHNJbmZvU3RvcmUgPSBjbGllbnRba0ludGVybmFsM10uZ3JvdXBzSW5mb1N0b3JlO1xuICBjb25zdCBnZXRHcm91cEluZm9TdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAoKSA9PiBncm91cHNJbmZvU3RvcmUuZ2V0SXRlbVN0YXRlKGdyb3VwSWQpLFxuICAgIFtncm91cHNJbmZvU3RvcmUsIGdyb3VwSWRdXG4gICk7XG4gIGNvbnN0IGdyb3VwSW5mb1N0YXRlID0gZ2V0R3JvdXBJbmZvU3RhdGUoKTtcbiAgaWYgKCFncm91cEluZm9TdGF0ZSB8fCBncm91cEluZm9TdGF0ZS5pc0xvYWRpbmcpIHtcbiAgICB0aHJvdyBncm91cHNJbmZvU3RvcmUuZW5xdWV1ZShncm91cElkKTtcbiAgfVxuICBpZiAoZ3JvdXBJbmZvU3RhdGUuZXJyb3IpIHtcbiAgICB0aHJvdyBncm91cEluZm9TdGF0ZS5lcnJvcjtcbiAgfVxuICBpZiAoIWdyb3VwSW5mb1N0YXRlLmRhdGEpIHtcbiAgICB0aHJvdyBtaXNzaW5nR3JvdXBJbmZvRXJyb3IoZ3JvdXBJZCk7XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgZ3JvdXBzSW5mb1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRHcm91cEluZm9TdGF0ZSxcbiAgICBnZXRHcm91cEluZm9TdGF0ZVxuICApO1xuICBhc3NlcnQoc3RhdGUgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3Npbmcgc3RhdGVcIik7XG4gIGFzc2VydCghc3RhdGUuaXNMb2FkaW5nLCBcIlVuZXhwZWN0ZWQgbG9hZGluZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0KCFzdGF0ZS5lcnJvciwgXCJVbmV4cGVjdGVkIGVycm9yIHN0YXRlXCIpO1xuICBhc3NlcnQoc3RhdGUuZGF0YSAhPT0gdm9pZCAwLCBcIlVuZXhwZWN0ZWQgbWlzc2luZyBncm91cCBpbmZvIGRhdGFcIik7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICBpbmZvOiBzdGF0ZS5kYXRhLFxuICAgIGVycm9yOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUFpQ2hhdHMob3B0aW9ucykge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRVbWJyZWxsYVN0b3JlRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZUFpQ2hhdHNRdWVyeUtleShvcHRpb25zPy5xdWVyeSk7XG4gIHVzZUVuc3VyZUFpQ29ubmVjdGlvbihjbGllbnQpO1xuICB1c2VFZmZlY3Q0KFxuICAgICgpID0+IHZvaWQgc3RvcmUub3V0cHV0cy5haUNoYXRzLmdldE9yQ3JlYXRlKHF1ZXJ5S2V5KS53YWl0VW50aWxMb2FkZWQoKVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIHdhaXRVbnRpbCBvbiAqZXZlcnkqIHJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGhhcm1sZXNzIHRob3VnaCwgb24gbW9zdCByZW5kZXJzLCBleGNlcHQ6XG4gICAgLy8gMS4gVGhlIHZlcnkgZmlyc3QgcmVuZGVyLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gdHJpZ2dlciB0aGUgaW5pdGlhbCBwYWdlIGZldGNoLlxuICAgIC8vIDIuIEFsbCBvdGhlciBzdWJzZXF1ZW50IHJlbmRlcnMgbm93IFwianVzdFwiIHJldHVybiB0aGUgc2FtZSBwcm9taXNlIChhIHF1aWNrIG9wZXJhdGlvbikuXG4gICAgLy8gMy4gSWYgZXZlciB0aGUgcHJvbWlzZSB3b3VsZCBmYWlsLCB0aGVuIGFmdGVyIDUgc2Vjb25kcyBpdCB3b3VsZCByZXNldCwgYW5kIG9uIHRoZSB2ZXJ5XG4gICAgLy8gICAgKm5leHQqIHJlbmRlciBhZnRlciB0aGF0LCBhICpuZXcqIGZldGNoL3Byb21pc2Ugd2lsbCBnZXQgY3JlYXRlZC5cbiAgKTtcbiAgcmV0dXJuIHVzZVNpZ25hbChcbiAgICBzdG9yZS5vdXRwdXRzLmFpQ2hhdHMuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLnNpZ25hbCxcbiAgICBpZGVudGl0eTIsXG4gICAgc2hhbGxvdzNcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUFpQ2hhdHNTdXNwZW5zZShvcHRpb25zKSB7XG4gIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudChjbGllbnQpO1xuICB1c2VFbnN1cmVBaUNvbm5lY3Rpb24oY2xpZW50KTtcbiAgY29uc3QgcXVlcnlLZXkgPSBtYWtlQWlDaGF0c1F1ZXJ5S2V5KG9wdGlvbnM/LnF1ZXJ5KTtcbiAgdXNlKHN0b3JlLm91dHB1dHMuYWlDaGF0cy5nZXRPckNyZWF0ZShxdWVyeUtleSkud2FpdFVudGlsTG9hZGVkKCkpO1xuICBjb25zdCByZXN1bHQgPSB1c2VBaUNoYXRzKG9wdGlvbnMpO1xuICBhc3NlcnQoIXJlc3VsdC5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VBaUNoYXRNZXNzYWdlcyhjaGF0SWQsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudChjbGllbnQpO1xuICB1c2VFbnN1cmVBaUNvbm5lY3Rpb24oY2xpZW50KTtcbiAgdXNlRWZmZWN0NChcbiAgICAoKSA9PiB2b2lkIHN0b3JlLm91dHB1dHMubWVzc2FnZXNCeUNoYXRJZC5nZXRPckNyZWF0ZShjaGF0SWQpLmdldE9yQ3JlYXRlKG9wdGlvbnM/LmJyYW5jaElkID8/IG51bGwpLndhaXRVbnRpbExvYWRlZCgpXG4gICAgLy8gTk9URTogRGVsaWJlcmF0ZWx5ICpub3QqIHVzaW5nIGEgZGVwZW5kZW5jeSBhcnJheSBoZXJlIVxuICAgIC8vXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNhbGwgd2FpdFVudGlsIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIHRoZSBpbml0aWFsIHBhZ2UgZmV0Y2guXG4gICAgLy8gMi4gQWxsIG90aGVyIHN1YnNlcXVlbnQgcmVuZGVycyBub3cgXCJqdXN0XCIgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UgKGEgcXVpY2sgb3BlcmF0aW9uKS5cbiAgICAvLyAzLiBJZiBldmVyIHRoZSBwcm9taXNlIHdvdWxkIGZhaWwsIHRoZW4gYWZ0ZXIgNSBzZWNvbmRzIGl0IHdvdWxkIHJlc2V0LCBhbmQgb24gdGhlIHZlcnlcbiAgICAvLyAgICAqbmV4dCogcmVuZGVyIGFmdGVyIHRoYXQsIGEgKm5ldyogZmV0Y2gvcHJvbWlzZSB3aWxsIGdldCBjcmVhdGVkLlxuICApO1xuICByZXR1cm4gdXNlU2lnbmFsKFxuICAgIHN0b3JlLm91dHB1dHMubWVzc2FnZXNCeUNoYXRJZC5nZXRPckNyZWF0ZShjaGF0SWQpLmdldE9yQ3JlYXRlKG9wdGlvbnM/LmJyYW5jaElkID8/IG51bGwpLnNpZ25hbFxuICApO1xufVxuZnVuY3Rpb24gdXNlQWlDaGF0TWVzc2FnZXNTdXNwZW5zZShjaGF0SWQsIG9wdGlvbnMpIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRVbWJyZWxsYVN0b3JlRm9yQ2xpZW50KGNsaWVudCk7XG4gIHVzZUVuc3VyZUFpQ29ubmVjdGlvbihjbGllbnQpO1xuICB1c2UoXG4gICAgc3RvcmUub3V0cHV0cy5tZXNzYWdlc0J5Q2hhdElkLmdldE9yQ3JlYXRlKGNoYXRJZCkuZ2V0T3JDcmVhdGUob3B0aW9ucz8uYnJhbmNoSWQgPz8gbnVsbCkud2FpdFVudGlsTG9hZGVkKClcbiAgKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlQWlDaGF0TWVzc2FnZXMoY2hhdElkLCBvcHRpb25zKTtcbiAgYXNzZXJ0KCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIGFzc2VydCghcmVzdWx0LmlzTG9hZGluZywgXCJEaWQgbm90IGV4cGVjdCBsb2FkaW5nXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlQWlDaGF0KGNoYXRJZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRVbWJyZWxsYVN0b3JlRm9yQ2xpZW50KGNsaWVudCk7XG4gIHVzZUVuc3VyZUFpQ29ubmVjdGlvbihjbGllbnQpO1xuICB1c2VFZmZlY3Q0KFxuICAgICgpID0+IHZvaWQgc3RvcmUub3V0cHV0cy5haUNoYXRCeUlkLmdldE9yQ3JlYXRlKGNoYXRJZCkud2FpdFVudGlsTG9hZGVkKClcbiAgICAvLyBOT1RFOiBEZWxpYmVyYXRlbHkgKm5vdCogdXNpbmcgYSBkZXBlbmRlbmN5IGFycmF5IGhlcmUhXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCB3YWl0VW50aWwgb24gKmV2ZXJ5KiByZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBoYXJtbGVzcyB0aG91Z2gsIG9uIG1vc3QgcmVuZGVycywgZXhjZXB0OlxuICAgIC8vIDEuIFRoZSB2ZXJ5IGZpcnN0IHJlbmRlciwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHRyaWdnZXIgdGhlIGluaXRpYWwgcGFnZSBmZXRjaC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBcImp1c3RcIiByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZSAoYSBxdWljayBvcGVyYXRpb24pLlxuICAgIC8vIDMuIElmIGV2ZXIgdGhlIHByb21pc2Ugd291bGQgZmFpbCwgdGhlbiBhZnRlciA1IHNlY29uZHMgaXQgd291bGQgcmVzZXQsIGFuZCBvbiB0aGUgdmVyeVxuICAgIC8vICAgICpuZXh0KiByZW5kZXIgYWZ0ZXIgdGhhdCwgYSAqbmV3KiBmZXRjaC9wcm9taXNlIHdpbGwgZ2V0IGNyZWF0ZWQuXG4gICk7XG4gIHJldHVybiB1c2VTaWduYWwoc3RvcmUub3V0cHV0cy5haUNoYXRCeUlkLmdldE9yQ3JlYXRlKGNoYXRJZCkuc2lnbmFsKTtcbn1cbmZ1bmN0aW9uIHVzZUFpQ2hhdFN1c3BlbnNlKGNoYXRJZCkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCBzdG9yZSA9IGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQoY2xpZW50KTtcbiAgdXNlRW5zdXJlQWlDb25uZWN0aW9uKGNsaWVudCk7XG4gIHVzZShzdG9yZS5vdXRwdXRzLmFpQ2hhdEJ5SWQuZ2V0T3JDcmVhdGUoY2hhdElkKS53YWl0VW50aWxMb2FkZWQoKSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZUFpQ2hhdChjaGF0SWQpO1xuICBhc3NlcnQoIXJlc3VsdC5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VVcmxNZXRhZGF0YSh1cmwpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudChjbGllbnQpO1xuICB1c2VFZmZlY3Q0KFxuICAgICgpID0+IHZvaWQgc3RvcmUub3V0cHV0cy51cmxNZXRhZGF0YUJ5VXJsLmdldE9yQ3JlYXRlKHVybCkud2FpdFVudGlsTG9hZGVkKClcbiAgICAvLyBOT1RFOiBEZWxpYmVyYXRlbHkgKm5vdCogdXNpbmcgYSBkZXBlbmRlbmN5IGFycmF5IGhlcmUhXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCB3YWl0VW50aWwgb24gKmV2ZXJ5KiByZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBoYXJtbGVzcyB0aG91Z2gsIG9uIG1vc3QgcmVuZGVycywgZXhjZXB0OlxuICAgIC8vIDEuIFRoZSB2ZXJ5IGZpcnN0IHJlbmRlciwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHRyaWdnZXIgdGhlIGluaXRpYWwgcGFnZSBmZXRjaC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBcImp1c3RcIiByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZSAoYSBxdWljayBvcGVyYXRpb24pLlxuICAgIC8vIDMuIElmIGV2ZXIgdGhlIHByb21pc2Ugd291bGQgZmFpbCwgdGhlbiBhZnRlciA1IHNlY29uZHMgaXQgd291bGQgcmVzZXQsIGFuZCBvbiB0aGUgdmVyeVxuICAgIC8vICAgICpuZXh0KiByZW5kZXIgYWZ0ZXIgdGhhdCwgYSAqbmV3KiBmZXRjaC9wcm9taXNlIHdpbGwgZ2V0IGNyZWF0ZWQuXG4gICk7XG4gIHJldHVybiB1c2VTaWduYWwoc3RvcmUub3V0cHV0cy51cmxNZXRhZGF0YUJ5VXJsLmdldE9yQ3JlYXRlKHVybCkuc2lnbmFsKTtcbn1cbmZ1bmN0aW9uIHVzZVVybE1ldGFkYXRhU3VzcGVuc2UodXJsKSB7XG4gIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudChjbGllbnQpO1xuICB1c2Uoc3RvcmUub3V0cHV0cy51cmxNZXRhZGF0YUJ5VXJsLmdldE9yQ3JlYXRlKHVybCkud2FpdFVudGlsTG9hZGVkKCkpO1xuICBjb25zdCByZXN1bHQgPSB1c2VVcmxNZXRhZGF0YSh1cmwpO1xuICBhc3NlcnQoIXJlc3VsdC5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVBaUNoYXQoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2syKFxuICAgIChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgaWQ6IG9wdGlvbnMgfTtcbiAgICAgIH1cbiAgICAgIGNsaWVudFtrSW50ZXJuYWwzXS5haS5nZXRPckNyZWF0ZUNoYXQob3B0aW9ucy5pZCwge1xuICAgICAgICB0aXRsZTogb3B0aW9ucy50aXRsZSxcbiAgICAgICAgbWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGFcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZTIuZXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBjcmVhdGUgY2hhdCB3aXRoIElEIFwiJHtvcHRpb25zLmlkfVwiOiAke1N0cmluZyhlcnIpfWBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW2NsaWVudF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZUFpQ2hhdCgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoXG4gICAgKGNoYXRJZCkgPT4ge1xuICAgICAgY2xpZW50W2tJbnRlcm5hbDNdLmFpLmRlbGV0ZUNoYXQoY2hhdElkKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUyLmVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gZGVsZXRlIGNoYXQgd2l0aCBJRCBcIiR7Y2hhdElkfVwiOiAke1N0cmluZyhlcnIpfWBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW2NsaWVudF1cbiAgKTtcbn1cbnZhciBESVNDT05ORUNURUQgPSBPYmplY3QuZnJlZXplKHsgc3RhdHVzOiBcImRpc2Nvbm5lY3RlZFwiIH0pO1xudmFyIExPQURJTkcgPSBPYmplY3QuZnJlZXplKHsgc3RhdHVzOiBcImxvYWRpbmdcIiB9KTtcbnZhciBJRExFID0gT2JqZWN0LmZyZWV6ZSh7IHN0YXR1czogXCJpZGxlXCIgfSk7XG5mdW5jdGlvbiB1c2VBaUNoYXRTdGF0dXMoY2hhdElkLCBicmFuY2hJZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRVbWJyZWxsYVN0b3JlRm9yQ2xpZW50KGNsaWVudCk7XG4gIHVzZUVuc3VyZUFpQ29ubmVjdGlvbihjbGllbnQpO1xuICB1c2VFZmZlY3Q0KFxuICAgICgpID0+IHZvaWQgc3RvcmUub3V0cHV0cy5tZXNzYWdlc0J5Q2hhdElkLmdldE9yQ3JlYXRlKGNoYXRJZCkuZ2V0T3JDcmVhdGUoYnJhbmNoSWQgPz8gbnVsbCkud2FpdFVudGlsTG9hZGVkKClcbiAgKTtcbiAgY29uc3QgaXNBdmFpbGFibGUgPSB1c2VTaWduYWwoXG4gICAgLy8gU3Vic2NyaWJlIHRvIGNvbm5lY3Rpb24gc3RhdHVzIHNpZ25hbFxuICAgIGNsaWVudFtrSW50ZXJuYWwzXS5haS5zaWduYWxzLnN0YXR1c1xcdTAzQTMsXG4gICAgLy8gXCJEaXNjb25uZWN0ZWRcIiBtZWFucyB0aGUgQUkgc2VydmljZSBpcyBub3QgYXZhaWxhYmxlXG4gICAgLy8gYXMgaXQgcmVwcmVzZW50cyBhIGZpbmFsIGVycm9yIHN0YXR1cy5cbiAgICAoc3RhdHVzKSA9PiBzdGF0dXMgIT09IFwiZGlzY29ubmVjdGVkXCJcbiAgKTtcbiAgY29uc3QgY2hhdFN0YXR1cyA9IHVzZVNpZ25hbChcbiAgICAvLyBTaWduYWxcbiAgICBzdG9yZS5vdXRwdXRzLm1lc3NhZ2VzQnlDaGF0SWQuZ2V0T3JDcmVhdGUoY2hhdElkKS5nZXRPckNyZWF0ZShicmFuY2hJZCA/PyBudWxsKS5zaWduYWwsXG4gICAgLy8gU2VsZWN0b3JcbiAgICAocmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0LmlzTG9hZGluZykgcmV0dXJuIExPQURJTkc7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSByZXR1cm4gSURMRTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gcmVzdWx0Lm1lc3NhZ2VzO1xuICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0TWVzc2FnZT8ucm9sZSAhPT0gXCJhc3Npc3RhbnRcIikgcmV0dXJuIElETEU7XG4gICAgICBpZiAobGFzdE1lc3NhZ2Uuc3RhdHVzICE9PSBcImdlbmVyYXRpbmdcIiAmJiBsYXN0TWVzc2FnZS5zdGF0dXMgIT09IFwiYXdhaXRpbmctdG9vbFwiKVxuICAgICAgICByZXR1cm4gSURMRTtcbiAgICAgIGNvbnN0IGNvbnRlbnRTb0ZhciA9IGxhc3RNZXNzYWdlLmNvbnRlbnRTb0ZhcjtcbiAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gY29udGVudFNvRmFyW2NvbnRlbnRTb0Zhci5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0UGFydD8udHlwZSA9PT0gXCJ0b29sLWludm9jYXRpb25cIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogXCJnZW5lcmF0aW5nXCIsXG4gICAgICAgICAgcGFydFR5cGU6IFwidG9vbC1pbnZvY2F0aW9uXCIsXG4gICAgICAgICAgdG9vbE5hbWU6IGxhc3RQYXJ0Lm5hbWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBcImdlbmVyYXRpbmdcIixcbiAgICAgICAgICBwYXJ0VHlwZTogbGFzdFBhcnQ/LnR5cGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIENvbnNpZGVyIHsgc3RhdHVzOiBcImdlbmVyYXRpbmdcIiwgcGFydFR5cGU6IFwidGV4dFwiIH0gYW5kIHsgc3RhdHVzOiBcImdlbmVyYXRpbmdcIiwgcGFydFR5cGU6IFwidGV4dFwiIH0gZXF1YWxcbiAgICBzaGFsbG93M1xuICApO1xuICBpZiAoIWlzQXZhaWxhYmxlKSB7XG4gICAgcmV0dXJuIERJU0NPTk5FQ1RFRDtcbiAgfVxuICByZXR1cm4gY2hhdFN0YXR1cztcbn1cbmZ1bmN0aW9uIHVzZVNlbmRBaU1lc3NhZ2UoY2hhdElkLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2syKFxuICAgIChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRleHQ6IG1lc3NhZ2VUZXh0LFxuICAgICAgICBjaGF0SWQ6IG1lc3NhZ2VPcHRpb25zQ2hhdElkLFxuICAgICAgICBjb3BpbG90SWQ6IG1lc3NhZ2VPcHRpb25zQ29waWxvdElkLFxuICAgICAgICAuLi5tZXNzYWdlT3B0aW9uc1xuICAgICAgfSA9IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyB0ZXh0OiBtZXNzYWdlIH0gOiBtZXNzYWdlO1xuICAgICAgY29uc3QgcmVzb2x2ZWRDaGF0SWQgPSBtZXNzYWdlT3B0aW9uc0NoYXRJZCA/PyBjaGF0SWQgPz8gLy8gVGhlIGB1c2VTZW5kQWlNZXNzYWdlYCBvdmVybG9hZHMgcHJldmVudCB0aGlzIHNjZW5hcmlvIGZyb20gaGFwcGVuaW5nXG4gICAgICAvLyBhdCB0aGUgdHlwZSBsZXZlbCwgYW5kIHRoaXMgZXJyb3IgcHJldmVudHMgaXQgZnJvbSBoYXBwZW5pbmcgYXQgcnVudGltZS5cbiAgICAgIHJhaXNlMihcbiAgICAgICAgXCJjaGF0SWQgbXVzdCBiZSBwcm92aWRlZCB0byBlaXRoZXIgYHVzZVNlbmRBaU1lc3NhZ2VgIG9yIGl0cyByZXR1cm5lZCBmdW5jdGlvbi5cIlxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gY2xpZW50W2tJbnRlcm5hbDNdLmFpLnNpZ25hbHMuZ2V0Q2hhdE1lc3NhZ2VzRm9yQnJhbmNoXFx1MDNBMyhyZXNvbHZlZENoYXRJZCkuZ2V0KCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFtZXNzYWdlT3B0aW9uc0NvcGlsb3RJZCAmJiAhb3B0aW9ucz8uY29waWxvdElkKSB7XG4gICAgICAgIGNvbnNvbGUyLndhcm4oXG4gICAgICAgICAgYE5vIGNvcGlsb3QgSUQgd2FzIHByb3ZpZGVkIHRvIHVzZVNlbmRBaU1lc3NhZ2Ugd2hlbiBzZW5kaW5nIHRoZSBtZXNzYWdlIFwiJHttZXNzYWdlVGV4dC5zbGljZShcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAyMFxuICAgICAgICAgICl9XFx1MjAyNlwiLiBBcyBhIHJlc3VsdCwgdGhlIG1lc3NhZ2Ugd2lsbCB1c2UgdGhlIGNoYXQncyBwcmV2aW91cyBjb3BpbG90IElELCB3aGljaCBjb3VsZCBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXG5UbyBlbnN1cmUgdGhlIGNvcnJlY3QgY29waWxvdCBJRCBpcyB1c2VkLCBzcGVjaWZ5IGl0IGVpdGhlciB0aHJvdWdoIHRoZSBob29rIGFzICd1c2VTZW5kQWlNZXNzYWdlKFwiJHtyZXNvbHZlZENoYXRJZH1cIiwgeyBjb3BpbG90SWQ6IFwiY29feHh4XCIgfSknIG9yIHZpYSB0aGUgZnVuY3Rpb24gYXMgJ3NlbmRBaU1lc3NhZ2UoeyB0ZXh0OiBcIiR7bWVzc2FnZVRleHQuc2xpY2UoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMjBcbiAgICAgICAgICApfVxcdTIwMjZcIiwgY29waWxvdElkOiBcImNvX3h4eFwiIH0pJ2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc29sdmVkQ29waWxvdElkID0gbWVzc2FnZU9wdGlvbnNDb3BpbG90SWQgPz8gb3B0aW9ucz8uY29waWxvdElkID8/IGNsaWVudFtrSW50ZXJuYWwzXS5haS5nZXRMYXN0VXNlZENvcGlsb3RJZChyZXNvbHZlZENoYXRJZCk7XG4gICAgICBjb25zdCBsYXN0TWVzc2FnZUlkID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0/LmlkID8/IG51bGw7XG4gICAgICBjb25zdCBjb250ZW50ID0gW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2VUZXh0IH1dO1xuICAgICAgY29uc3QgbmV3TWVzc2FnZUlkID0gY2xpZW50W2tJbnRlcm5hbDNdLmFpW2tJbnRlcm5hbDNdLmNvbnRleHQubWVzc2FnZXNTdG9yZS5jcmVhdGVPcHRpbWlzdGljYWxseShcbiAgICAgICAgcmVzb2x2ZWRDaGF0SWQsXG4gICAgICAgIFwidXNlclwiLFxuICAgICAgICBsYXN0TWVzc2FnZUlkLFxuICAgICAgICBjb250ZW50XG4gICAgICApO1xuICAgICAgY29uc3QgbmV3TWVzc2FnZSA9IGNsaWVudFtrSW50ZXJuYWwzXS5haVtrSW50ZXJuYWwzXS5jb250ZXh0Lm1lc3NhZ2VzU3RvcmUuZ2V0TWVzc2FnZUJ5SWQobmV3TWVzc2FnZUlkKTtcbiAgICAgIGNvbnN0IHRhcmdldE1lc3NhZ2VJZCA9IGNsaWVudFtrSW50ZXJuYWwzXS5haVtrSW50ZXJuYWwzXS5jb250ZXh0Lm1lc3NhZ2VzU3RvcmUuY3JlYXRlT3B0aW1pc3RpY2FsbHkoXG4gICAgICAgIHJlc29sdmVkQ2hhdElkLFxuICAgICAgICBcImFzc2lzdGFudFwiLFxuICAgICAgICBuZXdNZXNzYWdlSWQsXG4gICAgICAgIHJlc29sdmVkQ29waWxvdElkXG4gICAgICApO1xuICAgICAgdm9pZCBjbGllbnRba0ludGVybmFsM10uYWkuYXNrVXNlck1lc3NhZ2VJbkNoYXQoXG4gICAgICAgIHJlc29sdmVkQ2hhdElkLFxuICAgICAgICB7IGlkOiBuZXdNZXNzYWdlSWQsIHBhcmVudE1lc3NhZ2VJZDogbGFzdE1lc3NhZ2VJZCwgY29udGVudCB9LFxuICAgICAgICB0YXJnZXRNZXNzYWdlSWQsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHJlYW06IG1lc3NhZ2VPcHRpb25zLnN0cmVhbSA/PyBvcHRpb25zPy5zdHJlYW0sXG4gICAgICAgICAgY29waWxvdElkOiByZXNvbHZlZENvcGlsb3RJZCxcbiAgICAgICAgICB0aW1lb3V0OiBtZXNzYWdlT3B0aW9ucy50aW1lb3V0ID8/IG9wdGlvbnM/LnRpbWVvdXRcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXdNZXNzYWdlO1xuICAgIH0sXG4gICAgW2NsaWVudCwgY2hhdElkLCBvcHRpb25zPy5jb3BpbG90SWQsIG9wdGlvbnM/LnN0cmVhbSwgb3B0aW9ucz8udGltZW91dF1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNoYXJlZENvbnRleHQoY2xpZW50KSB7XG4gIGNvbnN0IHVzZUNsaWVudDIgPSAoKSA9PiBjbGllbnQ7XG4gIGZ1bmN0aW9uIHVzZVN5bmNTdGF0dXMyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdXNlU3luY1N0YXR1c193aXRoQ2xpZW50KGNsaWVudCwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjbGFzc2ljOiB7XG4gICAgICB1c2VDbGllbnQ6IHVzZUNsaWVudDIsXG4gICAgICB1c2VVc2VyOiAodXNlcklkKSA9PiB1c2VVc2VyX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpLFxuICAgICAgdXNlUm9vbUluZm86IChyb29tSWQpID0+IHVzZVJvb21JbmZvX3dpdGhDbGllbnQoY2xpZW50LCByb29tSWQpLFxuICAgICAgdXNlR3JvdXBJbmZvOiAoZ3JvdXBJZCkgPT4gdXNlR3JvdXBJbmZvX3dpdGhDbGllbnQoY2xpZW50LCBncm91cElkKSxcbiAgICAgIHVzZUlzSW5zaWRlUm9vbSxcbiAgICAgIHVzZUVycm9yTGlzdGVuZXIsXG4gICAgICB1c2VTeW5jU3RhdHVzOiB1c2VTeW5jU3RhdHVzMixcbiAgICAgIFJlZ2lzdGVyQWlLbm93bGVkZ2UsXG4gICAgICBSZWdpc3RlckFpVG9vbFxuICAgIH0sXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIHVzZUNsaWVudDogdXNlQ2xpZW50MixcbiAgICAgIHVzZVVzZXI6ICh1c2VySWQpID0+IHVzZVVzZXJTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKSxcbiAgICAgIHVzZVJvb21JbmZvOiAocm9vbUlkKSA9PiB1c2VSb29tSW5mb1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCByb29tSWQpLFxuICAgICAgdXNlR3JvdXBJbmZvOiAoZ3JvdXBJZCkgPT4gdXNlR3JvdXBJbmZvU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIGdyb3VwSWQpLFxuICAgICAgdXNlSXNJbnNpZGVSb29tLFxuICAgICAgdXNlRXJyb3JMaXN0ZW5lcixcbiAgICAgIHVzZVN5bmNTdGF0dXM6IHVzZVN5bmNTdGF0dXMyLFxuICAgICAgUmVnaXN0ZXJBaUtub3dsZWRnZSxcbiAgICAgIFJlZ2lzdGVyQWlUb29sXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdXNlRW5zdXJlTm9MaXZlYmxvY2tzUHJvdmlkZXIob3B0aW9ucykge1xuICBjb25zdCBleGlzdGluZyA9IHVzZUNsaWVudE9yTnVsbCgpO1xuICBpZiAoIW9wdGlvbnM/LmFsbG93TmVzdGluZyAmJiBleGlzdGluZyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbm5vdCBuZXN0IG11bHRpcGxlIExpdmVibG9ja3NQcm92aWRlciBpbnN0YW5jZXMgaW4gdGhlIHNhbWUgUmVhY3QgdHJlZS5cIlxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcldpdGhDbGllbnQocHJvcHMpIHtcbiAgdXNlRW5zdXJlTm9MaXZlYmxvY2tzUHJvdmlkZXIocHJvcHMpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChDbGllbnRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwcm9wcy5jbGllbnQsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcihwcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5vIH0gPSBwcm9wcztcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBwdWJsaWNBcGlLZXk6IHVzZUluaXRpYWwoby5wdWJsaWNBcGlLZXkpLFxuICAgIHRocm90dGxlOiB1c2VJbml0aWFsKG8udGhyb3R0bGUpLFxuICAgIGxvc3RDb25uZWN0aW9uVGltZW91dDogdXNlSW5pdGlhbChvLmxvc3RDb25uZWN0aW9uVGltZW91dCksXG4gICAgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQ6IHVzZUluaXRpYWwoby5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCksXG4gICAgcG9seWZpbGxzOiB1c2VJbml0aWFsKG8ucG9seWZpbGxzKSxcbiAgICBsYXJnZU1lc3NhZ2VTdHJhdGVneTogdXNlSW5pdGlhbChvLmxhcmdlTWVzc2FnZVN0cmF0ZWd5KSxcbiAgICB1bnN0YWJsZV9zdHJlYW1EYXRhOiB1c2VJbml0aWFsKG8udW5zdGFibGVfc3RyZWFtRGF0YSksXG4gICAgcHJldmVudFVuc2F2ZWRDaGFuZ2VzOiB1c2VJbml0aWFsKG8ucHJldmVudFVuc2F2ZWRDaGFuZ2VzKSxcbiAgICBhdXRoRW5kcG9pbnQ6IHVzZUluaXRpYWxVbmxlc3NGdW5jdGlvbihvLmF1dGhFbmRwb2ludCksXG4gICAgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uczogdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKFxuICAgICAgby5yZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zXG4gICAgKSxcbiAgICByZXNvbHZlVXNlcnM6IHVzZUluaXRpYWxVbmxlc3NGdW5jdGlvbihvLnJlc29sdmVVc2VycyksXG4gICAgcmVzb2x2ZVJvb21zSW5mbzogdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKG8ucmVzb2x2ZVJvb21zSW5mbyksXG4gICAgcmVzb2x2ZUdyb3Vwc0luZm86IHVzZUluaXRpYWxVbmxlc3NGdW5jdGlvbihvLnJlc29sdmVHcm91cHNJbmZvKSxcbiAgICBiYXNlVXJsOiB1c2VJbml0aWFsKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIEhpZGRlbiBjb25maWcgb3B0aW9uc1xuICAgICAgby5iYXNlVXJsXG4gICAgKSxcbiAgICBlbmFibGVEZWJ1Z0xvZ2dpbmc6IHVzZUluaXRpYWwoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gSGlkZGVuIGNvbmZpZyBvcHRpb25zXG4gICAgICBvLmVuYWJsZURlYnVnTG9nZ2luZ1xuICAgIClcbiAgfTtcbiAgY29uc3QgY2xpZW50ID0gdXNlTWVtbzMoKCkgPT4gY3JlYXRlQ2xpZW50KG9wdGlvbnMpLCBbXSk7XG4gIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uYWkuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtjbGllbnRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goTGl2ZWJsb2Nrc1Byb3ZpZGVyV2l0aENsaWVudCwgeyBjbGllbnQsIGNoaWxkcmVuIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTGl2ZWJsb2Nrc0NvbnRleHQoY2xpZW50KSB7XG4gIHJldHVybiBnZXRPckNyZWF0ZUNvbnRleHRCdW5kbGUoY2xpZW50KTtcbn1cbmZ1bmN0aW9uIHVzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbChvcHRpb25zID0ge30pIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHsgc3RvcmUsIHVzZXJUaHJlYWRzUG9sbGVyOiBwb2xsZXIgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgcXVlcnlLZXkgPSBtYWtlVXNlclRocmVhZHNRdWVyeUtleShvcHRpb25zLnF1ZXJ5KTtcbiAgdXNlRWZmZWN0NChcbiAgICAoKSA9PiB2b2lkIHN0b3JlLm91dHB1dHMubG9hZGluZ1VzZXJUaHJlYWRzLmdldE9yQ3JlYXRlKHF1ZXJ5S2V5KS53YWl0VW50aWxMb2FkZWQoKVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIHdhaXRVbnRpbCBvbiAqZXZlcnkqIHJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGhhcm1sZXNzIHRob3VnaCwgb24gbW9zdCByZW5kZXJzLCBleGNlcHQ6XG4gICAgLy8gMS4gVGhlIHZlcnkgZmlyc3QgcmVuZGVyLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gdHJpZ2dlciB0aGUgaW5pdGlhbCBwYWdlIGZldGNoLlxuICAgIC8vIDIuIEFsbCBvdGhlciBzdWJzZXF1ZW50IHJlbmRlcnMgbm93IFwianVzdFwiIHJldHVybiB0aGUgc2FtZSBwcm9taXNlIChhIHF1aWNrIG9wZXJhdGlvbikuXG4gICAgLy8gMy4gSWYgZXZlciB0aGUgcHJvbWlzZSB3b3VsZCBmYWlsLCB0aGVuIGFmdGVyIDUgc2Vjb25kcyBpdCB3b3VsZCByZXNldCwgYW5kIG9uIHRoZSB2ZXJ5XG4gICAgLy8gICAgKm5leHQqIHJlbmRlciBhZnRlciB0aGF0LCBhICpuZXcqIGZldGNoL3Byb21pc2Ugd2lsbCBnZXQgY3JlYXRlZC5cbiAgKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgcG9sbGVyLmluYygpO1xuICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb2xsZXIuZGVjKCk7XG4gICAgfTtcbiAgfSwgW3BvbGxlcl0pO1xuICByZXR1cm4gdXNlU2lnbmFsKFxuICAgIHN0b3JlLm91dHB1dHMubG9hZGluZ1VzZXJUaHJlYWRzLmdldE9yQ3JlYXRlKHF1ZXJ5S2V5KS5zaWduYWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVVzZXJUaHJlYWRzU3VzcGVuc2VfZXhwZXJpbWVudGFsKG9wdGlvbnMgPSB7fSkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCB7IHN0b3JlIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZVVzZXJUaHJlYWRzUXVlcnlLZXkob3B0aW9ucy5xdWVyeSk7XG4gIHVzZShzdG9yZS5vdXRwdXRzLmxvYWRpbmdVc2VyVGhyZWFkcy5nZXRPckNyZWF0ZShxdWVyeUtleSkud2FpdFVudGlsTG9hZGVkKCkpO1xuICBjb25zdCByZXN1bHQgPSB1c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWwob3B0aW9ucyk7XG4gIGFzc2VydCghcmVzdWx0LmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICBhc3NlcnQoIXJlc3VsdC5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiB1c2VJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChcbiAgICB1c2VDbGllbnQoKSxcbiAgICBpZGVudGl0eTIsXG4gICAgc2hhbGxvdzMsXG4gICAgb3B0aW9uc1xuICApO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2Uob3B0aW9ucykge1xuICByZXR1cm4gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2Vfd2l0aENsaWVudCh1c2VDbGllbnQoKSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZChpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gIHJldHVybiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZF93aXRoQ2xpZW50KFxuICAgIHVzZUNsaWVudCgpLFxuICAgIGluYm94Tm90aWZpY2F0aW9uSWRcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoKSB7XG4gIHJldHVybiB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKCkge1xuICByZXR1cm4gdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKCkge1xuICByZXR1cm4gdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb24oKSB7XG4gIHJldHVybiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbl93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50KG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50X3dpdGhDbGllbnQodXNlQ2xpZW50KCksIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZShvcHRpb25zKSB7XG4gIHJldHVybiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlX3dpdGhDbGllbnQoXG4gICAgdXNlQ2xpZW50KCksXG4gICAgb3B0aW9uc1xuICApO1xufVxuZnVuY3Rpb24gdXNlTm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gIHJldHVybiB1c2VOb3RpZmljYXRpb25TZXR0aW5nc193aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UoKSB7XG4gIHJldHVybiB1c2VOb3RpZmljYXRpb25TZXR0aW5nc1N1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gIHJldHVybiB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc193aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZVVzZXIodXNlcklkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlVXNlcl93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKTtcbn1cbmZ1bmN0aW9uIHVzZVVzZXJTdXNwZW5zZSh1c2VySWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VVc2VyU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIHVzZXJJZCk7XG59XG5mdW5jdGlvbiB1c2VSb29tSW5mbyhyb29tSWQpIHtcbiAgcmV0dXJuIHVzZVJvb21JbmZvX3dpdGhDbGllbnQodXNlQ2xpZW50KCksIHJvb21JZCk7XG59XG5mdW5jdGlvbiB1c2VSb29tSW5mb1N1c3BlbnNlKHJvb21JZCkge1xuICByZXR1cm4gdXNlUm9vbUluZm9TdXNwZW5zZV93aXRoQ2xpZW50KHVzZUNsaWVudCgpLCByb29tSWQpO1xufVxuZnVuY3Rpb24gdXNlR3JvdXBJbmZvKGdyb3VwSWQpIHtcbiAgcmV0dXJuIHVzZUdyb3VwSW5mb193aXRoQ2xpZW50KHVzZUNsaWVudCgpLCBncm91cElkKTtcbn1cbmZ1bmN0aW9uIHVzZUdyb3VwSW5mb1N1c3BlbnNlKGdyb3VwSWQpIHtcbiAgcmV0dXJuIHVzZUdyb3VwSW5mb1N1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCksIGdyb3VwSWQpO1xufVxudmFyIF91c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZCA9IHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkO1xudmFyIF91c2VVc2VyID0gdXNlVXNlcjtcbnZhciBfdXNlVXNlclN1c3BlbnNlID0gdXNlVXNlclN1c3BlbnNlO1xudmFyIF91c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWwgPSB1c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWw7XG52YXIgX3VzZVVzZXJUaHJlYWRzU3VzcGVuc2VfZXhwZXJpbWVudGFsID0gdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWw7XG52YXIgX3VzZUFpQ2hhdHMgPSB1c2VBaUNoYXRzO1xudmFyIF91c2VBaUNoYXRzU3VzcGVuc2UgPSB1c2VBaUNoYXRzU3VzcGVuc2U7XG52YXIgX3VzZUFpQ2hhdCA9IHVzZUFpQ2hhdDtcbnZhciBfdXNlQWlDaGF0U3VzcGVuc2UgPSB1c2VBaUNoYXRTdXNwZW5zZTtcbnZhciBfdXNlQWlDaGF0TWVzc2FnZXMgPSB1c2VBaUNoYXRNZXNzYWdlcztcbnZhciBfdXNlQWlDaGF0TWVzc2FnZXNTdXNwZW5zZSA9IHVzZUFpQ2hhdE1lc3NhZ2VzU3VzcGVuc2U7XG52YXIgX3VzZVVybE1ldGFkYXRhID0gdXNlVXJsTWV0YWRhdGE7XG52YXIgX3VzZVVybE1ldGFkYXRhU3VzcGVuc2UgPSB1c2VVcmxNZXRhZGF0YVN1c3BlbnNlO1xuZnVuY3Rpb24gdXNlU3luY1N0YXR1c193aXRoQ2xpZW50KGNsaWVudCwgb3B0aW9ucykge1xuICBjb25zdCBzbW9vdGggPSB1c2VJbml0aWFsKG9wdGlvbnM/LnNtb290aCA/PyBmYWxzZSk7XG4gIGlmIChzbW9vdGgpIHtcbiAgICByZXR1cm4gdXNlU3luY1N0YXR1c1Ntb290aF93aXRoQ2xpZW50KGNsaWVudCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVzZVN5bmNTdGF0dXNJbW1lZGlhdGVfd2l0aENsaWVudChjbGllbnQpO1xuICB9XG59XG5mdW5jdGlvbiB1c2VTeW5jU3RhdHVzSW1tZWRpYXRlX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgY2xpZW50LmV2ZW50cy5zeW5jU3RhdHVzLnN1YnNjcmliZSxcbiAgICBjbGllbnQuZ2V0U3luY1N0YXR1cyxcbiAgICBjbGllbnQuZ2V0U3luY1N0YXR1c1xuICApO1xufVxuZnVuY3Rpb24gdXNlU3luY1N0YXR1c1Ntb290aF93aXRoQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCBnZXR0ZXIgPSBjbGllbnQuZ2V0U3luY1N0YXR1cztcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlMihnZXR0ZXIpO1xuICBjb25zdCBvbGRTdGF0dXMgPSB1c2VMYXRlc3QoZ2V0dGVyKCkpO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IHVuc3ViID0gY2xpZW50LmV2ZW50cy5zeW5jU3RhdHVzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBjb25zdCBuZXdTdGF0dXMgPSBnZXR0ZXIoKTtcbiAgICAgIGlmIChvbGRTdGF0dXMuY3VycmVudCA9PT0gXCJzeW5jaHJvbml6aW5nXCIgJiYgbmV3U3RhdHVzID09PSBcInN5bmNocm9uaXplZFwiKSB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0U3RhdHVzKG5ld1N0YXR1cyksIGNvbmZpZy5TTU9PVEhfREVMQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIHNldFN0YXR1cyhuZXdTdGF0dXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHVuc3ViKCk7XG4gICAgfTtcbiAgfSwgW2NsaWVudCwgZ2V0dGVyLCBvbGRTdGF0dXNdKTtcbiAgcmV0dXJuIHN0YXR1cztcbn1cbmZ1bmN0aW9uIHVzZVN5bmNTdGF0dXMob3B0aW9ucykge1xuICByZXR1cm4gdXNlU3luY1N0YXR1c193aXRoQ2xpZW50KHVzZUNsaWVudCgpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHVzZUVycm9yTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICB1c2VFZmZlY3Q0KFxuICAgICgpID0+IGNsaWVudC5ldmVudHMuZXJyb3Iuc3Vic2NyaWJlKChlKSA9PiBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZSkpLFxuICAgIFtjbGllbnQsIHNhdmVkQ2FsbGJhY2tdXG4gICk7XG59XG5cbi8vIHNyYy9yb29tLnRzeFxuaW1wb3J0IHsgc2hhbGxvdyBhcyBzaGFsbG93NCB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jbGllbnRcIjtcbmltcG9ydCB7XG4gIGFzc2VydCBhcyBhc3NlcnQyLFxuICBjb25zb2xlIGFzIGNvbnNvbGUzLFxuICBjcmVhdGVDb21tZW50SWQsXG4gIGNyZWF0ZVRocmVhZElkLFxuICBEZWZhdWx0TWFwIGFzIERlZmF1bHRNYXAzLFxuICBlcnJvcklmLFxuICBnZXRTdWJzY3JpcHRpb25LZXkgYXMgZ2V0U3Vic2NyaXB0aW9uS2V5MyxcbiAgSHR0cEVycm9yIGFzIEh0dHBFcnJvcjIsXG4gIGtJbnRlcm5hbCBhcyBrSW50ZXJuYWw0LFxuICBtYWtlUG9sbGVyIGFzIG1ha2VQb2xsZXIyLFxuICBTZXJ2ZXJNc2dDb2RlLFxuICBzdGFibGVTdHJpbmdpZnkgYXMgc3RhYmxlU3RyaW5naWZ5MlxufSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0IHtcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2szLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NixcbiAgdXNlTWVtbyBhcyB1c2VNZW1vNCxcbiAgdXNlUmVmIGFzIHVzZVJlZjMsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMyxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmUzLFxuICB2ZXJzaW9uIGFzIHJlYWN0VmVyc2lvblxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3VzZS1zY3JvbGwtdG8tY29tbWVudC1vbi1sb2FkLWVmZmVjdC50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDUgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIGhhbmRsZVNjcm9sbFRvQ29tbWVudE9uTG9hZChzaG91bGRTY3JvbGxPbkxvYWQsIHN0YXRlKSB7XG4gIGlmIChzaG91bGRTY3JvbGxPbkxvYWQgPT09IGZhbHNlKSByZXR1cm47XG4gIGlmICghc3RhdGUudGhyZWFkcykgcmV0dXJuO1xuICBjb25zdCBpc1dpbmRvd0RlZmluZWQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICBpZiAoIWlzV2luZG93RGVmaW5lZCkgcmV0dXJuO1xuICBjb25zdCBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2g7XG4gIGNvbnN0IGNvbW1lbnRJZCA9IGhhc2guc2xpY2UoMSk7XG4gIGlmICghY29tbWVudElkLnN0YXJ0c1dpdGgoXCJjbV9cIikpIHJldHVybjtcbiAgY29uc3QgY29tbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbW1lbnRJZCk7XG4gIGlmIChjb21tZW50ID09PSBudWxsKSByZXR1cm47XG4gIGNvbnN0IGNvbW1lbnRzID0gc3RhdGUudGhyZWFkcy5mbGF0TWFwKCh0aHJlYWQpID0+IHRocmVhZC5jb21tZW50cyk7XG4gIGNvbnN0IGlzQ29tbWVudEluVGhyZWFkcyA9IGNvbW1lbnRzLnNvbWUoXG4gICAgKGNvbW1lbnQyKSA9PiBjb21tZW50Mi5pZCA9PT0gY29tbWVudElkXG4gICk7XG4gIGlmICghaXNDb21tZW50SW5UaHJlYWRzKSByZXR1cm47XG4gIGNvbW1lbnQuc2Nyb2xsSW50b1ZpZXcoKTtcbn1cbmZ1bmN0aW9uIHVzZVNjcm9sbFRvQ29tbWVudE9uTG9hZEVmZmVjdChzaG91bGRTY3JvbGxPbkxvYWQsIHN0YXRlKSB7XG4gIHVzZUVmZmVjdDUoXG4gICAgKCkgPT4ge1xuICAgICAgaGFuZGxlU2Nyb2xsVG9Db21tZW50T25Mb2FkKHNob3VsZFNjcm9sbE9uTG9hZCwgc3RhdGUpO1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAtLSBXZSBvbmx5IHdhbnQgdG8gcnVuIHRoaXMgZWZmZWN0IG9uY2VcbiAgICBbc3RhdGUuaXNMb2FkaW5nXVxuICApO1xufVxuXG4vLyBzcmMvcm9vbS50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgbm9vcDIgPSAoKSA9PiB7XG59O1xudmFyIGlkZW50aXR5MyA9ICh4KSA9PiB4O1xudmFyIFNUQUJMRV9FTVBUWV9MSVNUID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5mdW5jdGlvbiBhbHdheXNFbXB0eUxpc3QoKSB7XG4gIHJldHVybiBTVEFCTEVfRU1QVFlfTElTVDtcbn1cbmZ1bmN0aW9uIGFsd2F5c051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2VsZWN0b3JGb3JfdXNlT3RoZXJzQ29ubmVjdGlvbklkcyhvdGhlcnMpIHtcbiAgcmV0dXJuIG90aGVycy5tYXAoKHVzZXIpID0+IHVzZXIuY29ubmVjdGlvbklkKTtcbn1cbmZ1bmN0aW9uIG1ha2VNdXRhdGlvbkNvbnRleHQocm9vbSkge1xuICBjb25zdCBjYW5ub3RVc2VVbnRpbCA9IFwiVGhpcyBtdXRhdGlvbiBjYW5ub3QgYmUgdXNlZCB1bnRpbFwiO1xuICBjb25zdCBuZWVkc1ByZXNlbmNlID0gYCR7Y2Fubm90VXNlVW50aWx9IGNvbm5lY3RlZCB0byB0aGUgTGl2ZWJsb2NrcyByb29tYDtcbiAgY29uc3QgbmVlZHNTdG9yYWdlID0gYCR7Y2Fubm90VXNlVW50aWx9IHN0b3JhZ2UgaGFzIGJlZW4gbG9hZGVkYDtcbiAgcmV0dXJuIHtcbiAgICBnZXQgc3RvcmFnZSgpIHtcbiAgICAgIGNvbnN0IG11dGFibGVSb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgICAgIGlmIChtdXRhYmxlUm9vdCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmVlZHNTdG9yYWdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtdXRhYmxlUm9vdDtcbiAgICB9LFxuICAgIGdldCBzZWxmKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHJvb20uZ2V0U2VsZigpO1xuICAgICAgaWYgKHNlbGYgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5lZWRzUHJlc2VuY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcbiAgICBnZXQgb3RoZXJzKCkge1xuICAgICAgY29uc3Qgb3RoZXJzID0gcm9vbS5nZXRPdGhlcnMoKTtcbiAgICAgIGlmIChyb29tLmdldFNlbGYoKSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmVlZHNQcmVzZW5jZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3RoZXJzO1xuICAgIH0sXG4gICAgc2V0TXlQcmVzZW5jZTogcm9vbS51cGRhdGVQcmVzZW5jZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXJJZChjbGllbnQpIHtcbiAgY29uc3QgdXNlcklkID0gY2xpZW50W2tJbnRlcm5hbDRdLmN1cnJlbnRVc2VySWQuZ2V0KCk7XG4gIGlmICh1c2VySWQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBcImFub255bW91c1wiO1xuICB9XG4gIHJldHVybiB1c2VySWQ7XG59XG52YXIgX2V4dHJhczIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBfYnVuZGxlczIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldE9yQ3JlYXRlUm9vbUNvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGxldCBidW5kbGUgPSBfYnVuZGxlczIuZ2V0KGNsaWVudCk7XG4gIGlmICghYnVuZGxlKSB7XG4gICAgYnVuZGxlID0gbWFrZVJvb21Db250ZXh0QnVuZGxlKGNsaWVudCk7XG4gICAgX2J1bmRsZXMyLnNldChjbGllbnQsIGJ1bmRsZSk7XG4gIH1cbiAgcmV0dXJuIGJ1bmRsZTtcbn1cbmZ1bmN0aW9uIGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KSB7XG4gIGxldCBleHRyYXMgPSBfZXh0cmFzMi5nZXQoY2xpZW50KTtcbiAgaWYgKCFleHRyYXMpIHtcbiAgICBleHRyYXMgPSBtYWtlUm9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgIF9leHRyYXMyLnNldChjbGllbnQsIGV4dHJhcyk7XG4gIH1cbiAgcmV0dXJuIGV4dHJhcztcbn1cbmZ1bmN0aW9uIG1ha2VSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCBzdG9yZSA9IGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQoY2xpZW50KTtcbiAgZnVuY3Rpb24gb25NdXRhdGlvbkZhaWx1cmUob3B0aW1pc3RpY0lkLCBjb250ZXh0LCBpbm5lckVycm9yKSB7XG4gICAgc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNJZCk7XG4gICAgaWYgKGlubmVyRXJyb3IgaW5zdGFuY2VvZiBIdHRwRXJyb3IyKSB7XG4gICAgICBpZiAoaW5uZXJFcnJvci5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICBjb25zdCBkZXRhaWxlZE1lc3NhZ2UgPSBbXG4gICAgICAgICAgaW5uZXJFcnJvci5tZXNzYWdlLFxuICAgICAgICAgIGlubmVyRXJyb3IuZGV0YWlscz8uc3VnZ2VzdGlvbixcbiAgICAgICAgICBpbm5lckVycm9yLmRldGFpbHM/LmRvY3NcbiAgICAgICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICAgICAgY29uc29sZTMuZXJyb3IoZGV0YWlsZWRNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGNsaWVudFtrSW50ZXJuYWw0XS5lbWl0RXJyb3IoY29udGV4dCwgaW5uZXJFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGlubmVyRXJyb3I7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRocmVhZHNQb2xsZXJzQnlSb29tSWQgPSBuZXcgRGVmYXVsdE1hcDMoXG4gICAgKHJvb21JZCkgPT4gbWFrZVBvbGxlcjIoXG4gICAgICBhc3luYyAoc2lnbmFsKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLmZldGNoUm9vbVRocmVhZHNEZWx0YVVwZGF0ZShyb29tSWQsIHNpZ25hbCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUzLndhcm4oYFBvbGxpbmcgbmV3IHRocmVhZHMgZm9yICcke3Jvb21JZH0nIGZhaWxlZDogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb25maWcuUk9PTV9USFJFQURTX1BPTExfSU5URVJWQUwsXG4gICAgICB7IG1heFN0YWxlVGltZU1zOiBjb25maWcuUk9PTV9USFJFQURTX01BWF9TVEFMRV9USU1FIH1cbiAgICApXG4gICk7XG4gIGNvbnN0IHZlcnNpb25zUG9sbGVyc0J5Um9vbUlkID0gbmV3IERlZmF1bHRNYXAzKFxuICAgIChyb29tSWQpID0+IG1ha2VQb2xsZXIyKFxuICAgICAgYXN5bmMgKHNpZ25hbCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBzdG9yZS5mZXRjaFJvb21WZXJzaW9uc0RlbHRhVXBkYXRlKHJvb21JZCwgc2lnbmFsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZTMud2FybihgUG9sbGluZyBuZXcgaGlzdG9yeSB2ZXJzaW9ucyBmb3IgJyR7cm9vbUlkfScgZmFpbGVkOiAke1N0cmluZyhlcnIpfWApO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbmZpZy5ISVNUT1JZX1ZFUlNJT05TX1BPTExfSU5URVJWQUwsXG4gICAgICB7IG1heFN0YWxlVGltZU1zOiBjb25maWcuSElTVE9SWV9WRVJTSU9OU19NQVhfU1RBTEVfVElNRSB9XG4gICAgKVxuICApO1xuICBjb25zdCByb29tU3Vic2NyaXB0aW9uU2V0dGluZ3NQb2xsZXJzQnlSb29tSWQgPSBuZXcgRGVmYXVsdE1hcDMoXG4gICAgKHJvb21JZCkgPT4gbWFrZVBvbGxlcjIoXG4gICAgICBhc3luYyAoc2lnbmFsKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLnJlZnJlc2hSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3Mocm9vbUlkLCBzaWduYWwpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlMy53YXJuKGBQb2xsaW5nIHN1YnNjcmlwdGlvbiBzZXR0aW5ncyBmb3IgJyR7cm9vbUlkfScgZmFpbGVkOiAke1N0cmluZyhlcnIpfWApO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbmZpZy5ST09NX1NVQlNDUklQVElPTl9TRVRUSU5HU19QT0xMX0lOVEVSVkFMLFxuICAgICAgeyBtYXhTdGFsZVRpbWVNczogY29uZmlnLlJPT01fU1VCU0NSSVBUSU9OX1NFVFRJTkdTX01BWF9TVEFMRV9USU1FIH1cbiAgICApXG4gICk7XG4gIHJldHVybiB7XG4gICAgc3RvcmUsXG4gICAgb25NdXRhdGlvbkZhaWx1cmUsXG4gICAgcG9sbFRocmVhZHNGb3JSb29tSWQ6IChyb29tSWQpID0+IHtcbiAgICAgIGNvbnN0IHRocmVhZHNQb2xsZXIgPSB0aHJlYWRzUG9sbGVyc0J5Um9vbUlkLmdldE9yQ3JlYXRlKHJvb21JZCk7XG4gICAgICBpZiAodGhyZWFkc1BvbGxlcikge1xuICAgICAgICB0aHJlYWRzUG9sbGVyLm1hcmtBc1N0YWxlKCk7XG4gICAgICAgIHRocmVhZHNQb2xsZXIucG9sbE5vd0lmU3RhbGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldE9yQ3JlYXRlVGhyZWFkc1BvbGxlckZvclJvb21JZDogdGhyZWFkc1BvbGxlcnNCeVJvb21JZC5nZXRPckNyZWF0ZS5iaW5kKFxuICAgICAgdGhyZWFkc1BvbGxlcnNCeVJvb21JZFxuICAgICksXG4gICAgZ2V0T3JDcmVhdGVWZXJzaW9uc1BvbGxlckZvclJvb21JZDogdmVyc2lvbnNQb2xsZXJzQnlSb29tSWQuZ2V0T3JDcmVhdGUuYmluZCh2ZXJzaW9uc1BvbGxlcnNCeVJvb21JZCksXG4gICAgZ2V0T3JDcmVhdGVTdWJzY3JpcHRpb25TZXR0aW5nc1BvbGxlckZvclJvb21JZDogcm9vbVN1YnNjcmlwdGlvblNldHRpbmdzUG9sbGVyc0J5Um9vbUlkLmdldE9yQ3JlYXRlLmJpbmQoXG4gICAgICByb29tU3Vic2NyaXB0aW9uU2V0dGluZ3NQb2xsZXJzQnlSb29tSWRcbiAgICApXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlUm9vbUNvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGZ1bmN0aW9uIFJvb21Qcm92aWRlcl93aXRoSW1wbGljaXRMaXZlYmxvY2tzUHJvdmlkZXIocHJvcHMpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIoTGl2ZWJsb2Nrc1Byb3ZpZGVyV2l0aENsaWVudCwgeyBjbGllbnQsIGFsbG93TmVzdGluZzogdHJ1ZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFJvb21Qcm92aWRlciwgeyAuLi5wcm9wcyB9KSB9KTtcbiAgfVxuICBjb25zdCBzaGFyZWQgPSBjcmVhdGVTaGFyZWRDb250ZXh0KGNsaWVudCk7XG4gIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICBSb29tQ29udGV4dCxcbiAgICBSb29tUHJvdmlkZXI6IFJvb21Qcm92aWRlcl93aXRoSW1wbGljaXRMaXZlYmxvY2tzUHJvdmlkZXIsXG4gICAgdXNlUm9vbSxcbiAgICB1c2VTdGF0dXMsXG4gICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgdXNlT3RoZXJzTGlzdGVuZXIsXG4gICAgdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcixcbiAgICB1c2VFdmVudExpc3RlbmVyLFxuICAgIHVzZUhpc3RvcnksXG4gICAgdXNlVW5kbyxcbiAgICB1c2VSZWRvLFxuICAgIHVzZUNhblJlZG8sXG4gICAgdXNlQ2FuVW5kbyxcbiAgICB1c2VTdG9yYWdlUm9vdCxcbiAgICB1c2VTdG9yYWdlLFxuICAgIHVzZVNlbGYsXG4gICAgdXNlTXlQcmVzZW5jZSxcbiAgICB1c2VVcGRhdGVNeVByZXNlbmNlLFxuICAgIHVzZU90aGVycyxcbiAgICB1c2VPdGhlcnNNYXBwZWQsXG4gICAgdXNlT3RoZXJzQ29ubmVjdGlvbklkcyxcbiAgICB1c2VPdGhlcixcbiAgICB1c2VNdXRhdGlvbixcbiAgICB1c2VUaHJlYWRzLFxuICAgIHVzZVNlYXJjaENvbW1lbnRzLFxuICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICB1c2VEZWxldGVUaHJlYWQsXG4gICAgdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIHVzZU1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICAgIHVzZU1hcmtUaHJlYWRBc1VucmVzb2x2ZWQsXG4gICAgdXNlU3Vic2NyaWJlVG9UaHJlYWQsXG4gICAgdXNlVW5zdWJzY3JpYmVGcm9tVGhyZWFkLFxuICAgIHVzZUNyZWF0ZUNvbW1lbnQsXG4gICAgdXNlRWRpdENvbW1lbnQsXG4gICAgdXNlRGVsZXRlQ29tbWVudCxcbiAgICB1c2VBZGRSZWFjdGlvbixcbiAgICB1c2VSZW1vdmVSZWFjdGlvbixcbiAgICB1c2VNYXJrVGhyZWFkQXNSZWFkLFxuICAgIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgICB1c2VBdHRhY2htZW50VXJsLFxuICAgIHVzZUhpc3RvcnlWZXJzaW9ucyxcbiAgICB1c2VIaXN0b3J5VmVyc2lvbkRhdGEsXG4gICAgdXNlUm9vbVN1YnNjcmlwdGlvblNldHRpbmdzLFxuICAgIHVzZVVwZGF0ZVJvb21TdWJzY3JpcHRpb25TZXR0aW5ncyxcbiAgICAuLi5zaGFyZWQuY2xhc3NpYyxcbiAgICBzdXNwZW5zZToge1xuICAgICAgUm9vbUNvbnRleHQsXG4gICAgICBSb29tUHJvdmlkZXI6IFJvb21Qcm92aWRlcl93aXRoSW1wbGljaXRMaXZlYmxvY2tzUHJvdmlkZXIsXG4gICAgICB1c2VSb29tLFxuICAgICAgdXNlU3RhdHVzLFxuICAgICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgICB1c2VPdGhlcnNMaXN0ZW5lcixcbiAgICAgIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIsXG4gICAgICB1c2VFdmVudExpc3RlbmVyLFxuICAgICAgdXNlSGlzdG9yeSxcbiAgICAgIHVzZVVuZG8sXG4gICAgICB1c2VSZWRvLFxuICAgICAgdXNlQ2FuUmVkbyxcbiAgICAgIHVzZUNhblVuZG8sXG4gICAgICB1c2VTdG9yYWdlUm9vdCxcbiAgICAgIHVzZVN0b3JhZ2U6IHVzZVN0b3JhZ2VTdXNwZW5zZSxcbiAgICAgIHVzZVNlbGY6IHVzZVNlbGZTdXNwZW5zZSxcbiAgICAgIHVzZU15UHJlc2VuY2UsXG4gICAgICB1c2VVcGRhdGVNeVByZXNlbmNlLFxuICAgICAgdXNlT3RoZXJzOiB1c2VPdGhlcnNTdXNwZW5zZSxcbiAgICAgIHVzZU90aGVyc01hcHBlZDogdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzOiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcjogdXNlT3RoZXJTdXNwZW5zZSxcbiAgICAgIHVzZU11dGF0aW9uLFxuICAgICAgdXNlVGhyZWFkczogdXNlVGhyZWFkc1N1c3BlbnNlLFxuICAgICAgdXNlQ3JlYXRlVGhyZWFkLFxuICAgICAgdXNlRGVsZXRlVGhyZWFkLFxuICAgICAgdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICAgICAgdXNlTWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gICAgICB1c2VNYXJrVGhyZWFkQXNVbnJlc29sdmVkLFxuICAgICAgdXNlU3Vic2NyaWJlVG9UaHJlYWQsXG4gICAgICB1c2VVbnN1YnNjcmliZUZyb21UaHJlYWQsXG4gICAgICB1c2VDcmVhdGVDb21tZW50LFxuICAgICAgdXNlRWRpdENvbW1lbnQsXG4gICAgICB1c2VEZWxldGVDb21tZW50LFxuICAgICAgdXNlQWRkUmVhY3Rpb24sXG4gICAgICB1c2VSZW1vdmVSZWFjdGlvbixcbiAgICAgIHVzZU1hcmtUaHJlYWRBc1JlYWQsXG4gICAgICB1c2VUaHJlYWRTdWJzY3JpcHRpb24sXG4gICAgICB1c2VBdHRhY2htZW50VXJsOiB1c2VBdHRhY2htZW50VXJsU3VzcGVuc2UsXG4gICAgICAvLyBUT0RPOiB1c2VIaXN0b3J5VmVyc2lvbkRhdGE6IHVzZUhpc3RvcnlWZXJzaW9uRGF0YVN1c3BlbnNlLFxuICAgICAgdXNlSGlzdG9yeVZlcnNpb25zOiB1c2VIaXN0b3J5VmVyc2lvbnNTdXNwZW5zZSxcbiAgICAgIHVzZVJvb21TdWJzY3JpcHRpb25TZXR0aW5nczogdXNlUm9vbVN1YnNjcmlwdGlvblNldHRpbmdzU3VzcGVuc2UsXG4gICAgICB1c2VVcGRhdGVSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3MsXG4gICAgICAuLi5zaGFyZWQuc3VzcGVuc2VcbiAgICB9XG4gIH07XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVuZGxlLCBrSW50ZXJuYWw0LCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiBSb29tUHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IFtjYWNoZV0gPSB1c2VTdGF0ZTMoXG4gICAgKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICApO1xuICBjb25zdCBzdGFibGVFbnRlclJvb20gPSB1c2VDYWxsYmFjazMoXG4gICAgKHJvb21JZCwgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KHJvb21JZCk7XG4gICAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgICAgY29uc3QgcnYgPSBjbGllbnQuZW50ZXJSb29tKHJvb21JZCwgb3B0aW9ucyk7XG4gICAgICBjb25zdCBvcmlnTGVhdmUgPSBydi5sZWF2ZTtcbiAgICAgIHJ2LmxlYXZlID0gKCkgPT4ge1xuICAgICAgICBvcmlnTGVhdmUoKTtcbiAgICAgICAgY2FjaGUuZGVsZXRlKHJvb21JZCk7XG4gICAgICB9O1xuICAgICAgY2FjaGUuc2V0KHJvb21JZCwgcnYpO1xuICAgICAgcmV0dXJuIHJ2O1xuICAgIH0sXG4gICAgW2NsaWVudCwgY2FjaGVdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MihcbiAgICBSb29tUHJvdmlkZXJJbm5lcixcbiAgICB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHN0YWJsZUVudGVyUm9vbVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIFJvb21Qcm92aWRlcklubmVyKHByb3BzKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCB7IGlkOiByb29tSWQsIHN0YWJsZUVudGVyUm9vbSB9ID0gcHJvcHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIXJvb21JZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlJvb21Qcm92aWRlciBpZCBwcm9wZXJ0eSBpcyByZXF1aXJlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9saXZlYmxvY2tzLXJlYWN0L1Jvb21Qcm92aWRlci1pZC1wcm9wZXJ0eS1pcy1yZXF1aXJlZFwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJvb21JZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbVByb3ZpZGVyIGlkIHByb3BlcnR5IHNob3VsZCBiZSBhIHN0cmluZy5cIik7XG4gICAgfVxuICAgIGNvbnN0IG1ham9yUmVhY3RWZXJzaW9uID0gcGFyc2VJbnQocmVhY3RWZXJzaW9uKSB8fCAxO1xuICAgIGNvbnN0IHJlcXVpcmVkVmVyc2lvbiA9IDE4O1xuICAgIGVycm9ySWYoXG4gICAgICBtYWpvclJlYWN0VmVyc2lvbiA8IHJlcXVpcmVkVmVyc2lvbixcbiAgICAgIGBSZWFjdCAke3JlcXVpcmVkVmVyc2lvbn0gb3IgaGlnaGVyIGlzIHJlcXVpcmVkICh5b3VcXHUyMDE5cmUgb24gJHtyZWFjdFZlcnNpb259KWBcbiAgICApO1xuICB9XG4gIGNvbnN0IGZyb3plblByb3BzID0gdXNlSW5pdGlhbChcbiAgICB7XG4gICAgICBpbml0aWFsUHJlc2VuY2U6IHByb3BzLmluaXRpYWxQcmVzZW5jZSxcbiAgICAgIGluaXRpYWxTdG9yYWdlOiBwcm9wcy5pbml0aWFsU3RvcmFnZSxcbiAgICAgIGF1dG9Db25uZWN0OiBwcm9wcy5hdXRvQ29ubmVjdCA/PyB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgfSxcbiAgICByb29tSWRcbiAgKTtcbiAgY29uc3QgW3sgcm9vbSB9LCBzZXRSb29tTGVhdmVQYWlyXSA9IHVzZVN0YXRlMyhcbiAgICAoKSA9PiBzdGFibGVFbnRlclJvb20ocm9vbUlkLCB7XG4gICAgICAuLi5mcm96ZW5Qcm9wcyxcbiAgICAgIGF1dG9Db25uZWN0OiBmYWxzZVxuICAgICAgLy8gRGVsaWJlcmF0ZWx5IHVzaW5nIGZhbHNlIGhlcmUgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlIGJlbG93XG4gICAgfSlcbiAgKTtcbiAgdXNlRWZmZWN0NigoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNvbW1lbnRFdmVudChtZXNzYWdlKSB7XG4gICAgICBpZiAobWVzc2FnZS50eXBlID09PSBTZXJ2ZXJNc2dDb2RlLlRIUkVBRF9ERUxFVEVEKSB7XG4gICAgICAgIHN0b3JlLmRlbGV0ZVRocmVhZChtZXNzYWdlLnRocmVhZElkLCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IHJvb20uZ2V0VGhyZWFkKG1lc3NhZ2UudGhyZWFkSWQpO1xuICAgICAgaWYgKCFpbmZvLnRocmVhZCkge1xuICAgICAgICBzdG9yZS5kZWxldGVUaHJlYWQobWVzc2FnZS50aHJlYWRJZCwgbnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGhyZWFkLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbjogbWF5YmVOb3RpZmljYXRpb24sXG4gICAgICAgIHN1YnNjcmlwdGlvbjogbWF5YmVTdWJzY3JpcHRpb25cbiAgICAgIH0gPSBpbmZvO1xuICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdG9yZS5vdXRwdXRzLnRocmVhZHMuZ2V0KCkuZ2V0RXZlbklmRGVsZXRlZChtZXNzYWdlLnRocmVhZElkKTtcbiAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX0VESVRFRDpcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLlRIUkVBRF9NRVRBREFUQV9VUERBVEVEOlxuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuVEhSRUFEX1VQREFURUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX1JFQUNUSU9OX0FEREVEOlxuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEOlxuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9ERUxFVEVEOlxuICAgICAgICAgIGlmICghZXhpc3RpbmdUaHJlYWQpIGJyZWFrO1xuICAgICAgICAgIHN0b3JlLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICAgICAgICBbdGhyZWFkXSxcbiAgICAgICAgICAgIG1heWJlTm90aWZpY2F0aW9uID8gW21heWJlTm90aWZpY2F0aW9uXSA6IFtdLFxuICAgICAgICAgICAgbWF5YmVTdWJzY3JpcHRpb24gPyBbbWF5YmVTdWJzY3JpcHRpb25dIDogW11cbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9DUkVBVEVEOlxuICAgICAgICAgIHN0b3JlLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICAgICAgICBbdGhyZWFkXSxcbiAgICAgICAgICAgIG1heWJlTm90aWZpY2F0aW9uID8gW21heWJlTm90aWZpY2F0aW9uXSA6IFtdLFxuICAgICAgICAgICAgbWF5YmVTdWJzY3JpcHRpb24gPyBbbWF5YmVTdWJzY3JpcHRpb25dIDogW11cbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm9vbS5ldmVudHMuY29tbWVudHMuc3Vic2NyaWJlKFxuICAgICAgKG1lc3NhZ2UpID0+IHZvaWQgaGFuZGxlQ29tbWVudEV2ZW50KG1lc3NhZ2UpXG4gICAgKTtcbiAgfSwgW2NsaWVudCwgcm9vbV0pO1xuICB1c2VFZmZlY3Q2KCgpID0+IHtcbiAgICBjb25zdCBwYWlyID0gc3RhYmxlRW50ZXJSb29tKHJvb21JZCwgZnJvemVuUHJvcHMpO1xuICAgIHNldFJvb21MZWF2ZVBhaXIocGFpcik7XG4gICAgY29uc3QgeyByb29tOiByb29tMiwgbGVhdmUgfSA9IHBhaXI7XG4gICAgaWYgKGZyb3plblByb3BzLmF1dG9Db25uZWN0KSB7XG4gICAgICByb29tMi5jb25uZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsZWF2ZSgpO1xuICAgIH07XG4gIH0sIFtyb29tSWQsIGZyb3plblByb3BzLCBzdGFibGVFbnRlclJvb21dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFJvb21Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiByb29tLCBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4gfSk7XG59XG5mdW5jdGlvbiB1c2VSb29tKG9wdGlvbnMpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb21Pck51bGwoKTtcbiAgaWYgKHJvb20gPT09IG51bGwgJiYgIW9wdGlvbnM/LmFsbG93T3V0c2lkZVJvb20pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbiAgfVxuICByZXR1cm4gcm9vbTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXR1cygpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFN0YXR1cztcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSByb29tLmdldFN0YXR1cztcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG59XG5mdW5jdGlvbiB1c2VSZXBvcnRUZXh0RWRpdG9yKGVkaXRvciwgcm9vdEtleSkge1xuICBjb25zdCBpc1JlcG9ydGVkID0gdXNlUmVmMyhmYWxzZSk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgIGlmIChpc1JlcG9ydGVkLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSByb29tLmV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKChzdGF0dXMpID0+IHtcbiAgICAgIGlmIChzdGF0dXMgPT09IFwiY29ubmVjdGVkXCIgJiYgIWlzUmVwb3J0ZWQuY3VycmVudCkge1xuICAgICAgICBpc1JlcG9ydGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB2b2lkIHJvb21ba0ludGVybmFsNF0ucmVwb3J0VGV4dEVkaXRvcihlZGl0b3IsIHJvb3RLZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSwgW3Jvb20sIGVkaXRvciwgcm9vdEtleV0pO1xufVxuZnVuY3Rpb24gdXNlWWpzUHJvdmlkZXIoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHVzZUNhbGxiYWNrMyhcbiAgICAob25TdG9yZUNoYW5nZSkgPT4ge1xuICAgICAgcmV0dXJuIHJvb21ba0ludGVybmFsNF0ueWpzUHJvdmlkZXJEaWRDaGFuZ2Uuc3Vic2NyaWJlKG9uU3RvcmVDaGFuZ2UpO1xuICAgIH0sXG4gICAgW3Jvb21dXG4gICk7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gdXNlQ2FsbGJhY2szKCgpID0+IHtcbiAgICByZXR1cm4gcm9vbVtrSW50ZXJuYWw0XS5nZXRZanNQcm92aWRlcigpO1xuICB9LCBbcm9vbV0pO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUzKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNuYXBzaG90KTtcbn1cbmZ1bmN0aW9uIHVzZUNyZWF0ZVRleHRNZW50aW9uKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgIChtZW50aW9uSWQsIG1lbnRpb24pID0+IHtcbiAgICAgIHJvb21ba0ludGVybmFsNF0uY3JlYXRlVGV4dE1lbnRpb24obWVudGlvbklkLCBtZW50aW9uKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUzLmVycm9yKFxuICAgICAgICAgIGBDYW5ub3QgY3JlYXRlIHRleHQgbWVudGlvbiBmb3IgbWVudGlvbiAnJHttZW50aW9uSWR9J2AsXG4gICAgICAgICAgZXJyXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtyb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlVGV4dE1lbnRpb24oKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKG1lbnRpb25JZCkgPT4ge1xuICAgICAgcm9vbVtrSW50ZXJuYWw0XS5kZWxldGVUZXh0TWVudGlvbihtZW50aW9uSWQpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZTMuZXJyb3IoYENhbm5vdCBkZWxldGUgdGV4dCBtZW50aW9uICcke21lbnRpb25JZH0nYCwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW3Jvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VSZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIGNsaWVudFtrSW50ZXJuYWw0XS5yZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zO1xufVxuZnVuY3Rpb24gdXNlTWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gY2xpZW50W2tJbnRlcm5hbDRdLm1lbnRpb25TdWdnZXN0aW9uc0NhY2hlO1xufVxuZnVuY3Rpb24gdXNlQnJvYWRjYXN0RXZlbnQoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKGV2ZW50LCBvcHRpb25zID0geyBzaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeTogZmFsc2UgfSkgPT4ge1xuICAgICAgcm9vbS5icm9hZGNhc3RFdmVudChldmVudCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBbcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyc0xpc3RlbmVyKGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICB1c2VFZmZlY3Q2KFxuICAgICgpID0+IHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKGV2ZW50KSA9PiBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZXZlbnQpKSxcbiAgICBbcm9vbSwgc2F2ZWRDYWxsYmFja11cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gIHVzZUVmZmVjdDYoXG4gICAgKCkgPT4gcm9vbS5ldmVudHMubG9zdENvbm5lY3Rpb24uc3Vic2NyaWJlKFxuICAgICAgKGV2ZW50KSA9PiBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZXZlbnQpXG4gICAgKSxcbiAgICBbcm9vbSwgc2F2ZWRDYWxsYmFja11cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUV2ZW50TGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50RGF0YSkgPT4ge1xuICAgICAgc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50RGF0YSk7XG4gICAgfTtcbiAgICByZXR1cm4gcm9vbS5ldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgfSwgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdKTtcbn1cbmZ1bmN0aW9uIHVzZUhpc3RvcnkoKSB7XG4gIHJldHVybiB1c2VSb29tKCkuaGlzdG9yeTtcbn1cbmZ1bmN0aW9uIHVzZVVuZG8oKSB7XG4gIHJldHVybiB1c2VIaXN0b3J5KCkudW5kbztcbn1cbmZ1bmN0aW9uIHVzZVJlZG8oKSB7XG4gIHJldHVybiB1c2VIaXN0b3J5KCkucmVkbztcbn1cbmZ1bmN0aW9uIHVzZUNhblVuZG8oKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLmhpc3Rvcnkuc3Vic2NyaWJlO1xuICBjb25zdCBjYW5VbmRvID0gcm9vbS5oaXN0b3J5LmNhblVuZG87XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMoc3Vic2NyaWJlLCBjYW5VbmRvLCBjYW5VbmRvKTtcbn1cbmZ1bmN0aW9uIHVzZUNhblJlZG8oKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLmhpc3Rvcnkuc3Vic2NyaWJlO1xuICBjb25zdCBjYW5SZWRvID0gcm9vbS5oaXN0b3J5LmNhblJlZG87XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMoc3Vic2NyaWJlLCBjYW5SZWRvLCBjYW5SZWRvKTtcbn1cbmZ1bmN0aW9uIHVzZVNlbGYobWF5YmVTZWxlY3RvciwgaXNFcXVhbCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFNlbGY7XG4gIGNvbnN0IHNlbGVjdG9yID0gbWF5YmVTZWxlY3RvciA/PyBpZGVudGl0eTM7XG4gIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IHVzZUNhbGxiYWNrMyhcbiAgICAobWUpID0+IG1lICE9PSBudWxsID8gc2VsZWN0b3IobWUpIDogbnVsbCxcbiAgICBbc2VsZWN0b3JdXG4gICk7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHN1YnNjcmliZSxcbiAgICBnZXRTbmFwc2hvdCxcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICB3cmFwcGVkU2VsZWN0b3IsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlTXlQcmVzZW5jZSgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMubXlQcmVzZW5jZS5zdWJzY3JpYmU7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRQcmVzZW5jZTtcbiAgY29uc3QgcHJlc2VuY2UgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U25hcHNob3QpO1xuICBjb25zdCBzZXRQcmVzZW5jZSA9IHJvb20udXBkYXRlUHJlc2VuY2U7XG4gIHJldHVybiBbcHJlc2VuY2UsIHNldFByZXNlbmNlXTtcbn1cbmZ1bmN0aW9uIHVzZVVwZGF0ZU15UHJlc2VuY2UoKSB7XG4gIHJldHVybiB1c2VSb29tKCkudXBkYXRlUHJlc2VuY2U7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnMoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldE90aGVycztcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNFbXB0eUxpc3Q7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U25hcHNob3QsXG4gICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgc2VsZWN0b3IgPz8gaWRlbnRpdHkzLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyc01hcHBlZChpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKSB7XG4gIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IHVzZUNhbGxiYWNrMyhcbiAgICAob3RoZXJzKSA9PiBvdGhlcnMubWFwKChvdGhlcikgPT4gW290aGVyLmNvbm5lY3Rpb25JZCwgaXRlbVNlbGVjdG9yKG90aGVyKV0pLFxuICAgIFtpdGVtU2VsZWN0b3JdXG4gICk7XG4gIGNvbnN0IHdyYXBwZWRJc0VxdWFsID0gdXNlQ2FsbGJhY2szKFxuICAgIChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBlcSA9IGl0ZW1Jc0VxdWFsID8/IE9iamVjdC5pcztcbiAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoYXR1cGxlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBidHVwbGUgPSBiW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIGF0dXBsZVswXSA9PT0gYnR1cGxlWzBdICYmIGVxKGF0dXBsZVsxXSwgYnR1cGxlWzFdKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW2l0ZW1Jc0VxdWFsXVxuICApO1xuICByZXR1cm4gdXNlT3RoZXJzKHdyYXBwZWRTZWxlY3Rvciwgd3JhcHBlZElzRXF1YWwpO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzQ29ubmVjdGlvbklkcygpIHtcbiAgcmV0dXJuIHVzZU90aGVycyhzZWxlY3RvckZvcl91c2VPdGhlcnNDb25uZWN0aW9uSWRzLCBzaGFsbG93NCk7XG59XG52YXIgTk9UX0ZPVU5EID0gU3ltYm9sKCk7XG5mdW5jdGlvbiB1c2VPdGhlcihjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IHVzZUNhbGxiYWNrMyhcbiAgICAob3RoZXJzKSA9PiB7XG4gICAgICBjb25zdCBvdGhlcjIgPSBvdGhlcnMuZmluZCgob3RoZXIzKSA9PiBvdGhlcjMuY29ubmVjdGlvbklkID09PSBjb25uZWN0aW9uSWQpO1xuICAgICAgcmV0dXJuIG90aGVyMiAhPT0gdm9pZCAwID8gc2VsZWN0b3Iob3RoZXIyKSA6IE5PVF9GT1VORDtcbiAgICB9LFxuICAgIFtjb25uZWN0aW9uSWQsIHNlbGVjdG9yXVxuICApO1xuICBjb25zdCB3cmFwcGVkSXNFcXVhbCA9IHVzZUNhbGxiYWNrMyhcbiAgICAocHJldiwgY3VycikgPT4ge1xuICAgICAgaWYgKHByZXYgPT09IE5PVF9GT1VORCB8fCBjdXJyID09PSBOT1RfRk9VTkQpIHtcbiAgICAgICAgcmV0dXJuIHByZXYgPT09IGN1cnI7XG4gICAgICB9XG4gICAgICBjb25zdCBlcSA9IGlzRXF1YWwgPz8gT2JqZWN0LmlzO1xuICAgICAgcmV0dXJuIGVxKHByZXYsIGN1cnIpO1xuICAgIH0sXG4gICAgW2lzRXF1YWxdXG4gICk7XG4gIGNvbnN0IG90aGVyID0gdXNlT3RoZXJzKHdyYXBwZWRTZWxlY3Rvciwgd3JhcHBlZElzRXF1YWwpO1xuICBpZiAob3RoZXIgPT09IE5PVF9GT1VORCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBObyBzdWNoIG90aGVyIHVzZXIgd2l0aCBjb25uZWN0aW9uIGlkICR7Y29ubmVjdGlvbklkfSBleGlzdHNgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gb3RoZXI7XG59XG5mdW5jdGlvbiB1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2U7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3Q7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlUm9vdCgpIHtcbiAgcmV0dXJuIFt1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKV07XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHJvb3RPck51bGwgPSB1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKTtcbiAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gdXNlQ2FsbGJhY2szKFxuICAgIChyb290T3JOdWxsMikgPT4gcm9vdE9yTnVsbDIgIT09IG51bGwgPyBzZWxlY3Rvcihyb290T3JOdWxsMikgOiBudWxsLFxuICAgIFtzZWxlY3Rvcl1cbiAgKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2szKFxuICAgIChvblN0b3JlQ2hhbmdlKSA9PiByb290T3JOdWxsICE9PSBudWxsID8gcm9vbS5zdWJzY3JpYmUocm9vdE9yTnVsbCwgb25TdG9yZUNoYW5nZSwgeyBpc0RlZXA6IHRydWUgfSkgOiBub29wMixcbiAgICBbcm9vbSwgcm9vdE9yTnVsbF1cbiAgKTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSB1c2VDYWxsYmFjazMoKCkgPT4ge1xuICAgIGlmIChyb290T3JOdWxsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm9vdCA9IHJvb3RPck51bGw7XG4gICAgICBjb25zdCBpbW0gPSByb290LnRvSW1tdXRhYmxlKCk7XG4gICAgICByZXR1cm4gaW1tO1xuICAgIH1cbiAgfSwgW3Jvb3RPck51bGxdKTtcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNOdWxsO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgc3Vic2NyaWJlLFxuICAgIGdldFNuYXBzaG90LFxuICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNdXRhdGlvbihjYWxsYmFjaywgZGVwcykge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gdXNlTWVtbzQoXG4gICAgKCkgPT4ge1xuICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICByb29tLmJhdGNoKFxuICAgICAgICAgICgpID0+IChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgIG1ha2VNdXRhdGlvbkNvbnRleHQocm9vbSksXG4gICAgICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW3Jvb20sIC4uLmRlcHNdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VUaHJlYWRzKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHNjcm9sbE9uTG9hZCA9IHRydWUgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IHN0b3JlLCBnZXRPckNyZWF0ZVRocmVhZHNQb2xsZXJGb3JSb29tSWQgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgcXVlcnlLZXkgPSBtYWtlUm9vbVRocmVhZHNRdWVyeUtleShyb29tLmlkLCBvcHRpb25zLnF1ZXJ5KTtcbiAgY29uc3QgcG9sbGVyID0gZ2V0T3JDcmVhdGVUaHJlYWRzUG9sbGVyRm9yUm9vbUlkKHJvb20uaWQpO1xuICB1c2VFZmZlY3Q2KFxuICAgICgpID0+IHZvaWQgc3RvcmUub3V0cHV0cy5sb2FkaW5nUm9vbVRocmVhZHMuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLndhaXRVbnRpbExvYWRlZCgpXG4gICAgLy8gTk9URTogRGVsaWJlcmF0ZWx5ICpub3QqIHVzaW5nIGEgZGVwZW5kZW5jeSBhcnJheSBoZXJlIVxuICAgIC8vXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNhbGwgd2FpdFVudGlsIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIHRoZSBpbml0aWFsIHBhZ2UgZmV0Y2guXG4gICAgLy8gMi4gQWxsIG90aGVyIHN1YnNlcXVlbnQgcmVuZGVycyBub3cgXCJqdXN0XCIgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UgKGEgcXVpY2sgb3BlcmF0aW9uKS5cbiAgICAvLyAzLiBJZiBldmVyIHRoZSBwcm9taXNlIHdvdWxkIGZhaWwsIHRoZW4gYWZ0ZXIgNSBzZWNvbmRzIGl0IHdvdWxkIHJlc2V0LCBhbmQgb24gdGhlIHZlcnlcbiAgICAvLyAgICAqbmV4dCogcmVuZGVyIGFmdGVyIHRoYXQsIGEgKm5ldyogZmV0Y2gvcHJvbWlzZSB3aWxsIGdldCBjcmVhdGVkLlxuICApO1xuICB1c2VFZmZlY3Q2KCgpID0+IHtcbiAgICBwb2xsZXIuaW5jKCk7XG4gICAgcG9sbGVyLnBvbGxOb3dJZlN0YWxlKCk7XG4gICAgcmV0dXJuICgpID0+IHBvbGxlci5kZWMoKTtcbiAgfSwgW3BvbGxlcl0pO1xuICBjb25zdCByZXN1bHQgPSB1c2VTaWduYWwoXG4gICAgc3RvcmUub3V0cHV0cy5sb2FkaW5nUm9vbVRocmVhZHMuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLnNpZ25hbFxuICApO1xuICB1c2VTY3JvbGxUb0NvbW1lbnRPbkxvYWRFZmZlY3Qoc2Nyb2xsT25Mb2FkLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlU2VhcmNoQ29tbWVudHMob3B0aW9ucykge1xuICBjb25zdCBbcmVzdWx0LCBzZXRSZXN1bHRdID0gdXNlU3RhdGUzKHtcbiAgICBpc0xvYWRpbmc6IHRydWVcbiAgfSk7XG4gIGNvbnN0IGN1cnJlbnRSZXF1ZXN0SW5mbyA9IHVzZVJlZjMobnVsbCk7XG4gIGNvbnN0IHRpbWVvdXQgPSB1c2VSZWYzKG51bGwpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgcXVlcnlLZXkgPSBzdGFibGVTdHJpbmdpZnkyKFtyb29tLmlkLCBvcHRpb25zLnF1ZXJ5XSk7XG4gIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRSZXF1ZXN0SWQgPSAoY3VycmVudFJlcXVlc3RJbmZvLmN1cnJlbnQ/LmlkID8/IDApICsgMTtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGN1cnJlbnRSZXF1ZXN0SW5mby5jdXJyZW50ID0geyBpZDogY3VycmVudFJlcXVlc3RJZCwgY29udHJvbGxlciB9O1xuICAgIHNldFJlc3VsdCgocmVzdWx0MikgPT4ge1xuICAgICAgaWYgKHJlc3VsdDIuaXNMb2FkaW5nKSByZXR1cm4gcmVzdWx0MjtcbiAgICAgIHJldHVybiB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICAgIH0pO1xuICAgIHRpbWVvdXQuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjbGllbnRba0ludGVybmFsNF0uaHR0cENsaWVudC5zZWFyY2hDb21tZW50cyhcbiAgICAgICAgICB7XG4gICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICBxdWVyeTogb3B0aW9ucy5xdWVyeVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH1cbiAgICAgICAgKS50aGVuKCh7IGRhdGEgfSkgPT4ge1xuICAgICAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKGN1cnJlbnRSZXF1ZXN0SW5mby5jdXJyZW50Py5pZCAhPT0gY3VycmVudFJlcXVlc3RJZCkgcmV0dXJuO1xuICAgICAgICAgIHNldFJlc3VsdCh7IGlzTG9hZGluZzogZmFsc2UsIHJlc3VsdHM6IGRhdGEgfSk7XG4gICAgICAgICAgY3VycmVudFJlcXVlc3RJbmZvLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoY3VycmVudFJlcXVlc3RJbmZvLmN1cnJlbnQ/LmlkICE9PSBjdXJyZW50UmVxdWVzdElkKSByZXR1cm47XG4gICAgICAgICAgc2V0UmVzdWx0KHsgaXNMb2FkaW5nOiBmYWxzZSwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICBjdXJyZW50UmVxdWVzdEluZm8uY3VycmVudCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIDMwMFxuICAgICAgLyogZGVib3VuY2UgdGltZSAqL1xuICAgICk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0aW1lb3V0LmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0LmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRSZXF1ZXN0SW5mby5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRSZXF1ZXN0SW5mby5jdXJyZW50LmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbcXVlcnlLZXksIGNsaWVudCwgcm9vbS5pZF0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlQ3JlYXRlVGhyZWFkKCkge1xuICByZXR1cm4gdXNlQ3JlYXRlUm9vbVRocmVhZCh1c2VSb29tKCkuaWQpO1xufVxuZnVuY3Rpb24gdXNlQ3JlYXRlUm9vbVRocmVhZChyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IG9wdGlvbnMubWV0YWRhdGEgPz8ge307XG4gICAgICBjb25zdCBhdHRhY2htZW50cyA9IG9wdGlvbnMuYXR0YWNobWVudHM7XG4gICAgICBjb25zdCB0aHJlYWRJZCA9IGNyZWF0ZVRocmVhZElkKCk7XG4gICAgICBjb25zdCBjb21tZW50SWQgPSBjcmVhdGVDb21tZW50SWQoKTtcbiAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgbmV3Q29tbWVudCA9IHtcbiAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgdXNlcklkOiBnZXRDdXJyZW50VXNlcklkKGNsaWVudCksXG4gICAgICAgIGJvZHksXG4gICAgICAgIHJlYWN0aW9uczogW10sXG4gICAgICAgIGF0dGFjaG1lbnRzOiBhdHRhY2htZW50cyA/PyBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG5ld1RocmVhZCA9IHtcbiAgICAgICAgaWQ6IHRocmVhZElkLFxuICAgICAgICB0eXBlOiBcInRocmVhZFwiLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIHVwZGF0ZWRBdDogY3JlYXRlZEF0LFxuICAgICAgICByb29tSWQsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBjb21tZW50czogW25ld0NvbW1lbnRdLFxuICAgICAgICByZXNvbHZlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJjcmVhdGUtdGhyZWFkXCIsXG4gICAgICAgIHRocmVhZDogbmV3VGhyZWFkLFxuICAgICAgICByb29tSWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXR0YWNobWVudElkcyA9IGF0dGFjaG1lbnRzPy5tYXAoKGF0dGFjaG1lbnQpID0+IGF0dGFjaG1lbnQuaWQpO1xuICAgICAgY2xpZW50W2tJbnRlcm5hbDRdLmh0dHBDbGllbnQuY3JlYXRlVGhyZWFkKHtcbiAgICAgICAgcm9vbUlkLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudElkLFxuICAgICAgICBib2R5LFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgYXR0YWNobWVudElkc1xuICAgICAgfSkudGhlbihcbiAgICAgICAgKHRocmVhZCkgPT4ge1xuICAgICAgICAgIHN0b3JlLmNyZWF0ZVRocmVhZChvcHRpbWlzdGljSWQsIHRocmVhZCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIkNSRUFURV9USFJFQURfRVJST1JcIixcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXdUaHJlYWQ7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tSWRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVUaHJlYWQoKSB7XG4gIHJldHVybiB1c2VEZWxldGVSb29tVGhyZWFkKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVSb29tVGhyZWFkKHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAodGhyZWFkSWQpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKGNsaWVudCk7XG4gICAgICBjb25zdCBleGlzdGluZyA9IHN0b3JlLm91dHB1dHMudGhyZWFkcy5nZXQoKS5nZXQodGhyZWFkSWQpO1xuICAgICAgaWYgKGV4aXN0aW5nPy5jb21tZW50cz8uWzBdPy51c2VySWQgIT09IHVzZXJJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHRoZSB0aHJlYWQgY3JlYXRvciBjYW4gZGVsZXRlIHRoZSB0aHJlYWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgICB0eXBlOiBcImRlbGV0ZS10aHJlYWRcIixcbiAgICAgICAgcm9vbUlkLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgZGVsZXRlZEF0OiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgfSk7XG4gICAgICBjbGllbnRba0ludGVybmFsNF0uaHR0cENsaWVudC5kZWxldGVUaHJlYWQoeyByb29tSWQsIHRocmVhZElkIH0pLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5kZWxldGVUaHJlYWQodGhyZWFkSWQsIG9wdGltaXN0aWNJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICB7IHR5cGU6IFwiREVMRVRFX1RIUkVBRF9FUlJPUlwiLCByb29tSWQsIHRocmVhZElkIH0sXG4gICAgICAgICAgZXJyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tSWRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VFZGl0VGhyZWFkTWV0YWRhdGEoKSB7XG4gIHJldHVybiB1c2VFZGl0Um9vbVRocmVhZE1ldGFkYXRhKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VFZGl0Um9vbVRocmVhZE1ldGFkYXRhKHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAob3B0aW9ucykgPT4ge1xuICAgICAgaWYgKCFvcHRpb25zLm1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRocmVhZElkID0gb3B0aW9ucy50aHJlYWRJZDtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwiZWRpdC10aHJlYWQtbWV0YWRhdGFcIixcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICB1cGRhdGVkQXRcbiAgICAgIH0pO1xuICAgICAgY2xpZW50W2tJbnRlcm5hbDRdLmh0dHBDbGllbnQuZWRpdFRocmVhZE1ldGFkYXRhKHsgcm9vbUlkLCB0aHJlYWRJZCwgbWV0YWRhdGEgfSkudGhlbihcbiAgICAgICAgKG1ldGFkYXRhMikgPT4gKFxuICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIG9wdGltaXN0aWMgdXBkYXRlIGJ5IHRoZSByZWFsIHRoaW5nXG4gICAgICAgICAgc3RvcmUucGF0Y2hUaHJlYWQodGhyZWFkSWQsIG9wdGltaXN0aWNJZCwgeyBtZXRhZGF0YTogbWV0YWRhdGEyIH0sIHVwZGF0ZWRBdClcbiAgICAgICAgKSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiRURJVF9USFJFQURfTUVUQURBVEFfRVJST1JcIixcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlQ3JlYXRlQ29tbWVudCgpIHtcbiAgcmV0dXJuIHVzZUNyZWF0ZVJvb21Db21tZW50KHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVSb29tQ29tbWVudChyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHsgdGhyZWFkSWQsIGJvZHksIGF0dGFjaG1lbnRzIH0pID0+IHtcbiAgICAgIGNvbnN0IGNvbW1lbnRJZCA9IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBjb21tZW50ID0ge1xuICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgcm9vbUlkLFxuICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICB1c2VySWQ6IGdldEN1cnJlbnRVc2VySWQoY2xpZW50KSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgcmVhY3Rpb25zOiBbXSxcbiAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzID8/IFtdXG4gICAgICB9O1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwiY3JlYXRlLWNvbW1lbnRcIixcbiAgICAgICAgY29tbWVudFxuICAgICAgfSk7XG4gICAgICBjb25zdCBhdHRhY2htZW50SWRzID0gYXR0YWNobWVudHM/Lm1hcCgoYXR0YWNobWVudCkgPT4gYXR0YWNobWVudC5pZCk7XG4gICAgICBjbGllbnRba0ludGVybmFsNF0uaHR0cENsaWVudC5jcmVhdGVDb21tZW50KHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5LCBhdHRhY2htZW50SWRzIH0pLnRoZW4oXG4gICAgICAgIChuZXdDb21tZW50KSA9PiB7XG4gICAgICAgICAgc3RvcmUuY3JlYXRlQ29tbWVudChuZXdDb21tZW50LCBvcHRpbWlzdGljSWQpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJDUkVBVEVfQ09NTUVOVF9FUlJPUlwiLFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRWRpdENvbW1lbnQoKSB7XG4gIHJldHVybiB1c2VFZGl0Um9vbUNvbW1lbnQodXNlUm9vbSgpLmlkKTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRSb29tQ29tbWVudChyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSwgYXR0YWNobWVudHMgfSkgPT4ge1xuICAgICAgY29uc3QgZWRpdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBleGlzdGluZyA9IHN0b3JlLm91dHB1dHMudGhyZWFkcy5nZXQoKS5nZXRFdmVuSWZEZWxldGVkKHRocmVhZElkKTtcbiAgICAgIGlmIChleGlzdGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnNvbGUzLndhcm4oXG4gICAgICAgICAgYEludGVybmFsIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIENhbm5vdCBlZGl0IGNvbW1lbnQgaW4gdGhyZWFkIFwiJHt0aHJlYWRJZH1cIiBiZWNhdXNlIHRoZSB0aHJlYWQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tbWVudCA9IGV4aXN0aW5nLmNvbW1lbnRzLmZpbmQoXG4gICAgICAgIChjb21tZW50MikgPT4gY29tbWVudDIuaWQgPT09IGNvbW1lbnRJZFxuICAgICAgKTtcbiAgICAgIGlmIChjb21tZW50ID09PSB2b2lkIDAgfHwgY29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlMy53YXJuKFxuICAgICAgICAgIGBJbnRlcm5hbCB1bmV4cGVjdGVkIGJlaGF2aW9yLiBDYW5ub3QgZWRpdCBjb21tZW50IFwiJHtjb21tZW50SWR9XCIgaW4gdGhyZWFkIFwiJHt0aHJlYWRJZH1cIiBiZWNhdXNlIHRoZSBjb21tZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZS5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwiZWRpdC1jb21tZW50XCIsXG4gICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICAuLi5jb21tZW50LFxuICAgICAgICAgIGVkaXRlZEF0LFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzID8/IFtdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXR0YWNobWVudElkcyA9IGF0dGFjaG1lbnRzPy5tYXAoKGF0dGFjaG1lbnQpID0+IGF0dGFjaG1lbnQuaWQpO1xuICAgICAgY2xpZW50W2tJbnRlcm5hbDRdLmh0dHBDbGllbnQuZWRpdENvbW1lbnQoeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQsIGJvZHksIGF0dGFjaG1lbnRJZHMgfSkudGhlbihcbiAgICAgICAgKGVkaXRlZENvbW1lbnQpID0+IHtcbiAgICAgICAgICBzdG9yZS5lZGl0Q29tbWVudCh0aHJlYWRJZCwgb3B0aW1pc3RpY0lkLCBlZGl0ZWRDb21tZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgIHsgdHlwZTogXCJFRElUX0NPTU1FTlRfRVJST1JcIiwgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5IH0sXG4gICAgICAgICAgZXJyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tSWRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVDb21tZW50KCkge1xuICByZXR1cm4gdXNlRGVsZXRlUm9vbUNvbW1lbnQodXNlUm9vbSgpLmlkKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZVJvb21Db21tZW50KHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkIH0pID0+IHtcbiAgICAgIGNvbnN0IGRlbGV0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwiZGVsZXRlLWNvbW1lbnRcIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgZGVsZXRlZEF0LFxuICAgICAgICByb29tSWRcbiAgICAgIH0pO1xuICAgICAgY2xpZW50W2tJbnRlcm5hbDRdLmh0dHBDbGllbnQuZGVsZXRlQ29tbWVudCh7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCB9KS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUuZGVsZXRlQ29tbWVudCh0aHJlYWRJZCwgb3B0aW1pc3RpY0lkLCBjb21tZW50SWQsIGRlbGV0ZWRBdCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICB7IHR5cGU6IFwiREVMRVRFX0NPTU1FTlRfRVJST1JcIiwgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkIH0sXG4gICAgICAgICAgZXJyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tSWRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VBZGRSZWFjdGlvbigpIHtcbiAgcmV0dXJuIHVzZUFkZFJvb21Db21tZW50UmVhY3Rpb24odXNlUm9vbSgpLmlkKTtcbn1cbmZ1bmN0aW9uIHVzZUFkZFJvb21Db21tZW50UmVhY3Rpb24ocm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgICh7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pID0+IHtcbiAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgdXNlcklkID0gZ2V0Q3VycmVudFVzZXJJZChjbGllbnQpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwiYWRkLXJlYWN0aW9uXCIsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICBjb21tZW50SWQsXG4gICAgICAgIHJlYWN0aW9uOiB7XG4gICAgICAgICAgZW1vamksXG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNsaWVudFtrSW50ZXJuYWw0XS5odHRwQ2xpZW50LmFkZFJlYWN0aW9uKHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KS50aGVuKFxuICAgICAgICAoYWRkZWRSZWFjdGlvbikgPT4ge1xuICAgICAgICAgIHN0b3JlLmFkZFJlYWN0aW9uKFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBhZGRlZFJlYWN0aW9uLFxuICAgICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQUREX1JFQUNUSU9OX0VSUk9SXCIsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGVtb2ppXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVJlbW92ZVJlYWN0aW9uKCkge1xuICByZXR1cm4gdXNlUmVtb3ZlUm9vbUNvbW1lbnRSZWFjdGlvbih1c2VSb29tKCkuaWQpO1xufVxuZnVuY3Rpb24gdXNlUmVtb3ZlUm9vbUNvbW1lbnRSZWFjdGlvbihyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkgPT4ge1xuICAgICAgY29uc3QgdXNlcklkID0gZ2V0Q3VycmVudFVzZXJJZChjbGllbnQpO1xuICAgICAgY29uc3QgcmVtb3ZlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJyZW1vdmUtcmVhY3Rpb25cIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgZW1vamksXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgcmVtb3ZlZEF0XG4gICAgICB9KTtcbiAgICAgIGNsaWVudFtrSW50ZXJuYWw0XS5odHRwQ2xpZW50LnJlbW92ZVJlYWN0aW9uKHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUucmVtb3ZlUmVhY3Rpb24oXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgcmVtb3ZlZEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUkVNT1ZFX1JFQUNUSU9OX0VSUk9SXCIsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGVtb2ppXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU1hcmtUaHJlYWRBc1JlYWQoKSB7XG4gIHJldHVybiB1c2VNYXJrUm9vbVRocmVhZEFzUmVhZCh1c2VSb29tKCkuaWQpO1xufVxuZnVuY3Rpb24gdXNlTWFya1Jvb21UaHJlYWRBc1JlYWQocm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgICh0aHJlYWRJZCkgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uID0gT2JqZWN0LnZhbHVlcyhcbiAgICAgICAgc3RvcmUub3V0cHV0cy5ub3RpZmljYXRpb25zLmdldCgpLm5vdGlmaWNhdGlvbnNCeUlkXG4gICAgICApLmZpbmQoXG4gICAgICAgIChpbmJveE5vdGlmaWNhdGlvbjIpID0+IGluYm94Tm90aWZpY2F0aW9uMi5raW5kID09PSBcInRocmVhZFwiICYmIGluYm94Tm90aWZpY2F0aW9uMi50aHJlYWRJZCA9PT0gdGhyZWFkSWRcbiAgICAgICk7XG4gICAgICBpZiAoIWluYm94Tm90aWZpY2F0aW9uKSByZXR1cm47XG4gICAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwibWFyay1pbmJveC1ub3RpZmljYXRpb24tYXMtcmVhZFwiLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkOiBpbmJveE5vdGlmaWNhdGlvbi5pZCxcbiAgICAgICAgcmVhZEF0OiBub3dcbiAgICAgIH0pO1xuICAgICAgY2xpZW50W2tJbnRlcm5hbDRdLmh0dHBDbGllbnQubWFya1Jvb21JbmJveE5vdGlmaWNhdGlvbkFzUmVhZCh7XG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZDogaW5ib3hOb3RpZmljYXRpb24uaWRcbiAgICAgIH0pLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5tYXJrSW5ib3hOb3RpZmljYXRpb25SZWFkKFxuICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb24uaWQsXG4gICAgICAgICAgICBub3csXG4gICAgICAgICAgICBvcHRpbWlzdGljSWRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiTUFSS19JTkJPWF9OT1RJRklDQVRJT05fQVNfUkVBRF9FUlJPUlwiLFxuICAgICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQ6IGluYm94Tm90aWZpY2F0aW9uLmlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tSWRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrVGhyZWFkQXNSZXNvbHZlZCgpIHtcbiAgcmV0dXJuIHVzZU1hcmtSb29tVGhyZWFkQXNSZXNvbHZlZCh1c2VSb29tKCkuaWQpO1xufVxuZnVuY3Rpb24gdXNlTWFya1Jvb21UaHJlYWRBc1Jlc29sdmVkKHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAodGhyZWFkSWQpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwibWFyay10aHJlYWQtYXMtcmVzb2x2ZWRcIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIHVwZGF0ZWRBdFxuICAgICAgfSk7XG4gICAgICBjbGllbnRba0ludGVybmFsNF0uaHR0cENsaWVudC5tYXJrVGhyZWFkQXNSZXNvbHZlZCh7IHJvb21JZCwgdGhyZWFkSWQgfSkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnBhdGNoVGhyZWFkKFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAgICB7IHJlc29sdmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB1cGRhdGVkQXRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAgeyB0eXBlOiBcIk1BUktfVEhSRUFEX0FTX1JFU09MVkVEX0VSUk9SXCIsIHJvb21JZCwgdGhyZWFkSWQgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU1hcmtUaHJlYWRBc1VucmVzb2x2ZWQoKSB7XG4gIHJldHVybiB1c2VNYXJrUm9vbVRocmVhZEFzVW5yZXNvbHZlZCh1c2VSb29tKCkuaWQpO1xufVxuZnVuY3Rpb24gdXNlTWFya1Jvb21UaHJlYWRBc1VucmVzb2x2ZWQocm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgICh0aHJlYWRJZCkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLXRocmVhZC1hcy11bnJlc29sdmVkXCIsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICB1cGRhdGVkQXRcbiAgICAgIH0pO1xuICAgICAgY2xpZW50W2tJbnRlcm5hbDRdLmh0dHBDbGllbnQubWFya1RocmVhZEFzVW5yZXNvbHZlZCh7IHJvb21JZCwgdGhyZWFkSWQgfSkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnBhdGNoVGhyZWFkKFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAgICB7IHJlc29sdmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgdXBkYXRlZEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgIHsgdHlwZTogXCJNQVJLX1RIUkVBRF9BU19VTlJFU09MVkVEX0VSUk9SXCIsIHJvb21JZCwgdGhyZWFkSWQgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVN1YnNjcmliZVRvVGhyZWFkKCkge1xuICByZXR1cm4gdXNlU3Vic2NyaWJlVG9Sb29tVGhyZWFkKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VTdWJzY3JpYmVUb1Jvb21UaHJlYWQocm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgICh0aHJlYWRJZCkgPT4ge1xuICAgICAgY29uc3Qgc3Vic2NyaWJlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJzdWJzY3JpYmUtdG8tdGhyZWFkXCIsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICBzdWJzY3JpYmVkQXRcbiAgICAgIH0pO1xuICAgICAgY2xpZW50W2tJbnRlcm5hbDRdLmh0dHBDbGllbnQuc3Vic2NyaWJlVG9UaHJlYWQoeyByb29tSWQsIHRocmVhZElkIH0pLnRoZW4oXG4gICAgICAgIChzdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICBzdG9yZS5jcmVhdGVTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCBvcHRpbWlzdGljSWQpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAgeyB0eXBlOiBcIlNVQlNDUklCRV9UT19USFJFQURfRVJST1JcIiwgcm9vbUlkLCB0aHJlYWRJZCB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlVW5zdWJzY3JpYmVGcm9tVGhyZWFkKCkge1xuICByZXR1cm4gdXNlVW5zdWJzY3JpYmVGcm9tUm9vbVRocmVhZCh1c2VSb29tKCkuaWQpO1xufVxuZnVuY3Rpb24gdXNlVW5zdWJzY3JpYmVGcm9tUm9vbVRocmVhZChyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHRocmVhZElkKSA9PiB7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwidW5zdWJzY3JpYmUtZnJvbS10aHJlYWRcIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIHVuc3Vic2NyaWJlZEF0XG4gICAgICB9KTtcbiAgICAgIGNsaWVudFtrSW50ZXJuYWw0XS5odHRwQ2xpZW50LnVuc3Vic2NyaWJlRnJvbVRocmVhZCh7IHJvb21JZCwgdGhyZWFkSWQgfSkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLmRlbGV0ZVN1YnNjcmlwdGlvbihcbiAgICAgICAgICAgIGdldFN1YnNjcmlwdGlvbktleTMoXCJ0aHJlYWRcIiwgdGhyZWFkSWQpLFxuICAgICAgICAgICAgb3B0aW1pc3RpY0lkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgIHsgdHlwZTogXCJVTlNVQlNDUklCRV9GUk9NX1RIUkVBRF9FUlJPUlwiLCByb29tSWQsIHRocmVhZElkIH0sXG4gICAgICAgICAgZXJyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tSWRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VUaHJlYWRTdWJzY3JpcHRpb24odGhyZWFkSWQpIHtcbiAgcmV0dXJuIHVzZVJvb21UaHJlYWRTdWJzY3JpcHRpb24odXNlUm9vbSgpLmlkLCB0aHJlYWRJZCk7XG59XG5mdW5jdGlvbiB1c2VSb29tVGhyZWFkU3Vic2NyaXB0aW9uKHJvb21JZCwgdGhyZWFkSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHsgc3RvcmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3Qgc3Vic2NyaXB0aW9uS2V5ID0gdXNlTWVtbzQoXG4gICAgKCkgPT4gZ2V0U3Vic2NyaXB0aW9uS2V5MyhcInRocmVhZFwiLCB0aHJlYWRJZCksXG4gICAgW3RocmVhZElkXVxuICApO1xuICBjb25zdCBzdWJzY3JpYmVUb1RocmVhZCA9IHVzZVN1YnNjcmliZVRvUm9vbVRocmVhZChyb29tSWQpO1xuICBjb25zdCB1bnN1YnNjcmliZUZyb21UaHJlYWQgPSB1c2VVbnN1YnNjcmliZUZyb21Sb29tVGhyZWFkKHJvb21JZCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHVzZUNhbGxiYWNrMyhcbiAgICAoKSA9PiBzdWJzY3JpYmVUb1RocmVhZCh0aHJlYWRJZCksXG4gICAgW3N1YnNjcmliZVRvVGhyZWFkLCB0aHJlYWRJZF1cbiAgKTtcbiAgY29uc3QgdW5zdWJzY3JpYmUgPSB1c2VDYWxsYmFjazMoXG4gICAgKCkgPT4gdW5zdWJzY3JpYmVGcm9tVGhyZWFkKHRocmVhZElkKSxcbiAgICBbdW5zdWJzY3JpYmVGcm9tVGhyZWFkLCB0aHJlYWRJZF1cbiAgKTtcbiAgY29uc3Qgc2lnbmFsID0gc3RvcmUub3V0cHV0cy50aHJlYWRTdWJzY3JpcHRpb25zO1xuICBjb25zdCBzZWxlY3RvciA9IHVzZUNhbGxiYWNrMyhcbiAgICAoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN0YXRlLnN1YnNjcmlwdGlvbnNbc3Vic2NyaXB0aW9uS2V5XTtcbiAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IHN0YXRlLm5vdGlmaWNhdGlvbnMuZmluZChcbiAgICAgICAgKGluYm94Tm90aWZpY2F0aW9uKSA9PiBpbmJveE5vdGlmaWNhdGlvbi5raW5kID09PSBcInRocmVhZFwiICYmIGluYm94Tm90aWZpY2F0aW9uLnRocmVhZElkID09PSB0aHJlYWRJZFxuICAgICAgKTtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwibm90LXN1YnNjcmliZWRcIiwgc3Vic2NyaWJlLCB1bnN1YnNjcmliZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBcInN1YnNjcmliZWRcIixcbiAgICAgICAgdW5yZWFkU2luY2U6IG5vdGlmaWNhdGlvbj8ucmVhZEF0ID8/IG51bGwsXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgdW5zdWJzY3JpYmVcbiAgICAgIH07XG4gICAgfSxcbiAgICBbc3Vic2NyaXB0aW9uS2V5LCB0aHJlYWRJZCwgc3Vic2NyaWJlLCB1bnN1YnNjcmliZV1cbiAgKTtcbiAgcmV0dXJuIHVzZVNpZ25hbChzaWduYWwsIHNlbGVjdG9yLCBzaGFsbG93NCk7XG59XG5mdW5jdGlvbiB1c2VSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3MoKSB7XG4gIGNvbnN0IHVwZGF0ZVJvb21TdWJzY3JpcHRpb25TZXR0aW5ncyA9IHVzZVVwZGF0ZVJvb21TdWJzY3JpcHRpb25TZXR0aW5ncygpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgeyBzdG9yZSwgZ2V0T3JDcmVhdGVTdWJzY3JpcHRpb25TZXR0aW5nc1BvbGxlckZvclJvb21JZCB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBwb2xsZXIgPSBnZXRPckNyZWF0ZVN1YnNjcmlwdGlvblNldHRpbmdzUG9sbGVyRm9yUm9vbUlkKHJvb20uaWQpO1xuICB1c2VFZmZlY3Q2KFxuICAgICgpID0+IHZvaWQgc3RvcmUub3V0cHV0cy5yb29tU3Vic2NyaXB0aW9uU2V0dGluZ3NCeVJvb21JZC5nZXRPckNyZWF0ZShyb29tLmlkKS53YWl0VW50aWxMb2FkZWQoKVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIHdhaXRVbnRpbCBvbiAqZXZlcnkqIHJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGhhcm1sZXNzIHRob3VnaCwgb24gbW9zdCByZW5kZXJzLCBleGNlcHQ6XG4gICAgLy8gMS4gVGhlIHZlcnkgZmlyc3QgcmVuZGVyLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gdHJpZ2dlciB0aGUgaW5pdGlhbCBwYWdlIGZldGNoLlxuICAgIC8vIDIuIEFsbCBvdGhlciBzdWJzZXF1ZW50IHJlbmRlcnMgbm93IFwianVzdFwiIHJldHVybiB0aGUgc2FtZSBwcm9taXNlIChhIHF1aWNrIG9wZXJhdGlvbikuXG4gICAgLy8gMy4gSWYgZXZlciB0aGUgcHJvbWlzZSB3b3VsZCBmYWlsLCB0aGVuIGFmdGVyIDUgc2Vjb25kcyBpdCB3b3VsZCByZXNldCwgYW5kIG9uIHRoZSB2ZXJ5XG4gICAgLy8gICAgKm5leHQqIHJlbmRlciBhZnRlciB0aGF0LCBhICpuZXcqIGZldGNoL3Byb21pc2Ugd2lsbCBnZXQgY3JlYXRlZC5cbiAgKTtcbiAgdXNlRWZmZWN0NigoKSA9PiB7XG4gICAgcG9sbGVyLmluYygpO1xuICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb2xsZXIuZGVjKCk7XG4gICAgfTtcbiAgfSwgW3BvbGxlcl0pO1xuICBjb25zdCBzZXR0aW5ncyA9IHVzZVNpZ25hbChcbiAgICBzdG9yZS5vdXRwdXRzLnJvb21TdWJzY3JpcHRpb25TZXR0aW5nc0J5Um9vbUlkLmdldE9yQ3JlYXRlKHJvb20uaWQpLnNpZ25hbFxuICApO1xuICByZXR1cm4gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiBbc2V0dGluZ3MsIHVwZGF0ZVJvb21TdWJzY3JpcHRpb25TZXR0aW5nc107XG4gIH0sIFtzZXR0aW5ncywgdXBkYXRlUm9vbVN1YnNjcmlwdGlvblNldHRpbmdzXSk7XG59XG5mdW5jdGlvbiB1c2VSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3NTdXNwZW5zZSgpIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkuc3RvcmU7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHVzZShcbiAgICBzdG9yZS5vdXRwdXRzLnJvb21TdWJzY3JpcHRpb25TZXR0aW5nc0J5Um9vbUlkLmdldE9yQ3JlYXRlKHJvb20uaWQpLndhaXRVbnRpbExvYWRlZCgpXG4gICk7XG4gIGNvbnN0IFtzZXR0aW5ncywgdXBkYXRlUm9vbVN1YnNjcmlwdGlvblNldHRpbmdzXSA9IHVzZVJvb21TdWJzY3JpcHRpb25TZXR0aW5ncygpO1xuICBhc3NlcnQyKCFzZXR0aW5ncy5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0Mighc2V0dGluZ3MuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIFtzZXR0aW5ncywgdXBkYXRlUm9vbVN1YnNjcmlwdGlvblNldHRpbmdzXTtcbiAgfSwgW3NldHRpbmdzLCB1cGRhdGVSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3NdKTtcbn1cbmZ1bmN0aW9uIHVzZUhpc3RvcnlWZXJzaW9uRGF0YSh2ZXJzaW9uSWQpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTMoe1xuICAgIGlzTG9hZGluZzogdHJ1ZVxuICB9KTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgdXNlRWZmZWN0NigoKSA9PiB7XG4gICAgc2V0U3RhdGUoeyBpc0xvYWRpbmc6IHRydWUgfSk7XG4gICAgY29uc3QgbG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcm9vbVtrSW50ZXJuYWw0XS5nZXRUZXh0VmVyc2lvbih2ZXJzaW9uSWQpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgbG9hZGluZyB0aGlzIHZlcnNpb25cIlxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2b2lkIGxvYWQoKTtcbiAgfSwgW3Jvb20sIHZlcnNpb25JZF0pO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VIaXN0b3J5VmVyc2lvbnMoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IHN0b3JlLCBnZXRPckNyZWF0ZVZlcnNpb25zUG9sbGVyRm9yUm9vbUlkIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHBvbGxlciA9IGdldE9yQ3JlYXRlVmVyc2lvbnNQb2xsZXJGb3JSb29tSWQocm9vbS5pZCk7XG4gIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgIHBvbGxlci5pbmMoKTtcbiAgICBwb2xsZXIucG9sbE5vd0lmU3RhbGUoKTtcbiAgICByZXR1cm4gKCkgPT4gcG9sbGVyLmRlYygpO1xuICB9LCBbcG9sbGVyXSk7XG4gIHVzZUVmZmVjdDYoXG4gICAgKCkgPT4gdm9pZCBzdG9yZS5vdXRwdXRzLnZlcnNpb25zQnlSb29tSWQuZ2V0T3JDcmVhdGUocm9vbS5pZCkud2FpdFVudGlsTG9hZGVkKClcbiAgICAvLyBOT1RFOiBEZWxpYmVyYXRlbHkgKm5vdCogdXNpbmcgYSBkZXBlbmRlbmN5IGFycmF5IGhlcmUhXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCB3YWl0VW50aWwgb24gKmV2ZXJ5KiByZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBoYXJtbGVzcyB0aG91Z2gsIG9uIG1vc3QgcmVuZGVycywgZXhjZXB0OlxuICAgIC8vIDEuIFRoZSB2ZXJ5IGZpcnN0IHJlbmRlciwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHRyaWdnZXIgdGhlIGluaXRpYWwgcGFnZSBmZXRjaC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBcImp1c3RcIiByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZSAoYSBxdWljayBvcGVyYXRpb24pLlxuICAgIC8vIDMuIElmIGV2ZXIgdGhlIHByb21pc2Ugd291bGQgZmFpbCwgdGhlbiBhZnRlciA1IHNlY29uZHMgaXQgd291bGQgcmVzZXQsIGFuZCBvbiB0aGUgdmVyeVxuICAgIC8vICAgICpuZXh0KiByZW5kZXIgYWZ0ZXIgdGhhdCwgYSAqbmV3KiBmZXRjaC9wcm9taXNlIHdpbGwgZ2V0IGNyZWF0ZWQuXG4gICk7XG4gIHJldHVybiB1c2VTaWduYWwoc3RvcmUub3V0cHV0cy52ZXJzaW9uc0J5Um9vbUlkLmdldE9yQ3JlYXRlKHJvb20uaWQpLnNpZ25hbCk7XG59XG5mdW5jdGlvbiB1c2VIaXN0b3J5VmVyc2lvbnNTdXNwZW5zZSgpIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkuc3RvcmU7XG4gIHVzZShzdG9yZS5vdXRwdXRzLnZlcnNpb25zQnlSb29tSWQuZ2V0T3JDcmVhdGUocm9vbS5pZCkud2FpdFVudGlsTG9hZGVkKCkpO1xuICBjb25zdCByZXN1bHQgPSB1c2VIaXN0b3J5VmVyc2lvbnMoKTtcbiAgYXNzZXJ0MighcmVzdWx0LmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICBhc3NlcnQyKCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VVcGRhdGVSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3MoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgIChzZXR0aW5ncykgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUsIHBvbGxUaHJlYWRzRm9yUm9vbUlkIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgICB0eXBlOiBcInVwZGF0ZS1yb29tLXN1YnNjcmlwdGlvbi1zZXR0aW5nc1wiLFxuICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgc2V0dGluZ3NcbiAgICAgIH0pO1xuICAgICAgcm9vbS51cGRhdGVTdWJzY3JpcHRpb25TZXR0aW5ncyhzZXR0aW5ncykudGhlbihcbiAgICAgICAgKHVkcGF0ZWRTZXR0aW5ncykgPT4ge1xuICAgICAgICAgIHN0b3JlLnVwZGF0ZVJvb21TdWJzY3JpcHRpb25TZXR0aW5ncyhcbiAgICAgICAgICAgIHJvb20uaWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAgICB1ZHBhdGVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChzZXR0aW5ncy50aHJlYWRzKSB7XG4gICAgICAgICAgICBwb2xsVGhyZWFkc0ZvclJvb21JZChyb29tLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIlVQREFURV9ST09NX1NVQlNDUklQVElPTl9TRVRUSU5HU19FUlJPUlwiLFxuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHVzZShyb29tLndhaXRVbnRpbFByZXNlbmNlUmVhZHkoKSk7XG59XG5mdW5jdGlvbiB1c2VTZWxmU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VSZWFkeSgpO1xuICByZXR1cm4gdXNlU2VsZihcbiAgICBzZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcnMoXG4gICAgc2VsZWN0b3IsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlKCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZShpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZU90aGVyc01hcHBlZChpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyU3VzcGVuc2UoY29ubmVjdGlvbklkLCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcihjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VSZWFkeSgpIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICB1c2Uocm9vbS53YWl0VW50aWxTdG9yYWdlUmVhZHkoKSk7XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgdXNlU3VzcGVuZFVudGlsU3RvcmFnZVJlYWR5KCk7XG4gIHJldHVybiB1c2VTdG9yYWdlKFxuICAgIHNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVRocmVhZHNTdXNwZW5zZShvcHRpb25zID0ge30pIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBxdWVyeUtleSA9IG1ha2VSb29tVGhyZWFkc1F1ZXJ5S2V5KHJvb20uaWQsIG9wdGlvbnMucXVlcnkpO1xuICB1c2Uoc3RvcmUub3V0cHV0cy5sb2FkaW5nUm9vbVRocmVhZHMuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLndhaXRVbnRpbExvYWRlZCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlVGhyZWFkcyhvcHRpb25zKTtcbiAgYXNzZXJ0MighcmVzdWx0LmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICBhc3NlcnQyKCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VBdHRhY2htZW50VXJsKHN0YXRlKSB7XG4gIGlmIChzdGF0ZSA9PT0gdm9pZCAwIHx8IHN0YXRlPy5pc0xvYWRpbmcpIHtcbiAgICByZXR1cm4gc3RhdGUgPz8geyBpc0xvYWRpbmc6IHRydWUgfTtcbiAgfVxuICBpZiAoc3RhdGUuZXJyb3IpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgYXNzZXJ0MihzdGF0ZS5kYXRhICE9PSB2b2lkIDAsIFwiVW5leHBlY3RlZCBtaXNzaW5nIGF0dGFjaG1lbnQgVVJMXCIpO1xuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgdXJsOiBzdGF0ZS5kYXRhXG4gIH07XG59XG5mdW5jdGlvbiB1c2VBdHRhY2htZW50VXJsKGF0dGFjaG1lbnRJZCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gdXNlUm9vbUF0dGFjaG1lbnRVcmwoYXR0YWNobWVudElkLCByb29tLmlkKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21BdHRhY2htZW50VXJsKGF0dGFjaG1lbnRJZCwgcm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCBzdG9yZSA9IGNsaWVudFtrSW50ZXJuYWw0XS5odHRwQ2xpZW50LmdldE9yQ3JlYXRlQXR0YWNobWVudFVybHNTdG9yZShyb29tSWQpO1xuICBjb25zdCBnZXRBdHRhY2htZW50VXJsU3RhdGUgPSB1c2VDYWxsYmFjazMoXG4gICAgKCkgPT4gc3RvcmUuZ2V0SXRlbVN0YXRlKGF0dGFjaG1lbnRJZCksXG4gICAgW3N0b3JlLCBhdHRhY2htZW50SWRdXG4gICk7XG4gIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgIHZvaWQgc3RvcmUuZW5xdWV1ZShhdHRhY2htZW50SWQpO1xuICB9LCBbc3RvcmUsIGF0dGFjaG1lbnRJZF0pO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldEF0dGFjaG1lbnRVcmxTdGF0ZSxcbiAgICBnZXRBdHRhY2htZW50VXJsU3RhdGUsXG4gICAgc2VsZWN0b3JGb3JfdXNlQXR0YWNobWVudFVybCxcbiAgICBzaGFsbG93NFxuICApO1xufVxuZnVuY3Rpb24gdXNlQXR0YWNobWVudFVybFN1c3BlbnNlKGF0dGFjaG1lbnRJZCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IGF0dGFjaG1lbnRVcmxzU3RvcmUgfSA9IHJvb21ba0ludGVybmFsNF07XG4gIGNvbnN0IGdldEF0dGFjaG1lbnRVcmxTdGF0ZSA9IHVzZUNhbGxiYWNrMyhcbiAgICAoKSA9PiBhdHRhY2htZW50VXJsc1N0b3JlLmdldEl0ZW1TdGF0ZShhdHRhY2htZW50SWQpLFxuICAgIFthdHRhY2htZW50VXJsc1N0b3JlLCBhdHRhY2htZW50SWRdXG4gICk7XG4gIGNvbnN0IGF0dGFjaG1lbnRVcmxTdGF0ZSA9IGdldEF0dGFjaG1lbnRVcmxTdGF0ZSgpO1xuICBpZiAoIWF0dGFjaG1lbnRVcmxTdGF0ZSB8fCBhdHRhY2htZW50VXJsU3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgdGhyb3cgYXR0YWNobWVudFVybHNTdG9yZS5lbnF1ZXVlKGF0dGFjaG1lbnRJZCk7XG4gIH1cbiAgaWYgKGF0dGFjaG1lbnRVcmxTdGF0ZS5lcnJvcikge1xuICAgIHRocm93IGF0dGFjaG1lbnRVcmxTdGF0ZS5lcnJvcjtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhcbiAgICBhdHRhY2htZW50VXJsc1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRBdHRhY2htZW50VXJsU3RhdGUsXG4gICAgZ2V0QXR0YWNobWVudFVybFN0YXRlXG4gICk7XG4gIGFzc2VydDIoc3RhdGUgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3Npbmcgc3RhdGVcIik7XG4gIGFzc2VydDIoIXN0YXRlLmlzTG9hZGluZywgXCJVbmV4cGVjdGVkIGxvYWRpbmcgc3RhdGVcIik7XG4gIGFzc2VydDIoIXN0YXRlLmVycm9yLCBcIlVuZXhwZWN0ZWQgZXJyb3Igc3RhdGVcIik7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICB1cmw6IHN0YXRlLmRhdGEsXG4gICAgZXJyb3I6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gdXNlUm9vbVBlcm1pc3Npb25zKHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkuc3RvcmU7XG4gIHJldHVybiB1c2VTaWduYWwoc3RvcmUucGVybWlzc2lvbkhpbnRzLmdldFBlcm1pc3Npb25Gb3JSb29tXFx1MDNBMyhyb29tSWQpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb21Db250ZXh0KGNsaWVudCkge1xuICByZXR1cm4gZ2V0T3JDcmVhdGVSb29tQ29udGV4dEJ1bmRsZShjbGllbnQpO1xufVxudmFyIF9Sb29tUHJvdmlkZXIgPSBSb29tUHJvdmlkZXI7XG52YXIgX3VzZUJyb2FkY2FzdEV2ZW50ID0gdXNlQnJvYWRjYXN0RXZlbnQ7XG52YXIgX3VzZU90aGVyc0xpc3RlbmVyID0gdXNlT3RoZXJzTGlzdGVuZXI7XG52YXIgX3VzZVJvb20gPSB1c2VSb29tO1xudmFyIF91c2VJc0luc2lkZVJvb20gPSB1c2VJc0luc2lkZVJvb207XG52YXIgX3VzZUFkZFJlYWN0aW9uID0gdXNlQWRkUmVhY3Rpb247XG52YXIgX3VzZU11dGF0aW9uID0gdXNlTXV0YXRpb247XG52YXIgX3VzZUNyZWF0ZVRocmVhZCA9IHVzZUNyZWF0ZVRocmVhZDtcbnZhciBfdXNlRGVsZXRlVGhyZWFkID0gdXNlRGVsZXRlVGhyZWFkO1xudmFyIF91c2VFZGl0VGhyZWFkTWV0YWRhdGEgPSB1c2VFZGl0VGhyZWFkTWV0YWRhdGE7XG52YXIgX3VzZUV2ZW50TGlzdGVuZXIgPSB1c2VFdmVudExpc3RlbmVyO1xudmFyIF91c2VNeVByZXNlbmNlID0gdXNlTXlQcmVzZW5jZTtcbnZhciBfdXNlT3RoZXJzTWFwcGVkID0gdXNlT3RoZXJzTWFwcGVkO1xudmFyIF91c2VPdGhlcnNNYXBwZWRTdXNwZW5zZSA9IHVzZU90aGVyc01hcHBlZFN1c3BlbnNlO1xudmFyIF91c2VUaHJlYWRzID0gdXNlVGhyZWFkcztcbnZhciBfdXNlU2VhcmNoQ29tbWVudHMgPSB1c2VTZWFyY2hDb21tZW50cztcbnZhciBfdXNlVGhyZWFkc1N1c3BlbnNlID0gdXNlVGhyZWFkc1N1c3BlbnNlO1xudmFyIF91c2VSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3MgPSB1c2VSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3M7XG52YXIgX3VzZVJvb21TdWJzY3JpcHRpb25TZXR0aW5nc1N1c3BlbnNlID0gdXNlUm9vbVN1YnNjcmlwdGlvblNldHRpbmdzU3VzcGVuc2U7XG52YXIgX3VzZUhpc3RvcnlWZXJzaW9ucyA9IHVzZUhpc3RvcnlWZXJzaW9ucztcbnZhciBfdXNlSGlzdG9yeVZlcnNpb25zU3VzcGVuc2UgPSB1c2VIaXN0b3J5VmVyc2lvbnNTdXNwZW5zZTtcbnZhciBfdXNlT3RoZXIgPSB1c2VPdGhlcjtcbmZ1bmN0aW9uIF91c2VPdGhlcnMoLi4uYXJncykge1xuICByZXR1cm4gdXNlT3RoZXJzKC4uLmFyZ3MpO1xufVxudmFyIF91c2VPdGhlclN1c3BlbnNlID0gdXNlT3RoZXJTdXNwZW5zZTtcbmZ1bmN0aW9uIF91c2VPdGhlcnNTdXNwZW5zZSguLi5hcmdzKSB7XG4gIHJldHVybiB1c2VPdGhlcnNTdXNwZW5zZSguLi5hcmdzKTtcbn1cbnZhciBfdXNlU3RvcmFnZSA9IHVzZVN0b3JhZ2U7XG52YXIgX3VzZVN0b3JhZ2VTdXNwZW5zZSA9IHVzZVN0b3JhZ2VTdXNwZW5zZTtcbmZ1bmN0aW9uIF91c2VTZWxmKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHVzZVNlbGYoLi4uYXJncyk7XG59XG5mdW5jdGlvbiBfdXNlU2VsZlN1c3BlbnNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHVzZVNlbGZTdXNwZW5zZSguLi5hcmdzKTtcbn1cbnZhciBfdXNlU3RvcmFnZVJvb3QgPSB1c2VTdG9yYWdlUm9vdDtcbnZhciBfdXNlVXBkYXRlTXlQcmVzZW5jZSA9IHVzZVVwZGF0ZU15UHJlc2VuY2U7XG5cbmV4cG9ydCB7XG4gIENsaWVudENvbnRleHQsXG4gIHVzZUNsaWVudE9yTnVsbCxcbiAgdXNlQ2xpZW50LFxuICBSb29tQ29udGV4dCxcbiAgdXNlTGF0ZXN0LFxuICBSZWdpc3RlckFpS25vd2xlZGdlLFxuICBSZWdpc3RlckFpVG9vbCxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IsXG4gIHVzZVNpZ25hbCxcbiAgZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudCxcbiAgdXNlQ3JlYXRlQWlDaGF0LFxuICB1c2VEZWxldGVBaUNoYXQsXG4gIHVzZUFpQ2hhdFN0YXR1cyxcbiAgdXNlU2VuZEFpTWVzc2FnZSxcbiAgTGl2ZWJsb2Nrc1Byb3ZpZGVyLFxuICBjcmVhdGVMaXZlYmxvY2tzQ29udGV4dCxcbiAgdXNlSW5ib3hOb3RpZmljYXRpb25zLFxuICB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZSxcbiAgdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkLFxuICB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMsXG4gIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uLFxuICB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZSxcbiAgdXNlTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIHVzZU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UsXG4gIHVzZVVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICB1c2VSb29tSW5mbyxcbiAgdXNlUm9vbUluZm9TdXNwZW5zZSxcbiAgdXNlR3JvdXBJbmZvLFxuICB1c2VHcm91cEluZm9TdXNwZW5zZSxcbiAgX3VzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkLFxuICBfdXNlVXNlcixcbiAgX3VzZVVzZXJTdXNwZW5zZSxcbiAgX3VzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCxcbiAgX3VzZVVzZXJUaHJlYWRzU3VzcGVuc2VfZXhwZXJpbWVudGFsLFxuICBfdXNlQWlDaGF0cyxcbiAgX3VzZUFpQ2hhdHNTdXNwZW5zZSxcbiAgX3VzZUFpQ2hhdCxcbiAgX3VzZUFpQ2hhdFN1c3BlbnNlLFxuICBfdXNlQWlDaGF0TWVzc2FnZXMsXG4gIF91c2VBaUNoYXRNZXNzYWdlc1N1c3BlbnNlLFxuICBfdXNlVXJsTWV0YWRhdGEsXG4gIF91c2VVcmxNZXRhZGF0YVN1c3BlbnNlLFxuICB1c2VTeW5jU3RhdHVzLFxuICB1c2VFcnJvckxpc3RlbmVyLFxuICB1c2VTdGF0dXMsXG4gIHVzZVJlcG9ydFRleHRFZGl0b3IsXG4gIHVzZVlqc1Byb3ZpZGVyLFxuICB1c2VDcmVhdGVUZXh0TWVudGlvbixcbiAgdXNlRGVsZXRlVGV4dE1lbnRpb24sXG4gIHVzZVJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMsXG4gIHVzZU1lbnRpb25TdWdnZXN0aW9uc0NhY2hlLFxuICB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyLFxuICB1c2VIaXN0b3J5LFxuICB1c2VVbmRvLFxuICB1c2VSZWRvLFxuICB1c2VDYW5VbmRvLFxuICB1c2VDYW5SZWRvLFxuICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzLFxuICB1c2VDcmVhdGVSb29tVGhyZWFkLFxuICB1c2VEZWxldGVSb29tVGhyZWFkLFxuICB1c2VFZGl0Um9vbVRocmVhZE1ldGFkYXRhLFxuICB1c2VDcmVhdGVDb21tZW50LFxuICB1c2VDcmVhdGVSb29tQ29tbWVudCxcbiAgdXNlRWRpdENvbW1lbnQsXG4gIHVzZUVkaXRSb29tQ29tbWVudCxcbiAgdXNlRGVsZXRlQ29tbWVudCxcbiAgdXNlRGVsZXRlUm9vbUNvbW1lbnQsXG4gIHVzZUFkZFJvb21Db21tZW50UmVhY3Rpb24sXG4gIHVzZVJlbW92ZVJlYWN0aW9uLFxuICB1c2VSZW1vdmVSb29tQ29tbWVudFJlYWN0aW9uLFxuICB1c2VNYXJrVGhyZWFkQXNSZWFkLFxuICB1c2VNYXJrUm9vbVRocmVhZEFzUmVhZCxcbiAgdXNlTWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gIHVzZU1hcmtSb29tVGhyZWFkQXNSZXNvbHZlZCxcbiAgdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgdXNlTWFya1Jvb21UaHJlYWRBc1VucmVzb2x2ZWQsXG4gIHVzZVN1YnNjcmliZVRvVGhyZWFkLFxuICB1c2VVbnN1YnNjcmliZUZyb21UaHJlYWQsXG4gIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgdXNlUm9vbVRocmVhZFN1YnNjcmlwdGlvbixcbiAgdXNlSGlzdG9yeVZlcnNpb25EYXRhLFxuICB1c2VVcGRhdGVSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3MsXG4gIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHNTdXNwZW5zZSxcbiAgdXNlQXR0YWNobWVudFVybCxcbiAgdXNlUm9vbUF0dGFjaG1lbnRVcmwsXG4gIHVzZUF0dGFjaG1lbnRVcmxTdXNwZW5zZSxcbiAgdXNlUm9vbVBlcm1pc3Npb25zLFxuICBjcmVhdGVSb29tQ29udGV4dCxcbiAgX1Jvb21Qcm92aWRlcixcbiAgX3VzZUJyb2FkY2FzdEV2ZW50LFxuICBfdXNlT3RoZXJzTGlzdGVuZXIsXG4gIF91c2VSb29tLFxuICBfdXNlSXNJbnNpZGVSb29tLFxuICBfdXNlQWRkUmVhY3Rpb24sXG4gIF91c2VNdXRhdGlvbixcbiAgX3VzZUNyZWF0ZVRocmVhZCxcbiAgX3VzZURlbGV0ZVRocmVhZCxcbiAgX3VzZUVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgX3VzZUV2ZW50TGlzdGVuZXIsXG4gIF91c2VNeVByZXNlbmNlLFxuICBfdXNlT3RoZXJzTWFwcGVkLFxuICBfdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UsXG4gIF91c2VUaHJlYWRzLFxuICBfdXNlU2VhcmNoQ29tbWVudHMsXG4gIF91c2VUaHJlYWRzU3VzcGVuc2UsXG4gIF91c2VSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3MsXG4gIF91c2VSb29tU3Vic2NyaXB0aW9uU2V0dGluZ3NTdXNwZW5zZSxcbiAgX3VzZUhpc3RvcnlWZXJzaW9ucyxcbiAgX3VzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlLFxuICBfdXNlT3RoZXIsXG4gIF91c2VPdGhlcnMsXG4gIF91c2VPdGhlclN1c3BlbnNlLFxuICBfdXNlT3RoZXJzU3VzcGVuc2UsXG4gIF91c2VTdG9yYWdlLFxuICBfdXNlU3RvcmFnZVN1c3BlbnNlLFxuICBfdXNlU2VsZixcbiAgX3VzZVNlbGZTdXNwZW5zZSxcbiAgX3VzZVN0b3JhZ2VSb290LFxuICBfdXNlVXBkYXRlTXlQcmVzZW5jZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUpPWjRCUVdILmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/chunk-JOZ4BQWH.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/yjs/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@liveblocks/yjs/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiveblocksYjsProvider: () => (/* binding */ LiveblocksYjsProvider),\n/* harmony export */   getYjsProviderForRoom: () => (/* binding */ getYjsProviderForRoom)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! js-base64 */ \"(ssr)/./node_modules/js-base64/base64.mjs\");\n/* harmony import */ var y_indexeddb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! y-indexeddb */ \"(ssr)/./node_modules/y-indexeddb/src/y-indexeddb.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha2.js\");\n// src/index.ts\n\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/yjs\";\nvar PKG_VERSION = \"3.11.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/provider.ts\n\n\n\n\n// ../../node_modules/lib0/map.js\nvar create = () => /* @__PURE__ */ new Map();\nvar setIfUndefined = (map, key, createT) => {\n  let set = map.get(key);\n  if (set === void 0) {\n    map.set(key, set = createT());\n  }\n  return set;\n};\n\n// ../../node_modules/lib0/set.js\nvar create2 = () => /* @__PURE__ */ new Set();\n\n// ../../node_modules/lib0/array.js\nvar from = Array.from;\nvar isArray = Array.isArray;\n\n// ../../node_modules/lib0/observable.js\nvar Observable = class {\n  constructor() {\n    this._observers = create();\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on(name, f) {\n    setIfUndefined(this._observers, name, create2).add(f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once(name, f) {\n    const _f = (...args) => {\n      this.off(name, _f);\n      f(...args);\n    };\n    this.on(name, _f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off(name, f) {\n    const observers = this._observers.get(name);\n    if (observers !== void 0) {\n      observers.delete(f);\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit(name, args) {\n    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args));\n  }\n  destroy() {\n    this._observers = create();\n  }\n};\n\n// src/provider.ts\n\n\n\n// src/awareness.ts\nvar Y_PRESENCE_KEY = \"__yjs\";\nvar Y_PRESENCE_ID_KEY = \"__yjs_clientid\";\nvar Awareness = class extends Observable {\n  room;\n  doc;\n  states = /* @__PURE__ */ new Map();\n  // used to map liveblock's ActorId to Yjs ClientID, both unique numbers representing a client\n  actorToClientMap = /* @__PURE__ */ new Map();\n  // Meta is used to keep track and timeout users who disconnect. Liveblocks provides this for us, so we don't need to\n  // manage it here. Unfortunately, it's expected to exist by various integrations, so it's an empty map.\n  meta = /* @__PURE__ */ new Map();\n  // _checkInterval this would hold a timer to remove users, but Liveblock's presence already handles this\n  // unfortunately it's typed by various integrations\n  _checkInterval = 0;\n  othersUnsub;\n  constructor(doc, room) {\n    super();\n    this.doc = doc;\n    this.room = room;\n    this.room.updatePresence({\n      [Y_PRESENCE_ID_KEY]: this.doc.clientID\n    });\n    this.othersUnsub = this.room.events.others.subscribe((event) => {\n      let updates;\n      if (event.type === \"leave\") {\n        const targetClientId = this.actorToClientMap.get(\n          event.user.connectionId\n        );\n        if (targetClientId !== void 0) {\n          updates = { added: [], updated: [], removed: [targetClientId] };\n        }\n        this.rebuildActorToClientMap(event.others);\n      }\n      if (event.type === \"enter\" || event.type === \"update\") {\n        this.rebuildActorToClientMap(event.others);\n        const targetClientId = this.actorToClientMap.get(\n          event.user.connectionId\n        );\n        if (targetClientId !== void 0) {\n          updates = {\n            added: event.type === \"enter\" ? [targetClientId] : [],\n            updated: event.type === \"update\" ? [targetClientId] : [],\n            removed: []\n          };\n        }\n      }\n      if (event.type === \"reset\") {\n        this.rebuildActorToClientMap(event.others);\n      }\n      if (updates !== void 0) {\n        this.emit(\"change\", [updates, \"presence\"]);\n        this.emit(\"update\", [updates, \"presence\"]);\n      }\n    });\n  }\n  rebuildActorToClientMap(others) {\n    this.actorToClientMap.clear();\n    others.forEach((user) => {\n      if (user.presence[Y_PRESENCE_ID_KEY] !== void 0) {\n        this.actorToClientMap.set(\n          user.connectionId,\n          user.presence[Y_PRESENCE_ID_KEY]\n        );\n      }\n    });\n  }\n  destroy() {\n    this.emit(\"destroy\", [this]);\n    this.othersUnsub();\n    this.setLocalState(null);\n    super.destroy();\n  }\n  getLocalState() {\n    const presence = this.room.getPresence();\n    if (Object.keys(presence).length === 0 || typeof presence[Y_PRESENCE_KEY] === \"undefined\") {\n      return null;\n    }\n    return presence[Y_PRESENCE_KEY];\n  }\n  setLocalState(state) {\n    const presence = this.room.getSelf()?.presence;\n    if (state === null) {\n      if (presence === void 0) {\n        return;\n      }\n      this.room.updatePresence({ ...presence, [Y_PRESENCE_KEY]: null });\n      this.emit(\"update\", [\n        { added: [], updated: [], removed: [this.doc.clientID] },\n        \"local\"\n      ]);\n      return;\n    }\n    const yPresence = presence?.[Y_PRESENCE_KEY];\n    const added = yPresence === void 0 ? [this.doc.clientID] : [];\n    const updated = yPresence === void 0 ? [] : [this.doc.clientID];\n    this.room.updatePresence({\n      [Y_PRESENCE_KEY]: {\n        ...yPresence || {},\n        ...state || {}\n      }\n    });\n    this.emit(\"update\", [{ added, updated, removed: [] }, \"local\"]);\n  }\n  setLocalStateField(field, value) {\n    const presence = this.room.getSelf()?.presence[Y_PRESENCE_KEY];\n    const update = { [field]: value };\n    this.room.updatePresence({\n      [Y_PRESENCE_KEY]: { ...presence || {}, ...update }\n    });\n  }\n  // Translate liveblocks presence to yjs awareness\n  getStates() {\n    const others = this.room.getOthers();\n    const states = others.reduce((acc, otherUser) => {\n      const otherPresence = otherUser.presence[Y_PRESENCE_KEY];\n      const otherClientId = otherUser.presence[Y_PRESENCE_ID_KEY];\n      if (otherPresence !== void 0 && otherClientId !== void 0) {\n        acc.set(otherClientId, otherPresence || {});\n      }\n      return acc;\n    }, /* @__PURE__ */ new Map());\n    const localPresence = this.room.getSelf()?.presence[Y_PRESENCE_KEY];\n    if (localPresence !== void 0) {\n      states.set(this.doc.clientID, localPresence);\n    }\n    return states;\n  }\n};\n\n// src/doc.ts\n\n\n\n\n\nvar yDocHandler = class _yDocHandler extends Observable {\n  unsubscribers = [];\n  _synced = false;\n  doc;\n  updateRoomDoc;\n  fetchRoomDoc;\n  useV2Encoding;\n  localSnapshotHash\\u03A3;\n  remoteSnapshotHash\\u03A3;\n  debounceTimer = null;\n  static DEBOUNCE_INTERVAL_MS = 200;\n  isLocalAndRemoteSnapshotEqual\\u03A3;\n  constructor({\n    doc,\n    isRoot,\n    updateDoc,\n    fetchDoc,\n    useV2Encoding\n  }) {\n    super();\n    this.doc = doc;\n    this.useV2Encoding = useV2Encoding;\n    this.doc.on(useV2Encoding ? \"updateV2\" : \"update\", this.updateHandler);\n    this.updateRoomDoc = (update) => {\n      updateDoc(update, isRoot ? void 0 : this.doc.guid);\n    };\n    this.fetchRoomDoc = (vector) => {\n      fetchDoc(vector, isRoot ? void 0 : this.doc.guid);\n    };\n    this.syncDoc();\n    const encodedSnapshot = this.useV2Encoding ? yjs__WEBPACK_IMPORTED_MODULE_0__.encodeSnapshotV2(yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(this.doc)) : yjs__WEBPACK_IMPORTED_MODULE_0__.encodeSnapshot(yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(this.doc));\n    this.localSnapshotHash\\u03A3 = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal(\n      js_base64__WEBPACK_IMPORTED_MODULE_2__.Base64.fromUint8Array((0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_3__.sha256)(encodedSnapshot))\n    );\n    this.remoteSnapshotHash\\u03A3 = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal(null);\n    this.isLocalAndRemoteSnapshotEqual\\u03A3 = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n      const remoteSnapshotHash = this.remoteSnapshotHash\\u03A3.get();\n      if (remoteSnapshotHash === null) return false;\n      const localSnapshotHash = this.localSnapshotHash\\u03A3.get();\n      if (localSnapshotHash !== remoteSnapshotHash) {\n        return false;\n      }\n      return true;\n    });\n  }\n  handleServerUpdate = ({\n    update,\n    stateVector,\n    readOnly,\n    v2,\n    remoteSnapshotHash\n  }) => {\n    const applyUpdate2 = v2 ? yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdateV2 : yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdate;\n    applyUpdate2(this.doc, update, \"backend\");\n    if (stateVector) {\n      if (!readOnly) {\n        try {\n          const encodeUpdate = this.useV2Encoding ? yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateAsUpdateV2 : yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateAsUpdate;\n          const localUpdate = encodeUpdate(\n            this.doc,\n            js_base64__WEBPACK_IMPORTED_MODULE_2__.Base64.toUint8Array(stateVector)\n          );\n          this.updateRoomDoc(localUpdate);\n        } catch (e) {\n          console.warn(e);\n        }\n      }\n      this.synced = true;\n    }\n    this.remoteSnapshotHash\\u03A3.set(remoteSnapshotHash);\n  };\n  syncDoc = () => {\n    this.synced = false;\n    const encodedVector = js_base64__WEBPACK_IMPORTED_MODULE_2__.Base64.fromUint8Array(yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateVector(this.doc));\n    this.fetchRoomDoc(encodedVector);\n  };\n  // The sync'd property is required by some provider implementations\n  get synced() {\n    return this._synced;\n  }\n  set synced(state) {\n    if (this._synced !== state) {\n      this._synced = state;\n      this.emit(\"synced\", [state]);\n      this.emit(\"sync\", [state]);\n    }\n  }\n  debounced_updateLocalSnapshot() {\n    if (this.debounceTimer) clearTimeout(this.debounceTimer);\n    this.debounceTimer = setTimeout(() => {\n      const encodedSnapshot = this.useV2Encoding ? yjs__WEBPACK_IMPORTED_MODULE_0__.encodeSnapshotV2(yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(this.doc)) : yjs__WEBPACK_IMPORTED_MODULE_0__.encodeSnapshot(yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(this.doc));\n      this.localSnapshotHash\\u03A3.set(\n        js_base64__WEBPACK_IMPORTED_MODULE_2__.Base64.fromUint8Array((0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_3__.sha256)(encodedSnapshot))\n      );\n      this.debounceTimer = null;\n    }, _yDocHandler.DEBOUNCE_INTERVAL_MS);\n  }\n  updateHandler = (update, origin) => {\n    this.debounced_updateLocalSnapshot();\n    const isFromLocal = origin instanceof y_indexeddb__WEBPACK_IMPORTED_MODULE_4__.IndexeddbPersistence;\n    if (origin !== \"backend\" && !isFromLocal) {\n      this.updateRoomDoc(update);\n    }\n  };\n  experimental_getSyncStatus() {\n    const remoteSnapshotHash = this.remoteSnapshotHash\\u03A3.get();\n    if (remoteSnapshotHash === null) {\n      return \"loading\";\n    }\n    if (!this.isLocalAndRemoteSnapshotEqual\\u03A3.get()) {\n      return \"synchronizing\";\n    }\n    return \"synchronized\";\n  }\n  destroy() {\n    if (this.debounceTimer) clearTimeout(this.debounceTimer);\n    this.doc.off(\"update\", this.updateHandler);\n    this.unsubscribers.forEach((unsub) => unsub());\n    this._observers = /* @__PURE__ */ new Map();\n    this.doc.destroy();\n  }\n};\n\n// src/provider.ts\nvar LiveblocksYjsProvider = class extends Observable {\n  room;\n  rootDoc;\n  options;\n  indexeddbProvider = null;\n  isPaused = false;\n  unsubscribers = [];\n  awareness;\n  rootDocHandler;\n  subdocHandlers\\u03A3 = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(/* @__PURE__ */ new Map());\n  syncStatus\\u03A3;\n  permanentUserData;\n  constructor(room, doc, options = {}) {\n    super();\n    this.rootDoc = doc;\n    this.room = room;\n    this.options = options;\n    this.rootDocHandler = new yDocHandler({\n      doc,\n      isRoot: true,\n      updateDoc: this.updateDoc,\n      fetchDoc: this.fetchDoc,\n      useV2Encoding: this.options.useV2Encoding_experimental ?? false\n    });\n    if (this.options.enablePermanentUserData) {\n      this.permanentUserData = new yjs__WEBPACK_IMPORTED_MODULE_0__.PermanentUserData(doc);\n    }\n    room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].setYjsProvider(this);\n    this.awareness = new Awareness(this.rootDoc, this.room);\n    this.unsubscribers.push(\n      this.room.events.status.subscribe((status) => {\n        if (status === \"connected\") {\n          this.rootDocHandler.syncDoc();\n        } else {\n          this.rootDocHandler.synced = false;\n        }\n      })\n    );\n    this.unsubscribers.push(\n      this.room.events.ydoc.subscribe((message) => {\n        const { type } = message;\n        if (type === _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ClientMsgCode.UPDATE_YDOC) {\n          return;\n        }\n        const {\n          stateVector,\n          update: updateStr,\n          guid,\n          v2,\n          remoteSnapshotHash\n        } = message;\n        const canWrite = this.room.getSelf()?.canWrite ?? true;\n        const update = js_base64__WEBPACK_IMPORTED_MODULE_2__.Base64.toUint8Array(updateStr);\n        if (guid !== void 0) {\n          this.subdocHandlers\\u03A3.get().get(guid)?.handleServerUpdate({\n            update,\n            stateVector,\n            readOnly: !canWrite,\n            v2,\n            remoteSnapshotHash\n          });\n        } else {\n          this.rootDocHandler.handleServerUpdate({\n            update,\n            stateVector,\n            readOnly: !canWrite,\n            v2,\n            remoteSnapshotHash\n          });\n        }\n      })\n    );\n    if (options.offlineSupport_experimental) {\n      this.setupOfflineSupport();\n    }\n    this.rootDocHandler.on(\"synced\", () => {\n      const state = this.rootDocHandler.synced;\n      for (const [_, handler] of this.subdocHandlers\\u03A3.get()) {\n        handler.syncDoc();\n      }\n      this.emit(\"synced\", [state]);\n      this.emit(\"sync\", [state]);\n    });\n    this.rootDoc.on(\"subdocs\", this.handleSubdocs);\n    this.syncDoc();\n    this.syncStatus\\u03A3 = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n      const rootDocumentStatus = this.rootDocHandler.experimental_getSyncStatus();\n      if (rootDocumentStatus === \"loading\" || rootDocumentStatus === \"synchronizing\") {\n        return rootDocumentStatus;\n      }\n      const subdocumentStatuses = Array.from(\n        this.subdocHandlers\\u03A3.get().values()\n      ).map((handler) => handler.experimental_getSyncStatus());\n      if (subdocumentStatuses.some((state) => state !== \"synchronized\")) {\n        return \"synchronizing\";\n      }\n      return \"synchronized\";\n    });\n    this.emit(\"status\", [this.getStatus()]);\n    this.unsubscribers.push(\n      this.syncStatus\\u03A3.subscribe(() => {\n        this.emit(\"status\", [this.getStatus()]);\n      })\n    );\n  }\n  setupOfflineSupport = () => {\n    this.indexeddbProvider = new y_indexeddb__WEBPACK_IMPORTED_MODULE_4__.IndexeddbPersistence(\n      this.room.id,\n      this.rootDoc\n    );\n    const onIndexedDbSync = () => {\n      this.rootDocHandler.synced = true;\n    };\n    this.indexeddbProvider.on(\"synced\", onIndexedDbSync);\n    this.unsubscribers.push(() => {\n      this.indexeddbProvider?.off(\"synced\", onIndexedDbSync);\n    });\n  };\n  handleSubdocs = ({\n    loaded,\n    removed,\n    added\n  }) => {\n    loaded.forEach(this.createSubdocHandler);\n    const subdocHandlers = this.subdocHandlers\\u03A3.get();\n    if (this.options.autoloadSubdocs) {\n      for (const subdoc of added) {\n        if (!subdocHandlers.has(subdoc.guid)) {\n          subdoc.load();\n        }\n      }\n    }\n    for (const subdoc of removed) {\n      if (subdocHandlers.has(subdoc.guid)) {\n        subdocHandlers.get(subdoc.guid)?.destroy();\n        subdocHandlers.delete(subdoc.guid);\n      }\n    }\n  };\n  updateDoc = (update, guid) => {\n    const canWrite = this.room.getSelf()?.canWrite ?? true;\n    if (canWrite && !this.isPaused) {\n      this.room.updateYDoc(\n        js_base64__WEBPACK_IMPORTED_MODULE_2__.Base64.fromUint8Array(update),\n        guid,\n        this.useV2Encoding\n      );\n    }\n  };\n  fetchDoc = (vector, guid) => {\n    this.room.fetchYDoc(vector, guid, this.useV2Encoding);\n  };\n  createSubdocHandler = (subdoc) => {\n    const subdocHandlers = this.subdocHandlers\\u03A3.get();\n    if (subdocHandlers.has(subdoc.guid)) {\n      subdocHandlers.get(subdoc.guid)?.syncDoc();\n      return;\n    }\n    const handler = new yDocHandler({\n      doc: subdoc,\n      isRoot: false,\n      updateDoc: this.updateDoc,\n      fetchDoc: this.fetchDoc,\n      useV2Encoding: this.options.useV2Encoding_experimental ?? false\n    });\n    subdocHandlers.set(subdoc.guid, handler);\n  };\n  // attempt to load a subdoc of a given guid\n  loadSubdoc = (guid) => {\n    for (const subdoc of this.rootDoc.subdocs) {\n      if (subdoc.guid === guid) {\n        subdoc.load();\n        return true;\n      }\n    }\n    return false;\n  };\n  syncDoc = () => {\n    this.rootDocHandler.syncDoc();\n    for (const [_, handler] of this.subdocHandlers\\u03A3.get()) {\n      handler.syncDoc();\n    }\n  };\n  get useV2Encoding() {\n    return this.options.useV2Encoding_experimental ?? false;\n  }\n  // The sync'd property is required by some provider implementations\n  get synced() {\n    return this.rootDocHandler.synced;\n  }\n  async pause() {\n    await this.indexeddbProvider?.destroy();\n    this.indexeddbProvider = null;\n    this.isPaused = true;\n  }\n  unpause() {\n    this.isPaused = false;\n    if (this.options.offlineSupport_experimental) {\n      this.setupOfflineSupport();\n    }\n    this.rootDocHandler.syncDoc();\n  }\n  getStatus() {\n    return this.syncStatus\\u03A3.get();\n  }\n  destroy() {\n    this.unsubscribers.forEach((unsub) => unsub());\n    this.awareness.destroy();\n    this.rootDocHandler.destroy();\n    this._observers = /* @__PURE__ */ new Map();\n    for (const [_, handler] of this.subdocHandlers\\u03A3.get()) {\n      handler.destroy();\n    }\n    this.subdocHandlers\\u03A3.get().clear();\n    super.destroy();\n  }\n  async clearOfflineData() {\n    if (!this.indexeddbProvider) return;\n    return this.indexeddbProvider.clearData();\n  }\n  getYDoc() {\n    return this.rootDoc;\n  }\n  // Some provider implementations expect to be able to call connect/disconnect, implement as noop\n  disconnect() {\n  }\n  connect() {\n  }\n  get subdocHandlers() {\n    return this.subdocHandlers\\u03A3.get();\n  }\n  set subdocHandlers(value) {\n    this.subdocHandlers\\u03A3.mutate((map) => {\n      map.clear();\n      for (const [key, handler] of value) {\n        map.set(key, handler);\n      }\n    });\n  }\n};\n\n// src/providerContext.ts\n\nvar providersMap = /* @__PURE__ */ new WeakMap();\nvar getYjsProviderForRoom = (room, options = {}, forceNewProvider = false) => {\n  const provider = providersMap.get(room);\n  if (provider !== void 0) {\n    if (!forceNewProvider) {\n      return provider;\n    }\n    provider.destroy();\n    providersMap.delete(room);\n  }\n  const doc = new yjs__WEBPACK_IMPORTED_MODULE_0__.Doc();\n  const newProvider = new LiveblocksYjsProvider(room, doc, options);\n  room.events.roomWillDestroy.subscribeOnce(() => {\n    newProvider.destroy();\n  });\n  providersMap.set(room, newProvider);\n  return newProvider;\n};\n\n// src/index.ts\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MveWpzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQytDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUcwQjtBQUNpRDtBQUM3Qjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM0RTtBQUNwQzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQzBCO0FBQzFCO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0NBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUFXO0FBSVQ7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2FyeWFuZ295YWwvcmVhbC10aW1lLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy95anMvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IGRldGVjdER1cGVzIH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcblxuLy8gc3JjL3ZlcnNpb24udHNcbnZhciBQS0dfTkFNRSA9IFwiQGxpdmVibG9ja3MveWpzXCI7XG52YXIgUEtHX1ZFUlNJT04gPSBcIjMuMTEuMFwiO1xudmFyIFBLR19GT1JNQVQgPSBcImVzbVwiO1xuXG4vLyBzcmMvcHJvdmlkZXIudHNcbmltcG9ydCB7XG4gIERlcml2ZWRTaWduYWwgYXMgRGVyaXZlZFNpZ25hbDJcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7IENsaWVudE1zZ0NvZGUsIGtJbnRlcm5hbCwgTXV0YWJsZVNpZ25hbCB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgeyBCYXNlNjQgYXMgQmFzZTY0MiB9IGZyb20gXCJqcy1iYXNlNjRcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2xpYjAvbWFwLmpzXG52YXIgY3JlYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBzZXRJZlVuZGVmaW5lZCA9IChtYXAsIGtleSwgY3JlYXRlVCkgPT4ge1xuICBsZXQgc2V0ID0gbWFwLmdldChrZXkpO1xuICBpZiAoc2V0ID09PSB2b2lkIDApIHtcbiAgICBtYXAuc2V0KGtleSwgc2V0ID0gY3JlYXRlVCgpKTtcbiAgfVxuICByZXR1cm4gc2V0O1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2xpYjAvc2V0LmpzXG52YXIgY3JlYXRlMiA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9saWIwL2FycmF5LmpzXG52YXIgZnJvbSA9IEFycmF5LmZyb207XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9saWIwL29ic2VydmFibGUuanNcbnZhciBPYnNlcnZhYmxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBjcmVhdGUoKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtOfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9uKG5hbWUsIGYpIHtcbiAgICBzZXRJZlVuZGVmaW5lZCh0aGlzLl9vYnNlcnZlcnMsIG5hbWUsIGNyZWF0ZTIpLmFkZChmKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtOfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9uY2UobmFtZSwgZikge1xuICAgIGNvbnN0IF9mID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRoaXMub2ZmKG5hbWUsIF9mKTtcbiAgICAgIGYoLi4uYXJncyk7XG4gICAgfTtcbiAgICB0aGlzLm9uKG5hbWUsIF9mKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtOfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9mZihuYW1lLCBmKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXJzID0gdGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKTtcbiAgICBpZiAob2JzZXJ2ZXJzICE9PSB2b2lkIDApIHtcbiAgICAgIG9ic2VydmVycy5kZWxldGUoZik7XG4gICAgICBpZiAob2JzZXJ2ZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmRlbGV0ZShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVtaXQgYSBuYW1lZCBldmVudC4gQWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIHRoYXQgbGlzdGVuIHRvIHRoZVxuICAgKiBzcGVjaWZpZWQgbmFtZSB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBAdG9kbyBUaGlzIHNob3VsZCBjYXRjaCBleGNlcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzIFRoZSBhcmd1bWVudHMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBlbWl0KG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gZnJvbSgodGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKSB8fCBjcmVhdGUoKSkudmFsdWVzKCkpLmZvckVhY2goKGYpID0+IGYoLi4uYXJncykpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gY3JlYXRlKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci50c1xuaW1wb3J0IHsgSW5kZXhlZGRiUGVyc2lzdGVuY2UgYXMgSW5kZXhlZGRiUGVyc2lzdGVuY2UyIH0gZnJvbSBcInktaW5kZXhlZGRiXCI7XG5pbXBvcnQgeyBQZXJtYW5lbnRVc2VyRGF0YSB9IGZyb20gXCJ5anNcIjtcblxuLy8gc3JjL2F3YXJlbmVzcy50c1xudmFyIFlfUFJFU0VOQ0VfS0VZID0gXCJfX3lqc1wiO1xudmFyIFlfUFJFU0VOQ0VfSURfS0VZID0gXCJfX3lqc19jbGllbnRpZFwiO1xudmFyIEF3YXJlbmVzcyA9IGNsYXNzIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIHJvb207XG4gIGRvYztcbiAgc3RhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLy8gdXNlZCB0byBtYXAgbGl2ZWJsb2NrJ3MgQWN0b3JJZCB0byBZanMgQ2xpZW50SUQsIGJvdGggdW5pcXVlIG51bWJlcnMgcmVwcmVzZW50aW5nIGEgY2xpZW50XG4gIGFjdG9yVG9DbGllbnRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvLyBNZXRhIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBhbmQgdGltZW91dCB1c2VycyB3aG8gZGlzY29ubmVjdC4gTGl2ZWJsb2NrcyBwcm92aWRlcyB0aGlzIGZvciB1cywgc28gd2UgZG9uJ3QgbmVlZCB0b1xuICAvLyBtYW5hZ2UgaXQgaGVyZS4gVW5mb3J0dW5hdGVseSwgaXQncyBleHBlY3RlZCB0byBleGlzdCBieSB2YXJpb3VzIGludGVncmF0aW9ucywgc28gaXQncyBhbiBlbXB0eSBtYXAuXG4gIG1ldGEgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvLyBfY2hlY2tJbnRlcnZhbCB0aGlzIHdvdWxkIGhvbGQgYSB0aW1lciB0byByZW1vdmUgdXNlcnMsIGJ1dCBMaXZlYmxvY2sncyBwcmVzZW5jZSBhbHJlYWR5IGhhbmRsZXMgdGhpc1xuICAvLyB1bmZvcnR1bmF0ZWx5IGl0J3MgdHlwZWQgYnkgdmFyaW91cyBpbnRlZ3JhdGlvbnNcbiAgX2NoZWNrSW50ZXJ2YWwgPSAwO1xuICBvdGhlcnNVbnN1YjtcbiAgY29uc3RydWN0b3IoZG9jLCByb29tKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLnJvb20gPSByb29tO1xuICAgIHRoaXMucm9vbS51cGRhdGVQcmVzZW5jZSh7XG4gICAgICBbWV9QUkVTRU5DRV9JRF9LRVldOiB0aGlzLmRvYy5jbGllbnRJRFxuICAgIH0pO1xuICAgIHRoaXMub3RoZXJzVW5zdWIgPSB0aGlzLnJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICBsZXQgdXBkYXRlcztcbiAgICAgIGlmIChldmVudC50eXBlID09PSBcImxlYXZlXCIpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2xpZW50SWQgPSB0aGlzLmFjdG9yVG9DbGllbnRNYXAuZ2V0KFxuICAgICAgICAgIGV2ZW50LnVzZXIuY29ubmVjdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0YXJnZXRDbGllbnRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IHsgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZDogW3RhcmdldENsaWVudElkXSB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVidWlsZEFjdG9yVG9DbGllbnRNYXAoZXZlbnQub3RoZXJzKTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC50eXBlID09PSBcImVudGVyXCIgfHwgZXZlbnQudHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICB0aGlzLnJlYnVpbGRBY3RvclRvQ2xpZW50TWFwKGV2ZW50Lm90aGVycyk7XG4gICAgICAgIGNvbnN0IHRhcmdldENsaWVudElkID0gdGhpcy5hY3RvclRvQ2xpZW50TWFwLmdldChcbiAgICAgICAgICBldmVudC51c2VyLmNvbm5lY3Rpb25JZFxuICAgICAgICApO1xuICAgICAgICBpZiAodGFyZ2V0Q2xpZW50SWQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHVwZGF0ZXMgPSB7XG4gICAgICAgICAgICBhZGRlZDogZXZlbnQudHlwZSA9PT0gXCJlbnRlclwiID8gW3RhcmdldENsaWVudElkXSA6IFtdLFxuICAgICAgICAgICAgdXBkYXRlZDogZXZlbnQudHlwZSA9PT0gXCJ1cGRhdGVcIiA/IFt0YXJnZXRDbGllbnRJZF0gOiBbXSxcbiAgICAgICAgICAgIHJlbW92ZWQ6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwicmVzZXRcIikge1xuICAgICAgICB0aGlzLnJlYnVpbGRBY3RvclRvQ2xpZW50TWFwKGV2ZW50Lm90aGVycyk7XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCBbdXBkYXRlcywgXCJwcmVzZW5jZVwiXSk7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBbdXBkYXRlcywgXCJwcmVzZW5jZVwiXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVidWlsZEFjdG9yVG9DbGllbnRNYXAob3RoZXJzKSB7XG4gICAgdGhpcy5hY3RvclRvQ2xpZW50TWFwLmNsZWFyKCk7XG4gICAgb3RoZXJzLmZvckVhY2goKHVzZXIpID0+IHtcbiAgICAgIGlmICh1c2VyLnByZXNlbmNlW1lfUFJFU0VOQ0VfSURfS0VZXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuYWN0b3JUb0NsaWVudE1hcC5zZXQoXG4gICAgICAgICAgdXNlci5jb25uZWN0aW9uSWQsXG4gICAgICAgICAgdXNlci5wcmVzZW5jZVtZX1BSRVNFTkNFX0lEX0tFWV1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIiwgW3RoaXNdKTtcbiAgICB0aGlzLm90aGVyc1Vuc3ViKCk7XG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKG51bGwpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXRMb2NhbFN0YXRlKCkge1xuICAgIGNvbnN0IHByZXNlbmNlID0gdGhpcy5yb29tLmdldFByZXNlbmNlKCk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByZXNlbmNlKS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHByZXNlbmNlW1lfUFJFU0VOQ0VfS0VZXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV07XG4gIH1cbiAgc2V0TG9jYWxTdGF0ZShzdGF0ZSkge1xuICAgIGNvbnN0IHByZXNlbmNlID0gdGhpcy5yb29tLmdldFNlbGYoKT8ucHJlc2VuY2U7XG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICBpZiAocHJlc2VuY2UgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJvb20udXBkYXRlUHJlc2VuY2UoeyAuLi5wcmVzZW5jZSwgW1lfUFJFU0VOQ0VfS0VZXTogbnVsbCB9KTtcbiAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBbXG4gICAgICAgIHsgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZDogW3RoaXMuZG9jLmNsaWVudElEXSB9LFxuICAgICAgICBcImxvY2FsXCJcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB5UHJlc2VuY2UgPSBwcmVzZW5jZT8uW1lfUFJFU0VOQ0VfS0VZXTtcbiAgICBjb25zdCBhZGRlZCA9IHlQcmVzZW5jZSA9PT0gdm9pZCAwID8gW3RoaXMuZG9jLmNsaWVudElEXSA6IFtdO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSB5UHJlc2VuY2UgPT09IHZvaWQgMCA/IFtdIDogW3RoaXMuZG9jLmNsaWVudElEXTtcbiAgICB0aGlzLnJvb20udXBkYXRlUHJlc2VuY2Uoe1xuICAgICAgW1lfUFJFU0VOQ0VfS0VZXToge1xuICAgICAgICAuLi55UHJlc2VuY2UgfHwge30sXG4gICAgICAgIC4uLnN0YXRlIHx8IHt9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIFt7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkOiBbXSB9LCBcImxvY2FsXCJdKTtcbiAgfVxuICBzZXRMb2NhbFN0YXRlRmllbGQoZmllbGQsIHZhbHVlKSB7XG4gICAgY29uc3QgcHJlc2VuY2UgPSB0aGlzLnJvb20uZ2V0U2VsZigpPy5wcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV07XG4gICAgY29uc3QgdXBkYXRlID0geyBbZmllbGRdOiB2YWx1ZSB9O1xuICAgIHRoaXMucm9vbS51cGRhdGVQcmVzZW5jZSh7XG4gICAgICBbWV9QUkVTRU5DRV9LRVldOiB7IC4uLnByZXNlbmNlIHx8IHt9LCAuLi51cGRhdGUgfVxuICAgIH0pO1xuICB9XG4gIC8vIFRyYW5zbGF0ZSBsaXZlYmxvY2tzIHByZXNlbmNlIHRvIHlqcyBhd2FyZW5lc3NcbiAgZ2V0U3RhdGVzKCkge1xuICAgIGNvbnN0IG90aGVycyA9IHRoaXMucm9vbS5nZXRPdGhlcnMoKTtcbiAgICBjb25zdCBzdGF0ZXMgPSBvdGhlcnMucmVkdWNlKChhY2MsIG90aGVyVXNlcikgPT4ge1xuICAgICAgY29uc3Qgb3RoZXJQcmVzZW5jZSA9IG90aGVyVXNlci5wcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV07XG4gICAgICBjb25zdCBvdGhlckNsaWVudElkID0gb3RoZXJVc2VyLnByZXNlbmNlW1lfUFJFU0VOQ0VfSURfS0VZXTtcbiAgICAgIGlmIChvdGhlclByZXNlbmNlICE9PSB2b2lkIDAgJiYgb3RoZXJDbGllbnRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGFjYy5zZXQob3RoZXJDbGllbnRJZCwgb3RoZXJQcmVzZW5jZSB8fCB7fSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIGNvbnN0IGxvY2FsUHJlc2VuY2UgPSB0aGlzLnJvb20uZ2V0U2VsZigpPy5wcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV07XG4gICAgaWYgKGxvY2FsUHJlc2VuY2UgIT09IHZvaWQgMCkge1xuICAgICAgc3RhdGVzLnNldCh0aGlzLmRvYy5jbGllbnRJRCwgbG9jYWxQcmVzZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9kb2MudHNcbmltcG9ydCB7XG4gIERlcml2ZWRTaWduYWwsXG4gIFNpZ25hbFxufSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMlwiO1xuaW1wb3J0IHsgQmFzZTY0IH0gZnJvbSBcImpzLWJhc2U2NFwiO1xuaW1wb3J0IHsgSW5kZXhlZGRiUGVyc2lzdGVuY2UgfSBmcm9tIFwieS1pbmRleGVkZGJcIjtcbmltcG9ydCAqIGFzIFkgZnJvbSBcInlqc1wiO1xudmFyIHlEb2NIYW5kbGVyID0gY2xhc3MgX3lEb2NIYW5kbGVyIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIHVuc3Vic2NyaWJlcnMgPSBbXTtcbiAgX3N5bmNlZCA9IGZhbHNlO1xuICBkb2M7XG4gIHVwZGF0ZVJvb21Eb2M7XG4gIGZldGNoUm9vbURvYztcbiAgdXNlVjJFbmNvZGluZztcbiAgbG9jYWxTbmFwc2hvdEhhc2hcXHUwM0EzO1xuICByZW1vdGVTbmFwc2hvdEhhc2hcXHUwM0EzO1xuICBkZWJvdW5jZVRpbWVyID0gbnVsbDtcbiAgc3RhdGljIERFQk9VTkNFX0lOVEVSVkFMX01TID0gMjAwO1xuICBpc0xvY2FsQW5kUmVtb3RlU25hcHNob3RFcXVhbFxcdTAzQTM7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkb2MsXG4gICAgaXNSb290LFxuICAgIHVwZGF0ZURvYyxcbiAgICBmZXRjaERvYyxcbiAgICB1c2VWMkVuY29kaW5nXG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMudXNlVjJFbmNvZGluZyA9IHVzZVYyRW5jb2Rpbmc7XG4gICAgdGhpcy5kb2Mub24odXNlVjJFbmNvZGluZyA/IFwidXBkYXRlVjJcIiA6IFwidXBkYXRlXCIsIHRoaXMudXBkYXRlSGFuZGxlcik7XG4gICAgdGhpcy51cGRhdGVSb29tRG9jID0gKHVwZGF0ZSkgPT4ge1xuICAgICAgdXBkYXRlRG9jKHVwZGF0ZSwgaXNSb290ID8gdm9pZCAwIDogdGhpcy5kb2MuZ3VpZCk7XG4gICAgfTtcbiAgICB0aGlzLmZldGNoUm9vbURvYyA9ICh2ZWN0b3IpID0+IHtcbiAgICAgIGZldGNoRG9jKHZlY3RvciwgaXNSb290ID8gdm9pZCAwIDogdGhpcy5kb2MuZ3VpZCk7XG4gICAgfTtcbiAgICB0aGlzLnN5bmNEb2MoKTtcbiAgICBjb25zdCBlbmNvZGVkU25hcHNob3QgPSB0aGlzLnVzZVYyRW5jb2RpbmcgPyBZLmVuY29kZVNuYXBzaG90VjIoWS5zbmFwc2hvdCh0aGlzLmRvYykpIDogWS5lbmNvZGVTbmFwc2hvdChZLnNuYXBzaG90KHRoaXMuZG9jKSk7XG4gICAgdGhpcy5sb2NhbFNuYXBzaG90SGFzaFxcdTAzQTMgPSBuZXcgU2lnbmFsKFxuICAgICAgQmFzZTY0LmZyb21VaW50OEFycmF5KHNoYTI1NihlbmNvZGVkU25hcHNob3QpKVxuICAgICk7XG4gICAgdGhpcy5yZW1vdGVTbmFwc2hvdEhhc2hcXHUwM0EzID0gbmV3IFNpZ25hbChudWxsKTtcbiAgICB0aGlzLmlzTG9jYWxBbmRSZW1vdGVTbmFwc2hvdEVxdWFsXFx1MDNBMyA9IERlcml2ZWRTaWduYWwuZnJvbSgoKSA9PiB7XG4gICAgICBjb25zdCByZW1vdGVTbmFwc2hvdEhhc2ggPSB0aGlzLnJlbW90ZVNuYXBzaG90SGFzaFxcdTAzQTMuZ2V0KCk7XG4gICAgICBpZiAocmVtb3RlU25hcHNob3RIYXNoID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCBsb2NhbFNuYXBzaG90SGFzaCA9IHRoaXMubG9jYWxTbmFwc2hvdEhhc2hcXHUwM0EzLmdldCgpO1xuICAgICAgaWYgKGxvY2FsU25hcHNob3RIYXNoICE9PSByZW1vdGVTbmFwc2hvdEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlU2VydmVyVXBkYXRlID0gKHtcbiAgICB1cGRhdGUsXG4gICAgc3RhdGVWZWN0b3IsXG4gICAgcmVhZE9ubHksXG4gICAgdjIsXG4gICAgcmVtb3RlU25hcHNob3RIYXNoXG4gIH0pID0+IHtcbiAgICBjb25zdCBhcHBseVVwZGF0ZTIgPSB2MiA/IFkuYXBwbHlVcGRhdGVWMiA6IFkuYXBwbHlVcGRhdGU7XG4gICAgYXBwbHlVcGRhdGUyKHRoaXMuZG9jLCB1cGRhdGUsIFwiYmFja2VuZFwiKTtcbiAgICBpZiAoc3RhdGVWZWN0b3IpIHtcbiAgICAgIGlmICghcmVhZE9ubHkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVVcGRhdGUgPSB0aGlzLnVzZVYyRW5jb2RpbmcgPyBZLmVuY29kZVN0YXRlQXNVcGRhdGVWMiA6IFkuZW5jb2RlU3RhdGVBc1VwZGF0ZTtcbiAgICAgICAgICBjb25zdCBsb2NhbFVwZGF0ZSA9IGVuY29kZVVwZGF0ZShcbiAgICAgICAgICAgIHRoaXMuZG9jLFxuICAgICAgICAgICAgQmFzZTY0LnRvVWludDhBcnJheShzdGF0ZVZlY3RvcilcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMudXBkYXRlUm9vbURvYyhsb2NhbFVwZGF0ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc3luY2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdGVTbmFwc2hvdEhhc2hcXHUwM0EzLnNldChyZW1vdGVTbmFwc2hvdEhhc2gpO1xuICB9O1xuICBzeW5jRG9jID0gKCkgPT4ge1xuICAgIHRoaXMuc3luY2VkID0gZmFsc2U7XG4gICAgY29uc3QgZW5jb2RlZFZlY3RvciA9IEJhc2U2NC5mcm9tVWludDhBcnJheShZLmVuY29kZVN0YXRlVmVjdG9yKHRoaXMuZG9jKSk7XG4gICAgdGhpcy5mZXRjaFJvb21Eb2MoZW5jb2RlZFZlY3Rvcik7XG4gIH07XG4gIC8vIFRoZSBzeW5jJ2QgcHJvcGVydHkgaXMgcmVxdWlyZWQgYnkgc29tZSBwcm92aWRlciBpbXBsZW1lbnRhdGlvbnNcbiAgZ2V0IHN5bmNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY2VkO1xuICB9XG4gIHNldCBzeW5jZWQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fc3luY2VkICE9PSBzdGF0ZSkge1xuICAgICAgdGhpcy5fc3luY2VkID0gc3RhdGU7XG4gICAgICB0aGlzLmVtaXQoXCJzeW5jZWRcIiwgW3N0YXRlXSk7XG4gICAgICB0aGlzLmVtaXQoXCJzeW5jXCIsIFtzdGF0ZV0pO1xuICAgIH1cbiAgfVxuICBkZWJvdW5jZWRfdXBkYXRlTG9jYWxTbmFwc2hvdCgpIHtcbiAgICBpZiAodGhpcy5kZWJvdW5jZVRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVRpbWVyKTtcbiAgICB0aGlzLmRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IGVuY29kZWRTbmFwc2hvdCA9IHRoaXMudXNlVjJFbmNvZGluZyA/IFkuZW5jb2RlU25hcHNob3RWMihZLnNuYXBzaG90KHRoaXMuZG9jKSkgOiBZLmVuY29kZVNuYXBzaG90KFkuc25hcHNob3QodGhpcy5kb2MpKTtcbiAgICAgIHRoaXMubG9jYWxTbmFwc2hvdEhhc2hcXHUwM0EzLnNldChcbiAgICAgICAgQmFzZTY0LmZyb21VaW50OEFycmF5KHNoYTI1NihlbmNvZGVkU25hcHNob3QpKVxuICAgICAgKTtcbiAgICAgIHRoaXMuZGVib3VuY2VUaW1lciA9IG51bGw7XG4gICAgfSwgX3lEb2NIYW5kbGVyLkRFQk9VTkNFX0lOVEVSVkFMX01TKTtcbiAgfVxuICB1cGRhdGVIYW5kbGVyID0gKHVwZGF0ZSwgb3JpZ2luKSA9PiB7XG4gICAgdGhpcy5kZWJvdW5jZWRfdXBkYXRlTG9jYWxTbmFwc2hvdCgpO1xuICAgIGNvbnN0IGlzRnJvbUxvY2FsID0gb3JpZ2luIGluc3RhbmNlb2YgSW5kZXhlZGRiUGVyc2lzdGVuY2U7XG4gICAgaWYgKG9yaWdpbiAhPT0gXCJiYWNrZW5kXCIgJiYgIWlzRnJvbUxvY2FsKSB7XG4gICAgICB0aGlzLnVwZGF0ZVJvb21Eb2ModXBkYXRlKTtcbiAgICB9XG4gIH07XG4gIGV4cGVyaW1lbnRhbF9nZXRTeW5jU3RhdHVzKCkge1xuICAgIGNvbnN0IHJlbW90ZVNuYXBzaG90SGFzaCA9IHRoaXMucmVtb3RlU25hcHNob3RIYXNoXFx1MDNBMy5nZXQoKTtcbiAgICBpZiAocmVtb3RlU25hcHNob3RIYXNoID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJsb2FkaW5nXCI7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0xvY2FsQW5kUmVtb3RlU25hcHNob3RFcXVhbFxcdTAzQTMuZ2V0KCkpIHtcbiAgICAgIHJldHVybiBcInN5bmNocm9uaXppbmdcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwic3luY2hyb25pemVkXCI7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZWJvdW5jZVRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVRpbWVyKTtcbiAgICB0aGlzLmRvYy5vZmYoXCJ1cGRhdGVcIiwgdGhpcy51cGRhdGVIYW5kbGVyKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlcnMuZm9yRWFjaCgodW5zdWIpID0+IHVuc3ViKCkpO1xuICAgIHRoaXMuX29ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5kb2MuZGVzdHJveSgpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIudHNcbnZhciBMaXZlYmxvY2tzWWpzUHJvdmlkZXIgPSBjbGFzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICByb29tO1xuICByb290RG9jO1xuICBvcHRpb25zO1xuICBpbmRleGVkZGJQcm92aWRlciA9IG51bGw7XG4gIGlzUGF1c2VkID0gZmFsc2U7XG4gIHVuc3Vic2NyaWJlcnMgPSBbXTtcbiAgYXdhcmVuZXNzO1xuICByb290RG9jSGFuZGxlcjtcbiAgc3ViZG9jSGFuZGxlcnNcXHUwM0EzID0gbmV3IE11dGFibGVTaWduYWwoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIHN5bmNTdGF0dXNcXHUwM0EzO1xuICBwZXJtYW5lbnRVc2VyRGF0YTtcbiAgY29uc3RydWN0b3Iocm9vbSwgZG9jLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucm9vdERvYyA9IGRvYztcbiAgICB0aGlzLnJvb20gPSByb29tO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5yb290RG9jSGFuZGxlciA9IG5ldyB5RG9jSGFuZGxlcih7XG4gICAgICBkb2MsXG4gICAgICBpc1Jvb3Q6IHRydWUsXG4gICAgICB1cGRhdGVEb2M6IHRoaXMudXBkYXRlRG9jLFxuICAgICAgZmV0Y2hEb2M6IHRoaXMuZmV0Y2hEb2MsXG4gICAgICB1c2VWMkVuY29kaW5nOiB0aGlzLm9wdGlvbnMudXNlVjJFbmNvZGluZ19leHBlcmltZW50YWwgPz8gZmFsc2VcbiAgICB9KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZVBlcm1hbmVudFVzZXJEYXRhKSB7XG4gICAgICB0aGlzLnBlcm1hbmVudFVzZXJEYXRhID0gbmV3IFBlcm1hbmVudFVzZXJEYXRhKGRvYyk7XG4gICAgfVxuICAgIHJvb21ba0ludGVybmFsXS5zZXRZanNQcm92aWRlcih0aGlzKTtcbiAgICB0aGlzLmF3YXJlbmVzcyA9IG5ldyBBd2FyZW5lc3ModGhpcy5yb290RG9jLCB0aGlzLnJvb20pO1xuICAgIHRoaXMudW5zdWJzY3JpYmVycy5wdXNoKFxuICAgICAgdGhpcy5yb29tLmV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKChzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgICAgIHRoaXMucm9vdERvY0hhbmRsZXIuc3luY0RvYygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucm9vdERvY0hhbmRsZXIuc3luY2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlcnMucHVzaChcbiAgICAgIHRoaXMucm9vbS5ldmVudHMueWRvYy5zdWJzY3JpYmUoKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBtZXNzYWdlO1xuICAgICAgICBpZiAodHlwZSA9PT0gQ2xpZW50TXNnQ29kZS5VUERBVEVfWURPQykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3RhdGVWZWN0b3IsXG4gICAgICAgICAgdXBkYXRlOiB1cGRhdGVTdHIsXG4gICAgICAgICAgZ3VpZCxcbiAgICAgICAgICB2MixcbiAgICAgICAgICByZW1vdGVTbmFwc2hvdEhhc2hcbiAgICAgICAgfSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IGNhbldyaXRlID0gdGhpcy5yb29tLmdldFNlbGYoKT8uY2FuV3JpdGUgPz8gdHJ1ZTtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gQmFzZTY0Mi50b1VpbnQ4QXJyYXkodXBkYXRlU3RyKTtcbiAgICAgICAgaWYgKGd1aWQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRoaXMuc3ViZG9jSGFuZGxlcnNcXHUwM0EzLmdldCgpLmdldChndWlkKT8uaGFuZGxlU2VydmVyVXBkYXRlKHtcbiAgICAgICAgICAgIHVwZGF0ZSxcbiAgICAgICAgICAgIHN0YXRlVmVjdG9yLFxuICAgICAgICAgICAgcmVhZE9ubHk6ICFjYW5Xcml0ZSxcbiAgICAgICAgICAgIHYyLFxuICAgICAgICAgICAgcmVtb3RlU25hcHNob3RIYXNoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yb290RG9jSGFuZGxlci5oYW5kbGVTZXJ2ZXJVcGRhdGUoe1xuICAgICAgICAgICAgdXBkYXRlLFxuICAgICAgICAgICAgc3RhdGVWZWN0b3IsXG4gICAgICAgICAgICByZWFkT25seTogIWNhbldyaXRlLFxuICAgICAgICAgICAgdjIsXG4gICAgICAgICAgICByZW1vdGVTbmFwc2hvdEhhc2hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIGlmIChvcHRpb25zLm9mZmxpbmVTdXBwb3J0X2V4cGVyaW1lbnRhbCkge1xuICAgICAgdGhpcy5zZXR1cE9mZmxpbmVTdXBwb3J0KCk7XG4gICAgfVxuICAgIHRoaXMucm9vdERvY0hhbmRsZXIub24oXCJzeW5jZWRcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnJvb3REb2NIYW5kbGVyLnN5bmNlZDtcbiAgICAgIGZvciAoY29uc3QgW18sIGhhbmRsZXJdIG9mIHRoaXMuc3ViZG9jSGFuZGxlcnNcXHUwM0EzLmdldCgpKSB7XG4gICAgICAgIGhhbmRsZXIuc3luY0RvYygpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwic3luY2VkXCIsIFtzdGF0ZV0pO1xuICAgICAgdGhpcy5lbWl0KFwic3luY1wiLCBbc3RhdGVdKTtcbiAgICB9KTtcbiAgICB0aGlzLnJvb3REb2Mub24oXCJzdWJkb2NzXCIsIHRoaXMuaGFuZGxlU3ViZG9jcyk7XG4gICAgdGhpcy5zeW5jRG9jKCk7XG4gICAgdGhpcy5zeW5jU3RhdHVzXFx1MDNBMyA9IERlcml2ZWRTaWduYWwyLmZyb20oKCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdERvY3VtZW50U3RhdHVzID0gdGhpcy5yb290RG9jSGFuZGxlci5leHBlcmltZW50YWxfZ2V0U3luY1N0YXR1cygpO1xuICAgICAgaWYgKHJvb3REb2N1bWVudFN0YXR1cyA9PT0gXCJsb2FkaW5nXCIgfHwgcm9vdERvY3VtZW50U3RhdHVzID09PSBcInN5bmNocm9uaXppbmdcIikge1xuICAgICAgICByZXR1cm4gcm9vdERvY3VtZW50U3RhdHVzO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3ViZG9jdW1lbnRTdGF0dXNlcyA9IEFycmF5LmZyb20oXG4gICAgICAgIHRoaXMuc3ViZG9jSGFuZGxlcnNcXHUwM0EzLmdldCgpLnZhbHVlcygpXG4gICAgICApLm1hcCgoaGFuZGxlcikgPT4gaGFuZGxlci5leHBlcmltZW50YWxfZ2V0U3luY1N0YXR1cygpKTtcbiAgICAgIGlmIChzdWJkb2N1bWVudFN0YXR1c2VzLnNvbWUoKHN0YXRlKSA9PiBzdGF0ZSAhPT0gXCJzeW5jaHJvbml6ZWRcIikpIHtcbiAgICAgICAgcmV0dXJuIFwic3luY2hyb25pemluZ1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwic3luY2hyb25pemVkXCI7XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFwic3RhdHVzXCIsIFt0aGlzLmdldFN0YXR1cygpXSk7XG4gICAgdGhpcy51bnN1YnNjcmliZXJzLnB1c2goXG4gICAgICB0aGlzLnN5bmNTdGF0dXNcXHUwM0EzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcInN0YXR1c1wiLCBbdGhpcy5nZXRTdGF0dXMoKV0pO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHNldHVwT2ZmbGluZVN1cHBvcnQgPSAoKSA9PiB7XG4gICAgdGhpcy5pbmRleGVkZGJQcm92aWRlciA9IG5ldyBJbmRleGVkZGJQZXJzaXN0ZW5jZTIoXG4gICAgICB0aGlzLnJvb20uaWQsXG4gICAgICB0aGlzLnJvb3REb2NcbiAgICApO1xuICAgIGNvbnN0IG9uSW5kZXhlZERiU3luYyA9ICgpID0+IHtcbiAgICAgIHRoaXMucm9vdERvY0hhbmRsZXIuc3luY2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHRoaXMuaW5kZXhlZGRiUHJvdmlkZXIub24oXCJzeW5jZWRcIiwgb25JbmRleGVkRGJTeW5jKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlcnMucHVzaCgoKSA9PiB7XG4gICAgICB0aGlzLmluZGV4ZWRkYlByb3ZpZGVyPy5vZmYoXCJzeW5jZWRcIiwgb25JbmRleGVkRGJTeW5jKTtcbiAgICB9KTtcbiAgfTtcbiAgaGFuZGxlU3ViZG9jcyA9ICh7XG4gICAgbG9hZGVkLFxuICAgIHJlbW92ZWQsXG4gICAgYWRkZWRcbiAgfSkgPT4ge1xuICAgIGxvYWRlZC5mb3JFYWNoKHRoaXMuY3JlYXRlU3ViZG9jSGFuZGxlcik7XG4gICAgY29uc3Qgc3ViZG9jSGFuZGxlcnMgPSB0aGlzLnN1YmRvY0hhbmRsZXJzXFx1MDNBMy5nZXQoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9sb2FkU3ViZG9jcykge1xuICAgICAgZm9yIChjb25zdCBzdWJkb2Mgb2YgYWRkZWQpIHtcbiAgICAgICAgaWYgKCFzdWJkb2NIYW5kbGVycy5oYXMoc3ViZG9jLmd1aWQpKSB7XG4gICAgICAgICAgc3ViZG9jLmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHN1YmRvYyBvZiByZW1vdmVkKSB7XG4gICAgICBpZiAoc3ViZG9jSGFuZGxlcnMuaGFzKHN1YmRvYy5ndWlkKSkge1xuICAgICAgICBzdWJkb2NIYW5kbGVycy5nZXQoc3ViZG9jLmd1aWQpPy5kZXN0cm95KCk7XG4gICAgICAgIHN1YmRvY0hhbmRsZXJzLmRlbGV0ZShzdWJkb2MuZ3VpZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB1cGRhdGVEb2MgPSAodXBkYXRlLCBndWlkKSA9PiB7XG4gICAgY29uc3QgY2FuV3JpdGUgPSB0aGlzLnJvb20uZ2V0U2VsZigpPy5jYW5Xcml0ZSA/PyB0cnVlO1xuICAgIGlmIChjYW5Xcml0ZSAmJiAhdGhpcy5pc1BhdXNlZCkge1xuICAgICAgdGhpcy5yb29tLnVwZGF0ZVlEb2MoXG4gICAgICAgIEJhc2U2NDIuZnJvbVVpbnQ4QXJyYXkodXBkYXRlKSxcbiAgICAgICAgZ3VpZCxcbiAgICAgICAgdGhpcy51c2VWMkVuY29kaW5nXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgZmV0Y2hEb2MgPSAodmVjdG9yLCBndWlkKSA9PiB7XG4gICAgdGhpcy5yb29tLmZldGNoWURvYyh2ZWN0b3IsIGd1aWQsIHRoaXMudXNlVjJFbmNvZGluZyk7XG4gIH07XG4gIGNyZWF0ZVN1YmRvY0hhbmRsZXIgPSAoc3ViZG9jKSA9PiB7XG4gICAgY29uc3Qgc3ViZG9jSGFuZGxlcnMgPSB0aGlzLnN1YmRvY0hhbmRsZXJzXFx1MDNBMy5nZXQoKTtcbiAgICBpZiAoc3ViZG9jSGFuZGxlcnMuaGFzKHN1YmRvYy5ndWlkKSkge1xuICAgICAgc3ViZG9jSGFuZGxlcnMuZ2V0KHN1YmRvYy5ndWlkKT8uc3luY0RvYygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVyID0gbmV3IHlEb2NIYW5kbGVyKHtcbiAgICAgIGRvYzogc3ViZG9jLFxuICAgICAgaXNSb290OiBmYWxzZSxcbiAgICAgIHVwZGF0ZURvYzogdGhpcy51cGRhdGVEb2MsXG4gICAgICBmZXRjaERvYzogdGhpcy5mZXRjaERvYyxcbiAgICAgIHVzZVYyRW5jb2Rpbmc6IHRoaXMub3B0aW9ucy51c2VWMkVuY29kaW5nX2V4cGVyaW1lbnRhbCA/PyBmYWxzZVxuICAgIH0pO1xuICAgIHN1YmRvY0hhbmRsZXJzLnNldChzdWJkb2MuZ3VpZCwgaGFuZGxlcik7XG4gIH07XG4gIC8vIGF0dGVtcHQgdG8gbG9hZCBhIHN1YmRvYyBvZiBhIGdpdmVuIGd1aWRcbiAgbG9hZFN1YmRvYyA9IChndWlkKSA9PiB7XG4gICAgZm9yIChjb25zdCBzdWJkb2Mgb2YgdGhpcy5yb290RG9jLnN1YmRvY3MpIHtcbiAgICAgIGlmIChzdWJkb2MuZ3VpZCA9PT0gZ3VpZCkge1xuICAgICAgICBzdWJkb2MubG9hZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBzeW5jRG9jID0gKCkgPT4ge1xuICAgIHRoaXMucm9vdERvY0hhbmRsZXIuc3luY0RvYygpO1xuICAgIGZvciAoY29uc3QgW18sIGhhbmRsZXJdIG9mIHRoaXMuc3ViZG9jSGFuZGxlcnNcXHUwM0EzLmdldCgpKSB7XG4gICAgICBoYW5kbGVyLnN5bmNEb2MoKTtcbiAgICB9XG4gIH07XG4gIGdldCB1c2VWMkVuY29kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudXNlVjJFbmNvZGluZ19leHBlcmltZW50YWwgPz8gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHN5bmMnZCBwcm9wZXJ0eSBpcyByZXF1aXJlZCBieSBzb21lIHByb3ZpZGVyIGltcGxlbWVudGF0aW9uc1xuICBnZXQgc3luY2VkKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3REb2NIYW5kbGVyLnN5bmNlZDtcbiAgfVxuICBhc3luYyBwYXVzZSgpIHtcbiAgICBhd2FpdCB0aGlzLmluZGV4ZWRkYlByb3ZpZGVyPy5kZXN0cm95KCk7XG4gICAgdGhpcy5pbmRleGVkZGJQcm92aWRlciA9IG51bGw7XG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gIH1cbiAgdW5wYXVzZSgpIHtcbiAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZsaW5lU3VwcG9ydF9leHBlcmltZW50YWwpIHtcbiAgICAgIHRoaXMuc2V0dXBPZmZsaW5lU3VwcG9ydCgpO1xuICAgIH1cbiAgICB0aGlzLnJvb3REb2NIYW5kbGVyLnN5bmNEb2MoKTtcbiAgfVxuICBnZXRTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luY1N0YXR1c1xcdTAzQTMuZ2V0KCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVuc3Vic2NyaWJlcnMuZm9yRWFjaCgodW5zdWIpID0+IHVuc3ViKCkpO1xuICAgIHRoaXMuYXdhcmVuZXNzLmRlc3Ryb3koKTtcbiAgICB0aGlzLnJvb3REb2NIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9vYnNlcnZlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW18sIGhhbmRsZXJdIG9mIHRoaXMuc3ViZG9jSGFuZGxlcnNcXHUwM0EzLmdldCgpKSB7XG4gICAgICBoYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJkb2NIYW5kbGVyc1xcdTAzQTMuZ2V0KCkuY2xlYXIoKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgYXN5bmMgY2xlYXJPZmZsaW5lRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuaW5kZXhlZGRiUHJvdmlkZXIpIHJldHVybjtcbiAgICByZXR1cm4gdGhpcy5pbmRleGVkZGJQcm92aWRlci5jbGVhckRhdGEoKTtcbiAgfVxuICBnZXRZRG9jKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3REb2M7XG4gIH1cbiAgLy8gU29tZSBwcm92aWRlciBpbXBsZW1lbnRhdGlvbnMgZXhwZWN0IHRvIGJlIGFibGUgdG8gY2FsbCBjb25uZWN0L2Rpc2Nvbm5lY3QsIGltcGxlbWVudCBhcyBub29wXG4gIGRpc2Nvbm5lY3QoKSB7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgfVxuICBnZXQgc3ViZG9jSGFuZGxlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViZG9jSGFuZGxlcnNcXHUwM0EzLmdldCgpO1xuICB9XG4gIHNldCBzdWJkb2NIYW5kbGVycyh2YWx1ZSkge1xuICAgIHRoaXMuc3ViZG9jSGFuZGxlcnNcXHUwM0EzLm11dGF0ZSgobWFwKSA9PiB7XG4gICAgICBtYXAuY2xlYXIoKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgaGFuZGxlcl0gb2YgdmFsdWUpIHtcbiAgICAgICAgbWFwLnNldChrZXksIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXJDb250ZXh0LnRzXG5pbXBvcnQgeyBEb2MgfSBmcm9tIFwieWpzXCI7XG52YXIgcHJvdmlkZXJzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgZ2V0WWpzUHJvdmlkZXJGb3JSb29tID0gKHJvb20sIG9wdGlvbnMgPSB7fSwgZm9yY2VOZXdQcm92aWRlciA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IHByb3ZpZGVyID0gcHJvdmlkZXJzTWFwLmdldChyb29tKTtcbiAgaWYgKHByb3ZpZGVyICE9PSB2b2lkIDApIHtcbiAgICBpZiAoIWZvcmNlTmV3UHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9XG4gICAgcHJvdmlkZXIuZGVzdHJveSgpO1xuICAgIHByb3ZpZGVyc01hcC5kZWxldGUocm9vbSk7XG4gIH1cbiAgY29uc3QgZG9jID0gbmV3IERvYygpO1xuICBjb25zdCBuZXdQcm92aWRlciA9IG5ldyBMaXZlYmxvY2tzWWpzUHJvdmlkZXIocm9vbSwgZG9jLCBvcHRpb25zKTtcbiAgcm9vbS5ldmVudHMucm9vbVdpbGxEZXN0cm95LnN1YnNjcmliZU9uY2UoKCkgPT4ge1xuICAgIG5ld1Byb3ZpZGVyLmRlc3Ryb3koKTtcbiAgfSk7XG4gIHByb3ZpZGVyc01hcC5zZXQocm9vbSwgbmV3UHJvdmlkZXIpO1xuICByZXR1cm4gbmV3UHJvdmlkZXI7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG5leHBvcnQge1xuICBMaXZlYmxvY2tzWWpzUHJvdmlkZXIsXG4gIGdldFlqc1Byb3ZpZGVyRm9yUm9vbVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/yjs/dist/index.js\n");

/***/ })

};
;