"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@hocuspocus";
exports.ids = ["vendor-chunks/@hocuspocus"];
exports.modules = {

/***/ "(ssr)/./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthMessageType: () => (/* binding */ AuthMessageType),\n/* harmony export */   ConnectionTimeout: () => (/* binding */ ConnectionTimeout),\n/* harmony export */   Forbidden: () => (/* binding */ Forbidden),\n/* harmony export */   MessageTooBig: () => (/* binding */ MessageTooBig),\n/* harmony export */   ResetConnection: () => (/* binding */ ResetConnection),\n/* harmony export */   Unauthorized: () => (/* binding */ Unauthorized),\n/* harmony export */   WsReadyStates: () => (/* binding */ WsReadyStates),\n/* harmony export */   awarenessStatesToArray: () => (/* binding */ awarenessStatesToArray),\n/* harmony export */   readAuthMessage: () => (/* binding */ readAuthMessage),\n/* harmony export */   writeAuthenticated: () => (/* binding */ writeAuthenticated),\n/* harmony export */   writeAuthentication: () => (/* binding */ writeAuthentication),\n/* harmony export */   writePermissionDenied: () => (/* binding */ writePermissionDenied),\n/* harmony export */   writeTokenSyncRequest: () => (/* binding */ writeTokenSyncRequest)\n/* harmony export */ });\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b;\n\n/* eslint-env browser */\n\nconst BIT8 = 128;\nconst BITS7 = 127;\n\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i));\n  }\n  return buf\n};\n\n/* c8 ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\n\n/* c8 ignore next */\nlet utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true });\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null;\n}\n\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > BITS7) {\n    write(encoder, BIT8 | (BITS7 & num));\n    num = floor(num / 128); // shift >>> 7\n  }\n  write(encoder, BITS7 & num);\n};\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000);\nconst _maxStrBSize = _strBuffer.length / 3;\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n    writeVarUint(encoder, written);\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i]);\n    }\n  } else {\n    writeVarUint8Array(encoder, encodeUtf8(str));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nconst writeVarString = (utf8TextEncoder && /** @type {any} */ (utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill;\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf);\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\n\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nconst create = s => new Error(s);\n\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n\nconst errorUnexpectedEndOfArray = create('Unexpected end of array');\nconst errorIntegerOutOfRange = create('Integer out of Range');\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view\n};\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder));\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++];\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0;\n  let mult = 1;\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & BITS7) * mult; // shift $r << (7*#iterations) and add it to num\n    mult *= 128; // next iteration, shift 7 \"more\" to the left\n    if (r < BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n};\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nconst _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n};\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nconst _readVarStringNative = decoder =>\n  /** @type any */ (utf8TextDecoder).decode(readVarUint8Array(decoder));\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nconst readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\n\nvar AuthMessageType;\n(function (AuthMessageType) {\n    AuthMessageType[AuthMessageType[\"Token\"] = 0] = \"Token\";\n    AuthMessageType[AuthMessageType[\"PermissionDenied\"] = 1] = \"PermissionDenied\";\n    AuthMessageType[AuthMessageType[\"Authenticated\"] = 2] = \"Authenticated\";\n})(AuthMessageType || (AuthMessageType = {}));\nconst writeAuthentication = (encoder, auth) => {\n    writeVarUint(encoder, AuthMessageType.Token);\n    writeVarString(encoder, auth);\n};\nconst writePermissionDenied = (encoder, reason) => {\n    writeVarUint(encoder, AuthMessageType.PermissionDenied);\n    writeVarString(encoder, reason);\n};\nconst writeAuthenticated = (encoder, scope) => {\n    writeVarUint(encoder, AuthMessageType.Authenticated);\n    writeVarString(encoder, scope);\n};\nconst writeTokenSyncRequest = (encoder) => {\n    writeVarUint(encoder, AuthMessageType.Token);\n};\nconst readAuthMessage = (decoder, sendToken, permissionDeniedHandler, authenticatedHandler) => {\n    switch (readVarUint(decoder)) {\n        case AuthMessageType.Token: {\n            sendToken();\n            break;\n        }\n        case AuthMessageType.PermissionDenied: {\n            permissionDeniedHandler(readVarString(decoder));\n            break;\n        }\n        case AuthMessageType.Authenticated: {\n            authenticatedHandler(readVarString(decoder));\n            break;\n        }\n    }\n};\n\n/**\n * The server is terminating the connection because a data frame was received\n * that is too large.\n * See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code\n */\nconst MessageTooBig = {\n    code: 1009,\n    reason: \"Message Too Big\",\n};\n/**\n * The server successfully processed the request, asks that the requester reset\n * its document view, and is not returning any content.\n */\nconst ResetConnection = {\n    code: 4205,\n    reason: \"Reset Connection\",\n};\n/**\n * Similar to Forbidden, but specifically for use when authentication is required and has\n * failed or has not yet been provided.\n */\nconst Unauthorized = {\n    code: 4401,\n    reason: \"Unauthorized\",\n};\n/**\n * The request contained valid data and was understood by the server, but the server\n * is refusing action.\n */\nconst Forbidden = {\n    code: 4403,\n    reason: \"Forbidden\",\n};\n/**\n * The server timed out waiting for the request.\n */\nconst ConnectionTimeout = {\n    code: 4408,\n    reason: \"Connection Timeout\",\n};\n\nconst awarenessStatesToArray = (states) => {\n    return Array.from(states.entries()).map(([key, value]) => {\n        return {\n            clientId: key,\n            ...value,\n        };\n    });\n};\n\n/**\n * State of the WebSocket connection.\n * https://developer.mozilla.org/de/docs/Web/API/WebSocket/readyState\n */\nvar WsReadyStates;\n(function (WsReadyStates) {\n    WsReadyStates[WsReadyStates[\"Connecting\"] = 0] = \"Connecting\";\n    WsReadyStates[WsReadyStates[\"Open\"] = 1] = \"Open\";\n    WsReadyStates[WsReadyStates[\"Closing\"] = 2] = \"Closing\";\n    WsReadyStates[WsReadyStates[\"Closed\"] = 3] = \"Closed\";\n})(WsReadyStates || (WsReadyStates = {}));\n\n\n//# sourceMappingURL=hocuspocus-common.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhvY3VzcG9jdXMvY29tbW9uL2Rpc3QvaG9jdXNwb2N1cy1jb21tb24uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQix3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsYUFBYTs7QUFFaEQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZGQUE2Riw4QkFBOEI7O0FBRTNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQzs7QUFFK007QUFDdFAiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnlhbmdveWFsL3JlYWwtdGltZS10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQGhvY3VzcG9jdXMvY29tbW9uL2Rpc3QvaG9jdXNwb2N1cy1jb21tb24uZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29tbW9uIE1hdGggZXhwcmVzc2lvbnMuXG4gKlxuICogQG1vZHVsZSBtYXRoXG4gKi9cblxuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzbWFsbGVyIGVsZW1lbnQgb2YgYSBhbmQgYlxuICovXG5jb25zdCBtaW4gPSAoYSwgYikgPT4gYSA8IGIgPyBhIDogYjtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYmlnZ2VyIGVsZW1lbnQgb2YgYSBhbmQgYlxuICovXG5jb25zdCBtYXggPSAoYSwgYikgPT4gYSA+IGIgPyBhIDogYjtcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbmNvbnN0IEJJVDggPSAxMjg7XG5jb25zdCBCSVRTNyA9IDEyNztcblxuLyoqXG4gKiBVdGlsaXR5IGhlbHBlcnMgZm9yIHdvcmtpbmcgd2l0aCBudW1iZXJzLlxuICpcbiAqIEBtb2R1bGUgbnVtYmVyXG4gKi9cblxuXG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgX2VuY29kZVV0ZjhQb2x5ZmlsbCA9IHN0ciA9PiB7XG4gIGNvbnN0IGVuY29kZWRTdHJpbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gIGNvbnN0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoO1xuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbmNvZGVkU3RyaW5nLmNvZGVQb2ludEF0KGkpKTtcbiAgfVxuICByZXR1cm4gYnVmXG59O1xuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgdXRmOFRleHRFbmNvZGVyID0gLyoqIEB0eXBlIHtUZXh0RW5jb2Rlcn0gKi8gKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dEVuY29kZXIoKSA6IG51bGwpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IF9lbmNvZGVVdGY4TmF0aXZlID0gc3RyID0+IHV0ZjhUZXh0RW5jb2Rlci5lbmNvZGUoc3RyKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgZW5jb2RlVXRmOCA9IHV0ZjhUZXh0RW5jb2RlciA/IF9lbmNvZGVVdGY4TmF0aXZlIDogX2VuY29kZVV0ZjhQb2x5ZmlsbDtcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmxldCB1dGY4VGV4dERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiB0cnVlLCBpZ25vcmVCT006IHRydWUgfSk7XG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuaWYgKHV0ZjhUZXh0RGVjb2RlciAmJiB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSkge1xuICAvLyBTYWZhcmkgZG9lc24ndCBoYW5kbGUgQk9NIGNvcnJlY3RseS5cbiAgLy8gVGhpcyBmaXhlcyBhIGJ1ZyBpbiBTYWZhcmkgMTMuMC41IHdoZXJlIGl0IHByb2R1Y2VzIGEgQk9NIHRoZSBmaXJzdCB0aW1lIGl0IGlzIGNhbGxlZC5cbiAgLy8gdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEgb24gdGhlIGZpcnN0IGNhbGwgYW5kXG4gIC8vIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxIG9uIHRoZSBzZWNvbmQgY2FsbFxuICAvLyBBbm90aGVyIGlzc3VlIGlzIHRoYXQgZnJvbSB0aGVuIG9uIG5vIEJPTSBjaGFycyBhcmUgcmVjb2duaXplZCBhbnltb3JlXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIHV0ZjhUZXh0RGVjb2RlciA9IG51bGw7XG59XG5cbi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBlbmNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZW5jb2RpbmddIHdpdGggW2xpYjAvZGVjb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAqIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAyNTYpXG4gKiBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCAnSGVsbG8gd29ybGQhJylcbiAqIGNvbnN0IGJ1ZiA9IGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIGRlY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZW5jb2RpbmdcbiAqL1xuXG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIGJ5dGUgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCB3cml0ZSA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aDtcbiAgaWYgKGVuY29kZXIuY3BvcyA9PT0gYnVmZmVyTGVuKSB7XG4gICAgZW5jb2Rlci5idWZzLnB1c2goZW5jb2Rlci5jYnVmKTtcbiAgICBlbmNvZGVyLmNidWYgPSBuZXcgVWludDhBcnJheShidWZmZXJMZW4gKiAyKTtcbiAgICBlbmNvZGVyLmNwb3MgPSAwO1xuICB9XG4gIGVuY29kZXIuY2J1ZltlbmNvZGVyLmNwb3MrK10gPSBudW07XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHVuc2lnbmVkIGludGVnZXIuIE1heCBlbmNvZGFibGUgaW50ZWdlciBpcyAyXjUzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCB3cml0ZVZhclVpbnQgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIHdoaWxlIChudW0gPiBCSVRTNykge1xuICAgIHdyaXRlKGVuY29kZXIsIEJJVDggfCAoQklUUzcgJiBudW0pKTtcbiAgICBudW0gPSBmbG9vcihudW0gLyAxMjgpOyAvLyBzaGlmdCA+Pj4gN1xuICB9XG4gIHdyaXRlKGVuY29kZXIsIEJJVFM3ICYgbnVtKTtcbn07XG5cbi8qKlxuICogQSBjYWNoZSB0byBzdG9yZSBzdHJpbmdzIHRlbXBvcmFyaWx5XG4gKi9cbmNvbnN0IF9zdHJCdWZmZXIgPSBuZXcgVWludDhBcnJheSgzMDAwMCk7XG5jb25zdCBfbWF4U3RyQlNpemUgPSBfc3RyQnVmZmVyLmxlbmd0aCAvIDM7XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGlmIChzdHIubGVuZ3RoIDwgX21heFN0ckJTaXplKSB7XG4gICAgLy8gV2UgY2FuIGVuY29kZSB0aGUgc3RyaW5nIGludG8gdGhlIGV4aXN0aW5nIGJ1ZmZlclxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgY29uc3Qgd3JpdHRlbiA9IHV0ZjhUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHN0ciwgX3N0ckJ1ZmZlcikud3JpdHRlbiB8fCAwO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCB3cml0dGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyaXR0ZW47IGkrKykge1xuICAgICAgd3JpdGUoZW5jb2RlciwgX3N0ckJ1ZmZlcltpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGVVdGY4KHN0cikpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuY29uc3QgX3dyaXRlVmFyU3RyaW5nUG9seWZpbGwgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGNvbnN0IGVuY29kZWRTdHJpbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gIGNvbnN0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoO1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHdyaXRlKGVuY29kZXIsIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSkpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IHdyaXRlVmFyU3RyaW5nID0gKHV0ZjhUZXh0RW5jb2RlciAmJiAvKiogQHR5cGUge2FueX0gKi8gKHV0ZjhUZXh0RW5jb2RlcikuZW5jb2RlSW50bykgPyBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgOiBfd3JpdGVWYXJTdHJpbmdQb2x5ZmlsbDtcblxuLyoqXG4gKiBBcHBlbmQgZml4ZWQtbGVuZ3RoIFVpbnQ4QXJyYXkgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5jb25zdCB3cml0ZVVpbnQ4QXJyYXkgPSAoZW5jb2RlciwgdWludDhBcnJheSkgPT4ge1xuICBjb25zdCBidWZmZXJMZW4gPSBlbmNvZGVyLmNidWYubGVuZ3RoO1xuICBjb25zdCBjcG9zID0gZW5jb2Rlci5jcG9zO1xuICBjb25zdCBsZWZ0Q29weUxlbiA9IG1pbihidWZmZXJMZW4gLSBjcG9zLCB1aW50OEFycmF5Lmxlbmd0aCk7XG4gIGNvbnN0IHJpZ2h0Q29weUxlbiA9IHVpbnQ4QXJyYXkubGVuZ3RoIC0gbGVmdENvcHlMZW47XG4gIGVuY29kZXIuY2J1Zi5zZXQodWludDhBcnJheS5zdWJhcnJheSgwLCBsZWZ0Q29weUxlbiksIGNwb3MpO1xuICBlbmNvZGVyLmNwb3MgKz0gbGVmdENvcHlMZW47XG4gIGlmIChyaWdodENvcHlMZW4gPiAwKSB7XG4gICAgLy8gU3RpbGwgc29tZXRoaW5nIHRvIHdyaXRlLCB3cml0ZSByaWdodCBoYWxmLi5cbiAgICAvLyBBcHBlbmQgbmV3IGJ1ZmZlclxuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1Zik7XG4gICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHNpemUgb2YgcmVtYWluaW5nIGJ1ZmZlclxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KG1heChidWZmZXJMZW4gKiAyLCByaWdodENvcHlMZW4pKTtcbiAgICAvLyBjb3B5IGFycmF5XG4gICAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KGxlZnRDb3B5TGVuKSk7XG4gICAgZW5jb2Rlci5jcG9zID0gcmlnaHRDb3B5TGVuO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGVuZCBhbiBVaW50OEFycmF5IHRvIEVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5jb25zdCB3cml0ZVZhclVpbnQ4QXJyYXkgPSAoZW5jb2RlciwgdWludDhBcnJheSkgPT4ge1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgdWludDhBcnJheS5ieXRlTGVuZ3RoKTtcbiAgd3JpdGVVaW50OEFycmF5KGVuY29kZXIsIHVpbnQ4QXJyYXkpO1xufTtcblxuLyoqXG4gKiBFcnJvciBoZWxwZXJzLlxuICpcbiAqIEBtb2R1bGUgZXJyb3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IGNyZWF0ZSA9IHMgPT4gbmV3IEVycm9yKHMpO1xuXG4vKipcbiAqIEVmZmljaWVudCBzY2hlbWEtbGVzcyBiaW5hcnkgZGVjb2Rpbmcgd2l0aCBzdXBwb3J0IGZvciB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogVXNlIFtsaWIwL2RlY29kaW5nXSB3aXRoIFtsaWIwL2VuY29kaW5nXS4gRXZlcnkgZW5jb2RpbmcgZnVuY3Rpb24gaGFzIGEgY29ycmVzcG9uZGluZyBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBFbmNvZGVzIG51bWJlcnMgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciAobGVhc3QgdG8gbW9zdCBzaWduaWZpY2FudCBieXRlIG9yZGVyKVxuICogYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBHb2xhbmcncyBiaW5hcnkgZW5jb2RpbmcgKGh0dHBzOi8vZ29sYW5nLm9yZy9wa2cvZW5jb2RpbmcvYmluYXJ5LylcbiAqIHdoaWNoIGlzIGFsc28gdXNlZCBpbiBQcm90b2NvbCBCdWZmZXJzLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBlbmNvZGluZyBzdGVwXG4gKiBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gKiBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMjU2KVxuICogZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgJ0hlbGxvIHdvcmxkIScpXG4gKiBjb25zdCBidWYgPSBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWNvZGluZyBzdGVwXG4gKiBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpXG4gKiBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKSAvLyA9PiAyNTZcbiAqIGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikgLy8gPT4gJ0hlbGxvIHdvcmxkISdcbiAqIGRlY29kaW5nLmhhc0NvbnRlbnQoZGVjb2RlcikgLy8gPT4gZmFsc2UgLSBhbGwgZGF0YSBpcyByZWFkXG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIGRlY29kaW5nXG4gKi9cblxuXG5jb25zdCBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5ID0gY3JlYXRlKCdVbmV4cGVjdGVkIGVuZCBvZiBhcnJheScpO1xuY29uc3QgZXJyb3JJbnRlZ2VyT3V0T2ZSYW5nZSA9IGNyZWF0ZSgnSW50ZWdlciBvdXQgb2YgUmFuZ2UnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gVWludDhBcnJheSB2aWV3IG9mIHRoZSBuZXh0IGBsZW5gIGJ5dGVzIGFuZCBhZHZhbmNlIHRoZSBwb3NpdGlvbiBieSBgbGVuYC5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVGhlIGxlbmd0aCBvZiBieXRlcyB0byByZWFkXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCByZWFkVWludDhBcnJheSA9IChkZWNvZGVyLCBsZW4pID0+IHtcbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGRlY29kZXIuYXJyLmJ1ZmZlciwgZGVjb2Rlci5wb3MgKyBkZWNvZGVyLmFyci5ieXRlT2Zmc2V0LCBsZW4pO1xuICBkZWNvZGVyLnBvcyArPSBsZW47XG4gIHJldHVybiB2aWV3XG59O1xuXG4vKipcbiAqIFJlYWQgdmFyaWFibGUgbGVuZ3RoIFVpbnQ4QXJyYXkuXG4gKlxuICogSW1wb3J0YW50OiBUaGUgVWludDhBcnJheSBzdGlsbCBwb2ludHMgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIE1ha2Ugc3VyZSB0byBkaXNjYXJkIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBwcmV2ZW50IGFueSBtZW1vcnkgbGVha3MuXG4gKiAgICAgICAgICAgIFVzZSBgYnVmZmVyLmNvcHlVaW50OEFycmF5YCB0byBjb3B5IHRoZSByZXN1bHQgaW50byBhIG5ldyBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCByZWFkVmFyVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgcmVhZFZhclVpbnQoZGVjb2RlcikpO1xuXG4vKipcbiAqIFJlYWQgb25lIGJ5dGUgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAqL1xuY29uc3QgcmVhZFVpbnQ4ID0gZGVjb2RlciA9PiBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcblxuLyoqXG4gKiBSZWFkIHVuc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0bGVuZ3RoXG4gKiAgKiBudW1iZXJzIDwgMl4xNCBpcyBzdG9yZWQgaW4gdHdvIGJ5bGVuZ3RoXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5sZW5ndGhcbiAqL1xuY29uc3QgcmVhZFZhclVpbnQgPSBkZWNvZGVyID0+IHtcbiAgbGV0IG51bSA9IDA7XG4gIGxldCBtdWx0ID0gMTtcbiAgY29uc3QgbGVuID0gZGVjb2Rlci5hcnIubGVuZ3RoO1xuICB3aGlsZSAoZGVjb2Rlci5wb3MgPCBsZW4pIHtcbiAgICBjb25zdCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK107XG4gICAgLy8gbnVtID0gbnVtIHwgKChyICYgYmluYXJ5LkJJVFM3KSA8PCBsZW4pXG4gICAgbnVtID0gbnVtICsgKHIgJiBCSVRTNykgKiBtdWx0OyAvLyBzaGlmdCAkciA8PCAoNyojaXRlcmF0aW9ucykgYW5kIGFkZCBpdCB0byBudW1cbiAgICBtdWx0ICo9IDEyODsgLy8gbmV4dCBpdGVyYXRpb24sIHNoaWZ0IDcgXCJtb3JlXCIgdG8gdGhlIGxlZnRcbiAgICBpZiAociA8IEJJVDgpIHtcbiAgICAgIHJldHVybiBudW1cbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKG51bSA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IGVycm9ySW50ZWdlck91dE9mUmFuZ2VcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgfVxuICB0aHJvdyBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5XG59O1xuXG4vKipcbiAqIFdlIGRvbid0IHRlc3QgdGhpcyBmdW5jdGlvbiBhbnltb3JlIGFzIHdlIHVzZSBuYXRpdmUgZGVjb2RpbmcvZW5jb2RpbmcgYnkgZGVmYXVsdCBub3cuXG4gKiBCZXR0ZXIgbm90IG1vZGlmeSB0aGlzIGFueW1vcmUuLlxuICpcbiAqIFRyYW5zZm9ybWluZyB1dGY4IHRvIGEgc3RyaW5nIGlzIHByZXR0eSBleHBlbnNpdmUuIFRoZSBjb2RlIHBlcmZvcm1zIDEweCBiZXR0ZXJcbiAqIHdoZW4gU3RyaW5nLmZyb21Db2RlUG9pbnQgaXMgZmVkIHdpdGggYWxsIGNoYXJhY3RlcnMgYXMgYXJndW1lbnRzLlxuICogQnV0IG1vc3QgZW52aXJvbm1lbnRzIGhhdmUgYSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgcGVyIGZ1bmN0aW9ucy5cbiAqIEZvciBlZmZpZW5jeSByZWFzb25zIHdlIGFwcGx5IGEgbWF4aW11bSBvZiAxMDAwMCBjaGFyYWN0ZXJzIGF0IG9uY2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nLlxuICovXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IF9yZWFkVmFyU3RyaW5nUG9seWZpbGwgPSBkZWNvZGVyID0+IHtcbiAgbGV0IHJlbWFpbmluZ0xlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIpO1xuICBpZiAocmVtYWluaW5nTGVuID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH0gZWxzZSB7XG4gICAgbGV0IGVuY29kZWRTdHJpbmcgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChyZWFkVWludDgoZGVjb2RlcikpOyAvLyByZW1lbWJlciB0byBkZWNyZWFzZSByZW1haW5pbmdMZW5cbiAgICBpZiAoLS1yZW1haW5pbmdMZW4gPCAxMDApIHsgLy8gZG8gbm90IGNyZWF0ZSBhIFVpbnQ4QXJyYXkgZm9yIHNtYWxsIHN0cmluZ3NcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4tLSkge1xuICAgICAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHJlYWRVaW50OChkZWNvZGVyKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4gPiAwKSB7XG4gICAgICAgIGNvbnN0IG5leHRMZW4gPSByZW1haW5pbmdMZW4gPCAxMDAwMCA/IHJlbWFpbmluZ0xlbiA6IDEwMDAwO1xuICAgICAgICAvLyB0aGlzIGlzIGRhbmdlcm91cywgd2UgY3JlYXRlIGEgZnJlc2ggYXJyYXkgdmlldyBmcm9tIHRoZSBleGlzdGluZyBidWZmZXJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBkZWNvZGVyLmFyci5zdWJhcnJheShkZWNvZGVyLnBvcywgZGVjb2Rlci5wb3MgKyBuZXh0TGVuKTtcbiAgICAgICAgZGVjb2Rlci5wb3MgKz0gbmV4dExlbjtcbiAgICAgICAgLy8gU3RhcnRpbmcgd2l0aCBFUzUuMSB3ZSBjYW4gc3VwcGx5IGEgZ2VuZXJpYyBhcnJheS1saWtlIG9iamVjdCBhcyBhcmd1bWVudHNcbiAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCAvKiogQHR5cGUge2FueX0gKi8gKGJ5dGVzKSk7XG4gICAgICAgIHJlbWFpbmluZ0xlbiAtPSBuZXh0TGVuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShlbmNvZGVkU3RyaW5nKSlcbiAgfVxufTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nXG4gKi9cbmNvbnN0IF9yZWFkVmFyU3RyaW5nTmF0aXZlID0gZGVjb2RlciA9PlxuICAvKiogQHR5cGUgYW55ICovICh1dGY4VGV4dERlY29kZXIpLmRlY29kZShyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG5cbi8qKlxuICogUmVhZCBzdHJpbmcgb2YgdmFyaWFibGUgbGVuZ3RoXG4gKiAqIHZhclVpbnQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmdcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVhZCBTdHJpbmdcbiAqXG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCByZWFkVmFyU3RyaW5nID0gdXRmOFRleHREZWNvZGVyID8gX3JlYWRWYXJTdHJpbmdOYXRpdmUgOiBfcmVhZFZhclN0cmluZ1BvbHlmaWxsO1xuXG52YXIgQXV0aE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChBdXRoTWVzc2FnZVR5cGUpIHtcbiAgICBBdXRoTWVzc2FnZVR5cGVbQXV0aE1lc3NhZ2VUeXBlW1wiVG9rZW5cIl0gPSAwXSA9IFwiVG9rZW5cIjtcbiAgICBBdXRoTWVzc2FnZVR5cGVbQXV0aE1lc3NhZ2VUeXBlW1wiUGVybWlzc2lvbkRlbmllZFwiXSA9IDFdID0gXCJQZXJtaXNzaW9uRGVuaWVkXCI7XG4gICAgQXV0aE1lc3NhZ2VUeXBlW0F1dGhNZXNzYWdlVHlwZVtcIkF1dGhlbnRpY2F0ZWRcIl0gPSAyXSA9IFwiQXV0aGVudGljYXRlZFwiO1xufSkoQXV0aE1lc3NhZ2VUeXBlIHx8IChBdXRoTWVzc2FnZVR5cGUgPSB7fSkpO1xuY29uc3Qgd3JpdGVBdXRoZW50aWNhdGlvbiA9IChlbmNvZGVyLCBhdXRoKSA9PiB7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIEF1dGhNZXNzYWdlVHlwZS5Ub2tlbik7XG4gICAgd3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgYXV0aCk7XG59O1xuY29uc3Qgd3JpdGVQZXJtaXNzaW9uRGVuaWVkID0gKGVuY29kZXIsIHJlYXNvbikgPT4ge1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBBdXRoTWVzc2FnZVR5cGUuUGVybWlzc2lvbkRlbmllZCk7XG4gICAgd3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgcmVhc29uKTtcbn07XG5jb25zdCB3cml0ZUF1dGhlbnRpY2F0ZWQgPSAoZW5jb2Rlciwgc2NvcGUpID0+IHtcbiAgICB3cml0ZVZhclVpbnQoZW5jb2RlciwgQXV0aE1lc3NhZ2VUeXBlLkF1dGhlbnRpY2F0ZWQpO1xuICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHNjb3BlKTtcbn07XG5jb25zdCB3cml0ZVRva2VuU3luY1JlcXVlc3QgPSAoZW5jb2RlcikgPT4ge1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBBdXRoTWVzc2FnZVR5cGUuVG9rZW4pO1xufTtcbmNvbnN0IHJlYWRBdXRoTWVzc2FnZSA9IChkZWNvZGVyLCBzZW5kVG9rZW4sIHBlcm1pc3Npb25EZW5pZWRIYW5kbGVyLCBhdXRoZW50aWNhdGVkSGFuZGxlcikgPT4ge1xuICAgIHN3aXRjaCAocmVhZFZhclVpbnQoZGVjb2RlcikpIHtcbiAgICAgICAgY2FzZSBBdXRoTWVzc2FnZVR5cGUuVG9rZW46IHtcbiAgICAgICAgICAgIHNlbmRUb2tlbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBBdXRoTWVzc2FnZVR5cGUuUGVybWlzc2lvbkRlbmllZDoge1xuICAgICAgICAgICAgcGVybWlzc2lvbkRlbmllZEhhbmRsZXIocmVhZFZhclN0cmluZyhkZWNvZGVyKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEF1dGhNZXNzYWdlVHlwZS5BdXRoZW50aWNhdGVkOiB7XG4gICAgICAgICAgICBhdXRoZW50aWNhdGVkSGFuZGxlcihyZWFkVmFyU3RyaW5nKGRlY29kZXIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgc2VydmVyIGlzIHRlcm1pbmF0aW5nIHRoZSBjb25uZWN0aW9uIGJlY2F1c2UgYSBkYXRhIGZyYW1lIHdhcyByZWNlaXZlZFxuICogdGhhdCBpcyB0b28gbGFyZ2UuXG4gKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50L2NvZGVcbiAqL1xuY29uc3QgTWVzc2FnZVRvb0JpZyA9IHtcbiAgICBjb2RlOiAxMDA5LFxuICAgIHJlYXNvbjogXCJNZXNzYWdlIFRvbyBCaWdcIixcbn07XG4vKipcbiAqIFRoZSBzZXJ2ZXIgc3VjY2Vzc2Z1bGx5IHByb2Nlc3NlZCB0aGUgcmVxdWVzdCwgYXNrcyB0aGF0IHRoZSByZXF1ZXN0ZXIgcmVzZXRcbiAqIGl0cyBkb2N1bWVudCB2aWV3LCBhbmQgaXMgbm90IHJldHVybmluZyBhbnkgY29udGVudC5cbiAqL1xuY29uc3QgUmVzZXRDb25uZWN0aW9uID0ge1xuICAgIGNvZGU6IDQyMDUsXG4gICAgcmVhc29uOiBcIlJlc2V0IENvbm5lY3Rpb25cIixcbn07XG4vKipcbiAqIFNpbWlsYXIgdG8gRm9yYmlkZGVuLCBidXQgc3BlY2lmaWNhbGx5IGZvciB1c2Ugd2hlbiBhdXRoZW50aWNhdGlvbiBpcyByZXF1aXJlZCBhbmQgaGFzXG4gKiBmYWlsZWQgb3IgaGFzIG5vdCB5ZXQgYmVlbiBwcm92aWRlZC5cbiAqL1xuY29uc3QgVW5hdXRob3JpemVkID0ge1xuICAgIGNvZGU6IDQ0MDEsXG4gICAgcmVhc29uOiBcIlVuYXV0aG9yaXplZFwiLFxufTtcbi8qKlxuICogVGhlIHJlcXVlc3QgY29udGFpbmVkIHZhbGlkIGRhdGEgYW5kIHdhcyB1bmRlcnN0b29kIGJ5IHRoZSBzZXJ2ZXIsIGJ1dCB0aGUgc2VydmVyXG4gKiBpcyByZWZ1c2luZyBhY3Rpb24uXG4gKi9cbmNvbnN0IEZvcmJpZGRlbiA9IHtcbiAgICBjb2RlOiA0NDAzLFxuICAgIHJlYXNvbjogXCJGb3JiaWRkZW5cIixcbn07XG4vKipcbiAqIFRoZSBzZXJ2ZXIgdGltZWQgb3V0IHdhaXRpbmcgZm9yIHRoZSByZXF1ZXN0LlxuICovXG5jb25zdCBDb25uZWN0aW9uVGltZW91dCA9IHtcbiAgICBjb2RlOiA0NDA4LFxuICAgIHJlYXNvbjogXCJDb25uZWN0aW9uIFRpbWVvdXRcIixcbn07XG5cbmNvbnN0IGF3YXJlbmVzc1N0YXRlc1RvQXJyYXkgPSAoc3RhdGVzKSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGVzLmVudHJpZXMoKSkubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudElkOiBrZXksXG4gICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU3RhdGUgb2YgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZGUvZG9jcy9XZWIvQVBJL1dlYlNvY2tldC9yZWFkeVN0YXRlXG4gKi9cbnZhciBXc1JlYWR5U3RhdGVzO1xuKGZ1bmN0aW9uIChXc1JlYWR5U3RhdGVzKSB7XG4gICAgV3NSZWFkeVN0YXRlc1tXc1JlYWR5U3RhdGVzW1wiQ29ubmVjdGluZ1wiXSA9IDBdID0gXCJDb25uZWN0aW5nXCI7XG4gICAgV3NSZWFkeVN0YXRlc1tXc1JlYWR5U3RhdGVzW1wiT3BlblwiXSA9IDFdID0gXCJPcGVuXCI7XG4gICAgV3NSZWFkeVN0YXRlc1tXc1JlYWR5U3RhdGVzW1wiQ2xvc2luZ1wiXSA9IDJdID0gXCJDbG9zaW5nXCI7XG4gICAgV3NSZWFkeVN0YXRlc1tXc1JlYWR5U3RhdGVzW1wiQ2xvc2VkXCJdID0gM10gPSBcIkNsb3NlZFwiO1xufSkoV3NSZWFkeVN0YXRlcyB8fCAoV3NSZWFkeVN0YXRlcyA9IHt9KSk7XG5cbmV4cG9ydCB7IEF1dGhNZXNzYWdlVHlwZSwgQ29ubmVjdGlvblRpbWVvdXQsIEZvcmJpZGRlbiwgTWVzc2FnZVRvb0JpZywgUmVzZXRDb25uZWN0aW9uLCBVbmF1dGhvcml6ZWQsIFdzUmVhZHlTdGF0ZXMsIGF3YXJlbmVzc1N0YXRlc1RvQXJyYXksIHJlYWRBdXRoTWVzc2FnZSwgd3JpdGVBdXRoZW50aWNhdGVkLCB3cml0ZUF1dGhlbnRpY2F0aW9uLCB3cml0ZVBlcm1pc3Npb25EZW5pZWQsIHdyaXRlVG9rZW5TeW5jUmVxdWVzdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9jdXNwb2N1cy1jb21tb24uZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AwarenessError: () => (/* binding */ AwarenessError),\n/* harmony export */   HocuspocusProvider: () => (/* binding */ HocuspocusProvider),\n/* harmony export */   HocuspocusProviderWebsocket: () => (/* binding */ HocuspocusProviderWebsocket),\n/* harmony export */   MessageType: () => (/* binding */ MessageType),\n/* harmony export */   WebSocketStatus: () => (/* binding */ WebSocketStatus)\n/* harmony export */ });\n/* harmony import */ var _hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hocuspocus/common */ \"(ssr)/./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _lifeomic_attempt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lifeomic/attempt */ \"(ssr)/./node_modules/@lifeomic/attempt/dist/es6/src/index.js\");\n\n\n\n\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b;\n\n/* eslint-env browser */\n\nconst BIT7 = 64;\nconst BIT8 = 128;\nconst BITS6 = 63;\nconst BITS7 = 127;\n\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nconst create$2 = () => new Set();\n\n/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nconst from = Array.from;\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i));\n  }\n  return buf\n};\n\n/* c8 ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\n\n/* c8 ignore next */\nlet utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true });\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null;\n}\n\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nclass Encoder {\n  constructor () {\n    this.cpos = 0;\n    this.cbuf = new Uint8Array(100);\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = [];\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nconst createEncoder = () => new Encoder();\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nconst length$1 = encoder => {\n  let len = encoder.cpos;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length;\n  }\n  return len\n};\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nconst toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length$1(encoder));\n  let curPos = 0;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i];\n    uint8arr.set(d, curPos);\n    curPos += d.length;\n  }\n  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n  return uint8arr\n};\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > BITS7) {\n    write(encoder, BIT8 | (BITS7 & num));\n    num = floor(num / 128); // shift >>> 7\n  }\n  write(encoder, BITS7 & num);\n};\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000);\nconst _maxStrBSize = _strBuffer.length / 3;\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n    writeVarUint(encoder, written);\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i]);\n    }\n  } else {\n    writeVarUint8Array(encoder, encodeUtf8(str));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nconst writeVarString = (utf8TextEncoder && /** @type {any} */ (utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill;\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf);\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\n\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nconst create$1 = s => new Error(s);\n\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n\nconst errorUnexpectedEndOfArray = create$1('Unexpected end of array');\nconst errorIntegerOutOfRange = create$1('Integer out of Range');\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nclass Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array;\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0;\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nconst createDecoder = uint8Array => new Decoder(uint8Array);\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view\n};\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder));\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++];\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0;\n  let mult = 1;\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & BITS7) * mult; // shift $r << (7*#iterations) and add it to num\n    mult *= 128; // next iteration, shift 7 \"more\" to the left\n    if (r < BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n};\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++];\n  let num = r & BITS6;\n  let mult = 64;\n  const sign = (r & BIT7) > 0 ? -1 : 1;\n  if ((r & BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & BITS7) * mult;\n    mult *= 128;\n    if (r < BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n};\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nconst _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n};\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nconst _readVarStringNative = decoder =>\n  /** @type any */ (utf8TextDecoder).decode(readVarUint8Array(decoder));\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nconst readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nconst peekVarString = decoder => {\n  const pos = decoder.pos;\n  const s = readVarString(decoder);\n  decoder.pos = pos;\n  return s\n};\n\n/**\n * Utility module to work with time.\n *\n * @module time\n */\n\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nconst getUnixTime = Date.now;\n\n/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nconst create = () => new Map();\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template {Map<any, any>} MAP\n * @template {MAP extends Map<any,infer V> ? function():V : unknown} CF\n * @param {MAP} map\n * @param {MAP extends Map<infer K,any> ? K : unknown} key\n * @param {CF} createT\n * @return {ReturnType<CF>}\n */\nconst setIfUndefined = (map, key, createT) => {\n  let set = map.get(key);\n  if (set === undefined) {\n    map.set(key, set = createT());\n  }\n  return set\n};\n\n/**\n * Observable class prototype.\n *\n * @module observable\n */\n\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nclass Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = create();\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    setIfUndefined(this._observers, name, create$2).add(f);\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f);\n      f(...args);\n    };\n    this.on(name, _f);\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name);\n    if (observers !== undefined) {\n      observers.delete(f);\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return from((this._observers.get(name) || create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = create();\n  }\n}\n/* c8 ignore end */\n\n/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n\n/**\n * @param {Object<string,any>} obj\n */\nconst keys = Object.keys;\n\n/**\n * @deprecated use object.size instead\n * @param {Object<string,any>} obj\n * @return {number}\n */\nconst length = obj => keys(obj).length;\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nconst hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\n\n/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nconst equalityStrict = (a, b) => a === b;\n\n/* c8 ignore start */\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (length(a) !== length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n};\n\n/**\n * @module awareness-protocol\n */\n\n\nconst outdatedTimeout = 30000;\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nclass Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super();\n    this.doc = doc;\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID;\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map();\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map();\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = getUnixTime();\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState());\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = [];\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid);\n        }\n      });\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout');\n      }\n    }, floor(outdatedTimeout / 10)));\n    doc.on('destroy', () => {\n      this.destroy();\n    });\n    this.setLocalState({});\n  }\n\n  destroy () {\n    this.emit('destroy', [this]);\n    this.setLocalState(null);\n    super.destroy();\n    clearInterval(this._checkInterval);\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID;\n    const currLocalMeta = this.meta.get(clientID);\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1;\n    const prevState = this.states.get(clientID);\n    if (state === null) {\n      this.states.delete(clientID);\n    } else {\n      this.states.set(clientID, state);\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: getUnixTime()\n    });\n    const added = [];\n    const updated = [];\n    const filteredUpdated = [];\n    const removed = [];\n    if (state === null) {\n      removed.push(clientID);\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID);\n      }\n    } else {\n      updated.push(clientID);\n      if (!equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID);\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local']);\n    }\n    this.emit('update', [{ added, updated, removed }, 'local']);\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState();\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      });\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nconst removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = [];\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i];\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID);\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID));\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: getUnixTime()\n        });\n      }\n      removed.push(clientID);\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin]);\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin]);\n  }\n};\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nconst encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length;\n  const encoder = createEncoder();\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i];\n    const state = states.get(clientID) || null;\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock;\n    writeVarUint(encoder, clientID);\n    writeVarUint(encoder, clock);\n    writeVarString(encoder, JSON.stringify(state));\n  }\n  return toUint8Array(encoder)\n};\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nconst applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = createDecoder(update);\n  const timestamp = getUnixTime();\n  const added = [];\n  const updated = [];\n  const filteredUpdated = [];\n  const removed = [];\n  const len = readVarUint(decoder);\n  for (let i = 0; i < len; i++) {\n    const clientID = readVarUint(decoder);\n    let clock = readVarUint(decoder);\n    const state = JSON.parse(readVarString(decoder));\n    const clientMeta = awareness.meta.get(clientID);\n    const prevState = awareness.states.get(clientID);\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock;\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++;\n        } else {\n          awareness.states.delete(clientID);\n        }\n      } else {\n        awareness.states.set(clientID, state);\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      });\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID);\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID);\n      } else if (state !== null) {\n        if (!equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID);\n        }\n        updated.push(clientID);\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin]);\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin]);\n  }\n};\n\nclass EventEmitter {\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n        this.callbacks = {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    on(event, fn) {\n        if (!this.callbacks[event]) {\n            this.callbacks[event] = [];\n        }\n        this.callbacks[event].push(fn);\n        return this;\n    }\n    emit(event, ...args) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            callbacks.forEach((callback) => callback.apply(this, args));\n        }\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    off(event, fn) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            if (fn) {\n                this.callbacks[event] = callbacks.filter((callback) => callback !== fn);\n            }\n            else {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    }\n    removeAllListeners() {\n        this.callbacks = {};\n    }\n}\n\nclass IncomingMessage {\n    constructor(data) {\n        this.data = data;\n        this.encoder = createEncoder();\n        this.decoder = createDecoder(new Uint8Array(this.data));\n    }\n    peekVarString() {\n        return peekVarString(this.decoder);\n    }\n    readVarUint() {\n        return readVarUint(this.decoder);\n    }\n    readVarString() {\n        return readVarString(this.decoder);\n    }\n    readVarUint8Array() {\n        return readVarUint8Array(this.decoder);\n    }\n    writeVarUint(type) {\n        return writeVarUint(this.encoder, type);\n    }\n    writeVarString(string) {\n        return writeVarString(this.encoder, string);\n    }\n    writeVarUint8Array(data) {\n        return writeVarUint8Array(this.encoder, data);\n    }\n    length() {\n        return length$1(this.encoder);\n    }\n}\n\nvar MessageType;\n(function (MessageType) {\n    MessageType[MessageType[\"Sync\"] = 0] = \"Sync\";\n    MessageType[MessageType[\"Awareness\"] = 1] = \"Awareness\";\n    MessageType[MessageType[\"Auth\"] = 2] = \"Auth\";\n    MessageType[MessageType[\"QueryAwareness\"] = 3] = \"QueryAwareness\";\n    MessageType[MessageType[\"Stateless\"] = 5] = \"Stateless\";\n    MessageType[MessageType[\"CLOSE\"] = 7] = \"CLOSE\";\n    MessageType[MessageType[\"SyncStatus\"] = 8] = \"SyncStatus\";\n})(MessageType || (MessageType = {}));\nvar WebSocketStatus;\n(function (WebSocketStatus) {\n    WebSocketStatus[\"Connecting\"] = \"connecting\";\n    WebSocketStatus[\"Connected\"] = \"connected\";\n    WebSocketStatus[\"Disconnected\"] = \"disconnected\";\n})(WebSocketStatus || (WebSocketStatus = {}));\n\nclass OutgoingMessage {\n    constructor() {\n        this.encoder = createEncoder();\n    }\n    get(args) {\n        return args.encoder;\n    }\n    toUint8Array() {\n        return toUint8Array(this.encoder);\n    }\n}\n\nclass CloseMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.CLOSE;\n        this.description = \"Ask the server to close the connection\";\n    }\n    get(args) {\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        return this.encoder;\n    }\n}\n\nclass HocuspocusProviderWebsocket extends EventEmitter {\n    constructor(configuration) {\n        super();\n        this.messageQueue = [];\n        this.configuration = {\n            url: \"\",\n            autoConnect: true,\n            // @ts-ignore\n            document: undefined,\n            WebSocketPolyfill: undefined,\n            // TODO: this should depend on awareness.outdatedTime\n            messageReconnectTimeout: 30000,\n            // 1 second\n            delay: 1000,\n            // instant\n            initialDelay: 0,\n            // double the delay each time\n            factor: 2,\n            // unlimited retries\n            maxAttempts: 0,\n            // wait at least 1 second\n            minDelay: 1000,\n            // at least every 30 seconds\n            maxDelay: 30000,\n            // randomize\n            jitter: true,\n            // retry forever\n            timeout: 0,\n            onOpen: () => null,\n            onConnect: () => null,\n            onMessage: () => null,\n            onOutgoingMessage: () => null,\n            onStatus: () => null,\n            onDisconnect: () => null,\n            onClose: () => null,\n            onDestroy: () => null,\n            onAwarenessUpdate: () => null,\n            onAwarenessChange: () => null,\n            handleTimeout: null,\n            providerMap: new Map(),\n        };\n        this.webSocket = null;\n        this.webSocketHandlers = {};\n        this.shouldConnect = true;\n        this.status = WebSocketStatus.Disconnected;\n        this.lastMessageReceived = 0;\n        this.identifier = 0;\n        this.intervals = {\n            connectionChecker: null,\n        };\n        this.connectionAttempt = null;\n        this.receivedOnOpenPayload = undefined;\n        this.closeTries = 0;\n        this.setConfiguration(configuration);\n        this.configuration.WebSocketPolyfill = configuration.WebSocketPolyfill\n            ? configuration.WebSocketPolyfill\n            : WebSocket;\n        this.on(\"open\", this.configuration.onOpen);\n        this.on(\"open\", this.onOpen.bind(this));\n        this.on(\"connect\", this.configuration.onConnect);\n        this.on(\"message\", this.configuration.onMessage);\n        this.on(\"outgoingMessage\", this.configuration.onOutgoingMessage);\n        this.on(\"status\", this.configuration.onStatus);\n        this.on(\"disconnect\", this.configuration.onDisconnect);\n        this.on(\"close\", this.configuration.onClose);\n        this.on(\"destroy\", this.configuration.onDestroy);\n        this.on(\"awarenessUpdate\", this.configuration.onAwarenessUpdate);\n        this.on(\"awarenessChange\", this.configuration.onAwarenessChange);\n        this.on(\"close\", this.onClose.bind(this));\n        this.on(\"message\", this.onMessage.bind(this));\n        this.intervals.connectionChecker = setInterval(this.checkConnection.bind(this), this.configuration.messageReconnectTimeout / 10);\n        if (this.shouldConnect) {\n            this.connect();\n        }\n    }\n    async onOpen(event) {\n        this.status = WebSocketStatus.Connected;\n        this.emit(\"status\", { status: WebSocketStatus.Connected });\n        this.cancelWebsocketRetry = undefined;\n        this.receivedOnOpenPayload = event;\n    }\n    attach(provider) {\n        this.configuration.providerMap.set(provider.configuration.name, provider);\n        if (this.status === WebSocketStatus.Disconnected && this.shouldConnect) {\n            this.connect();\n        }\n        if (this.receivedOnOpenPayload &&\n            this.status === WebSocketStatus.Connected) {\n            provider.onOpen(this.receivedOnOpenPayload);\n        }\n    }\n    detach(provider) {\n        if (this.configuration.providerMap.has(provider.configuration.name)) {\n            provider.send(CloseMessage, {\n                documentName: provider.configuration.name,\n            });\n            this.configuration.providerMap.delete(provider.configuration.name);\n        }\n    }\n    setConfiguration(configuration = {}) {\n        this.configuration = { ...this.configuration, ...configuration };\n        if (!this.configuration.autoConnect) {\n            this.shouldConnect = false;\n        }\n    }\n    async connect() {\n        if (this.status === WebSocketStatus.Connected) {\n            return;\n        }\n        // Always cancel any previously initiated connection retryer instances\n        if (this.cancelWebsocketRetry) {\n            this.cancelWebsocketRetry();\n            this.cancelWebsocketRetry = undefined;\n        }\n        this.receivedOnOpenPayload = undefined;\n        this.shouldConnect = true;\n        const abortableRetry = () => {\n            let cancelAttempt = false;\n            const retryPromise = (0,_lifeomic_attempt__WEBPACK_IMPORTED_MODULE_1__.retry)(this.createWebSocketConnection.bind(this), {\n                delay: this.configuration.delay,\n                initialDelay: this.configuration.initialDelay,\n                factor: this.configuration.factor,\n                maxAttempts: this.configuration.maxAttempts,\n                minDelay: this.configuration.minDelay,\n                maxDelay: this.configuration.maxDelay,\n                jitter: this.configuration.jitter,\n                timeout: this.configuration.timeout,\n                handleTimeout: this.configuration.handleTimeout,\n                beforeAttempt: (context) => {\n                    if (!this.shouldConnect || cancelAttempt) {\n                        context.abort();\n                    }\n                },\n            }).catch((error) => {\n                // If we aborted the connection attempt then dont throw an error\n                // ref: https://github.com/lifeomic/attempt/blob/master/src/index.ts#L136\n                if (error && error.code !== \"ATTEMPT_ABORTED\") {\n                    throw error;\n                }\n            });\n            return {\n                retryPromise,\n                cancelFunc: () => {\n                    cancelAttempt = true;\n                },\n            };\n        };\n        const { retryPromise, cancelFunc } = abortableRetry();\n        this.cancelWebsocketRetry = cancelFunc;\n        return retryPromise;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    attachWebSocketListeners(ws, reject) {\n        const { identifier } = ws;\n        const onMessageHandler = (payload) => this.emit(\"message\", payload);\n        const onCloseHandler = (payload) => this.emit(\"close\", { event: payload });\n        const onOpenHandler = (payload) => this.emit(\"open\", payload);\n        const onErrorHandler = (err) => {\n            reject(err);\n        };\n        this.webSocketHandlers[identifier] = {\n            message: onMessageHandler,\n            close: onCloseHandler,\n            open: onOpenHandler,\n            error: onErrorHandler,\n        };\n        const handlers = this.webSocketHandlers[ws.identifier];\n        Object.keys(handlers).forEach((name) => {\n            ws.addEventListener(name, handlers[name]);\n        });\n    }\n    cleanupWebSocket() {\n        if (!this.webSocket) {\n            return;\n        }\n        const { identifier } = this.webSocket;\n        const handlers = this.webSocketHandlers[identifier];\n        Object.keys(handlers).forEach((name) => {\n            var _a;\n            (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.removeEventListener(name, handlers[name]);\n            delete this.webSocketHandlers[identifier];\n        });\n        this.webSocket.close();\n        this.webSocket = null;\n    }\n    createWebSocketConnection() {\n        return new Promise((resolve, reject) => {\n            if (this.webSocket) {\n                this.messageQueue = [];\n                this.cleanupWebSocket();\n            }\n            this.lastMessageReceived = 0;\n            this.identifier += 1;\n            // Init the WebSocket connection\n            const ws = new this.configuration.WebSocketPolyfill(this.url);\n            ws.binaryType = \"arraybuffer\";\n            ws.identifier = this.identifier;\n            this.attachWebSocketListeners(ws, reject);\n            this.webSocket = ws;\n            // Reset the status\n            this.status = WebSocketStatus.Connecting;\n            this.emit(\"status\", { status: WebSocketStatus.Connecting });\n            // Store resolve/reject for later use\n            this.connectionAttempt = {\n                resolve,\n                reject,\n            };\n        });\n    }\n    onMessage(event) {\n        var _a;\n        this.resolveConnectionAttempt();\n        this.lastMessageReceived = getUnixTime();\n        const message = new IncomingMessage(event.data);\n        const documentName = message.peekVarString();\n        (_a = this.configuration.providerMap.get(documentName)) === null || _a === void 0 ? void 0 : _a.onMessage(event);\n    }\n    resolveConnectionAttempt() {\n        if (this.connectionAttempt) {\n            this.connectionAttempt.resolve();\n            this.connectionAttempt = null;\n            this.status = WebSocketStatus.Connected;\n            this.emit(\"status\", { status: WebSocketStatus.Connected });\n            this.emit(\"connect\");\n            this.messageQueue.forEach((message) => this.send(message));\n            this.messageQueue = [];\n        }\n    }\n    stopConnectionAttempt() {\n        this.connectionAttempt = null;\n    }\n    rejectConnectionAttempt() {\n        var _a;\n        (_a = this.connectionAttempt) === null || _a === void 0 ? void 0 : _a.reject();\n        this.connectionAttempt = null;\n    }\n    checkConnection() {\n        var _a;\n        // Dont check the connection when its not even established\n        if (this.status !== WebSocketStatus.Connected) {\n            return;\n        }\n        // Dont close the connection while waiting for the first message\n        if (!this.lastMessageReceived) {\n            return;\n        }\n        // Dont close the connection when a message was received recently\n        if (this.configuration.messageReconnectTimeout >=\n            getUnixTime() - this.lastMessageReceived) {\n            return;\n        }\n        // No message received in a long time, not even your own\n        // Awareness updates, which are updated every 15 seconds\n        // if awareness is enabled.\n        this.closeTries += 1;\n        // https://bugs.webkit.org/show_bug.cgi?id=247943\n        if (this.closeTries > 2) {\n            this.onClose({\n                event: {\n                    code: 4408,\n                    reason: \"forced\",\n                },\n            });\n            this.closeTries = 0;\n        }\n        else {\n            (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.close();\n            this.messageQueue = [];\n        }\n    }\n    // Ensure that the URL never ends with /\n    get serverUrl() {\n        while (this.configuration.url[this.configuration.url.length - 1] === \"/\") {\n            return this.configuration.url.slice(0, this.configuration.url.length - 1);\n        }\n        return this.configuration.url;\n    }\n    get url() {\n        return this.serverUrl;\n    }\n    disconnect() {\n        this.shouldConnect = false;\n        if (this.webSocket === null) {\n            return;\n        }\n        try {\n            this.webSocket.close();\n            this.messageQueue = [];\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    send(message) {\n        var _a;\n        if (((_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.readyState) === _hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.WsReadyStates.Open) {\n            this.webSocket.send(message);\n        }\n        else {\n            this.messageQueue.push(message);\n        }\n    }\n    onClose({ event }) {\n        this.closeTries = 0;\n        this.cleanupWebSocket();\n        if (this.connectionAttempt) {\n            // That connection attempt failed.\n            this.rejectConnectionAttempt();\n        }\n        // Lets update the connection status.\n        this.status = WebSocketStatus.Disconnected;\n        this.emit(\"status\", { status: WebSocketStatus.Disconnected });\n        this.emit(\"disconnect\", { event });\n        // trigger connect if no retry is running and we want to have a connection\n        if (!this.cancelWebsocketRetry && this.shouldConnect) {\n            setTimeout(() => {\n                this.connect();\n            }, this.configuration.delay);\n        }\n    }\n    destroy() {\n        this.emit(\"destroy\");\n        clearInterval(this.intervals.connectionChecker);\n        // If there is still a connection attempt outstanding then we should stop\n        // it before calling disconnect, otherwise it will be rejected in the onClose\n        // handler and trigger a retry\n        this.stopConnectionAttempt();\n        this.disconnect();\n        this.removeAllListeners();\n        this.cleanupWebSocket();\n    }\n}\n\n/**\n * @module sync-protocol\n */\n\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n *  YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n *  YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server should only reply to requests, and not initiate them.\n * Therefore it is necessary that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nconst messageYjsSyncStep1 = 0;\nconst messageYjsSyncStep2 = 1;\nconst messageYjsUpdate = 2;\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nconst writeSyncStep1 = (encoder, doc) => {\n  writeVarUint(encoder, messageYjsSyncStep1);\n  const sv = yjs__WEBPACK_IMPORTED_MODULE_2__.encodeStateVector(doc);\n  writeVarUint8Array(encoder, sv);\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nconst writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  writeVarUint(encoder, messageYjsSyncStep2);\n  writeVarUint8Array(encoder, yjs__WEBPACK_IMPORTED_MODULE_2__.encodeStateAsUpdate(doc, encodedStateVector));\n};\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nconst readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, readVarUint8Array(decoder));\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    yjs__WEBPACK_IMPORTED_MODULE_2__.applyUpdate(doc, readVarUint8Array(decoder), transactionOrigin);\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error('Caught error while handling a Yjs update', error);\n  }\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nconst writeUpdate = (encoder, update) => {\n  writeVarUint(encoder, messageYjsUpdate);\n  writeVarUint8Array(encoder, update);\n};\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readUpdate = readSyncStep2;\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Does not need to be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = readVarUint(decoder);\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc);\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin);\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin);\n      break\n    default:\n      throw new Error('Unknown message type')\n  }\n  return messageType\n};\n\nclass MessageReceiver {\n    constructor(message) {\n        this.message = message;\n    }\n    apply(provider, emitSynced) {\n        const { message } = this;\n        const type = message.readVarUint();\n        const emptyMessageLength = message.length();\n        switch (type) {\n            case MessageType.Sync:\n                this.applySyncMessage(provider, emitSynced);\n                break;\n            case MessageType.Awareness:\n                this.applyAwarenessMessage(provider);\n                break;\n            case MessageType.Auth:\n                this.applyAuthMessage(provider);\n                break;\n            case MessageType.QueryAwareness:\n                this.applyQueryAwarenessMessage(provider);\n                break;\n            case MessageType.Stateless:\n                provider.receiveStateless(readVarString(message.decoder));\n                break;\n            case MessageType.SyncStatus:\n                this.applySyncStatusMessage(provider, readVarInt(message.decoder) === 1);\n                break;\n            case MessageType.CLOSE:\n                // eslint-disable-next-line no-case-declarations\n                const event = {\n                    code: 1000,\n                    reason: readVarString(message.decoder),\n                    // @ts-ignore\n                    target: provider.configuration.websocketProvider.webSocket,\n                    type: \"close\",\n                };\n                provider.onClose();\n                provider.configuration.onClose({ event });\n                provider.forwardClose(event);\n                break;\n            default:\n                throw new Error(`Cant apply message of unknown type: ${type}`);\n        }\n        // Reply\n        if (message.length() > emptyMessageLength + 1) {\n            // length of documentName (considered in emptyMessageLength plus length of yjs sync type, set in applySyncMessage)\n            // @ts-ignore\n            provider.send(OutgoingMessage, { encoder: message.encoder });\n        }\n    }\n    applySyncMessage(provider, emitSynced) {\n        const { message } = this;\n        message.writeVarUint(MessageType.Sync);\n        // Apply update\n        const syncMessageType = readSyncMessage(message.decoder, message.encoder, provider.document, provider);\n        // Synced once we receive Step2\n        if (emitSynced && syncMessageType === messageYjsSyncStep2) {\n            provider.synced = true;\n        }\n    }\n    applySyncStatusMessage(provider, applied) {\n        if (applied) {\n            provider.decrementUnsyncedChanges();\n        }\n    }\n    applyAwarenessMessage(provider) {\n        if (!provider.awareness)\n            return;\n        const { message } = this;\n        applyAwarenessUpdate(provider.awareness, message.readVarUint8Array(), provider);\n    }\n    applyAuthMessage(provider) {\n        const { message } = this;\n        (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.readAuthMessage)(message.decoder, provider.sendToken.bind(provider), provider.permissionDeniedHandler.bind(provider), provider.authenticatedHandler.bind(provider));\n    }\n    applyQueryAwarenessMessage(provider) {\n        if (!provider.awareness)\n            return;\n        const { message } = this;\n        message.writeVarUint(MessageType.Awareness);\n        message.writeVarUint8Array(encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())));\n    }\n}\n\nclass MessageSender {\n    constructor(Message, args = {}) {\n        this.message = new Message();\n        this.encoder = this.message.get(args);\n    }\n    create() {\n        return toUint8Array(this.encoder);\n    }\n    send(webSocket) {\n        webSocket === null || webSocket === void 0 ? void 0 : webSocket.send(this.create());\n    }\n}\n\nclass AuthenticationMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Auth;\n        this.description = \"Authentication\";\n    }\n    get(args) {\n        if (typeof args.token === \"undefined\") {\n            throw new Error(\"The authentication message requires `token` as an argument.\");\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.writeAuthentication)(this.encoder, args.token);\n        return this.encoder;\n    }\n}\n\nclass AwarenessMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Awareness;\n        this.description = \"Awareness states update\";\n    }\n    get(args) {\n        if (typeof args.awareness === \"undefined\") {\n            throw new Error(\"The awareness message requires awareness as an argument\");\n        }\n        if (typeof args.clients === \"undefined\") {\n            throw new Error(\"The awareness message requires clients as an argument\");\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        let awarenessUpdate;\n        if (args.states === undefined) {\n            awarenessUpdate = encodeAwarenessUpdate(args.awareness, args.clients);\n        }\n        else {\n            awarenessUpdate = encodeAwarenessUpdate(args.awareness, args.clients, args.states);\n        }\n        writeVarUint8Array(this.encoder, awarenessUpdate);\n        return this.encoder;\n    }\n}\n\nclass StatelessMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Stateless;\n        this.description = \"A stateless message\";\n    }\n    get(args) {\n        var _a;\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeVarString(this.encoder, (_a = args.payload) !== null && _a !== void 0 ? _a : \"\");\n        return this.encoder;\n    }\n}\n\nclass SyncStepOneMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Sync;\n        this.description = \"First sync step\";\n    }\n    get(args) {\n        if (typeof args.document === \"undefined\") {\n            throw new Error(\"The sync step one message requires document as an argument\");\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeSyncStep1(this.encoder, args.document);\n        return this.encoder;\n    }\n}\n\nclass UpdateMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Sync;\n        this.description = \"A document update\";\n    }\n    get(args) {\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeUpdate(this.encoder, args.update);\n        return this.encoder;\n    }\n}\n\nclass AwarenessError extends Error {\n    constructor() {\n        super(...arguments);\n        this.code = 1001;\n    }\n}\nclass HocuspocusProvider extends EventEmitter {\n    constructor(configuration) {\n        var _a, _b, _c;\n        super();\n        this.configuration = {\n            name: \"\",\n            // @ts-ignore\n            document: undefined,\n            // @ts-ignore\n            awareness: undefined,\n            token: null,\n            forceSyncInterval: false,\n            onAuthenticated: () => null,\n            onAuthenticationFailed: () => null,\n            onOpen: () => null,\n            onConnect: () => null,\n            onMessage: () => null,\n            onOutgoingMessage: () => null,\n            onSynced: () => null,\n            onStatus: () => null,\n            onDisconnect: () => null,\n            onClose: () => null,\n            onDestroy: () => null,\n            onAwarenessUpdate: () => null,\n            onAwarenessChange: () => null,\n            onStateless: () => null,\n            onUnsyncedChanges: () => null,\n        };\n        this.isSynced = false;\n        this.unsyncedChanges = 0;\n        this.isAuthenticated = false;\n        this.authorizedScope = undefined;\n        // @internal\n        this.manageSocket = false;\n        this._isAttached = false;\n        this.intervals = {\n            forceSync: null,\n        };\n        this.boundDocumentUpdateHandler = this.documentUpdateHandler.bind(this);\n        this.boundAwarenessUpdateHandler = this.awarenessUpdateHandler.bind(this);\n        this.boundPageHide = this.pageHide.bind(this);\n        this.boundOnOpen = this.onOpen.bind(this);\n        this.boundOnClose = this.onClose.bind(this);\n        this.forwardConnect = () => this.emit(\"connect\");\n        this.forwardStatus = (e) => this.emit(\"status\", e);\n        this.forwardClose = (e) => this.emit(\"close\", e);\n        this.forwardDisconnect = (e) => this.emit(\"disconnect\", e);\n        this.forwardDestroy = () => this.emit(\"destroy\");\n        this.setConfiguration(configuration);\n        this.configuration.document = configuration.document\n            ? configuration.document\n            : new yjs__WEBPACK_IMPORTED_MODULE_2__.Doc();\n        this.configuration.awareness =\n            configuration.awareness !== undefined\n                ? configuration.awareness\n                : new Awareness(this.document);\n        this.on(\"open\", this.configuration.onOpen);\n        this.on(\"message\", this.configuration.onMessage);\n        this.on(\"outgoingMessage\", this.configuration.onOutgoingMessage);\n        this.on(\"synced\", this.configuration.onSynced);\n        this.on(\"destroy\", this.configuration.onDestroy);\n        this.on(\"awarenessUpdate\", this.configuration.onAwarenessUpdate);\n        this.on(\"awarenessChange\", this.configuration.onAwarenessChange);\n        this.on(\"stateless\", this.configuration.onStateless);\n        this.on(\"unsyncedChanges\", this.configuration.onUnsyncedChanges);\n        this.on(\"authenticated\", this.configuration.onAuthenticated);\n        this.on(\"authenticationFailed\", this.configuration.onAuthenticationFailed);\n        (_a = this.awareness) === null || _a === void 0 ? void 0 : _a.on(\"update\", () => {\n            this.emit(\"awarenessUpdate\", {\n                states: (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.awarenessStatesToArray)(this.awareness.getStates()),\n            });\n        });\n        (_b = this.awareness) === null || _b === void 0 ? void 0 : _b.on(\"change\", () => {\n            this.emit(\"awarenessChange\", {\n                states: (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.awarenessStatesToArray)(this.awareness.getStates()),\n            });\n        });\n        this.document.on(\"update\", this.boundDocumentUpdateHandler);\n        (_c = this.awareness) === null || _c === void 0 ? void 0 : _c.on(\"update\", this.boundAwarenessUpdateHandler);\n        this.registerEventListeners();\n        if (this.configuration.forceSyncInterval &&\n            typeof this.configuration.forceSyncInterval === \"number\") {\n            this.intervals.forceSync = setInterval(this.forceSync.bind(this), this.configuration.forceSyncInterval);\n        }\n        if (this.manageSocket) {\n            this.attach();\n        }\n    }\n    setConfiguration(configuration = {}) {\n        if (!configuration.websocketProvider) {\n            const websocketProviderConfig = configuration;\n            this.manageSocket = true;\n            this.configuration.websocketProvider = new HocuspocusProviderWebsocket({\n                url: websocketProviderConfig.url,\n            });\n        }\n        this.configuration = { ...this.configuration, ...configuration };\n    }\n    get document() {\n        return this.configuration.document;\n    }\n    get isAttached() {\n        return this._isAttached;\n    }\n    get awareness() {\n        return this.configuration.awareness;\n    }\n    get hasUnsyncedChanges() {\n        return this.unsyncedChanges > 0;\n    }\n    resetUnsyncedChanges() {\n        this.unsyncedChanges = 1;\n        this.emit(\"unsyncedChanges\", { number: this.unsyncedChanges });\n    }\n    incrementUnsyncedChanges() {\n        this.unsyncedChanges += 1;\n        this.emit(\"unsyncedChanges\", { number: this.unsyncedChanges });\n    }\n    decrementUnsyncedChanges() {\n        if (this.unsyncedChanges > 0) {\n            this.unsyncedChanges -= 1;\n        }\n        if (this.unsyncedChanges === 0) {\n            this.synced = true;\n        }\n        this.emit(\"unsyncedChanges\", { number: this.unsyncedChanges });\n    }\n    forceSync() {\n        this.resetUnsyncedChanges();\n        this.send(SyncStepOneMessage, {\n            document: this.document,\n            documentName: this.configuration.name,\n        });\n    }\n    pageHide() {\n        if (this.awareness) {\n            removeAwarenessStates(this.awareness, [this.document.clientID], \"page hide\");\n        }\n    }\n    registerEventListeners() {\n        if (typeof window === \"undefined\" || !(\"addEventListener\" in window)) {\n            return;\n        }\n        window.addEventListener(\"pagehide\", this.boundPageHide);\n    }\n    sendStateless(payload) {\n        this.send(StatelessMessage, {\n            documentName: this.configuration.name,\n            payload,\n        });\n    }\n    async sendToken() {\n        let token;\n        try {\n            token = await this.getToken();\n        }\n        catch (error) {\n            this.permissionDeniedHandler(`Failed to get token during sendToken(): ${error}`);\n            return;\n        }\n        this.send(AuthenticationMessage, {\n            token: token !== null && token !== void 0 ? token : \"\",\n            documentName: this.configuration.name,\n        });\n    }\n    documentUpdateHandler(update, origin) {\n        if (origin === this) {\n            return;\n        }\n        this.incrementUnsyncedChanges();\n        this.send(UpdateMessage, { update, documentName: this.configuration.name });\n    }\n    awarenessUpdateHandler({ added, updated, removed }, origin) {\n        const changedClients = added.concat(updated).concat(removed);\n        this.send(AwarenessMessage, {\n            awareness: this.awareness,\n            clients: changedClients,\n            documentName: this.configuration.name,\n        });\n    }\n    /**\n     * Indicates whether a first handshake with the server has been established\n     *\n     * Note: this does not mean all updates from the client have been persisted to the backend. For this,\n     * use `hasUnsyncedChanges`.\n     */\n    get synced() {\n        return this.isSynced;\n    }\n    set synced(state) {\n        if (this.isSynced === state) {\n            return;\n        }\n        this.isSynced = state;\n        if (state) {\n            this.emit(\"synced\", { state });\n        }\n    }\n    receiveStateless(payload) {\n        this.emit(\"stateless\", { payload });\n    }\n    // not needed, but provides backward compatibility with e.g. lexical/yjs\n    async connect() {\n        if (this.manageSocket) {\n            return this.configuration.websocketProvider.connect();\n        }\n        console.warn(\"HocuspocusProvider::connect() is deprecated and does not do anything. Please connect/disconnect on the websocketProvider, or attach/deattach providers.\");\n    }\n    disconnect() {\n        if (this.manageSocket) {\n            return this.configuration.websocketProvider.disconnect();\n        }\n        console.warn(\"HocuspocusProvider::disconnect() is deprecated and does not do anything. Please connect/disconnect on the websocketProvider, or attach/deattach providers.\");\n    }\n    async onOpen(event) {\n        this.isAuthenticated = false;\n        this.emit(\"open\", { event });\n        await this.sendToken();\n        this.startSync();\n    }\n    async getToken() {\n        if (typeof this.configuration.token === \"function\") {\n            const token = await this.configuration.token();\n            return token;\n        }\n        return this.configuration.token;\n    }\n    startSync() {\n        this.resetUnsyncedChanges();\n        this.send(SyncStepOneMessage, {\n            document: this.document,\n            documentName: this.configuration.name,\n        });\n        if (this.awareness && this.awareness.getLocalState() !== null) {\n            this.send(AwarenessMessage, {\n                awareness: this.awareness,\n                clients: [this.document.clientID],\n                documentName: this.configuration.name,\n            });\n        }\n    }\n    send(message, args) {\n        if (!this._isAttached)\n            return;\n        const messageSender = new MessageSender(message, args);\n        this.emit(\"outgoingMessage\", { message: messageSender.message });\n        messageSender.send(this.configuration.websocketProvider);\n    }\n    onMessage(event) {\n        const message = new IncomingMessage(event.data);\n        const documentName = message.readVarString();\n        message.writeVarString(documentName);\n        this.emit(\"message\", { event, message: new IncomingMessage(event.data) });\n        new MessageReceiver(message).apply(this, true);\n    }\n    onClose() {\n        this.isAuthenticated = false;\n        this.synced = false;\n        // update awareness (all users except local left)\n        if (this.awareness) {\n            removeAwarenessStates(this.awareness, Array.from(this.awareness.getStates().keys()).filter((client) => client !== this.document.clientID), this);\n        }\n    }\n    destroy() {\n        this.emit(\"destroy\");\n        if (this.intervals.forceSync) {\n            clearInterval(this.intervals.forceSync);\n        }\n        if (this.awareness) {\n            removeAwarenessStates(this.awareness, [this.document.clientID], \"provider destroy\");\n            this.awareness.off(\"update\", this.boundAwarenessUpdateHandler);\n            this.awareness.destroy();\n        }\n        this.document.off(\"update\", this.boundDocumentUpdateHandler);\n        this.removeAllListeners();\n        this.detach();\n        if (this.manageSocket) {\n            this.configuration.websocketProvider.destroy();\n        }\n        if (typeof window === \"undefined\" || !(\"removeEventListener\" in window)) {\n            return;\n        }\n        window.removeEventListener(\"pagehide\", this.boundPageHide);\n    }\n    detach() {\n        this.configuration.websocketProvider.off(\"connect\", this.configuration.onConnect);\n        this.configuration.websocketProvider.off(\"connect\", this.forwardConnect);\n        this.configuration.websocketProvider.off(\"status\", this.forwardStatus);\n        this.configuration.websocketProvider.off(\"status\", this.configuration.onStatus);\n        this.configuration.websocketProvider.off(\"open\", this.boundOnOpen);\n        this.configuration.websocketProvider.off(\"close\", this.boundOnClose);\n        this.configuration.websocketProvider.off(\"close\", this.configuration.onClose);\n        this.configuration.websocketProvider.off(\"close\", this.forwardClose);\n        this.configuration.websocketProvider.off(\"disconnect\", this.configuration.onDisconnect);\n        this.configuration.websocketProvider.off(\"disconnect\", this.forwardDisconnect);\n        this.configuration.websocketProvider.off(\"destroy\", this.configuration.onDestroy);\n        this.configuration.websocketProvider.off(\"destroy\", this.forwardDestroy);\n        this.configuration.websocketProvider.detach(this);\n        this._isAttached = false;\n    }\n    attach() {\n        if (this._isAttached)\n            return;\n        this.configuration.websocketProvider.on(\"connect\", this.configuration.onConnect);\n        this.configuration.websocketProvider.on(\"connect\", this.forwardConnect);\n        this.configuration.websocketProvider.on(\"status\", this.configuration.onStatus);\n        this.configuration.websocketProvider.on(\"status\", this.forwardStatus);\n        this.configuration.websocketProvider.on(\"open\", this.boundOnOpen);\n        this.configuration.websocketProvider.on(\"close\", this.boundOnClose);\n        this.configuration.websocketProvider.on(\"close\", this.configuration.onClose);\n        this.configuration.websocketProvider.on(\"close\", this.forwardClose);\n        this.configuration.websocketProvider.on(\"disconnect\", this.configuration.onDisconnect);\n        this.configuration.websocketProvider.on(\"disconnect\", this.forwardDisconnect);\n        this.configuration.websocketProvider.on(\"destroy\", this.configuration.onDestroy);\n        this.configuration.websocketProvider.on(\"destroy\", this.forwardDestroy);\n        this.configuration.websocketProvider.attach(this);\n        this._isAttached = true;\n    }\n    permissionDeniedHandler(reason) {\n        this.emit(\"authenticationFailed\", { reason });\n        this.isAuthenticated = false;\n    }\n    authenticatedHandler(scope) {\n        this.isAuthenticated = true;\n        this.authorizedScope = scope;\n        this.emit(\"authenticated\", { scope });\n    }\n    setAwarenessField(key, value) {\n        if (!this.awareness) {\n            throw new AwarenessError(`Cannot set awareness field \"${key}\" to ${JSON.stringify(value)}. You have disabled Awareness for this provider by explicitly passing awareness: null in the provider configuration.`);\n        }\n        this.awareness.setLocalStateField(key, value);\n    }\n}\n\n\n//# sourceMappingURL=hocuspocus-provider.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhvY3VzcG9jdXMvcHJvdmlkZXIvZGlzdC9ob2N1c3BvY3VzLXByb3ZpZGVyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFpSDtBQUN4RjtBQUNpQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxhQUFhOztBQUVoRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkZBQTZGLDhCQUE4Qjs7QUFFM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQ0FBZ0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUFpRDtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLElBQUksT0FBTyxzQkFBc0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7O0FBRXlHO0FBQ3pHIiwic291cmNlcyI6WyIvVXNlcnMvYXJ5YW5nb3lhbC9yZWFsLXRpbWUtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bob2N1c3BvY3VzL3Byb3ZpZGVyL2Rpc3QvaG9jdXNwb2N1cy1wcm92aWRlci5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV3NSZWFkeVN0YXRlcywgcmVhZEF1dGhNZXNzYWdlLCB3cml0ZUF1dGhlbnRpY2F0aW9uLCBhd2FyZW5lc3NTdGF0ZXNUb0FycmF5IH0gZnJvbSAnQGhvY3VzcG9jdXMvY29tbW9uJztcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJztcbmltcG9ydCB7IHJldHJ5IH0gZnJvbSAnQGxpZmVvbWljL2F0dGVtcHQnO1xuXG4vKipcbiAqIENvbW1vbiBNYXRoIGV4cHJlc3Npb25zLlxuICpcbiAqIEBtb2R1bGUgbWF0aFxuICovXG5cbmNvbnN0IGZsb29yID0gTWF0aC5mbG9vcjtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc21hbGxlciBlbGVtZW50IG9mIGEgYW5kIGJcbiAqL1xuY29uc3QgbWluID0gKGEsIGIpID0+IGEgPCBiID8gYSA6IGI7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGJpZ2dlciBlbGVtZW50IG9mIGEgYW5kIGJcbiAqL1xuY29uc3QgbWF4ID0gKGEsIGIpID0+IGEgPiBiID8gYSA6IGI7XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG5jb25zdCBCSVQ3ID0gNjQ7XG5jb25zdCBCSVQ4ID0gMTI4O1xuY29uc3QgQklUUzYgPSA2MztcbmNvbnN0IEJJVFM3ID0gMTI3O1xuXG4vKipcbiAqIFV0aWxpdHkgaGVscGVycyBmb3Igd29ya2luZyB3aXRoIG51bWJlcnMuXG4gKlxuICogQG1vZHVsZSBudW1iZXJcbiAqL1xuXG5cbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggc2V0cy5cbiAqXG4gKiBAbW9kdWxlIHNldFxuICovXG5cbmNvbnN0IGNyZWF0ZSQyID0gKCkgPT4gbmV3IFNldCgpO1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBBcnJheXMuXG4gKlxuICogQG1vZHVsZSBhcnJheVxuICovXG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHNvbWV0aGluZyBhcnJheS1saWtlIHRvIGFuIGFjdHVhbCBBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxUPnxJdGVyYWJsZTxUPn0gYXJyYXlsaWtlXG4gKiBAcmV0dXJuIHtUfVxuICovXG5jb25zdCBmcm9tID0gQXJyYXkuZnJvbTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBfZW5jb2RlVXRmOFBvbHlmaWxsID0gc3RyID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbiAgY29uc3QgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGg7XG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGVuY29kZWRTdHJpbmcuY29kZVBvaW50QXQoaSkpO1xuICB9XG4gIHJldHVybiBidWZcbn07XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCB1dGY4VGV4dEVuY29kZXIgPSAvKiogQHR5cGUge1RleHRFbmNvZGVyfSAqLyAodHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RW5jb2RlcigpIDogbnVsbCk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgX2VuY29kZVV0ZjhOYXRpdmUgPSBzdHIgPT4gdXRmOFRleHRFbmNvZGVyLmVuY29kZShzdHIpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCBlbmNvZGVVdGY4ID0gdXRmOFRleHRFbmNvZGVyID8gX2VuY29kZVV0ZjhOYXRpdmUgOiBfZW5jb2RlVXRmOFBvbHlmaWxsO1xuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xubGV0IHV0ZjhUZXh0RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUsIGlnbm9yZUJPTTogdHJ1ZSB9KTtcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5pZiAodXRmOFRleHREZWNvZGVyICYmIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxKSB7XG4gIC8vIFNhZmFyaSBkb2Vzbid0IGhhbmRsZSBCT00gY29ycmVjdGx5LlxuICAvLyBUaGlzIGZpeGVzIGEgYnVnIGluIFNhZmFyaSAxMy4wLjUgd2hlcmUgaXQgcHJvZHVjZXMgYSBCT00gdGhlIGZpcnN0IHRpbWUgaXQgaXMgY2FsbGVkLlxuICAvLyB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSBvbiB0aGUgZmlyc3QgY2FsbCBhbmRcbiAgLy8gdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEgb24gdGhlIHNlY29uZCBjYWxsXG4gIC8vIEFub3RoZXIgaXNzdWUgaXMgdGhhdCBmcm9tIHRoZW4gb24gbm8gQk9NIGNoYXJzIGFyZSByZWNvZ25pemVkIGFueW1vcmVcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgdXRmOFRleHREZWNvZGVyID0gbnVsbDtcbn1cblxuLyoqXG4gKiBFZmZpY2llbnQgc2NoZW1hLWxlc3MgYmluYXJ5IGVuY29kaW5nIHdpdGggc3VwcG9ydCBmb3IgdmFyaWFibGUgbGVuZ3RoIGVuY29kaW5nLlxuICpcbiAqIFVzZSBbbGliMC9lbmNvZGluZ10gd2l0aCBbbGliMC9kZWNvZGluZ10uIEV2ZXJ5IGVuY29kaW5nIGZ1bmN0aW9uIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjb2RpbmcgZnVuY3Rpb24uXG4gKlxuICogRW5jb2RlcyBudW1iZXJzIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgKGxlYXN0IHRvIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBvcmRlcilcbiAqIGFuZCBpcyBjb21wYXRpYmxlIHdpdGggR29sYW5nJ3MgYmluYXJ5IGVuY29kaW5nIChodHRwczovL2dvbGFuZy5vcmcvcGtnL2VuY29kaW5nL2JpbmFyeS8pXG4gKiB3aGljaCBpcyBhbHNvIHVzZWQgaW4gUHJvdG9jb2wgQnVmZmVycy5cbiAqXG4gKiBgYGBqc1xuICogLy8gZW5jb2Rpbmcgc3RlcFxuICogY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICogZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDI1NilcbiAqIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsICdIZWxsbyB3b3JsZCEnKVxuICogY29uc3QgYnVmID0gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVjb2Rpbmcgc3RlcFxuICogY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICogZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gPT4gMjU2XG4gKiBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpIC8vID0+ICdIZWxsbyB3b3JsZCEnXG4gKiBkZWNvZGluZy5oYXNDb250ZW50KGRlY29kZXIpIC8vID0+IGZhbHNlIC0gYWxsIGRhdGEgaXMgcmVhZFxuICogYGBgXG4gKlxuICogQG1vZHVsZSBlbmNvZGluZ1xuICovXG5cblxuLyoqXG4gKiBBIEJpbmFyeUVuY29kZXIgaGFuZGxlcyB0aGUgZW5jb2RpbmcgdG8gYW4gVWludDhBcnJheS5cbiAqL1xuY2xhc3MgRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmNwb3MgPSAwO1xuICAgIHRoaXMuY2J1ZiA9IG5ldyBVaW50OEFycmF5KDEwMCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFVpbnQ4QXJyYXk+fVxuICAgICAqL1xuICAgIHRoaXMuYnVmcyA9IFtdO1xuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtFbmNvZGVyfVxuICovXG5jb25zdCBjcmVhdGVFbmNvZGVyID0gKCkgPT4gbmV3IEVuY29kZXIoKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudCBsZW5ndGggb2YgdGhlIGVuY29kZWQgZGF0YS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBsZW5ndGgkMSA9IGVuY29kZXIgPT4ge1xuICBsZXQgbGVuID0gZW5jb2Rlci5jcG9zO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZXIuYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGxlbiArPSBlbmNvZGVyLmJ1ZnNbaV0ubGVuZ3RoO1xuICB9XG4gIHJldHVybiBsZW5cbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIHRvIFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IFRoZSBjcmVhdGVkIEFycmF5QnVmZmVyLlxuICovXG5jb25zdCB0b1VpbnQ4QXJyYXkgPSBlbmNvZGVyID0+IHtcbiAgY29uc3QgdWludDhhcnIgPSBuZXcgVWludDhBcnJheShsZW5ndGgkMShlbmNvZGVyKSk7XG4gIGxldCBjdXJQb3MgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZXIuYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGQgPSBlbmNvZGVyLmJ1ZnNbaV07XG4gICAgdWludDhhcnIuc2V0KGQsIGN1clBvcyk7XG4gICAgY3VyUG9zICs9IGQubGVuZ3RoO1xuICB9XG4gIHVpbnQ4YXJyLnNldChuZXcgVWludDhBcnJheShlbmNvZGVyLmNidWYuYnVmZmVyLCAwLCBlbmNvZGVyLmNwb3MpLCBjdXJQb3MpO1xuICByZXR1cm4gdWludDhhcnJcbn07XG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIGJ5dGUgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCB3cml0ZSA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aDtcbiAgaWYgKGVuY29kZXIuY3BvcyA9PT0gYnVmZmVyTGVuKSB7XG4gICAgZW5jb2Rlci5idWZzLnB1c2goZW5jb2Rlci5jYnVmKTtcbiAgICBlbmNvZGVyLmNidWYgPSBuZXcgVWludDhBcnJheShidWZmZXJMZW4gKiAyKTtcbiAgICBlbmNvZGVyLmNwb3MgPSAwO1xuICB9XG4gIGVuY29kZXIuY2J1ZltlbmNvZGVyLmNwb3MrK10gPSBudW07XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHVuc2lnbmVkIGludGVnZXIuIE1heCBlbmNvZGFibGUgaW50ZWdlciBpcyAyXjUzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCB3cml0ZVZhclVpbnQgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIHdoaWxlIChudW0gPiBCSVRTNykge1xuICAgIHdyaXRlKGVuY29kZXIsIEJJVDggfCAoQklUUzcgJiBudW0pKTtcbiAgICBudW0gPSBmbG9vcihudW0gLyAxMjgpOyAvLyBzaGlmdCA+Pj4gN1xuICB9XG4gIHdyaXRlKGVuY29kZXIsIEJJVFM3ICYgbnVtKTtcbn07XG5cbi8qKlxuICogQSBjYWNoZSB0byBzdG9yZSBzdHJpbmdzIHRlbXBvcmFyaWx5XG4gKi9cbmNvbnN0IF9zdHJCdWZmZXIgPSBuZXcgVWludDhBcnJheSgzMDAwMCk7XG5jb25zdCBfbWF4U3RyQlNpemUgPSBfc3RyQnVmZmVyLmxlbmd0aCAvIDM7XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGlmIChzdHIubGVuZ3RoIDwgX21heFN0ckJTaXplKSB7XG4gICAgLy8gV2UgY2FuIGVuY29kZSB0aGUgc3RyaW5nIGludG8gdGhlIGV4aXN0aW5nIGJ1ZmZlclxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgY29uc3Qgd3JpdHRlbiA9IHV0ZjhUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHN0ciwgX3N0ckJ1ZmZlcikud3JpdHRlbiB8fCAwO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCB3cml0dGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyaXR0ZW47IGkrKykge1xuICAgICAgd3JpdGUoZW5jb2RlciwgX3N0ckJ1ZmZlcltpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGVVdGY4KHN0cikpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuY29uc3QgX3dyaXRlVmFyU3RyaW5nUG9seWZpbGwgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGNvbnN0IGVuY29kZWRTdHJpbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gIGNvbnN0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoO1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHdyaXRlKGVuY29kZXIsIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSkpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IHdyaXRlVmFyU3RyaW5nID0gKHV0ZjhUZXh0RW5jb2RlciAmJiAvKiogQHR5cGUge2FueX0gKi8gKHV0ZjhUZXh0RW5jb2RlcikuZW5jb2RlSW50bykgPyBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgOiBfd3JpdGVWYXJTdHJpbmdQb2x5ZmlsbDtcblxuLyoqXG4gKiBBcHBlbmQgZml4ZWQtbGVuZ3RoIFVpbnQ4QXJyYXkgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5jb25zdCB3cml0ZVVpbnQ4QXJyYXkgPSAoZW5jb2RlciwgdWludDhBcnJheSkgPT4ge1xuICBjb25zdCBidWZmZXJMZW4gPSBlbmNvZGVyLmNidWYubGVuZ3RoO1xuICBjb25zdCBjcG9zID0gZW5jb2Rlci5jcG9zO1xuICBjb25zdCBsZWZ0Q29weUxlbiA9IG1pbihidWZmZXJMZW4gLSBjcG9zLCB1aW50OEFycmF5Lmxlbmd0aCk7XG4gIGNvbnN0IHJpZ2h0Q29weUxlbiA9IHVpbnQ4QXJyYXkubGVuZ3RoIC0gbGVmdENvcHlMZW47XG4gIGVuY29kZXIuY2J1Zi5zZXQodWludDhBcnJheS5zdWJhcnJheSgwLCBsZWZ0Q29weUxlbiksIGNwb3MpO1xuICBlbmNvZGVyLmNwb3MgKz0gbGVmdENvcHlMZW47XG4gIGlmIChyaWdodENvcHlMZW4gPiAwKSB7XG4gICAgLy8gU3RpbGwgc29tZXRoaW5nIHRvIHdyaXRlLCB3cml0ZSByaWdodCBoYWxmLi5cbiAgICAvLyBBcHBlbmQgbmV3IGJ1ZmZlclxuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1Zik7XG4gICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHNpemUgb2YgcmVtYWluaW5nIGJ1ZmZlclxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KG1heChidWZmZXJMZW4gKiAyLCByaWdodENvcHlMZW4pKTtcbiAgICAvLyBjb3B5IGFycmF5XG4gICAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KGxlZnRDb3B5TGVuKSk7XG4gICAgZW5jb2Rlci5jcG9zID0gcmlnaHRDb3B5TGVuO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGVuZCBhbiBVaW50OEFycmF5IHRvIEVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5jb25zdCB3cml0ZVZhclVpbnQ4QXJyYXkgPSAoZW5jb2RlciwgdWludDhBcnJheSkgPT4ge1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgdWludDhBcnJheS5ieXRlTGVuZ3RoKTtcbiAgd3JpdGVVaW50OEFycmF5KGVuY29kZXIsIHVpbnQ4QXJyYXkpO1xufTtcblxuLyoqXG4gKiBFcnJvciBoZWxwZXJzLlxuICpcbiAqIEBtb2R1bGUgZXJyb3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IGNyZWF0ZSQxID0gcyA9PiBuZXcgRXJyb3Iocyk7XG5cbi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBkZWNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZGVjb2RpbmddIHdpdGggW2xpYjAvZW5jb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAqIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAyNTYpXG4gKiBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCAnSGVsbG8gd29ybGQhJylcbiAqIGNvbnN0IGJ1ZiA9IGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIGRlY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZGVjb2RpbmdcbiAqL1xuXG5cbmNvbnN0IGVycm9yVW5leHBlY3RlZEVuZE9mQXJyYXkgPSBjcmVhdGUkMSgnVW5leHBlY3RlZCBlbmQgb2YgYXJyYXknKTtcbmNvbnN0IGVycm9ySW50ZWdlck91dE9mUmFuZ2UgPSBjcmVhdGUkMSgnSW50ZWdlciBvdXQgb2YgUmFuZ2UnKTtcblxuLyoqXG4gKiBBIERlY29kZXIgaGFuZGxlcyB0aGUgZGVjb2Rpbmcgb2YgYW4gVWludDhBcnJheS5cbiAqL1xuY2xhc3MgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXkgQmluYXJ5IGRhdGEgdG8gZGVjb2RlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIC8qKlxuICAgICAqIERlY29kaW5nIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXJyID0gdWludDhBcnJheTtcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGRlY29kaW5nIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDA7XG4gIH1cbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICogQHJldHVybiB7RGVjb2Rlcn1cbiAqL1xuY29uc3QgY3JlYXRlRGVjb2RlciA9IHVpbnQ4QXJyYXkgPT4gbmV3IERlY29kZXIodWludDhBcnJheSk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIFVpbnQ4QXJyYXkgdmlldyBvZiB0aGUgbmV4dCBgbGVuYCBieXRlcyBhbmQgYWR2YW5jZSB0aGUgcG9zaXRpb24gYnkgYGxlbmAuXG4gKlxuICogSW1wb3J0YW50OiBUaGUgVWludDhBcnJheSBzdGlsbCBwb2ludHMgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIE1ha2Ugc3VyZSB0byBkaXNjYXJkIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBwcmV2ZW50IGFueSBtZW1vcnkgbGVha3MuXG4gKiAgICAgICAgICAgIFVzZSBgYnVmZmVyLmNvcHlVaW50OEFycmF5YCB0byBjb3B5IHRoZSByZXN1bHQgaW50byBhIG5ldyBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFRoZSBsZW5ndGggb2YgYnl0ZXMgdG8gcmVhZFxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgcmVhZFVpbnQ4QXJyYXkgPSAoZGVjb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShkZWNvZGVyLmFyci5idWZmZXIsIGRlY29kZXIucG9zICsgZGVjb2Rlci5hcnIuYnl0ZU9mZnNldCwgbGVuKTtcbiAgZGVjb2Rlci5wb3MgKz0gbGVuO1xuICByZXR1cm4gdmlld1xufTtcblxuLyoqXG4gKiBSZWFkIHZhcmlhYmxlIGxlbmd0aCBVaW50OEFycmF5LlxuICpcbiAqIEltcG9ydGFudDogVGhlIFVpbnQ4QXJyYXkgc3RpbGwgcG9pbnRzIHRvIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLiBNYWtlIHN1cmUgdG8gZGlzY2FyZCB0aGUgcmVzdWx0IGFzIHNvb24gYXMgcG9zc2libGUgdG8gcHJldmVudCBhbnkgbWVtb3J5IGxlYWtzLlxuICogICAgICAgICAgICBVc2UgYGJ1ZmZlci5jb3B5VWludDhBcnJheWAgdG8gY29weSB0aGUgcmVzdWx0IGludG8gYSBuZXcgVWludDhBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgcmVhZFZhclVpbnQ4QXJyYXkgPSBkZWNvZGVyID0+IHJlYWRVaW50OEFycmF5KGRlY29kZXIsIHJlYWRWYXJVaW50KGRlY29kZXIpKTtcblxuLyoqXG4gKiBSZWFkIG9uZSBieXRlIGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHJldHVybiB7bnVtYmVyfSBVbnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gKi9cbmNvbnN0IHJlYWRVaW50OCA9IGRlY29kZXIgPT4gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK107XG5cbi8qKlxuICogUmVhZCB1bnNpZ25lZCBpbnRlZ2VyICgzMmJpdCkgd2l0aCB2YXJpYWJsZSBsZW5ndGguXG4gKiAxLzh0aCBvZiB0aGUgc3RvcmFnZSBpcyB1c2VkIGFzIGVuY29kaW5nIG92ZXJoZWFkLlxuICogICogbnVtYmVycyA8IDJeNyBpcyBzdG9yZWQgaW4gb25lIGJ5dGxlbmd0aFxuICogICogbnVtYmVycyA8IDJeMTQgaXMgc3RvcmVkIGluIHR3byBieWxlbmd0aFxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIubGVuZ3RoXG4gKi9cbmNvbnN0IHJlYWRWYXJVaW50ID0gZGVjb2RlciA9PiB7XG4gIGxldCBudW0gPSAwO1xuICBsZXQgbXVsdCA9IDE7XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIuYXJyLmxlbmd0aDtcbiAgd2hpbGUgKGRlY29kZXIucG9zIDwgbGVuKSB7XG4gICAgY29uc3QgciA9IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdO1xuICAgIC8vIG51bSA9IG51bSB8ICgociAmIGJpbmFyeS5CSVRTNykgPDwgbGVuKVxuICAgIG51bSA9IG51bSArIChyICYgQklUUzcpICogbXVsdDsgLy8gc2hpZnQgJHIgPDwgKDcqI2l0ZXJhdGlvbnMpIGFuZCBhZGQgaXQgdG8gbnVtXG4gICAgbXVsdCAqPSAxMjg7IC8vIG5leHQgaXRlcmF0aW9uLCBzaGlmdCA3IFwibW9yZVwiIHRvIHRoZSBsZWZ0XG4gICAgaWYgKHIgPCBCSVQ4KSB7XG4gICAgICByZXR1cm4gbnVtXG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChudW0gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aHJvdyBlcnJvckludGVnZXJPdXRPZlJhbmdlXG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gIH1cbiAgdGhyb3cgZXJyb3JVbmV4cGVjdGVkRW5kT2ZBcnJheVxufTtcblxuLyoqXG4gKiBSZWFkIHNpZ25lZCBpbnRlZ2VyICgzMmJpdCkgd2l0aCB2YXJpYWJsZSBsZW5ndGguXG4gKiAxLzh0aCBvZiB0aGUgc3RvcmFnZSBpcyB1c2VkIGFzIGVuY29kaW5nIG92ZXJoZWFkLlxuICogICogbnVtYmVycyA8IDJeNyBpcyBzdG9yZWQgaW4gb25lIGJ5dGxlbmd0aFxuICogICogbnVtYmVycyA8IDJeMTQgaXMgc3RvcmVkIGluIHR3byBieWxlbmd0aFxuICogQHRvZG8gVGhpcyBzaG91bGQgcHJvYmFibHkgY3JlYXRlIHRoZSBpbnZlcnNlIH5udW0gaWYgbnVtYmVyIGlzIG5lZ2F0aXZlIC0gYnV0IHRoaXMgd291bGQgYmUgYSBicmVha2luZyBjaGFuZ2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5sZW5ndGhcbiAqL1xuY29uc3QgcmVhZFZhckludCA9IGRlY29kZXIgPT4ge1xuICBsZXQgciA9IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdO1xuICBsZXQgbnVtID0gciAmIEJJVFM2O1xuICBsZXQgbXVsdCA9IDY0O1xuICBjb25zdCBzaWduID0gKHIgJiBCSVQ3KSA+IDAgPyAtMSA6IDE7XG4gIGlmICgociAmIEJJVDgpID09PSAwKSB7XG4gICAgLy8gZG9uJ3QgY29udGludWUgcmVhZGluZ1xuICAgIHJldHVybiBzaWduICogbnVtXG4gIH1cbiAgY29uc3QgbGVuID0gZGVjb2Rlci5hcnIubGVuZ3RoO1xuICB3aGlsZSAoZGVjb2Rlci5wb3MgPCBsZW4pIHtcbiAgICByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK107XG4gICAgLy8gbnVtID0gbnVtIHwgKChyICYgYmluYXJ5LkJJVFM3KSA8PCBsZW4pXG4gICAgbnVtID0gbnVtICsgKHIgJiBCSVRTNykgKiBtdWx0O1xuICAgIG11bHQgKj0gMTI4O1xuICAgIGlmIChyIDwgQklUOCkge1xuICAgICAgcmV0dXJuIHNpZ24gKiBudW1cbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKG51bSA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IGVycm9ySW50ZWdlck91dE9mUmFuZ2VcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgfVxuICB0aHJvdyBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5XG59O1xuXG4vKipcbiAqIFdlIGRvbid0IHRlc3QgdGhpcyBmdW5jdGlvbiBhbnltb3JlIGFzIHdlIHVzZSBuYXRpdmUgZGVjb2RpbmcvZW5jb2RpbmcgYnkgZGVmYXVsdCBub3cuXG4gKiBCZXR0ZXIgbm90IG1vZGlmeSB0aGlzIGFueW1vcmUuLlxuICpcbiAqIFRyYW5zZm9ybWluZyB1dGY4IHRvIGEgc3RyaW5nIGlzIHByZXR0eSBleHBlbnNpdmUuIFRoZSBjb2RlIHBlcmZvcm1zIDEweCBiZXR0ZXJcbiAqIHdoZW4gU3RyaW5nLmZyb21Db2RlUG9pbnQgaXMgZmVkIHdpdGggYWxsIGNoYXJhY3RlcnMgYXMgYXJndW1lbnRzLlxuICogQnV0IG1vc3QgZW52aXJvbm1lbnRzIGhhdmUgYSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgcGVyIGZ1bmN0aW9ucy5cbiAqIEZvciBlZmZpZW5jeSByZWFzb25zIHdlIGFwcGx5IGEgbWF4aW11bSBvZiAxMDAwMCBjaGFyYWN0ZXJzIGF0IG9uY2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nLlxuICovXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IF9yZWFkVmFyU3RyaW5nUG9seWZpbGwgPSBkZWNvZGVyID0+IHtcbiAgbGV0IHJlbWFpbmluZ0xlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIpO1xuICBpZiAocmVtYWluaW5nTGVuID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH0gZWxzZSB7XG4gICAgbGV0IGVuY29kZWRTdHJpbmcgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChyZWFkVWludDgoZGVjb2RlcikpOyAvLyByZW1lbWJlciB0byBkZWNyZWFzZSByZW1haW5pbmdMZW5cbiAgICBpZiAoLS1yZW1haW5pbmdMZW4gPCAxMDApIHsgLy8gZG8gbm90IGNyZWF0ZSBhIFVpbnQ4QXJyYXkgZm9yIHNtYWxsIHN0cmluZ3NcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4tLSkge1xuICAgICAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHJlYWRVaW50OChkZWNvZGVyKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4gPiAwKSB7XG4gICAgICAgIGNvbnN0IG5leHRMZW4gPSByZW1haW5pbmdMZW4gPCAxMDAwMCA/IHJlbWFpbmluZ0xlbiA6IDEwMDAwO1xuICAgICAgICAvLyB0aGlzIGlzIGRhbmdlcm91cywgd2UgY3JlYXRlIGEgZnJlc2ggYXJyYXkgdmlldyBmcm9tIHRoZSBleGlzdGluZyBidWZmZXJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBkZWNvZGVyLmFyci5zdWJhcnJheShkZWNvZGVyLnBvcywgZGVjb2Rlci5wb3MgKyBuZXh0TGVuKTtcbiAgICAgICAgZGVjb2Rlci5wb3MgKz0gbmV4dExlbjtcbiAgICAgICAgLy8gU3RhcnRpbmcgd2l0aCBFUzUuMSB3ZSBjYW4gc3VwcGx5IGEgZ2VuZXJpYyBhcnJheS1saWtlIG9iamVjdCBhcyBhcmd1bWVudHNcbiAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCAvKiogQHR5cGUge2FueX0gKi8gKGJ5dGVzKSk7XG4gICAgICAgIHJlbWFpbmluZ0xlbiAtPSBuZXh0TGVuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShlbmNvZGVkU3RyaW5nKSlcbiAgfVxufTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nXG4gKi9cbmNvbnN0IF9yZWFkVmFyU3RyaW5nTmF0aXZlID0gZGVjb2RlciA9PlxuICAvKiogQHR5cGUgYW55ICovICh1dGY4VGV4dERlY29kZXIpLmRlY29kZShyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG5cbi8qKlxuICogUmVhZCBzdHJpbmcgb2YgdmFyaWFibGUgbGVuZ3RoXG4gKiAqIHZhclVpbnQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmdcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVhZCBTdHJpbmdcbiAqXG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCByZWFkVmFyU3RyaW5nID0gdXRmOFRleHREZWNvZGVyID8gX3JlYWRWYXJTdHJpbmdOYXRpdmUgOiBfcmVhZFZhclN0cmluZ1BvbHlmaWxsO1xuXG4vKipcbiAqIExvb2sgYWhlYWQgYW5kIHJlYWQgdmFyU3RyaW5nIHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgcGVla1ZhclN0cmluZyA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBwb3MgPSBkZWNvZGVyLnBvcztcbiAgY29uc3QgcyA9IHJlYWRWYXJTdHJpbmcoZGVjb2Rlcik7XG4gIGRlY29kZXIucG9zID0gcG9zO1xuICByZXR1cm4gc1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggdGltZS5cbiAqXG4gKiBAbW9kdWxlIHRpbWVcbiAqL1xuXG5cbi8qKlxuICogUmV0dXJuIGN1cnJlbnQgdW5peCB0aW1lLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgZ2V0VW5peFRpbWUgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGgga2V5LXZhbHVlIHN0b3Jlcy5cbiAqXG4gKiBAbW9kdWxlIG1hcFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBNYXAgaW5zdGFuY2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtNYXA8YW55LCBhbnk+fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGUgPSAoKSA9PiBuZXcgTWFwKCk7XG5cbi8qKlxuICogR2V0IG1hcCBwcm9wZXJ0eS4gQ3JlYXRlIFQgaWYgcHJvcGVydHkgaXMgdW5kZWZpbmVkIGFuZCBzZXQgVCBvbiBtYXAuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxpc3RlbmVycyA9IG1hcC5zZXRJZlVuZGVmaW5lZChldmVudHMsICdldmVudE5hbWUnLCBzZXQuY3JlYXRlKVxuICogbGlzdGVuZXJzLmFkZChsaXN0ZW5lcilcbiAqIGBgYFxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIHtNYXA8YW55LCBhbnk+fSBNQVBcbiAqIEB0ZW1wbGF0ZSB7TUFQIGV4dGVuZHMgTWFwPGFueSxpbmZlciBWPiA/IGZ1bmN0aW9uKCk6ViA6IHVua25vd259IENGXG4gKiBAcGFyYW0ge01BUH0gbWFwXG4gKiBAcGFyYW0ge01BUCBleHRlbmRzIE1hcDxpbmZlciBLLGFueT4gPyBLIDogdW5rbm93bn0ga2V5XG4gKiBAcGFyYW0ge0NGfSBjcmVhdGVUXG4gKiBAcmV0dXJuIHtSZXR1cm5UeXBlPENGPn1cbiAqL1xuY29uc3Qgc2V0SWZVbmRlZmluZWQgPSAobWFwLCBrZXksIGNyZWF0ZVQpID0+IHtcbiAgbGV0IHNldCA9IG1hcC5nZXQoa2V5KTtcbiAgaWYgKHNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFwLnNldChrZXksIHNldCA9IGNyZWF0ZVQoKSk7XG4gIH1cbiAgcmV0dXJuIHNldFxufTtcblxuLyoqXG4gKiBPYnNlcnZhYmxlIGNsYXNzIHByb3RvdHlwZS5cbiAqXG4gKiBAbW9kdWxlIG9ic2VydmFibGVcbiAqL1xuXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBIYW5kbGVzIG5hbWVkIGV2ZW50cy5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQHRlbXBsYXRlIE5cbiAqL1xuY2xhc3MgT2JzZXJ2YWJsZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBTb21lIGRlc2MuXG4gICAgICogQHR5cGUge01hcDxOLCBhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuX29ic2VydmVycyA9IGNyZWF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvbiAobmFtZSwgZikge1xuICAgIHNldElmVW5kZWZpbmVkKHRoaXMuX29ic2VydmVycywgbmFtZSwgY3JlYXRlJDIpLmFkZChmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb25jZSAobmFtZSwgZikge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuICAgICAqL1xuICAgIGNvbnN0IF9mID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRoaXMub2ZmKG5hbWUsIF9mKTtcbiAgICAgIGYoLi4uYXJncyk7XG4gICAgfTtcbiAgICB0aGlzLm9uKG5hbWUsIF9mKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb2ZmIChuYW1lLCBmKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXJzID0gdGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKTtcbiAgICBpZiAob2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9ic2VydmVycy5kZWxldGUoZik7XG4gICAgICBpZiAob2JzZXJ2ZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmRlbGV0ZShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhIG5hbWVkIGV2ZW50LiBBbGwgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMgdGhhdCBsaXN0ZW4gdG8gdGhlXG4gICAqIHNwZWNpZmllZCBuYW1lIHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEB0b2RvIFRoaXMgc2hvdWxkIGNhdGNoIGV4Y2VwdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtOfSBuYW1lIFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyZ3MgVGhlIGFyZ3VtZW50cyB0aGF0IGFyZSBhcHBsaWVkIHRvIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIGVtaXQgKG5hbWUsIGFyZ3MpIHtcbiAgICAvLyBjb3B5IGFsbCBsaXN0ZW5lcnMgdG8gYW4gYXJyYXkgZmlyc3QgdG8gbWFrZSBzdXJlIHRoYXQgbm8gZXZlbnQgaXMgZW1pdHRlZCB0byBsaXN0ZW5lcnMgdGhhdCBhcmUgc3Vic2NyaWJlZCB3aGlsZSB0aGUgZXZlbnQgaGFuZGxlciBpcyBjYWxsZWQuXG4gICAgcmV0dXJuIGZyb20oKHRoaXMuX29ic2VydmVycy5nZXQobmFtZSkgfHwgY3JlYXRlKCkpLnZhbHVlcygpKS5mb3JFYWNoKGYgPT4gZiguLi5hcmdzKSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX29ic2VydmVycyA9IGNyZWF0ZSgpO1xuICB9XG59XG4vKiBjOCBpZ25vcmUgZW5kICovXG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBFY21hU2NyaXB0IG9iamVjdHMuXG4gKlxuICogQG1vZHVsZSBvYmplY3RcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICovXG5jb25zdCBrZXlzID0gT2JqZWN0LmtleXM7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIG9iamVjdC5zaXplIGluc3RlYWRcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgbGVuZ3RoID0gb2JqID0+IGtleXMob2JqKS5sZW5ndGg7XG5cbi8qKlxuICogQ2FsbHMgYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7YW55fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfHN5bWJvbH0ga2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBoYXNQcm9wZXJ0eSA9IChvYmosIGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcblxuLyoqXG4gKiBDb21tb24gZnVuY3Rpb25zIGFuZCBmdW5jdGlvbiBjYWxsIGhlbHBlcnMuXG4gKlxuICogQG1vZHVsZSBmdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEBwYXJhbSB7VH0gYVxuICogQHBhcmFtIHtUfSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBlcXVhbGl0eVN0cmljdCA9IChhLCBiKSA9PiBhID09PSBiO1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVxdWFsaXR5RGVlcCA9IChhLCBiKSA9PiB7XG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVxdWFsaXR5U3RyaWN0KGEsIGIpXG4gIH1cbiAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgc3dpdGNoIChhLmNvbnN0cnVjdG9yKSB7XG4gICAgY2FzZSBBcnJheUJ1ZmZlcjpcbiAgICAgIGEgPSBuZXcgVWludDhBcnJheShhKTtcbiAgICAgIGIgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICBjYXNlIFVpbnQ4QXJyYXk6IHtcbiAgICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIFNldDoge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBhKSB7XG4gICAgICAgIGlmICghYi5oYXModmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgTWFwOiB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhLmtleXMoKSkge1xuICAgICAgICBpZiAoIWIuaGFzKGtleSkgfHwgIWVxdWFsaXR5RGVlcChhLmdldChrZXkpLCBiLmdldChrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIE9iamVjdDpcbiAgICAgIGlmIChsZW5ndGgoYSkgIT09IGxlbmd0aChiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wZXJ0eShhLCBrZXkpIHx8ICFlcXVhbGl0eURlZXAoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSBBcnJheTpcbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFlcXVhbGl0eURlZXAoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8qKlxuICogQG1vZHVsZSBhd2FyZW5lc3MtcHJvdG9jb2xcbiAqL1xuXG5cbmNvbnN0IG91dGRhdGVkVGltZW91dCA9IDMwMDAwO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFDbGllbnRTdGF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IE1ldGFDbGllbnRTdGF0ZS5jbG9ja1xuICogQHByb3BlcnR5IHtudW1iZXJ9IE1ldGFDbGllbnRTdGF0ZS5sYXN0VXBkYXRlZCB1bml4IHRpbWVzdGFtcFxuICovXG5cbi8qKlxuICogVGhlIEF3YXJlbmVzcyBjbGFzcyBpbXBsZW1lbnRzIGEgc2ltcGxlIHNoYXJlZCBzdGF0ZSBwcm90b2NvbCB0aGF0IGNhbiBiZSB1c2VkIGZvciBub24tcGVyc2lzdGVudCBkYXRhIGxpa2UgYXdhcmVuZXNzIGluZm9ybWF0aW9uXG4gKiAoY3Vyc29yLCB1c2VybmFtZSwgc3RhdHVzLCAuLikuIEVhY2ggY2xpZW50IGNhbiB1cGRhdGUgaXRzIG93biBsb2NhbCBzdGF0ZSBhbmQgbGlzdGVuIHRvIHN0YXRlIGNoYW5nZXMgb2ZcbiAqIHJlbW90ZSBjbGllbnRzLiBFdmVyeSBjbGllbnQgbWF5IHNldCBhIHN0YXRlIG9mIGEgcmVtb3RlIHBlZXIgdG8gYG51bGxgIHRvIG1hcmsgdGhlIGNsaWVudCBhcyBvZmZsaW5lLlxuICpcbiAqIEVhY2ggY2xpZW50IGlzIGlkZW50aWZpZWQgYnkgYSB1bmlxdWUgY2xpZW50IGlkIChzb21ldGhpbmcgd2UgYm9ycm93IGZyb20gYGRvYy5jbGllbnRJRGApLiBBIGNsaWVudCBjYW4gb3ZlcnJpZGVcbiAqIGl0cyBvd24gc3RhdGUgYnkgcHJvcGFnYXRpbmcgYSBtZXNzYWdlIHdpdGggYW4gaW5jcmVhc2luZyB0aW1lc3RhbXAgKGBjbG9ja2ApLiBJZiBzdWNoIGEgbWVzc2FnZSBpcyByZWNlaXZlZCwgaXQgaXNcbiAqIGFwcGxpZWQgaWYgdGhlIGtub3duIHN0YXRlIG9mIHRoYXQgY2xpZW50IGlzIG9sZGVyIHRoYW4gdGhlIG5ldyBzdGF0ZSAoYGNsb2NrIDwgbmV3Q2xvY2tgKS4gSWYgYSBjbGllbnQgdGhpbmtzIHRoYXRcbiAqIGEgcmVtb3RlIGNsaWVudCBpcyBvZmZsaW5lLCBpdCBtYXkgcHJvcGFnYXRlIGEgbWVzc2FnZSB3aXRoXG4gKiBgeyBjbG9jazogY3VycmVudENsaWVudENsb2NrLCBzdGF0ZTogbnVsbCwgY2xpZW50OiByZW1vdGVDbGllbnQgfWAuIElmIHN1Y2ggYVxuICogbWVzc2FnZSBpcyByZWNlaXZlZCwgYW5kIHRoZSBrbm93biBjbG9jayBvZiB0aGF0IGNsaWVudCBlcXVhbHMgdGhlIHJlY2VpdmVkIGNsb2NrLCBpdCB3aWxsIG92ZXJyaWRlIHRoZSBzdGF0ZSB3aXRoIGBudWxsYC5cbiAqXG4gKiBCZWZvcmUgYSBjbGllbnQgZGlzY29ubmVjdHMsIGl0IHNob3VsZCBwcm9wYWdhdGUgYSBgbnVsbGAgc3RhdGUgd2l0aCBhbiB1cGRhdGVkIGNsb2NrLlxuICpcbiAqIEF3YXJlbmVzcyBzdGF0ZXMgbXVzdCBiZSB1cGRhdGVkIGV2ZXJ5IDMwIHNlY29uZHMuIE90aGVyd2lzZSB0aGUgQXdhcmVuZXNzIGluc3RhbmNlIHdpbGwgZGVsZXRlIHRoZSBjbGllbnQgc3RhdGUuXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8c3RyaW5nPn1cbiAqL1xuY2xhc3MgQXdhcmVuZXNzIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb2MpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRJRCA9IGRvYy5jbGllbnRJRDtcbiAgICAvKipcbiAgICAgKiBNYXBzIGZyb20gY2xpZW50IGlkIHRvIGNsaWVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBPYmplY3Q8c3RyaW5nLCBhbnk+Pn1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgTWV0YUNsaWVudFN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fY2hlY2tJbnRlcnZhbCA9IC8qKiBAdHlwZSB7YW55fSAqLyAoc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gZ2V0VW5peFRpbWUoKTtcbiAgICAgIGlmICh0aGlzLmdldExvY2FsU3RhdGUoKSAhPT0gbnVsbCAmJiAob3V0ZGF0ZWRUaW1lb3V0IC8gMiA8PSBub3cgLSAvKiogQHR5cGUge3tsYXN0VXBkYXRlZDpudW1iZXJ9fSAqLyAodGhpcy5tZXRhLmdldCh0aGlzLmNsaWVudElEKSkubGFzdFVwZGF0ZWQpKSB7XG4gICAgICAgIC8vIHJlbmV3IGxvY2FsIGNsb2NrXG4gICAgICAgIHRoaXMuc2V0TG9jYWxTdGF0ZSh0aGlzLmdldExvY2FsU3RhdGUoKSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAgICovXG4gICAgICBjb25zdCByZW1vdmUgPSBbXTtcbiAgICAgIHRoaXMubWV0YS5mb3JFYWNoKChtZXRhLCBjbGllbnRpZCkgPT4ge1xuICAgICAgICBpZiAoY2xpZW50aWQgIT09IHRoaXMuY2xpZW50SUQgJiYgb3V0ZGF0ZWRUaW1lb3V0IDw9IG5vdyAtIG1ldGEubGFzdFVwZGF0ZWQgJiYgdGhpcy5zdGF0ZXMuaGFzKGNsaWVudGlkKSkge1xuICAgICAgICAgIHJlbW92ZS5wdXNoKGNsaWVudGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHRoaXMsIHJlbW92ZSwgJ3RpbWVvdXQnKTtcbiAgICAgIH1cbiAgICB9LCBmbG9vcihvdXRkYXRlZFRpbWVvdXQgLyAxMCkpKTtcbiAgICBkb2Mub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICB0aGlzLnNldExvY2FsU3RhdGUoe30pO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JywgW3RoaXNdKTtcbiAgICB0aGlzLnNldExvY2FsU3RhdGUobnVsbCk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tJbnRlcnZhbCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxhbnk+fG51bGx9XG4gICAqL1xuICBnZXRMb2NhbFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXMuZ2V0KHRoaXMuY2xpZW50SUQpIHx8IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55PnxudWxsfSBzdGF0ZVxuICAgKi9cbiAgc2V0TG9jYWxTdGF0ZSAoc3RhdGUpIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IHRoaXMuY2xpZW50SUQ7XG4gICAgY29uc3QgY3VyckxvY2FsTWV0YSA9IHRoaXMubWV0YS5nZXQoY2xpZW50SUQpO1xuICAgIGNvbnN0IGNsb2NrID0gY3VyckxvY2FsTWV0YSA9PT0gdW5kZWZpbmVkID8gMCA6IGN1cnJMb2NhbE1ldGEuY2xvY2sgKyAxO1xuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc3RhdGVzLmdldChjbGllbnRJRCk7XG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlcy5zZXQoY2xpZW50SUQsIHN0YXRlKTtcbiAgICB9XG4gICAgdGhpcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgY2xvY2ssXG4gICAgICBsYXN0VXBkYXRlZDogZ2V0VW5peFRpbWUoKVxuICAgIH0pO1xuICAgIGNvbnN0IGFkZGVkID0gW107XG4gICAgY29uc3QgdXBkYXRlZCA9IFtdO1xuICAgIGNvbnN0IGZpbHRlcmVkVXBkYXRlZCA9IFtdO1xuICAgIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHJlbW92ZWQucHVzaChjbGllbnRJRCk7XG4gICAgfSBlbHNlIGlmIChwcmV2U3RhdGUgPT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgYWRkZWQucHVzaChjbGllbnRJRCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZWQucHVzaChjbGllbnRJRCk7XG4gICAgICBpZiAoIWVxdWFsaXR5RGVlcChwcmV2U3RhdGUsIHN0YXRlKSkge1xuICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IGZpbHRlcmVkVXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCBbeyBhZGRlZCwgdXBkYXRlZDogZmlsdGVyZWRVcGRhdGVkLCByZW1vdmVkIH0sICdsb2NhbCddKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBbeyBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZCB9LCAnbG9jYWwnXSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKi9cbiAgc2V0TG9jYWxTdGF0ZUZpZWxkIChmaWVsZCwgdmFsdWUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0TG9jYWxTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5zZXRMb2NhbFN0YXRlKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFtmaWVsZF06IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TWFwPG51bWJlcixPYmplY3Q8c3RyaW5nLGFueT4+fVxuICAgKi9cbiAgZ2V0U3RhdGVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNcbiAgfVxufVxuXG4vKipcbiAqIE1hcmsgKHJlbW90ZSkgY2xpZW50cyBhcyBpbmFjdGl2ZSBhbmQgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgcGVlcnMuXG4gKiBUaGlzIGNoYW5nZSB3aWxsIGJlIHByb3BhZ2F0ZWQgdG8gcmVtb3RlIGNsaWVudHMuXG4gKlxuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbGllbnRzXG4gKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gKi9cbmNvbnN0IHJlbW92ZUF3YXJlbmVzc1N0YXRlcyA9IChhd2FyZW5lc3MsIGNsaWVudHMsIG9yaWdpbikgPT4ge1xuICBjb25zdCByZW1vdmVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2xpZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gY2xpZW50c1tpXTtcbiAgICBpZiAoYXdhcmVuZXNzLnN0YXRlcy5oYXMoY2xpZW50SUQpKSB7XG4gICAgICBhd2FyZW5lc3Muc3RhdGVzLmRlbGV0ZShjbGllbnRJRCk7XG4gICAgICBpZiAoY2xpZW50SUQgPT09IGF3YXJlbmVzcy5jbGllbnRJRCkge1xuICAgICAgICBjb25zdCBjdXJNZXRhID0gLyoqIEB0eXBlIHtNZXRhQ2xpZW50U3RhdGV9ICovIChhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpKTtcbiAgICAgICAgYXdhcmVuZXNzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICAgICAgY2xvY2s6IGN1ck1ldGEuY2xvY2sgKyAxLFxuICAgICAgICAgIGxhc3RVcGRhdGVkOiBnZXRVbml4VGltZSgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCdjaGFuZ2UnLCBbeyBhZGRlZDogW10sIHVwZGF0ZWQ6IFtdLCByZW1vdmVkIH0sIG9yaWdpbl0pO1xuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbeyBhZGRlZDogW10sIHVwZGF0ZWQ6IFtdLCByZW1vdmVkIH0sIG9yaWdpbl0pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xpZW50c1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlQXdhcmVuZXNzVXBkYXRlID0gKGF3YXJlbmVzcywgY2xpZW50cywgc3RhdGVzID0gYXdhcmVuZXNzLnN0YXRlcykgPT4ge1xuICBjb25zdCBsZW4gPSBjbGllbnRzLmxlbmd0aDtcbiAgY29uc3QgZW5jb2RlciA9IGNyZWF0ZUVuY29kZXIoKTtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGNsaWVudHNbaV07XG4gICAgY29uc3Qgc3RhdGUgPSBzdGF0ZXMuZ2V0KGNsaWVudElEKSB8fCBudWxsO1xuICAgIGNvbnN0IGNsb2NrID0gLyoqIEB0eXBlIHtNZXRhQ2xpZW50U3RhdGV9ICovIChhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpKS5jbG9jaztcbiAgICB3cml0ZVZhclVpbnQoZW5jb2RlciwgY2xpZW50SUQpO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBjbG9jayk7XG4gICAgd3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgfVxuICByZXR1cm4gdG9VaW50OEFycmF5KGVuY29kZXIpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gb3JpZ2luIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgZW1pdHRlZCBjaGFuZ2UgZXZlbnRcbiAqL1xuY29uc3QgYXBwbHlBd2FyZW5lc3NVcGRhdGUgPSAoYXdhcmVuZXNzLCB1cGRhdGUsIG9yaWdpbikgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gY3JlYXRlRGVjb2Rlcih1cGRhdGUpO1xuICBjb25zdCB0aW1lc3RhbXAgPSBnZXRVbml4VGltZSgpO1xuICBjb25zdCBhZGRlZCA9IFtdO1xuICBjb25zdCB1cGRhdGVkID0gW107XG4gIGNvbnN0IGZpbHRlcmVkVXBkYXRlZCA9IFtdO1xuICBjb25zdCByZW1vdmVkID0gW107XG4gIGNvbnN0IGxlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSByZWFkVmFyVWludChkZWNvZGVyKTtcbiAgICBsZXQgY2xvY2sgPSByZWFkVmFyVWludChkZWNvZGVyKTtcbiAgICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2UocmVhZFZhclN0cmluZyhkZWNvZGVyKSk7XG4gICAgY29uc3QgY2xpZW50TWV0YSA9IGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRCk7XG4gICAgY29uc3QgcHJldlN0YXRlID0gYXdhcmVuZXNzLnN0YXRlcy5nZXQoY2xpZW50SUQpO1xuICAgIGNvbnN0IGN1cnJDbG9jayA9IGNsaWVudE1ldGEgPT09IHVuZGVmaW5lZCA/IDAgOiBjbGllbnRNZXRhLmNsb2NrO1xuICAgIGlmIChjdXJyQ2xvY2sgPCBjbG9jayB8fCAoY3VyckNsb2NrID09PSBjbG9jayAmJiBzdGF0ZSA9PT0gbnVsbCAmJiBhd2FyZW5lc3Muc3RhdGVzLmhhcyhjbGllbnRJRCkpKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gbmV2ZXIgbGV0IGEgcmVtb3RlIGNsaWVudCByZW1vdmUgdGhpcyBsb2NhbCBzdGF0ZVxuICAgICAgICBpZiAoY2xpZW50SUQgPT09IGF3YXJlbmVzcy5jbGllbnRJRCAmJiBhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpICE9IG51bGwpIHtcbiAgICAgICAgICAvLyByZW1vdGUgY2xpZW50IHJlbW92ZWQgdGhlIGxvY2FsIHN0YXRlLiBEbyBub3QgcmVtb3RlIHN0YXRlLiBCcm9hZGNhc3QgYSBtZXNzYWdlIGluZGljYXRpbmdcbiAgICAgICAgICAvLyB0aGF0IHRoaXMgY2xpZW50IHN0aWxsIGV4aXN0cyBieSBpbmNyZWFzaW5nIHRoZSBjbG9ja1xuICAgICAgICAgIGNsb2NrKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhcmVuZXNzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FyZW5lc3Muc3RhdGVzLnNldChjbGllbnRJRCwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgYXdhcmVuZXNzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICAgIGNsb2NrLFxuICAgICAgICBsYXN0VXBkYXRlZDogdGltZXN0YW1wXG4gICAgICB9KTtcbiAgICAgIGlmIChjbGllbnRNZXRhID09PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgYWRkZWQucHVzaChjbGllbnRJRCk7XG4gICAgICB9IGVsc2UgaWYgKGNsaWVudE1ldGEgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWVxdWFsaXR5RGVlcChzdGF0ZSwgcHJldlN0YXRlKSkge1xuICAgICAgICAgIGZpbHRlcmVkVXBkYXRlZC5wdXNoKGNsaWVudElEKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkLnB1c2goY2xpZW50SUQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCBmaWx0ZXJlZFVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgnY2hhbmdlJywgW3tcbiAgICAgIGFkZGVkLCB1cGRhdGVkOiBmaWx0ZXJlZFVwZGF0ZWQsIHJlbW92ZWRcbiAgICB9LCBvcmlnaW5dKTtcbiAgfVxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCB1cGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ3VwZGF0ZScsIFt7XG4gICAgICBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZFxuICAgIH0sIG9yaWdpbl0pO1xuICB9XG59O1xuXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1mdW5jdGlvbi10eXBlXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWZ1bmN0aW9uLXR5cGVcbiAgICBvbihldmVudCwgZm4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrc1tldmVudF0pIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XS5wdXNoKGZuKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3NbZXZlbnRdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZnVuY3Rpb24tdHlwZVxuICAgIG9mZihldmVudCwgZm4pIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3NbZXZlbnRdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0gPSBjYWxsYmFja3MuZmlsdGVyKChjYWxsYmFjaykgPT4gY2FsbGJhY2sgIT09IGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICB9XG59XG5cbmNsYXNzIEluY29taW5nTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBjcmVhdGVFbmNvZGVyKCk7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IGNyZWF0ZURlY29kZXIobmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhKSk7XG4gICAgfVxuICAgIHBlZWtWYXJTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBwZWVrVmFyU3RyaW5nKHRoaXMuZGVjb2Rlcik7XG4gICAgfVxuICAgIHJlYWRWYXJVaW50KCkge1xuICAgICAgICByZXR1cm4gcmVhZFZhclVpbnQodGhpcy5kZWNvZGVyKTtcbiAgICB9XG4gICAgcmVhZFZhclN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRWYXJTdHJpbmcodGhpcy5kZWNvZGVyKTtcbiAgICB9XG4gICAgcmVhZFZhclVpbnQ4QXJyYXkoKSB7XG4gICAgICAgIHJldHVybiByZWFkVmFyVWludDhBcnJheSh0aGlzLmRlY29kZXIpO1xuICAgIH1cbiAgICB3cml0ZVZhclVpbnQodHlwZSkge1xuICAgICAgICByZXR1cm4gd3JpdGVWYXJVaW50KHRoaXMuZW5jb2RlciwgdHlwZSk7XG4gICAgfVxuICAgIHdyaXRlVmFyU3RyaW5nKHN0cmluZykge1xuICAgICAgICByZXR1cm4gd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBzdHJpbmcpO1xuICAgIH1cbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZGF0YSkge1xuICAgICAgICByZXR1cm4gd3JpdGVWYXJVaW50OEFycmF5KHRoaXMuZW5jb2RlciwgZGF0YSk7XG4gICAgfVxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCQxKHRoaXMuZW5jb2Rlcik7XG4gICAgfVxufVxuXG52YXIgTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKE1lc3NhZ2VUeXBlKSB7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJTeW5jXCJdID0gMF0gPSBcIlN5bmNcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkF3YXJlbmVzc1wiXSA9IDFdID0gXCJBd2FyZW5lc3NcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkF1dGhcIl0gPSAyXSA9IFwiQXV0aFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiUXVlcnlBd2FyZW5lc3NcIl0gPSAzXSA9IFwiUXVlcnlBd2FyZW5lc3NcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlN0YXRlbGVzc1wiXSA9IDVdID0gXCJTdGF0ZWxlc3NcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkNMT1NFXCJdID0gN10gPSBcIkNMT1NFXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJTeW5jU3RhdHVzXCJdID0gOF0gPSBcIlN5bmNTdGF0dXNcIjtcbn0pKE1lc3NhZ2VUeXBlIHx8IChNZXNzYWdlVHlwZSA9IHt9KSk7XG52YXIgV2ViU29ja2V0U3RhdHVzO1xuKGZ1bmN0aW9uIChXZWJTb2NrZXRTdGF0dXMpIHtcbiAgICBXZWJTb2NrZXRTdGF0dXNbXCJDb25uZWN0aW5nXCJdID0gXCJjb25uZWN0aW5nXCI7XG4gICAgV2ViU29ja2V0U3RhdHVzW1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgICBXZWJTb2NrZXRTdGF0dXNbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xufSkoV2ViU29ja2V0U3RhdHVzIHx8IChXZWJTb2NrZXRTdGF0dXMgPSB7fSkpO1xuXG5jbGFzcyBPdXRnb2luZ01lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBjcmVhdGVFbmNvZGVyKCk7XG4gICAgfVxuICAgIGdldChhcmdzKSB7XG4gICAgICAgIHJldHVybiBhcmdzLmVuY29kZXI7XG4gICAgfVxuICAgIHRvVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLmVuY29kZXIpO1xuICAgIH1cbn1cblxuY2xhc3MgQ2xvc2VNZXNzYWdlIGV4dGVuZHMgT3V0Z29pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gTWVzc2FnZVR5cGUuQ0xPU0U7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIkFzayB0aGUgc2VydmVyIHRvIGNsb3NlIHRoZSBjb25uZWN0aW9uXCI7XG4gICAgfVxuICAgIGdldChhcmdzKSB7XG4gICAgICAgIHdyaXRlVmFyU3RyaW5nKHRoaXMuZW5jb2RlciwgYXJncy5kb2N1bWVudE5hbWUpO1xuICAgICAgICB3cml0ZVZhclVpbnQodGhpcy5lbmNvZGVyLCB0aGlzLnR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyO1xuICAgIH1cbn1cblxuY2xhc3MgSG9jdXNwb2N1c1Byb3ZpZGVyV2Vic29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHVybDogXCJcIixcbiAgICAgICAgICAgIGF1dG9Db25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZG9jdW1lbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFdlYlNvY2tldFBvbHlmaWxsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBkZXBlbmQgb24gYXdhcmVuZXNzLm91dGRhdGVkVGltZVxuICAgICAgICAgICAgbWVzc2FnZVJlY29ubmVjdFRpbWVvdXQ6IDMwMDAwLFxuICAgICAgICAgICAgLy8gMSBzZWNvbmRcbiAgICAgICAgICAgIGRlbGF5OiAxMDAwLFxuICAgICAgICAgICAgLy8gaW5zdGFudFxuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiAwLFxuICAgICAgICAgICAgLy8gZG91YmxlIHRoZSBkZWxheSBlYWNoIHRpbWVcbiAgICAgICAgICAgIGZhY3RvcjogMixcbiAgICAgICAgICAgIC8vIHVubGltaXRlZCByZXRyaWVzXG4gICAgICAgICAgICBtYXhBdHRlbXB0czogMCxcbiAgICAgICAgICAgIC8vIHdhaXQgYXQgbGVhc3QgMSBzZWNvbmRcbiAgICAgICAgICAgIG1pbkRlbGF5OiAxMDAwLFxuICAgICAgICAgICAgLy8gYXQgbGVhc3QgZXZlcnkgMzAgc2Vjb25kc1xuICAgICAgICAgICAgbWF4RGVsYXk6IDMwMDAwLFxuICAgICAgICAgICAgLy8gcmFuZG9taXplXG4gICAgICAgICAgICBqaXR0ZXI6IHRydWUsXG4gICAgICAgICAgICAvLyByZXRyeSBmb3JldmVyXG4gICAgICAgICAgICB0aW1lb3V0OiAwLFxuICAgICAgICAgICAgb25PcGVuOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25Db25uZWN0OiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25NZXNzYWdlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25PdXRnb2luZ01lc3NhZ2U6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvblN0YXR1czogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uRGlzY29ubmVjdDogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQ2xvc2U6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkRlc3Ryb3k6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkF3YXJlbmVzc1VwZGF0ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQXdhcmVuZXNzQ2hhbmdlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgaGFuZGxlVGltZW91dDogbnVsbCxcbiAgICAgICAgICAgIHByb3ZpZGVyTWFwOiBuZXcgTWFwKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2ViU29ja2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRIYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnNob3VsZENvbm5lY3QgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFdlYlNvY2tldFN0YXR1cy5EaXNjb25uZWN0ZWQ7XG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IDA7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzID0ge1xuICAgICAgICAgICAgY29ubmVjdGlvbkNoZWNrZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkF0dGVtcHQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY2VpdmVkT25PcGVuUGF5bG9hZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbG9zZVRyaWVzID0gMDtcbiAgICAgICAgdGhpcy5zZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uV2ViU29ja2V0UG9seWZpbGwgPSBjb25maWd1cmF0aW9uLldlYlNvY2tldFBvbHlmaWxsXG4gICAgICAgICAgICA/IGNvbmZpZ3VyYXRpb24uV2ViU29ja2V0UG9seWZpbGxcbiAgICAgICAgICAgIDogV2ViU29ja2V0O1xuICAgICAgICB0aGlzLm9uKFwib3BlblwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25PcGVuKTtcbiAgICAgICAgdGhpcy5vbihcIm9wZW5cIiwgdGhpcy5vbk9wZW4uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMub24oXCJjb25uZWN0XCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkNvbm5lY3QpO1xuICAgICAgICB0aGlzLm9uKFwibWVzc2FnZVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25NZXNzYWdlKTtcbiAgICAgICAgdGhpcy5vbihcIm91dGdvaW5nTWVzc2FnZVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25PdXRnb2luZ01lc3NhZ2UpO1xuICAgICAgICB0aGlzLm9uKFwic3RhdHVzXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vblN0YXR1cyk7XG4gICAgICAgIHRoaXMub24oXCJkaXNjb25uZWN0XCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkRpc2Nvbm5lY3QpO1xuICAgICAgICB0aGlzLm9uKFwiY2xvc2VcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uQ2xvc2UpO1xuICAgICAgICB0aGlzLm9uKFwiZGVzdHJveVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25EZXN0cm95KTtcbiAgICAgICAgdGhpcy5vbihcImF3YXJlbmVzc1VwZGF0ZVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25Bd2FyZW5lc3NVcGRhdGUpO1xuICAgICAgICB0aGlzLm9uKFwiYXdhcmVuZXNzQ2hhbmdlXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkF3YXJlbmVzc0NoYW5nZSk7XG4gICAgICAgIHRoaXMub24oXCJjbG9zZVwiLCB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMub24oXCJtZXNzYWdlXCIsIHRoaXMub25NZXNzYWdlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmludGVydmFscy5jb25uZWN0aW9uQ2hlY2tlciA9IHNldEludGVydmFsKHRoaXMuY2hlY2tDb25uZWN0aW9uLmJpbmQodGhpcyksIHRoaXMuY29uZmlndXJhdGlvbi5tZXNzYWdlUmVjb25uZWN0VGltZW91dCAvIDEwKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25PcGVuKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RlZDtcbiAgICAgICAgdGhpcy5lbWl0KFwic3RhdHVzXCIsIHsgc3RhdHVzOiBXZWJTb2NrZXRTdGF0dXMuQ29ubmVjdGVkIH0pO1xuICAgICAgICB0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlY2VpdmVkT25PcGVuUGF5bG9hZCA9IGV2ZW50O1xuICAgIH1cbiAgICBhdHRhY2gocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVyTWFwLnNldChwcm92aWRlci5jb25maWd1cmF0aW9uLm5hbWUsIHByb3ZpZGVyKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBXZWJTb2NrZXRTdGF0dXMuRGlzY29ubmVjdGVkICYmIHRoaXMuc2hvdWxkQ29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjZWl2ZWRPbk9wZW5QYXlsb2FkICYmXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgcHJvdmlkZXIub25PcGVuKHRoaXMucmVjZWl2ZWRPbk9wZW5QYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXRhY2gocHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5wcm92aWRlck1hcC5oYXMocHJvdmlkZXIuY29uZmlndXJhdGlvbi5uYW1lKSkge1xuICAgICAgICAgICAgcHJvdmlkZXIuc2VuZChDbG9zZU1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudE5hbWU6IHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24ubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVyTWFwLmRlbGV0ZShwcm92aWRlci5jb25maWd1cmF0aW9uLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbiA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHsgLi4udGhpcy5jb25maWd1cmF0aW9uLCAuLi5jb25maWd1cmF0aW9uIH07XG4gICAgICAgIGlmICghdGhpcy5jb25maWd1cmF0aW9uLmF1dG9Db25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFdlYlNvY2tldFN0YXR1cy5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHdheXMgY2FuY2VsIGFueSBwcmV2aW91c2x5IGluaXRpYXRlZCBjb25uZWN0aW9uIHJldHJ5ZXIgaW5zdGFuY2VzXG4gICAgICAgIGlmICh0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5KSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5KCk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjZWl2ZWRPbk9wZW5QYXlsb2FkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNob3VsZENvbm5lY3QgPSB0cnVlO1xuICAgICAgICBjb25zdCBhYm9ydGFibGVSZXRyeSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBjYW5jZWxBdHRlbXB0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCByZXRyeVByb21pc2UgPSByZXRyeSh0aGlzLmNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24uYmluZCh0aGlzKSwge1xuICAgICAgICAgICAgICAgIGRlbGF5OiB0aGlzLmNvbmZpZ3VyYXRpb24uZGVsYXksXG4gICAgICAgICAgICAgICAgaW5pdGlhbERlbGF5OiB0aGlzLmNvbmZpZ3VyYXRpb24uaW5pdGlhbERlbGF5LFxuICAgICAgICAgICAgICAgIGZhY3RvcjogdGhpcy5jb25maWd1cmF0aW9uLmZhY3RvcixcbiAgICAgICAgICAgICAgICBtYXhBdHRlbXB0czogdGhpcy5jb25maWd1cmF0aW9uLm1heEF0dGVtcHRzLFxuICAgICAgICAgICAgICAgIG1pbkRlbGF5OiB0aGlzLmNvbmZpZ3VyYXRpb24ubWluRGVsYXksXG4gICAgICAgICAgICAgICAgbWF4RGVsYXk6IHRoaXMuY29uZmlndXJhdGlvbi5tYXhEZWxheSxcbiAgICAgICAgICAgICAgICBqaXR0ZXI6IHRoaXMuY29uZmlndXJhdGlvbi5qaXR0ZXIsXG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5jb25maWd1cmF0aW9uLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlVGltZW91dDogdGhpcy5jb25maWd1cmF0aW9uLmhhbmRsZVRpbWVvdXQsXG4gICAgICAgICAgICAgICAgYmVmb3JlQXR0ZW1wdDogKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZENvbm5lY3QgfHwgY2FuY2VsQXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFib3J0ZWQgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCB0aGVuIGRvbuKAmXQgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAvLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9saWZlb21pYy9hdHRlbXB0L2Jsb2IvbWFzdGVyL3NyYy9pbmRleC50cyNMMTM2XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgIT09IFwiQVRURU1QVF9BQk9SVEVEXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJldHJ5UHJvbWlzZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxGdW5jOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEF0dGVtcHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IHJldHJ5UHJvbWlzZSwgY2FuY2VsRnVuYyB9ID0gYWJvcnRhYmxlUmV0cnkoKTtcbiAgICAgICAgdGhpcy5jYW5jZWxXZWJzb2NrZXRSZXRyeSA9IGNhbmNlbEZ1bmM7XG4gICAgICAgIHJldHVybiByZXRyeVByb21pc2U7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWZ1bmN0aW9uLXR5cGVcbiAgICBhdHRhY2hXZWJTb2NrZXRMaXN0ZW5lcnMod3MsIHJlamVjdCkge1xuICAgICAgICBjb25zdCB7IGlkZW50aWZpZXIgfSA9IHdzO1xuICAgICAgICBjb25zdCBvbk1lc3NhZ2VIYW5kbGVyID0gKHBheWxvYWQpID0+IHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgcGF5bG9hZCk7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2VIYW5kbGVyID0gKHBheWxvYWQpID0+IHRoaXMuZW1pdChcImNsb3NlXCIsIHsgZXZlbnQ6IHBheWxvYWQgfSk7XG4gICAgICAgIGNvbnN0IG9uT3BlbkhhbmRsZXIgPSAocGF5bG9hZCkgPT4gdGhpcy5lbWl0KFwib3BlblwiLCBwYXlsb2FkKTtcbiAgICAgICAgY29uc3Qgb25FcnJvckhhbmRsZXIgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRIYW5kbGVyc1tpZGVudGlmaWVyXSA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG9uTWVzc2FnZUhhbmRsZXIsXG4gICAgICAgICAgICBjbG9zZTogb25DbG9zZUhhbmRsZXIsXG4gICAgICAgICAgICBvcGVuOiBvbk9wZW5IYW5kbGVyLFxuICAgICAgICAgICAgZXJyb3I6IG9uRXJyb3JIYW5kbGVyLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMud2ViU29ja2V0SGFuZGxlcnNbd3MuaWRlbnRpZmllcl07XG4gICAgICAgIE9iamVjdC5rZXlzKGhhbmRsZXJzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXJzW25hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsZWFudXBXZWJTb2NrZXQoKSB7XG4gICAgICAgIGlmICghdGhpcy53ZWJTb2NrZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlkZW50aWZpZXIgfSA9IHRoaXMud2ViU29ja2V0O1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMud2ViU29ja2V0SGFuZGxlcnNbaWRlbnRpZmllcl07XG4gICAgICAgIE9iamVjdC5rZXlzKGhhbmRsZXJzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLndlYlNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMud2ViU29ja2V0SGFuZGxlcnNbaWRlbnRpZmllcl07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndlYlNvY2tldC5jbG9zZSgpO1xuICAgICAgICB0aGlzLndlYlNvY2tldCA9IG51bGw7XG4gICAgfVxuICAgIGNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy53ZWJTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cFdlYlNvY2tldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkID0gMDtcbiAgICAgICAgICAgIHRoaXMuaWRlbnRpZmllciArPSAxO1xuICAgICAgICAgICAgLy8gSW5pdCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHdzID0gbmV3IHRoaXMuY29uZmlndXJhdGlvbi5XZWJTb2NrZXRQb2x5ZmlsbCh0aGlzLnVybCk7XG4gICAgICAgICAgICB3cy5iaW5hcnlUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICAgICAgd3MuaWRlbnRpZmllciA9IHRoaXMuaWRlbnRpZmllcjtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoV2ViU29ja2V0TGlzdGVuZXJzKHdzLCByZWplY3QpO1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQgPSB3cztcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBzdGF0dXNcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gV2ViU29ja2V0U3RhdHVzLkNvbm5lY3Rpbmc7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJzdGF0dXNcIiwgeyBzdGF0dXM6IFdlYlNvY2tldFN0YXR1cy5Db25uZWN0aW5nIH0pO1xuICAgICAgICAgICAgLy8gU3RvcmUgcmVzb2x2ZS9yZWplY3QgZm9yIGxhdGVyIHVzZVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQXR0ZW1wdCA9IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlc29sdmVDb25uZWN0aW9uQXR0ZW1wdCgpO1xuICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWQgPSBnZXRVbml4VGltZSgpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IEluY29taW5nTWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnROYW1lID0gbWVzc2FnZS5wZWVrVmFyU3RyaW5nKCk7XG4gICAgICAgIChfYSA9IHRoaXMuY29uZmlndXJhdGlvbi5wcm92aWRlck1hcC5nZXQoZG9jdW1lbnROYW1lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uTWVzc2FnZShldmVudCk7XG4gICAgfVxuICAgIHJlc29sdmVDb25uZWN0aW9uQXR0ZW1wdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbkF0dGVtcHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbkF0dGVtcHQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQXR0ZW1wdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFdlYlNvY2tldFN0YXR1cy5Db25uZWN0ZWQ7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJzdGF0dXNcIiwgeyBzdGF0dXM6IFdlYlNvY2tldFN0YXR1cy5Db25uZWN0ZWQgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUuZm9yRWFjaCgobWVzc2FnZSkgPT4gdGhpcy5zZW5kKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcENvbm5lY3Rpb25BdHRlbXB0KCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0ID0gbnVsbDtcbiAgICB9XG4gICAgcmVqZWN0Q29ubmVjdGlvbkF0dGVtcHQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jb25uZWN0aW9uQXR0ZW1wdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlamVjdCgpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0ID0gbnVsbDtcbiAgICB9XG4gICAgY2hlY2tDb25uZWN0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIERvbuKAmXQgY2hlY2sgdGhlIGNvbm5lY3Rpb24gd2hlbiBpdOKAmXMgbm90IGV2ZW4gZXN0YWJsaXNoZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBXZWJTb2NrZXRTdGF0dXMuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9u4oCZdCBjbG9zZSB0aGUgY29ubmVjdGlvbiB3aGlsZSB3YWl0aW5nIGZvciB0aGUgZmlyc3QgbWVzc2FnZVxuICAgICAgICBpZiAoIXRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbuKAmXQgY2xvc2UgdGhlIGNvbm5lY3Rpb24gd2hlbiBhIG1lc3NhZ2Ugd2FzIHJlY2VpdmVkIHJlY2VudGx5XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24ubWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgPj1cbiAgICAgICAgICAgIGdldFVuaXhUaW1lKCkgLSB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBtZXNzYWdlIHJlY2VpdmVkIGluIGEgbG9uZyB0aW1lLCBub3QgZXZlbiB5b3VyIG93blxuICAgICAgICAvLyBBd2FyZW5lc3MgdXBkYXRlcywgd2hpY2ggYXJlIHVwZGF0ZWQgZXZlcnkgMTUgc2Vjb25kc1xuICAgICAgICAvLyBpZiBhd2FyZW5lc3MgaXMgZW5hYmxlZC5cbiAgICAgICAgdGhpcy5jbG9zZVRyaWVzICs9IDE7XG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yNDc5NDNcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VUcmllcyA+IDIpIHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogNDQwOCxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcImZvcmNlZFwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VUcmllcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLndlYlNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBVUkwgbmV2ZXIgZW5kcyB3aXRoIC9cbiAgICBnZXQgc2VydmVyVXJsKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5jb25maWd1cmF0aW9uLnVybFt0aGlzLmNvbmZpZ3VyYXRpb24udXJsLmxlbmd0aCAtIDFdID09PSBcIi9cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi51cmwuc2xpY2UoMCwgdGhpcy5jb25maWd1cmF0aW9uLnVybC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnVybDtcbiAgICB9XG4gICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyVXJsO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMud2ViU29ja2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmQobWVzc2FnZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy53ZWJTb2NrZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeVN0YXRlKSA9PT0gV3NSZWFkeVN0YXRlcy5PcGVuKSB7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkNsb3NlKHsgZXZlbnQgfSkge1xuICAgICAgICB0aGlzLmNsb3NlVHJpZXMgPSAwO1xuICAgICAgICB0aGlzLmNsZWFudXBXZWJTb2NrZXQoKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbkF0dGVtcHQpIHtcbiAgICAgICAgICAgIC8vIFRoYXQgY29ubmVjdGlvbiBhdHRlbXB0IGZhaWxlZC5cbiAgICAgICAgICAgIHRoaXMucmVqZWN0Q29ubmVjdGlvbkF0dGVtcHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMZXTigJlzIHVwZGF0ZSB0aGUgY29ubmVjdGlvbiBzdGF0dXMuXG4gICAgICAgIHRoaXMuc3RhdHVzID0gV2ViU29ja2V0U3RhdHVzLkRpc2Nvbm5lY3RlZDtcbiAgICAgICAgdGhpcy5lbWl0KFwic3RhdHVzXCIsIHsgc3RhdHVzOiBXZWJTb2NrZXRTdGF0dXMuRGlzY29ubmVjdGVkIH0pO1xuICAgICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIHsgZXZlbnQgfSk7XG4gICAgICAgIC8vIHRyaWdnZXIgY29ubmVjdCBpZiBubyByZXRyeSBpcyBydW5uaW5nIGFuZCB3ZSB3YW50IHRvIGhhdmUgYSBjb25uZWN0aW9uXG4gICAgICAgIGlmICghdGhpcy5jYW5jZWxXZWJzb2NrZXRSZXRyeSAmJiB0aGlzLnNob3VsZENvbm5lY3QpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgfSwgdGhpcy5jb25maWd1cmF0aW9uLmRlbGF5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIpO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxzLmNvbm5lY3Rpb25DaGVja2VyKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgc3RpbGwgYSBjb25uZWN0aW9uIGF0dGVtcHQgb3V0c3RhbmRpbmcgdGhlbiB3ZSBzaG91bGQgc3RvcFxuICAgICAgICAvLyBpdCBiZWZvcmUgY2FsbGluZyBkaXNjb25uZWN0LCBvdGhlcndpc2UgaXQgd2lsbCBiZSByZWplY3RlZCBpbiB0aGUgb25DbG9zZVxuICAgICAgICAvLyBoYW5kbGVyIGFuZCB0cmlnZ2VyIGEgcmV0cnlcbiAgICAgICAgdGhpcy5zdG9wQ29ubmVjdGlvbkF0dGVtcHQoKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuY2xlYW51cFdlYlNvY2tldCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbW9kdWxlIHN5bmMtcHJvdG9jb2xcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge01hcDxudW1iZXIsIG51bWJlcj59IFN0YXRlTWFwXG4gKi9cblxuLyoqXG4gKiBDb3JlIFlqcyBkZWZpbmVzIHR3byBtZXNzYWdlIHR5cGVzOlxuICog4oCiIFlqc1N5bmNTdGVwMTogSW5jbHVkZXMgdGhlIFN0YXRlIFNldCBvZiB0aGUgc2VuZGluZyBjbGllbnQuIFdoZW4gcmVjZWl2ZWQsIHRoZSBjbGllbnQgc2hvdWxkIHJlcGx5IHdpdGggWWpzU3luY1N0ZXAyLlxuICog4oCiIFlqc1N5bmNTdGVwMjogSW5jbHVkZXMgYWxsIG1pc3Npbmcgc3RydWN0cyBhbmQgdGhlIGNvbXBsZXRlIGRlbGV0ZSBzZXQuIFdoZW4gcmVjZWl2ZWQsIHRoZSBjbGllbnQgaXMgYXNzdXJlZCB0aGF0IGl0XG4gKiAgIHJlY2VpdmVkIGFsbCBpbmZvcm1hdGlvbiBmcm9tIHRoZSByZW1vdGUgY2xpZW50LlxuICpcbiAqIEluIGEgcGVlci10by1wZWVyIG5ldHdvcmssIHlvdSBtYXkgd2FudCB0byBpbnRyb2R1Y2UgYSBTeW5jRG9uZSBtZXNzYWdlIHR5cGUuIEJvdGggcGFydGllcyBzaG91bGQgaW5pdGlhdGUgdGhlIGNvbm5lY3Rpb25cbiAqIHdpdGggU3luY1N0ZXAxLiBXaGVuIGEgY2xpZW50IHJlY2VpdmVkIFN5bmNTdGVwMiwgaXQgc2hvdWxkIHJlcGx5IHdpdGggU3luY0RvbmUuIFdoZW4gdGhlIGxvY2FsIGNsaWVudCByZWNlaXZlZCBib3RoXG4gKiBTeW5jU3RlcDIgYW5kIFN5bmNEb25lLCBpdCBpcyBhc3N1cmVkIHRoYXQgaXQgaXMgc3luY2VkIHRvIHRoZSByZW1vdGUgY2xpZW50LlxuICpcbiAqIEluIGEgY2xpZW50LXNlcnZlciBtb2RlbCwgeW91IHdhbnQgdG8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHk6IFRoZSBjbGllbnQgc2hvdWxkIGluaXRpYXRlIHRoZSBjb25uZWN0aW9uIHdpdGggU3luY1N0ZXAxLlxuICogV2hlbiB0aGUgc2VydmVyIHJlY2VpdmVzIFN5bmNTdGVwMSwgaXQgc2hvdWxkIHJlcGx5IHdpdGggU3luY1N0ZXAyIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFN5bmNTdGVwMS4gVGhlIGNsaWVudCByZXBsaWVzXG4gKiB3aXRoIFN5bmNTdGVwMiB3aGVuIGl0IHJlY2VpdmVzIFN5bmNTdGVwMS4gT3B0aW9uYWxseSB0aGUgc2VydmVyIG1heSBzZW5kIGEgU3luY0RvbmUgYWZ0ZXIgaXQgcmVjZWl2ZWQgU3luY1N0ZXAyLCBzbyB0aGVcbiAqIGNsaWVudCBrbm93cyB0aGF0IHRoZSBzeW5jIGlzIGZpbmlzaGVkLiAgVGhlcmUgYXJlIHR3byByZWFzb25zIGZvciB0aGlzIG1vcmUgZWxhYm9yYXRlZCBzeW5jIG1vZGVsOiAxLiBUaGlzIHByb3RvY29sIGNhblxuICogZWFzaWx5IGJlIGltcGxlbWVudGVkIG9uIHRvcCBvZiBodHRwIGFuZCB3ZWJzb2NrZXRzLiAyLiBUaGUgc2VydmVyIHNob3VsZCBvbmx5IHJlcGx5IHRvIHJlcXVlc3RzLCBhbmQgbm90IGluaXRpYXRlIHRoZW0uXG4gKiBUaGVyZWZvcmUgaXQgaXMgbmVjZXNzYXJ5IHRoYXQgdGhlIGNsaWVudCBpbml0aWF0ZXMgdGhlIHN5bmMuXG4gKlxuICogQ29uc3RydWN0aW9uIG9mIGEgbWVzc2FnZTpcbiAqIFttZXNzYWdlVHlwZSA6IHZhclVpbnQsIG1lc3NhZ2UgZGVmaW5pdGlvbi4uXVxuICpcbiAqIE5vdGU6IEEgbWVzc2FnZSBkb2VzIG5vdCBpbmNsdWRlIGluZm9ybWF0aW9uIGFib3V0IHRoZSByb29tIG5hbWUuIFRoaXMgbXVzdCB0byBiZSBoYW5kbGVkIGJ5IHRoZSB1cHBlciBsYXllciBwcm90b2NvbCFcbiAqXG4gKiBzdHJpbmdpZnlbbWVzc2FnZVR5cGVdIHN0cmluZ2lmaWVzIGEgbWVzc2FnZSBkZWZpbml0aW9uIChtZXNzYWdlVHlwZSBpcyBhbHJlYWR5IHJlYWQgZnJvbSB0aGUgYnVmZmZlcilcbiAqL1xuXG5jb25zdCBtZXNzYWdlWWpzU3luY1N0ZXAxID0gMDtcbmNvbnN0IG1lc3NhZ2VZanNTeW5jU3RlcDIgPSAxO1xuY29uc3QgbWVzc2FnZVlqc1VwZGF0ZSA9IDI7XG5cbi8qKlxuICogQ3JlYXRlIGEgc3luYyBzdGVwIDEgbWVzc2FnZSBiYXNlZCBvbiB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgc2hhcmVkIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKi9cbmNvbnN0IHdyaXRlU3luY1N0ZXAxID0gKGVuY29kZXIsIGRvYykgPT4ge1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVlqc1N5bmNTdGVwMSk7XG4gIGNvbnN0IHN2ID0gWS5lbmNvZGVTdGF0ZVZlY3Rvcihkb2MpO1xuICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2Rlciwgc3YpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSBbZW5jb2RlZFN0YXRlVmVjdG9yXVxuICovXG5jb25zdCB3cml0ZVN5bmNTdGVwMiA9IChlbmNvZGVyLCBkb2MsIGVuY29kZWRTdGF0ZVZlY3RvcikgPT4ge1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVlqc1N5bmNTdGVwMik7XG4gIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBZLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jLCBlbmNvZGVkU3RhdGVWZWN0b3IpKTtcbn07XG5cbi8qKlxuICogUmVhZCBTeW5jU3RlcDEgbWVzc2FnZSBhbmQgcmVwbHkgd2l0aCBTeW5jU3RlcDIuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyIFRoZSByZXBseSB0byB0aGUgcmVjZWl2ZWQgbWVzc2FnZVxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyIFRoZSByZWNlaXZlZCBtZXNzYWdlXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqL1xuY29uc3QgcmVhZFN5bmNTdGVwMSA9IChkZWNvZGVyLCBlbmNvZGVyLCBkb2MpID0+XG4gIHdyaXRlU3luY1N0ZXAyKGVuY29kZXIsIGRvYywgcmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuXG4vKipcbiAqIFJlYWQgYW5kIGFwcGx5IFN0cnVjdHMgYW5kIHRoZW4gRGVsZXRlU3RvcmUgdG8gYSB5IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuY29uc3QgcmVhZFN5bmNTdGVwMiA9IChkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiB7XG4gIHRyeSB7XG4gICAgWS5hcHBseVVwZGF0ZShkb2MsIHJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpLCB0cmFuc2FjdGlvbk9yaWdpbik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyB0aGF0IGFyZSB0aHJvd24gYnkgZXZlbnQgaGFuZGxlcnNcbiAgICBjb25zb2xlLmVycm9yKCdDYXVnaHQgZXJyb3Igd2hpbGUgaGFuZGxpbmcgYSBZanMgdXBkYXRlJywgZXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqL1xuY29uc3Qgd3JpdGVVcGRhdGUgPSAoZW5jb2RlciwgdXBkYXRlKSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzVXBkYXRlKTtcbiAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHVwZGF0ZSk7XG59O1xuXG4vKipcbiAqIFJlYWQgYW5kIGFwcGx5IFN0cnVjdHMgYW5kIHRoZW4gRGVsZXRlU3RvcmUgdG8gYSB5IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuY29uc3QgcmVhZFVwZGF0ZSA9IHJlYWRTeW5jU3RlcDI7XG5cbi8qKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyIEEgbWVzc2FnZSByZWNlaXZlZCBmcm9tIGFub3RoZXIgY2xpZW50XG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXIgVGhlIHJlcGx5IG1lc3NhZ2UuIERvZXMgbm90IG5lZWQgdG8gYmUgc2VudCBpZiBlbXB0eS5cbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICogQHBhcmFtIHthbnl9IHRyYW5zYWN0aW9uT3JpZ2luXG4gKi9cbmNvbnN0IHJlYWRTeW5jTWVzc2FnZSA9IChkZWNvZGVyLCBlbmNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2VUeXBlID0gcmVhZFZhclVpbnQoZGVjb2Rlcik7XG4gIHN3aXRjaCAobWVzc2FnZVR5cGUpIHtcbiAgICBjYXNlIG1lc3NhZ2VZanNTeW5jU3RlcDE6XG4gICAgICByZWFkU3luY1N0ZXAxKGRlY29kZXIsIGVuY29kZXIsIGRvYyk7XG4gICAgICBicmVha1xuICAgIGNhc2UgbWVzc2FnZVlqc1N5bmNTdGVwMjpcbiAgICAgIHJlYWRTeW5jU3RlcDIoZGVjb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbik7XG4gICAgICBicmVha1xuICAgIGNhc2UgbWVzc2FnZVlqc1VwZGF0ZTpcbiAgICAgIHJlYWRVcGRhdGUoZGVjb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbik7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbWVzc2FnZSB0eXBlJylcbiAgfVxuICByZXR1cm4gbWVzc2FnZVR5cGVcbn07XG5cbmNsYXNzIE1lc3NhZ2VSZWNlaXZlciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICBhcHBseShwcm92aWRlciwgZW1pdFN5bmNlZCkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIGNvbnN0IGVtcHR5TWVzc2FnZUxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoKCk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TeW5jOlxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlTeW5jTWVzc2FnZShwcm92aWRlciwgZW1pdFN5bmNlZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkF3YXJlbmVzczpcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5QXdhcmVuZXNzTWVzc2FnZShwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkF1dGg6XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUF1dGhNZXNzYWdlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuUXVlcnlBd2FyZW5lc3M6XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVF1ZXJ5QXdhcmVuZXNzTWVzc2FnZShwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlN0YXRlbGVzczpcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZWNlaXZlU3RhdGVsZXNzKHJlYWRWYXJTdHJpbmcobWVzc2FnZS5kZWNvZGVyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlN5bmNTdGF0dXM6XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVN5bmNTdGF0dXNNZXNzYWdlKHByb3ZpZGVyLCByZWFkVmFySW50KG1lc3NhZ2UuZGVjb2RlcikgPT09IDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5DTE9TRTpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiByZWFkVmFyU3RyaW5nKG1lc3NhZ2UuZGVjb2RlciksXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBwcm92aWRlci5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLndlYlNvY2tldCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjbG9zZVwiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIub25DbG9zZSgpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24ub25DbG9zZSh7IGV2ZW50IH0pO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLmZvcndhcmRDbG9zZShldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fu4oCZdCBhcHBseSBtZXNzYWdlIG9mIHVua25vd24gdHlwZTogJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGx5XG4gICAgICAgIGlmIChtZXNzYWdlLmxlbmd0aCgpID4gZW1wdHlNZXNzYWdlTGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGRvY3VtZW50TmFtZSAoY29uc2lkZXJlZCBpbiBlbXB0eU1lc3NhZ2VMZW5ndGggcGx1cyBsZW5ndGggb2YgeWpzIHN5bmMgdHlwZSwgc2V0IGluIGFwcGx5U3luY01lc3NhZ2UpXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBwcm92aWRlci5zZW5kKE91dGdvaW5nTWVzc2FnZSwgeyBlbmNvZGVyOiBtZXNzYWdlLmVuY29kZXIgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlTeW5jTWVzc2FnZShwcm92aWRlciwgZW1pdFN5bmNlZCkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHRoaXM7XG4gICAgICAgIG1lc3NhZ2Uud3JpdGVWYXJVaW50KE1lc3NhZ2VUeXBlLlN5bmMpO1xuICAgICAgICAvLyBBcHBseSB1cGRhdGVcbiAgICAgICAgY29uc3Qgc3luY01lc3NhZ2VUeXBlID0gcmVhZFN5bmNNZXNzYWdlKG1lc3NhZ2UuZGVjb2RlciwgbWVzc2FnZS5lbmNvZGVyLCBwcm92aWRlci5kb2N1bWVudCwgcHJvdmlkZXIpO1xuICAgICAgICAvLyBTeW5jZWQgb25jZSB3ZSByZWNlaXZlIFN0ZXAyXG4gICAgICAgIGlmIChlbWl0U3luY2VkICYmIHN5bmNNZXNzYWdlVHlwZSA9PT0gbWVzc2FnZVlqc1N5bmNTdGVwMikge1xuICAgICAgICAgICAgcHJvdmlkZXIuc3luY2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseVN5bmNTdGF0dXNNZXNzYWdlKHByb3ZpZGVyLCBhcHBsaWVkKSB7XG4gICAgICAgIGlmIChhcHBsaWVkKSB7XG4gICAgICAgICAgICBwcm92aWRlci5kZWNyZW1lbnRVbnN5bmNlZENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseUF3YXJlbmVzc01lc3NhZ2UocHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKCFwcm92aWRlci5hd2FyZW5lc3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgYXBwbHlBd2FyZW5lc3NVcGRhdGUocHJvdmlkZXIuYXdhcmVuZXNzLCBtZXNzYWdlLnJlYWRWYXJVaW50OEFycmF5KCksIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgYXBwbHlBdXRoTWVzc2FnZShwcm92aWRlcikge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHRoaXM7XG4gICAgICAgIHJlYWRBdXRoTWVzc2FnZShtZXNzYWdlLmRlY29kZXIsIHByb3ZpZGVyLnNlbmRUb2tlbi5iaW5kKHByb3ZpZGVyKSwgcHJvdmlkZXIucGVybWlzc2lvbkRlbmllZEhhbmRsZXIuYmluZChwcm92aWRlciksIHByb3ZpZGVyLmF1dGhlbnRpY2F0ZWRIYW5kbGVyLmJpbmQocHJvdmlkZXIpKTtcbiAgICB9XG4gICAgYXBwbHlRdWVyeUF3YXJlbmVzc01lc3NhZ2UocHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKCFwcm92aWRlci5hd2FyZW5lc3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgbWVzc2FnZS53cml0ZVZhclVpbnQoTWVzc2FnZVR5cGUuQXdhcmVuZXNzKTtcbiAgICAgICAgbWVzc2FnZS53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHByb3ZpZGVyLmF3YXJlbmVzcywgQXJyYXkuZnJvbShwcm92aWRlci5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKSkpO1xuICAgIH1cbn1cblxuY2xhc3MgTWVzc2FnZVNlbmRlciB7XG4gICAgY29uc3RydWN0b3IoTWVzc2FnZSwgYXJncyA9IHt9KSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG5ldyBNZXNzYWdlKCk7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IHRoaXMubWVzc2FnZS5nZXQoYXJncyk7XG4gICAgfVxuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLmVuY29kZXIpO1xuICAgIH1cbiAgICBzZW5kKHdlYlNvY2tldCkge1xuICAgICAgICB3ZWJTb2NrZXQgPT09IG51bGwgfHwgd2ViU29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3ZWJTb2NrZXQuc2VuZCh0aGlzLmNyZWF0ZSgpKTtcbiAgICB9XG59XG5cbmNsYXNzIEF1dGhlbnRpY2F0aW9uTWVzc2FnZSBleHRlbmRzIE91dGdvaW5nTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IE1lc3NhZ2VUeXBlLkF1dGg7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIkF1dGhlbnRpY2F0aW9uXCI7XG4gICAgfVxuICAgIGdldChhcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJncy50b2tlbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGF1dGhlbnRpY2F0aW9uIG1lc3NhZ2UgcmVxdWlyZXMgYHRva2VuYCBhcyBhbiBhcmd1bWVudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50TmFtZSk7XG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLmVuY29kZXIsIHRoaXMudHlwZSk7XG4gICAgICAgIHdyaXRlQXV0aGVudGljYXRpb24odGhpcy5lbmNvZGVyLCBhcmdzLnRva2VuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlcjtcbiAgICB9XG59XG5cbmNsYXNzIEF3YXJlbmVzc01lc3NhZ2UgZXh0ZW5kcyBPdXRnb2luZ01lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSBNZXNzYWdlVHlwZS5Bd2FyZW5lc3M7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIkF3YXJlbmVzcyBzdGF0ZXMgdXBkYXRlXCI7XG4gICAgfVxuICAgIGdldChhcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJncy5hd2FyZW5lc3MgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhd2FyZW5lc3MgbWVzc2FnZSByZXF1aXJlcyBhd2FyZW5lc3MgYXMgYW4gYXJndW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzLmNsaWVudHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhd2FyZW5lc3MgbWVzc2FnZSByZXF1aXJlcyBjbGllbnRzIGFzIGFuIGFyZ3VtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlVmFyU3RyaW5nKHRoaXMuZW5jb2RlciwgYXJncy5kb2N1bWVudE5hbWUpO1xuICAgICAgICB3cml0ZVZhclVpbnQodGhpcy5lbmNvZGVyLCB0aGlzLnR5cGUpO1xuICAgICAgICBsZXQgYXdhcmVuZXNzVXBkYXRlO1xuICAgICAgICBpZiAoYXJncy5zdGF0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXdhcmVuZXNzVXBkYXRlID0gZW5jb2RlQXdhcmVuZXNzVXBkYXRlKGFyZ3MuYXdhcmVuZXNzLCBhcmdzLmNsaWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhcmVuZXNzVXBkYXRlID0gZW5jb2RlQXdhcmVuZXNzVXBkYXRlKGFyZ3MuYXdhcmVuZXNzLCBhcmdzLmNsaWVudHMsIGFyZ3Muc3RhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZVZhclVpbnQ4QXJyYXkodGhpcy5lbmNvZGVyLCBhd2FyZW5lc3NVcGRhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyO1xuICAgIH1cbn1cblxuY2xhc3MgU3RhdGVsZXNzTWVzc2FnZSBleHRlbmRzIE91dGdvaW5nTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IE1lc3NhZ2VUeXBlLlN0YXRlbGVzcztcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiQSBzdGF0ZWxlc3MgbWVzc2FnZVwiO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHdyaXRlVmFyU3RyaW5nKHRoaXMuZW5jb2RlciwgYXJncy5kb2N1bWVudE5hbWUpO1xuICAgICAgICB3cml0ZVZhclVpbnQodGhpcy5lbmNvZGVyLCB0aGlzLnR5cGUpO1xuICAgICAgICB3cml0ZVZhclN0cmluZyh0aGlzLmVuY29kZXIsIChfYSA9IGFyZ3MucGF5bG9hZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIik7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZXI7XG4gICAgfVxufVxuXG5jbGFzcyBTeW5jU3RlcE9uZU1lc3NhZ2UgZXh0ZW5kcyBPdXRnb2luZ01lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSBNZXNzYWdlVHlwZS5TeW5jO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJGaXJzdCBzeW5jIHN0ZXBcIjtcbiAgICB9XG4gICAgZ2V0KGFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzLmRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3luYyBzdGVwIG9uZSBtZXNzYWdlIHJlcXVpcmVzIGRvY3VtZW50IGFzIGFuIGFyZ3VtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlVmFyU3RyaW5nKHRoaXMuZW5jb2RlciwgYXJncy5kb2N1bWVudE5hbWUpO1xuICAgICAgICB3cml0ZVZhclVpbnQodGhpcy5lbmNvZGVyLCB0aGlzLnR5cGUpO1xuICAgICAgICB3cml0ZVN5bmNTdGVwMSh0aGlzLmVuY29kZXIsIGFyZ3MuZG9jdW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyO1xuICAgIH1cbn1cblxuY2xhc3MgVXBkYXRlTWVzc2FnZSBleHRlbmRzIE91dGdvaW5nTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IE1lc3NhZ2VUeXBlLlN5bmM7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIkEgZG9jdW1lbnQgdXBkYXRlXCI7XG4gICAgfVxuICAgIGdldChhcmdzKSB7XG4gICAgICAgIHdyaXRlVmFyU3RyaW5nKHRoaXMuZW5jb2RlciwgYXJncy5kb2N1bWVudE5hbWUpO1xuICAgICAgICB3cml0ZVZhclVpbnQodGhpcy5lbmNvZGVyLCB0aGlzLnR5cGUpO1xuICAgICAgICB3cml0ZVVwZGF0ZSh0aGlzLmVuY29kZXIsIGFyZ3MudXBkYXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlcjtcbiAgICB9XG59XG5cbmNsYXNzIEF3YXJlbmVzc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNvZGUgPSAxMDAxO1xuICAgIH1cbn1cbmNsYXNzIEhvY3VzcG9jdXNQcm92aWRlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0ge1xuICAgICAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGRvY3VtZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBhd2FyZW5lc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgZm9yY2VTeW5jSW50ZXJ2YWw6IGZhbHNlLFxuICAgICAgICAgICAgb25BdXRoZW50aWNhdGVkOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25BdXRoZW50aWNhdGlvbkZhaWxlZDogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uT3BlbjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQ29ubmVjdDogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uTWVzc2FnZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uT3V0Z29pbmdNZXNzYWdlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25TeW5jZWQ6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvblN0YXR1czogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uRGlzY29ubmVjdDogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQ2xvc2U6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkRlc3Ryb3k6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkF3YXJlbmVzc1VwZGF0ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQXdhcmVuZXNzQ2hhbmdlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25TdGF0ZWxlc3M6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvblVuc3luY2VkQ2hhbmdlczogKCkgPT4gbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc1N5bmNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVuc3luY2VkQ2hhbmdlcyA9IDA7XG4gICAgICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0aG9yaXplZFNjb3BlID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5tYW5hZ2VTb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmludGVydmFscyA9IHtcbiAgICAgICAgICAgIGZvcmNlU3luYzogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ib3VuZERvY3VtZW50VXBkYXRlSGFuZGxlciA9IHRoaXMuZG9jdW1lbnRVcGRhdGVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm91bmRBd2FyZW5lc3NVcGRhdGVIYW5kbGVyID0gdGhpcy5hd2FyZW5lc3NVcGRhdGVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm91bmRQYWdlSGlkZSA9IHRoaXMucGFnZUhpZGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ib3VuZE9uT3BlbiA9IHRoaXMub25PcGVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm91bmRPbkNsb3NlID0gdGhpcy5vbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZm9yd2FyZENvbm5lY3QgPSAoKSA9PiB0aGlzLmVtaXQoXCJjb25uZWN0XCIpO1xuICAgICAgICB0aGlzLmZvcndhcmRTdGF0dXMgPSAoZSkgPT4gdGhpcy5lbWl0KFwic3RhdHVzXCIsIGUpO1xuICAgICAgICB0aGlzLmZvcndhcmRDbG9zZSA9IChlKSA9PiB0aGlzLmVtaXQoXCJjbG9zZVwiLCBlKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkRGlzY29ubmVjdCA9IChlKSA9PiB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIGUpO1xuICAgICAgICB0aGlzLmZvcndhcmREZXN0cm95ID0gKCkgPT4gdGhpcy5lbWl0KFwiZGVzdHJveVwiKTtcbiAgICAgICAgdGhpcy5zZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZG9jdW1lbnQgPSBjb25maWd1cmF0aW9uLmRvY3VtZW50XG4gICAgICAgICAgICA/IGNvbmZpZ3VyYXRpb24uZG9jdW1lbnRcbiAgICAgICAgICAgIDogbmV3IFkuRG9jKCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5hd2FyZW5lc3MgPVxuICAgICAgICAgICAgY29uZmlndXJhdGlvbi5hd2FyZW5lc3MgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gY29uZmlndXJhdGlvbi5hd2FyZW5lc3NcbiAgICAgICAgICAgICAgICA6IG5ldyBBd2FyZW5lc3ModGhpcy5kb2N1bWVudCk7XG4gICAgICAgIHRoaXMub24oXCJvcGVuXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbk9wZW4pO1xuICAgICAgICB0aGlzLm9uKFwibWVzc2FnZVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25NZXNzYWdlKTtcbiAgICAgICAgdGhpcy5vbihcIm91dGdvaW5nTWVzc2FnZVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25PdXRnb2luZ01lc3NhZ2UpO1xuICAgICAgICB0aGlzLm9uKFwic3luY2VkXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vblN5bmNlZCk7XG4gICAgICAgIHRoaXMub24oXCJkZXN0cm95XCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkRlc3Ryb3kpO1xuICAgICAgICB0aGlzLm9uKFwiYXdhcmVuZXNzVXBkYXRlXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkF3YXJlbmVzc1VwZGF0ZSk7XG4gICAgICAgIHRoaXMub24oXCJhd2FyZW5lc3NDaGFuZ2VcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uQXdhcmVuZXNzQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5vbihcInN0YXRlbGVzc1wiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25TdGF0ZWxlc3MpO1xuICAgICAgICB0aGlzLm9uKFwidW5zeW5jZWRDaGFuZ2VzXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vblVuc3luY2VkQ2hhbmdlcyk7XG4gICAgICAgIHRoaXMub24oXCJhdXRoZW50aWNhdGVkXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkF1dGhlbnRpY2F0ZWQpO1xuICAgICAgICB0aGlzLm9uKFwiYXV0aGVudGljYXRpb25GYWlsZWRcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uQXV0aGVudGljYXRpb25GYWlsZWQpO1xuICAgICAgICAoX2EgPSB0aGlzLmF3YXJlbmVzcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uKFwidXBkYXRlXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImF3YXJlbmVzc1VwZGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgc3RhdGVzOiBhd2FyZW5lc3NTdGF0ZXNUb0FycmF5KHRoaXMuYXdhcmVuZXNzLmdldFN0YXRlcygpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgKF9iID0gdGhpcy5hd2FyZW5lc3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJhd2FyZW5lc3NDaGFuZ2VcIiwge1xuICAgICAgICAgICAgICAgIHN0YXRlczogYXdhcmVuZXNzU3RhdGVzVG9BcnJheSh0aGlzLmF3YXJlbmVzcy5nZXRTdGF0ZXMoKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQub24oXCJ1cGRhdGVcIiwgdGhpcy5ib3VuZERvY3VtZW50VXBkYXRlSGFuZGxlcik7XG4gICAgICAgIChfYyA9IHRoaXMuYXdhcmVuZXNzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mub24oXCJ1cGRhdGVcIiwgdGhpcy5ib3VuZEF3YXJlbmVzc1VwZGF0ZUhhbmRsZXIpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5mb3JjZVN5bmNJbnRlcnZhbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuY29uZmlndXJhdGlvbi5mb3JjZVN5bmNJbnRlcnZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHMuZm9yY2VTeW5jID0gc2V0SW50ZXJ2YWwodGhpcy5mb3JjZVN5bmMuYmluZCh0aGlzKSwgdGhpcy5jb25maWd1cmF0aW9uLmZvcmNlU3luY0ludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYW5hZ2VTb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uID0ge30pIHtcbiAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB3ZWJzb2NrZXRQcm92aWRlckNvbmZpZyA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgICAgICB0aGlzLm1hbmFnZVNvY2tldCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIgPSBuZXcgSG9jdXNwb2N1c1Byb3ZpZGVyV2Vic29ja2V0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHdlYnNvY2tldFByb3ZpZGVyQ29uZmlnLnVybCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHsgLi4udGhpcy5jb25maWd1cmF0aW9uLCAuLi5jb25maWd1cmF0aW9uIH07XG4gICAgfVxuICAgIGdldCBkb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5kb2N1bWVudDtcbiAgICB9XG4gICAgZ2V0IGlzQXR0YWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0F0dGFjaGVkO1xuICAgIH1cbiAgICBnZXQgYXdhcmVuZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmF3YXJlbmVzcztcbiAgICB9XG4gICAgZ2V0IGhhc1Vuc3luY2VkQ2hhbmdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zeW5jZWRDaGFuZ2VzID4gMDtcbiAgICB9XG4gICAgcmVzZXRVbnN5bmNlZENoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMudW5zeW5jZWRDaGFuZ2VzID0gMTtcbiAgICAgICAgdGhpcy5lbWl0KFwidW5zeW5jZWRDaGFuZ2VzXCIsIHsgbnVtYmVyOiB0aGlzLnVuc3luY2VkQ2hhbmdlcyB9KTtcbiAgICB9XG4gICAgaW5jcmVtZW50VW5zeW5jZWRDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLnVuc3luY2VkQ2hhbmdlcyArPSAxO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1bnN5bmNlZENoYW5nZXNcIiwgeyBudW1iZXI6IHRoaXMudW5zeW5jZWRDaGFuZ2VzIH0pO1xuICAgIH1cbiAgICBkZWNyZW1lbnRVbnN5bmNlZENoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuc3luY2VkQ2hhbmdlcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudW5zeW5jZWRDaGFuZ2VzIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudW5zeW5jZWRDaGFuZ2VzID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN5bmNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwidW5zeW5jZWRDaGFuZ2VzXCIsIHsgbnVtYmVyOiB0aGlzLnVuc3luY2VkQ2hhbmdlcyB9KTtcbiAgICB9XG4gICAgZm9yY2VTeW5jKCkge1xuICAgICAgICB0aGlzLnJlc2V0VW5zeW5jZWRDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuc2VuZChTeW5jU3RlcE9uZU1lc3NhZ2UsIHtcbiAgICAgICAgICAgIGRvY3VtZW50OiB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgICAgZG9jdW1lbnROYW1lOiB0aGlzLmNvbmZpZ3VyYXRpb24ubmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhZ2VIaWRlKCkge1xuICAgICAgICBpZiAodGhpcy5hd2FyZW5lc3MpIHtcbiAgICAgICAgICAgIHJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLmF3YXJlbmVzcywgW3RoaXMuZG9jdW1lbnQuY2xpZW50SURdLCBcInBhZ2UgaGlkZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIHdpbmRvdykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIHRoaXMuYm91bmRQYWdlSGlkZSk7XG4gICAgfVxuICAgIHNlbmRTdGF0ZWxlc3MocGF5bG9hZCkge1xuICAgICAgICB0aGlzLnNlbmQoU3RhdGVsZXNzTWVzc2FnZSwge1xuICAgICAgICAgICAgZG9jdW1lbnROYW1lOiB0aGlzLmNvbmZpZ3VyYXRpb24ubmFtZSxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVG9rZW4oKSB7XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRva2VuID0gYXdhaXQgdGhpcy5nZXRUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uRGVuaWVkSGFuZGxlcihgRmFpbGVkIHRvIGdldCB0b2tlbiBkdXJpbmcgc2VuZFRva2VuKCk6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kKEF1dGhlbnRpY2F0aW9uTWVzc2FnZSwge1xuICAgICAgICAgICAgdG9rZW46IHRva2VuICE9PSBudWxsICYmIHRva2VuICE9PSB2b2lkIDAgPyB0b2tlbiA6IFwiXCIsXG4gICAgICAgICAgICBkb2N1bWVudE5hbWU6IHRoaXMuY29uZmlndXJhdGlvbi5uYW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZG9jdW1lbnRVcGRhdGVIYW5kbGVyKHVwZGF0ZSwgb3JpZ2luKSB7XG4gICAgICAgIGlmIChvcmlnaW4gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluY3JlbWVudFVuc3luY2VkQ2hhbmdlcygpO1xuICAgICAgICB0aGlzLnNlbmQoVXBkYXRlTWVzc2FnZSwgeyB1cGRhdGUsIGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUgfSk7XG4gICAgfVxuICAgIGF3YXJlbmVzc1VwZGF0ZUhhbmRsZXIoeyBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZCB9LCBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgY2hhbmdlZENsaWVudHMgPSBhZGRlZC5jb25jYXQodXBkYXRlZCkuY29uY2F0KHJlbW92ZWQpO1xuICAgICAgICB0aGlzLnNlbmQoQXdhcmVuZXNzTWVzc2FnZSwge1xuICAgICAgICAgICAgYXdhcmVuZXNzOiB0aGlzLmF3YXJlbmVzcyxcbiAgICAgICAgICAgIGNsaWVudHM6IGNoYW5nZWRDbGllbnRzLFxuICAgICAgICAgICAgZG9jdW1lbnROYW1lOiB0aGlzLmNvbmZpZ3VyYXRpb24ubmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGEgZmlyc3QgaGFuZHNoYWtlIHdpdGggdGhlIHNlcnZlciBoYXMgYmVlbiBlc3RhYmxpc2hlZFxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBkb2VzIG5vdCBtZWFuIGFsbCB1cGRhdGVzIGZyb20gdGhlIGNsaWVudCBoYXZlIGJlZW4gcGVyc2lzdGVkIHRvIHRoZSBiYWNrZW5kLiBGb3IgdGhpcyxcbiAgICAgKiB1c2UgYGhhc1Vuc3luY2VkQ2hhbmdlc2AuXG4gICAgICovXG4gICAgZ2V0IHN5bmNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTeW5jZWQ7XG4gICAgfVxuICAgIHNldCBzeW5jZWQoc3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTeW5jZWQgPT09IHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N5bmNlZCA9IHN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInN5bmNlZFwiLCB7IHN0YXRlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlY2VpdmVTdGF0ZWxlc3MocGF5bG9hZCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJzdGF0ZWxlc3NcIiwgeyBwYXlsb2FkIH0pO1xuICAgIH1cbiAgICAvLyBub3QgbmVlZGVkLCBidXQgcHJvdmlkZXMgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGUuZy4gbGV4aWNhbC95anNcbiAgICBhc3luYyBjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5tYW5hZ2VTb2NrZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihcIkhvY3VzcG9jdXNQcm92aWRlcjo6Y29ubmVjdCgpIGlzIGRlcHJlY2F0ZWQgYW5kIGRvZXMgbm90IGRvIGFueXRoaW5nLiBQbGVhc2UgY29ubmVjdC9kaXNjb25uZWN0IG9uIHRoZSB3ZWJzb2NrZXRQcm92aWRlciwgb3IgYXR0YWNoL2RlYXR0YWNoIHByb3ZpZGVycy5cIik7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hbmFnZVNvY2tldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKFwiSG9jdXNwb2N1c1Byb3ZpZGVyOjpkaXNjb25uZWN0KCkgaXMgZGVwcmVjYXRlZCBhbmQgZG9lcyBub3QgZG8gYW55dGhpbmcuIFBsZWFzZSBjb25uZWN0L2Rpc2Nvbm5lY3Qgb24gdGhlIHdlYnNvY2tldFByb3ZpZGVyLCBvciBhdHRhY2gvZGVhdHRhY2ggcHJvdmlkZXJzLlwiKTtcbiAgICB9XG4gICAgYXN5bmMgb25PcGVuKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdChcIm9wZW5cIiwgeyBldmVudCB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kVG9rZW4oKTtcbiAgICAgICAgdGhpcy5zdGFydFN5bmMoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VG9rZW4oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb25maWd1cmF0aW9uLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5jb25maWd1cmF0aW9uLnRva2VuKCk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi50b2tlbjtcbiAgICB9XG4gICAgc3RhcnRTeW5jKCkge1xuICAgICAgICB0aGlzLnJlc2V0VW5zeW5jZWRDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuc2VuZChTeW5jU3RlcE9uZU1lc3NhZ2UsIHtcbiAgICAgICAgICAgIGRvY3VtZW50OiB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgICAgZG9jdW1lbnROYW1lOiB0aGlzLmNvbmZpZ3VyYXRpb24ubmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmF3YXJlbmVzcyAmJiB0aGlzLmF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZChBd2FyZW5lc3NNZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgYXdhcmVuZXNzOiB0aGlzLmF3YXJlbmVzcyxcbiAgICAgICAgICAgICAgICBjbGllbnRzOiBbdGhpcy5kb2N1bWVudC5jbGllbnRJRF0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnROYW1lOiB0aGlzLmNvbmZpZ3VyYXRpb24ubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmQobWVzc2FnZSwgYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQXR0YWNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VTZW5kZXIgPSBuZXcgTWVzc2FnZVNlbmRlcihtZXNzYWdlLCBhcmdzKTtcbiAgICAgICAgdGhpcy5lbWl0KFwib3V0Z29pbmdNZXNzYWdlXCIsIHsgbWVzc2FnZTogbWVzc2FnZVNlbmRlci5tZXNzYWdlIH0pO1xuICAgICAgICBtZXNzYWdlU2VuZGVyLnNlbmQodGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyKTtcbiAgICB9XG4gICAgb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgSW5jb21pbmdNZXNzYWdlKGV2ZW50LmRhdGEpO1xuICAgICAgICBjb25zdCBkb2N1bWVudE5hbWUgPSBtZXNzYWdlLnJlYWRWYXJTdHJpbmcoKTtcbiAgICAgICAgbWVzc2FnZS53cml0ZVZhclN0cmluZyhkb2N1bWVudE5hbWUpO1xuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIHsgZXZlbnQsIG1lc3NhZ2U6IG5ldyBJbmNvbWluZ01lc3NhZ2UoZXZlbnQuZGF0YSkgfSk7XG4gICAgICAgIG5ldyBNZXNzYWdlUmVjZWl2ZXIobWVzc2FnZSkuYXBwbHkodGhpcywgdHJ1ZSk7XG4gICAgfVxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3luY2VkID0gZmFsc2U7XG4gICAgICAgIC8vIHVwZGF0ZSBhd2FyZW5lc3MgKGFsbCB1c2VycyBleGNlcHQgbG9jYWwgbGVmdClcbiAgICAgICAgaWYgKHRoaXMuYXdhcmVuZXNzKSB7XG4gICAgICAgICAgICByZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcy5hd2FyZW5lc3MsIEFycmF5LmZyb20odGhpcy5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKS5maWx0ZXIoKGNsaWVudCkgPT4gY2xpZW50ICE9PSB0aGlzLmRvY3VtZW50LmNsaWVudElEKSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiKTtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxzLmZvcmNlU3luYykge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFscy5mb3JjZVN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF3YXJlbmVzcykge1xuICAgICAgICAgICAgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHRoaXMuYXdhcmVuZXNzLCBbdGhpcy5kb2N1bWVudC5jbGllbnRJRF0sIFwicHJvdmlkZXIgZGVzdHJveVwiKTtcbiAgICAgICAgICAgIHRoaXMuYXdhcmVuZXNzLm9mZihcInVwZGF0ZVwiLCB0aGlzLmJvdW5kQXdhcmVuZXNzVXBkYXRlSGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLmF3YXJlbmVzcy5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb2N1bWVudC5vZmYoXCJ1cGRhdGVcIiwgdGhpcy5ib3VuZERvY3VtZW50VXBkYXRlSGFuZGxlcik7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIGlmICh0aGlzLm1hbmFnZVNvY2tldCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiIGluIHdpbmRvdykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIHRoaXMuYm91bmRQYWdlSGlkZSk7XG4gICAgfVxuICAgIGRldGFjaCgpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZihcImNvbm5lY3RcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uQ29ubmVjdCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoXCJjb25uZWN0XCIsIHRoaXMuZm9yd2FyZENvbm5lY3QpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub2ZmKFwic3RhdHVzXCIsIHRoaXMuZm9yd2FyZFN0YXR1cyk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoXCJzdGF0dXNcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uU3RhdHVzKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZihcIm9wZW5cIiwgdGhpcy5ib3VuZE9uT3Blbik7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoXCJjbG9zZVwiLCB0aGlzLmJvdW5kT25DbG9zZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoXCJjbG9zZVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25DbG9zZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoXCJjbG9zZVwiLCB0aGlzLmZvcndhcmRDbG9zZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoXCJkaXNjb25uZWN0XCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkRpc2Nvbm5lY3QpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub2ZmKFwiZGlzY29ubmVjdFwiLCB0aGlzLmZvcndhcmREaXNjb25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZihcImRlc3Ryb3lcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uRGVzdHJveSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoXCJkZXN0cm95XCIsIHRoaXMuZm9yd2FyZERlc3Ryb3kpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIuZGV0YWNoKHRoaXMpO1xuICAgICAgICB0aGlzLl9pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGF0dGFjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQXR0YWNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vbihcImNvbm5lY3RcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uQ29ubmVjdCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vbihcImNvbm5lY3RcIiwgdGhpcy5mb3J3YXJkQ29ubmVjdCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vbihcInN0YXR1c1wiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25TdGF0dXMpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oXCJzdGF0dXNcIiwgdGhpcy5mb3J3YXJkU3RhdHVzKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKFwib3BlblwiLCB0aGlzLmJvdW5kT25PcGVuKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKFwiY2xvc2VcIiwgdGhpcy5ib3VuZE9uQ2xvc2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oXCJjbG9zZVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25DbG9zZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vbihcImNsb3NlXCIsIHRoaXMuZm9yd2FyZENsb3NlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKFwiZGlzY29ubmVjdFwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25EaXNjb25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKFwiZGlzY29ubmVjdFwiLCB0aGlzLmZvcndhcmREaXNjb25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKFwiZGVzdHJveVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25EZXN0cm95KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKFwiZGVzdHJveVwiLCB0aGlzLmZvcndhcmREZXN0cm95KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLmF0dGFjaCh0aGlzKTtcbiAgICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWU7XG4gICAgfVxuICAgIHBlcm1pc3Npb25EZW5pZWRIYW5kbGVyKHJlYXNvbikge1xuICAgICAgICB0aGlzLmVtaXQoXCJhdXRoZW50aWNhdGlvbkZhaWxlZFwiLCB7IHJlYXNvbiB9KTtcbiAgICAgICAgdGhpcy5pc0F1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYXV0aGVudGljYXRlZEhhbmRsZXIoc2NvcGUpIHtcbiAgICAgICAgdGhpcy5pc0F1dGhlbnRpY2F0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmF1dGhvcml6ZWRTY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLmVtaXQoXCJhdXRoZW50aWNhdGVkXCIsIHsgc2NvcGUgfSk7XG4gICAgfVxuICAgIHNldEF3YXJlbmVzc0ZpZWxkKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmF3YXJlbmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF3YXJlbmVzc0Vycm9yKGBDYW5ub3Qgc2V0IGF3YXJlbmVzcyBmaWVsZCBcIiR7a2V5fVwiIHRvICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfS4gWW91IGhhdmUgZGlzYWJsZWQgQXdhcmVuZXNzIGZvciB0aGlzIHByb3ZpZGVyIGJ5IGV4cGxpY2l0bHkgcGFzc2luZyBhd2FyZW5lc3M6IG51bGwgaW4gdGhlIHByb3ZpZGVyIGNvbmZpZ3VyYXRpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKGtleSwgdmFsdWUpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQXdhcmVuZXNzRXJyb3IsIEhvY3VzcG9jdXNQcm92aWRlciwgSG9jdXNwb2N1c1Byb3ZpZGVyV2Vic29ja2V0LCBNZXNzYWdlVHlwZSwgV2ViU29ja2V0U3RhdHVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob2N1c3BvY3VzLXByb3ZpZGVyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js\n");

/***/ })

};
;