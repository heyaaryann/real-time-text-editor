"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lifeomic";
exports.ids = ["vendor-chunks/@lifeomic"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lifeomic/attempt/dist/es6/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lifeomic/attempt/dist/es6/src/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultCalculateDelay: () => (/* binding */ defaultCalculateDelay),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\nfunction applyDefaults(options) {\n    if (!options) {\n        options = {};\n    }\n    return {\n        delay: (options.delay === undefined) ? 200 : options.delay,\n        initialDelay: (options.initialDelay === undefined) ? 0 : options.initialDelay,\n        minDelay: (options.minDelay === undefined) ? 0 : options.minDelay,\n        maxDelay: (options.maxDelay === undefined) ? 0 : options.maxDelay,\n        factor: (options.factor === undefined) ? 0 : options.factor,\n        maxAttempts: (options.maxAttempts === undefined) ? 3 : options.maxAttempts,\n        timeout: (options.timeout === undefined) ? 0 : options.timeout,\n        jitter: (options.jitter === true),\n        initialJitter: (options.initialJitter === true),\n        handleError: (options.handleError === undefined) ? null : options.handleError,\n        handleTimeout: (options.handleTimeout === undefined) ? null : options.handleTimeout,\n        beforeAttempt: (options.beforeAttempt === undefined) ? null : options.beforeAttempt,\n        calculateDelay: (options.calculateDelay === undefined) ? null : options.calculateDelay\n    };\n}\nasync function sleep(delay) {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n}\nfunction defaultCalculateDelay(context, options) {\n    let delay = options.delay;\n    if (delay === 0) {\n        // no delay between attempts\n        return 0;\n    }\n    if (options.factor) {\n        delay *= Math.pow(options.factor, context.attemptNum - 1);\n        if (options.maxDelay !== 0) {\n            delay = Math.min(delay, options.maxDelay);\n        }\n    }\n    if (options.jitter) {\n        // Jitter will result in a random value between `minDelay` and\n        // calculated delay for a given attempt.\n        // See https://www.awsarchitectureblog.com/2015/03/backoff.html\n        // We're using the \"full jitter\" strategy.\n        const min = Math.ceil(options.minDelay);\n        const max = Math.floor(delay);\n        delay = Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return Math.round(delay);\n}\nasync function retry(attemptFunc, attemptOptions) {\n    const options = applyDefaults(attemptOptions);\n    for (const prop of [\n        'delay',\n        'initialDelay',\n        'minDelay',\n        'maxDelay',\n        'maxAttempts',\n        'timeout'\n    ]) {\n        const value = options[prop];\n        if (!Number.isInteger(value) || (value < 0)) {\n            throw new Error(`Value for ${prop} must be an integer greater than or equal to 0`);\n        }\n    }\n    if ((options.factor.constructor !== Number) || (options.factor < 0)) {\n        throw new Error(`Value for factor must be a number greater than or equal to 0`);\n    }\n    if (options.delay < options.minDelay) {\n        throw new Error(`delay cannot be less than minDelay (delay: ${options.delay}, minDelay: ${options.minDelay}`);\n    }\n    const context = {\n        attemptNum: 0,\n        attemptsRemaining: options.maxAttempts ? options.maxAttempts : -1,\n        aborted: false,\n        abort() {\n            context.aborted = true;\n        }\n    };\n    const calculateDelay = options.calculateDelay || defaultCalculateDelay;\n    async function makeAttempt() {\n        if (options.beforeAttempt) {\n            options.beforeAttempt(context, options);\n        }\n        if (context.aborted) {\n            const err = new Error(`Attempt aborted`);\n            err.code = 'ATTEMPT_ABORTED';\n            throw err;\n        }\n        const onError = async (err) => {\n            if (options.handleError) {\n                await options.handleError(err, context, options);\n            }\n            if (context.aborted || (context.attemptsRemaining === 0)) {\n                throw err;\n            }\n            // We are about to try again so increment attempt number\n            context.attemptNum++;\n            const delay = calculateDelay(context, options);\n            if (delay) {\n                await sleep(delay);\n            }\n            return makeAttempt();\n        };\n        if (context.attemptsRemaining > 0) {\n            context.attemptsRemaining--;\n        }\n        if (options.timeout) {\n            return new Promise((resolve, reject) => {\n                const timer = setTimeout(() => {\n                    if (options.handleTimeout) {\n                        // If calling handleTimeout throws an error that is not wrapped in a promise\n                        // we want to catch the error and reject.\n                        try {\n                            resolve(options.handleTimeout(context, options));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                    }\n                    else {\n                        const err = new Error(`Retry timeout (attemptNum: ${context.attemptNum}, timeout: ${options.timeout})`);\n                        err.code = 'ATTEMPT_TIMEOUT';\n                        reject(err);\n                    }\n                }, options.timeout);\n                attemptFunc(context, options).then((result) => {\n                    clearTimeout(timer);\n                    resolve(result);\n                }).catch((err) => {\n                    clearTimeout(timer);\n                    // Calling resolve with a Promise that rejects here will result\n                    // in an unhandled rejection. Calling `reject` with errors\n                    // does not result in an unhandled rejection\n                    onError(err).then(resolve).catch(reject);\n                });\n            });\n        }\n        else {\n            // No timeout provided so wait indefinitely for the returned promise\n            // to be resolved.\n            return attemptFunc(context, options).catch(onError);\n        }\n    }\n    const initialDelay = options.calculateDelay\n        ? options.calculateDelay(context, options)\n        : options.initialDelay;\n    if (initialDelay) {\n        await sleep(initialDelay);\n    }\n    if (context.attemptNum < 1 && options.initialJitter) {\n        const delay = calculateDelay(context, options);\n        if (delay) {\n            await sleep(delay);\n        }\n    }\n    return makeAttempt();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpZmVvbWljL2F0dGVtcHQvZGlzdC9lczYvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGNBQWMsY0FBYyxpQkFBaUI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLG1CQUFtQixhQUFhLGdCQUFnQjtBQUM1SDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FyeWFuZ295YWwvcmVhbC10aW1lLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AbGlmZW9taWMvYXR0ZW1wdC9kaXN0L2VzNi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXk6IChvcHRpb25zLmRlbGF5ID09PSB1bmRlZmluZWQpID8gMjAwIDogb3B0aW9ucy5kZWxheSxcbiAgICAgICAgaW5pdGlhbERlbGF5OiAob3B0aW9ucy5pbml0aWFsRGVsYXkgPT09IHVuZGVmaW5lZCkgPyAwIDogb3B0aW9ucy5pbml0aWFsRGVsYXksXG4gICAgICAgIG1pbkRlbGF5OiAob3B0aW9ucy5taW5EZWxheSA9PT0gdW5kZWZpbmVkKSA/IDAgOiBvcHRpb25zLm1pbkRlbGF5LFxuICAgICAgICBtYXhEZWxheTogKG9wdGlvbnMubWF4RGVsYXkgPT09IHVuZGVmaW5lZCkgPyAwIDogb3B0aW9ucy5tYXhEZWxheSxcbiAgICAgICAgZmFjdG9yOiAob3B0aW9ucy5mYWN0b3IgPT09IHVuZGVmaW5lZCkgPyAwIDogb3B0aW9ucy5mYWN0b3IsXG4gICAgICAgIG1heEF0dGVtcHRzOiAob3B0aW9ucy5tYXhBdHRlbXB0cyA9PT0gdW5kZWZpbmVkKSA/IDMgOiBvcHRpb25zLm1heEF0dGVtcHRzLFxuICAgICAgICB0aW1lb3V0OiAob3B0aW9ucy50aW1lb3V0ID09PSB1bmRlZmluZWQpID8gMCA6IG9wdGlvbnMudGltZW91dCxcbiAgICAgICAgaml0dGVyOiAob3B0aW9ucy5qaXR0ZXIgPT09IHRydWUpLFxuICAgICAgICBpbml0aWFsSml0dGVyOiAob3B0aW9ucy5pbml0aWFsSml0dGVyID09PSB0cnVlKSxcbiAgICAgICAgaGFuZGxlRXJyb3I6IChvcHRpb25zLmhhbmRsZUVycm9yID09PSB1bmRlZmluZWQpID8gbnVsbCA6IG9wdGlvbnMuaGFuZGxlRXJyb3IsXG4gICAgICAgIGhhbmRsZVRpbWVvdXQ6IChvcHRpb25zLmhhbmRsZVRpbWVvdXQgPT09IHVuZGVmaW5lZCkgPyBudWxsIDogb3B0aW9ucy5oYW5kbGVUaW1lb3V0LFxuICAgICAgICBiZWZvcmVBdHRlbXB0OiAob3B0aW9ucy5iZWZvcmVBdHRlbXB0ID09PSB1bmRlZmluZWQpID8gbnVsbCA6IG9wdGlvbnMuYmVmb3JlQXR0ZW1wdCxcbiAgICAgICAgY2FsY3VsYXRlRGVsYXk6IChvcHRpb25zLmNhbGN1bGF0ZURlbGF5ID09PSB1bmRlZmluZWQpID8gbnVsbCA6IG9wdGlvbnMuY2FsY3VsYXRlRGVsYXlcbiAgICB9O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKGRlbGF5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdENhbGN1bGF0ZURlbGF5KGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBsZXQgZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICAgIGlmIChkZWxheSA9PT0gMCkge1xuICAgICAgICAvLyBubyBkZWxheSBiZXR3ZWVuIGF0dGVtcHRzXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mYWN0b3IpIHtcbiAgICAgICAgZGVsYXkgKj0gTWF0aC5wb3cob3B0aW9ucy5mYWN0b3IsIGNvbnRleHQuYXR0ZW1wdE51bSAtIDEpO1xuICAgICAgICBpZiAob3B0aW9ucy5tYXhEZWxheSAhPT0gMCkge1xuICAgICAgICAgICAgZGVsYXkgPSBNYXRoLm1pbihkZWxheSwgb3B0aW9ucy5tYXhEZWxheSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaml0dGVyKSB7XG4gICAgICAgIC8vIEppdHRlciB3aWxsIHJlc3VsdCBpbiBhIHJhbmRvbSB2YWx1ZSBiZXR3ZWVuIGBtaW5EZWxheWAgYW5kXG4gICAgICAgIC8vIGNhbGN1bGF0ZWQgZGVsYXkgZm9yIGEgZ2l2ZW4gYXR0ZW1wdC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3LmF3c2FyY2hpdGVjdHVyZWJsb2cuY29tLzIwMTUvMDMvYmFja29mZi5odG1sXG4gICAgICAgIC8vIFdlJ3JlIHVzaW5nIHRoZSBcImZ1bGwgaml0dGVyXCIgc3RyYXRlZ3kuXG4gICAgICAgIGNvbnN0IG1pbiA9IE1hdGguY2VpbChvcHRpb25zLm1pbkRlbGF5KTtcbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5mbG9vcihkZWxheSk7XG4gICAgICAgIGRlbGF5ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQoZGVsYXkpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJldHJ5KGF0dGVtcHRGdW5jLCBhdHRlbXB0T3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRzKGF0dGVtcHRPcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgW1xuICAgICAgICAnZGVsYXknLFxuICAgICAgICAnaW5pdGlhbERlbGF5JyxcbiAgICAgICAgJ21pbkRlbGF5JyxcbiAgICAgICAgJ21heERlbGF5JyxcbiAgICAgICAgJ21heEF0dGVtcHRzJyxcbiAgICAgICAgJ3RpbWVvdXQnXG4gICAgXSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgKHZhbHVlIDwgMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgZm9yICR7cHJvcH0gbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChvcHRpb25zLmZhY3Rvci5jb25zdHJ1Y3RvciAhPT0gTnVtYmVyKSB8fCAob3B0aW9ucy5mYWN0b3IgPCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIGZvciBmYWN0b3IgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMGApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kZWxheSA8IG9wdGlvbnMubWluRGVsYXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkZWxheSBjYW5ub3QgYmUgbGVzcyB0aGFuIG1pbkRlbGF5IChkZWxheTogJHtvcHRpb25zLmRlbGF5fSwgbWluRGVsYXk6ICR7b3B0aW9ucy5taW5EZWxheX1gKTtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgYXR0ZW1wdE51bTogMCxcbiAgICAgICAgYXR0ZW1wdHNSZW1haW5pbmc6IG9wdGlvbnMubWF4QXR0ZW1wdHMgPyBvcHRpb25zLm1heEF0dGVtcHRzIDogLTEsXG4gICAgICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgICAgICBhYm9ydCgpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNhbGN1bGF0ZURlbGF5ID0gb3B0aW9ucy5jYWxjdWxhdGVEZWxheSB8fCBkZWZhdWx0Q2FsY3VsYXRlRGVsYXk7XG4gICAgYXN5bmMgZnVuY3Rpb24gbWFrZUF0dGVtcHQoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmJlZm9yZUF0dGVtcHQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYmVmb3JlQXR0ZW1wdChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYEF0dGVtcHQgYWJvcnRlZGApO1xuICAgICAgICAgICAgZXJyLmNvZGUgPSAnQVRURU1QVF9BQk9SVEVEJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkVycm9yID0gYXN5bmMgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFuZGxlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvcHRpb25zLmhhbmRsZUVycm9yKGVyciwgY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGV4dC5hYm9ydGVkIHx8IChjb250ZXh0LmF0dGVtcHRzUmVtYWluaW5nID09PSAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGFyZSBhYm91dCB0byB0cnkgYWdhaW4gc28gaW5jcmVtZW50IGF0dGVtcHQgbnVtYmVyXG4gICAgICAgICAgICBjb250ZXh0LmF0dGVtcHROdW0rKztcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gY2FsY3VsYXRlRGVsYXkoY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZUF0dGVtcHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbnRleHQuYXR0ZW1wdHNSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LmF0dGVtcHRzUmVtYWluaW5nLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBjYWxsaW5nIGhhbmRsZVRpbWVvdXQgdGhyb3dzIGFuIGVycm9yIHRoYXQgaXMgbm90IHdyYXBwZWQgaW4gYSBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGNhdGNoIHRoZSBlcnJvciBhbmQgcmVqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9wdGlvbnMuaGFuZGxlVGltZW91dChjb250ZXh0LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgUmV0cnkgdGltZW91dCAoYXR0ZW1wdE51bTogJHtjb250ZXh0LmF0dGVtcHROdW19LCB0aW1lb3V0OiAke29wdGlvbnMudGltZW91dH0pYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSA9ICdBVFRFTVBUX1RJTUVPVVQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGF0dGVtcHRGdW5jKGNvbnRleHQsIG9wdGlvbnMpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsaW5nIHJlc29sdmUgd2l0aCBhIFByb21pc2UgdGhhdCByZWplY3RzIGhlcmUgd2lsbCByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gYW4gdW5oYW5kbGVkIHJlamVjdGlvbi4gQ2FsbGluZyBgcmVqZWN0YCB3aXRoIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCByZXN1bHQgaW4gYW4gdW5oYW5kbGVkIHJlamVjdGlvblxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycikudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyB0aW1lb3V0IHByb3ZpZGVkIHNvIHdhaXQgaW5kZWZpbml0ZWx5IGZvciB0aGUgcmV0dXJuZWQgcHJvbWlzZVxuICAgICAgICAgICAgLy8gdG8gYmUgcmVzb2x2ZWQuXG4gICAgICAgICAgICByZXR1cm4gYXR0ZW1wdEZ1bmMoY29udGV4dCwgb3B0aW9ucykuY2F0Y2gob25FcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbERlbGF5ID0gb3B0aW9ucy5jYWxjdWxhdGVEZWxheVxuICAgICAgICA/IG9wdGlvbnMuY2FsY3VsYXRlRGVsYXkoY29udGV4dCwgb3B0aW9ucylcbiAgICAgICAgOiBvcHRpb25zLmluaXRpYWxEZWxheTtcbiAgICBpZiAoaW5pdGlhbERlbGF5KSB7XG4gICAgICAgIGF3YWl0IHNsZWVwKGluaXRpYWxEZWxheSk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmF0dGVtcHROdW0gPCAxICYmIG9wdGlvbnMuaW5pdGlhbEppdHRlcikge1xuICAgICAgICBjb25zdCBkZWxheSA9IGNhbGN1bGF0ZURlbGF5KGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKGRlbGF5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFrZUF0dGVtcHQoKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lifeomic/attempt/dist/es6/src/index.js\n");

/***/ })

};
;