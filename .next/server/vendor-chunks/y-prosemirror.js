"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/y-prosemirror";
exports.ids = ["vendor-chunks/y-prosemirror"];
exports.modules = {

/***/ "(ssr)/./node_modules/y-prosemirror/src/lib.js":
/*!***********************************************!*\
  !*** ./node_modules/y-prosemirror/src/lib.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   absolutePositionToRelativePosition: () => (/* binding */ absolutePositionToRelativePosition),\n/* harmony export */   initProseMirrorDoc: () => (/* binding */ initProseMirrorDoc),\n/* harmony export */   prosemirrorJSONToYDoc: () => (/* binding */ prosemirrorJSONToYDoc),\n/* harmony export */   prosemirrorJSONToYXmlFragment: () => (/* binding */ prosemirrorJSONToYXmlFragment),\n/* harmony export */   prosemirrorToYDoc: () => (/* binding */ prosemirrorToYDoc),\n/* harmony export */   prosemirrorToYXmlFragment: () => (/* binding */ prosemirrorToYXmlFragment),\n/* harmony export */   relativePositionToAbsolutePosition: () => (/* binding */ relativePositionToAbsolutePosition),\n/* harmony export */   setMeta: () => (/* binding */ setMeta),\n/* harmony export */   yDocToProsemirror: () => (/* binding */ yDocToProsemirror),\n/* harmony export */   yDocToProsemirrorJSON: () => (/* binding */ yDocToProsemirrorJSON),\n/* harmony export */   yXmlFragmentToProseMirrorFragment: () => (/* binding */ yXmlFragmentToProseMirrorFragment),\n/* harmony export */   yXmlFragmentToProseMirrorRootNode: () => (/* binding */ yXmlFragmentToProseMirrorRootNode),\n/* harmony export */   yXmlFragmentToProsemirror: () => (/* binding */ yXmlFragmentToProsemirror),\n/* harmony export */   yXmlFragmentToProsemirrorJSON: () => (/* binding */ yXmlFragmentToProsemirrorJSON)\n/* harmony export */ });\n/* harmony import */ var _plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/sync-plugin.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var _plugins_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/error */ \"(ssr)/./node_modules/lib0/error.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/map */ \"(ssr)/./node_modules/lib0/map.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/eventloop */ \"(ssr)/./node_modules/lib0/eventloop.js\");\n // eslint-disable-line\n\n\n // eslint-disable-line\n // eslint-disable-line\n\n\n\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType, Node | Array<Node>>} ProsemirrorMapping\n */\n\n/**\n * Is null if no timeout is in progress.\n * Is defined if a timeout is in progress.\n * Maps from view\n * @type {Map<EditorView, Map<any, any>>|null}\n */\nlet viewsToUpdate = null\n\nconst updateMetas = () => {\n  const ups = /** @type {Map<EditorView, Map<any, any>>} */ (viewsToUpdate)\n  viewsToUpdate = null\n  ups.forEach((metas, view) => {\n    const tr = view.state.tr\n    const syncState = _plugins_keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(view.state)\n    if (syncState && syncState.binding && !syncState.binding.isDestroyed) {\n      metas.forEach((val, key) => {\n        tr.setMeta(key, val)\n      })\n      view.dispatch(tr)\n    }\n  })\n}\n\nconst setMeta = (view, key, value) => {\n  if (!viewsToUpdate) {\n    viewsToUpdate = new Map()\n    lib0_eventloop__WEBPACK_IMPORTED_MODULE_1__.timeout(0, updateMetas)\n  }\n  lib0_map__WEBPACK_IMPORTED_MODULE_2__.setIfUndefined(viewsToUpdate, view, lib0_map__WEBPACK_IMPORTED_MODULE_2__.create).set(key, value)\n}\n\n/**\n * Transforms a Prosemirror based absolute position to a Yjs Cursor (relative position in the Yjs model).\n *\n * @param {number} pos\n * @param {Y.XmlFragment} type\n * @param {ProsemirrorMapping} mapping\n * @return {any} relative position\n */\nconst absolutePositionToRelativePosition = (pos, type, mapping) => {\n  if (pos === 0) {\n    // if the type is later populated, we want to retain the 0 position (hence assoc=-1)\n    return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, 0, type.length === 0 ? -1 : 0)\n  }\n  /**\n   * @type {any}\n   */\n  let n = type._first === null ? null : /** @type {Y.ContentType} */ (type._first.content).type\n  while (n !== null && type !== n) {\n    if (n instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n      if (n._length >= pos) {\n        return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(n, pos, type.length === 0 ? -1 : 0)\n      } else {\n        pos -= n._length\n      }\n      if (n._item !== null && n._item.next !== null) {\n        n = /** @type {Y.ContentType} */ (n._item.next.content).type\n      } else {\n        do {\n          n = n._item === null ? null : n._item.parent\n          pos--\n        } while (n !== type && n !== null && n._item !== null && n._item.next === null)\n        if (n !== null && n !== type) {\n          // @ts-gnore we know that n.next !== null because of above loop conditition\n          n = n._item === null ? null : /** @type {Y.ContentType} */ (/** @type Y.Item */ (n._item.next).content).type\n        }\n      }\n    } else {\n      const pNodeSize = /** @type {any} */ (mapping.get(n) || { nodeSize: 0 }).nodeSize\n      if (n._first !== null && pos < pNodeSize) {\n        n = /** @type {Y.ContentType} */ (n._first.content).type\n        pos--\n      } else {\n        if (pos === 1 && n._length === 0 && pNodeSize > 1) {\n          // edge case, should end in this paragraph\n          return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(n) : null, null)\n        }\n        pos -= pNodeSize\n        if (n._item !== null && n._item.next !== null) {\n          n = /** @type {Y.ContentType} */ (n._item.next.content).type\n        } else {\n          if (pos === 0) {\n            // set to end of n.parent\n            n = n._item === null ? n : n._item.parent\n            return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(n) : null, null)\n          }\n          do {\n            n = /** @type {Y.Item} */ (n._item).parent\n            pos--\n          } while (n !== type && /** @type {Y.Item} */ (n._item).next === null)\n          // if n is null at this point, we have an unexpected case\n          if (n !== type) {\n            // We know that n._item.next is defined because of above loop condition\n            n = /** @type {Y.ContentType} */ (/** @type {Y.Item} */ (/** @type {Y.Item} */ (n._item).next).content).type\n          }\n        }\n      }\n    }\n    if (n === null) {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_4__.unexpectedCase()\n    }\n    if (pos === 0 && n.constructor !== yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText && n !== type) { // TODO: set to <= 0\n      return createRelativePosition(n._item.parent, n._item)\n    }\n  }\n  return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, type._length, type.length === 0 ? -1 : 0)\n}\n\nconst createRelativePosition = (type, item) => {\n  let typeid = null\n  let tname = null\n  if (type._item === null) {\n    tname = yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(type)\n  } else {\n    typeid = yjs__WEBPACK_IMPORTED_MODULE_3__.createID(type._item.id.client, type._item.id.clock)\n  }\n  return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(typeid, tname, item.id)\n}\n\n/**\n * @param {Y.Doc} y\n * @param {Y.XmlFragment} documentType Top level type that is bound to pView\n * @param {any} relPos Encoded Yjs based relative position\n * @param {ProsemirrorMapping} mapping\n * @return {null|number}\n */\nconst relativePositionToAbsolutePosition = (y, documentType, relPos, mapping) => {\n  const decodedPos = yjs__WEBPACK_IMPORTED_MODULE_3__.createAbsolutePositionFromRelativePosition(relPos, y)\n  if (decodedPos === null || (decodedPos.type !== documentType && !yjs__WEBPACK_IMPORTED_MODULE_3__.isParentOf(documentType, decodedPos.type._item))) {\n    return null\n  }\n  let type = decodedPos.type\n  let pos = 0\n  if (type.constructor === yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n    pos = decodedPos.index\n  } else if (type._item === null || !type._item.deleted) {\n    let n = type._first\n    let i = 0\n    while (i < type._length && i < decodedPos.index && n !== null) {\n      if (!n.deleted) {\n        const t = /** @type {Y.ContentType} */ (n.content).type\n        i++\n        if (t instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n          pos += t._length\n        } else {\n          pos += /** @type {any} */ (mapping.get(t)).nodeSize\n        }\n      }\n      n = /** @type {Y.Item} */ (n.right)\n    }\n    pos += 1 // increase because we go out of n\n  }\n  while (type !== documentType && type._item !== null) {\n    // @ts-ignore\n    const parent = type._item.parent\n    // @ts-ignore\n    if (parent._item === null || !parent._item.deleted) {\n      pos += 1 // the start tag\n      let n = /** @type {Y.AbstractType} */ (parent)._first\n      // now iterate until we found type\n      while (n !== null) {\n        const contentType = /** @type {Y.ContentType} */ (n.content).type\n        if (contentType === type) {\n          break\n        }\n        if (!n.deleted) {\n          if (contentType instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n            pos += contentType._length\n          } else {\n            pos += /** @type {any} */ (mapping.get(contentType)).nodeSize\n          }\n        }\n        n = n.right\n      }\n    }\n    type = /** @type {Y.AbstractType} */ (parent)\n  }\n  return pos - 1 // we don't count the most outer tag, because it is a fragment\n}\n\n/**\n * Utility function for converting an Y.Fragment to a ProseMirror fragment.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */\nconst yXmlFragmentToProseMirrorFragment = (yXmlFragment, schema) => {\n  const fragmentContent = yXmlFragment.toArray().map((t) =>\n    (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createNodeFromYElement)(\n      /** @type {Y.XmlElement} */ (t),\n      schema,\n      (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createEmptyMeta)()\n    )\n  ).filter((n) => n !== null)\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Fragment.fromArray(fragmentContent)\n}\n\n/**\n * Utility function for converting an Y.Fragment to a ProseMirror node.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */\nconst yXmlFragmentToProseMirrorRootNode = (yXmlFragment, schema) =>\n  schema.topNodeType.create(null, yXmlFragmentToProseMirrorFragment(yXmlFragment, schema))\n\n/**\n * The initial ProseMirror content should be supplied by Yjs. This function transforms a Y.Fragment\n * to a ProseMirror Doc node and creates a mapping that is used by the sync plugin.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n *\n * @todo deprecate mapping property\n */\nconst initProseMirrorDoc = (yXmlFragment, schema) => {\n  const meta = (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createEmptyMeta)()\n  const fragmentContent = yXmlFragment.toArray().map((t) =>\n    (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createNodeFromYElement)(\n      /** @type {Y.XmlElement} */ (t),\n      schema,\n      meta\n    )\n  ).filter((n) => n !== null)\n  const doc = schema.topNodeType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Fragment.fromArray(fragmentContent))\n  return { doc, meta, mapping: meta.mapping }\n}\n\n/**\n * Utility method to convert a Prosemirror Doc Node into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Node} doc\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */\nfunction prosemirrorToYDoc (doc, xmlFragment = 'prosemirror') {\n  const ydoc = new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc()\n  const type = /** @type {Y.XmlFragment} */ (ydoc.get(xmlFragment, yjs__WEBPACK_IMPORTED_MODULE_3__.XmlFragment))\n  if (!type.doc) {\n    return ydoc\n  }\n\n  prosemirrorToYXmlFragment(doc, type)\n  return type.doc\n}\n\n/**\n * Utility method to update an empty Y.XmlFragment with content from a Prosemirror Doc Node.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * Note: The Y.XmlFragment does not need to be part of a Y.Doc document at the time that this\n * method is called, but it must be added before any other operations are performed on it.\n *\n * @param {Node} doc prosemirror document.\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */\nfunction prosemirrorToYXmlFragment (doc, xmlFragment) {\n  const type = xmlFragment || new yjs__WEBPACK_IMPORTED_MODULE_3__.XmlFragment()\n  const ydoc = type.doc ? type.doc : { transact: (transaction) => transaction(undefined) }\n  ;(0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.updateYFragment)(ydoc, type, doc, { mapping: new Map(), isOMark: new Map() })\n  return type\n}\n\n/**\n * Utility method to convert Prosemirror compatible JSON into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */\nfunction prosemirrorJSONToYDoc (schema, state, xmlFragment = 'prosemirror') {\n  const doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n  return prosemirrorToYDoc(doc, xmlFragment)\n}\n\n/**\n * Utility method to convert Prosemirror compatible JSON to a Y.XmlFragment\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */\nfunction prosemirrorJSONToYXmlFragment (schema, state, xmlFragment) {\n  const doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n  return prosemirrorToYXmlFragment(doc, xmlFragment)\n}\n\n/**\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.Doc to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.Doc} ydoc\n * @return {Node}\n */\nfunction yDocToProsemirror (schema, ydoc) {\n  const state = yDocToProsemirrorJSON(ydoc)\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n}\n\n/**\n *\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.XmlFragment to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.XmlFragment} xmlFragment\n * @return {Node}\n */\nfunction yXmlFragmentToProsemirror (schema, xmlFragment) {\n  const state = yXmlFragmentToProsemirrorJSON(xmlFragment)\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n}\n\n/**\n *\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.Doc} ydoc\n * @param {string} xmlFragment\n * @return {Record<string, any>}\n */\nfunction yDocToProsemirrorJSON (\n  ydoc,\n  xmlFragment = 'prosemirror'\n) {\n  return yXmlFragmentToProsemirrorJSON(ydoc.getXmlFragment(xmlFragment))\n}\n\n/**\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.XmlFragment} xmlFragment The fragment, which must be part of a Y.Doc.\n * @return {Record<string, any>}\n */\nfunction yXmlFragmentToProsemirrorJSON (xmlFragment) {\n  const items = xmlFragment.toArray()\n\n  /**\n   * @param {Y.AbstractType} item\n   */\n  const serialize = item => {\n    /**\n     * @type {Object} NodeObject\n     * @property {string} NodeObject.type\n     * @property {Record<string, string>=} NodeObject.attrs\n     * @property {Array<NodeObject>=} NodeObject.content\n     */\n    let response\n\n    // TODO: Must be a better way to detect text nodes than this\n    if (item instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n      const delta = item.toDelta()\n      response = delta.map(/** @param {any} d */ (d) => {\n        const text = {\n          type: 'text',\n          text: d.insert\n        }\n        if (d.attributes) {\n          text.marks = Object.keys(d.attributes).map((type_) => {\n            const attrs = d.attributes[type_]\n            const type = (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.yattr2markname)(type_)\n            const mark = {\n              type\n            }\n            if (Object.keys(attrs)) {\n              mark.attrs = attrs\n            }\n            return mark\n          })\n        }\n        return text\n      })\n    } else if (item instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlElement) {\n      response = {\n        type: item.nodeName\n      }\n\n      const attrs = item.getAttributes()\n      if (Object.keys(attrs).length) {\n        response.attrs = attrs\n      }\n\n      const children = item.toArray()\n      if (children.length) {\n        response.content = children.map(serialize).flat()\n      }\n    } else {\n      // expected either Y.XmlElement or Y.XmlText\n      lib0_error__WEBPACK_IMPORTED_MODULE_4__.unexpectedCase()\n    }\n\n    return response\n  }\n\n  return {\n    type: 'doc',\n    content: items.map(serialize)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvbGliLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtSDtBQUNqRTtBQUMxQjtBQUNxQjtBQUNhO0FBQ3ZCO0FBQ0o7QUFDWTs7QUFFM0M7QUFDQTtBQUNBLGFBQWEseUNBQXlDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0REFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7QUFDQSxJQUFJLG1EQUFpQjtBQUNyQjtBQUNBLEVBQUUsb0RBQWtCLHNCQUFzQiw0Q0FBVTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsb0JBQW9CO0FBQy9CLFlBQVksS0FBSztBQUNqQjtBQUNPO0FBQ1A7QUFDQTtBQUNBLFdBQVcsb0VBQXFDO0FBQ2hEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxtREFBbUQsZUFBZTtBQUNsRTtBQUNBLHFCQUFxQix3Q0FBUztBQUM5QjtBQUNBLGVBQWUsb0VBQXFDO0FBQ3BELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxtREFBbUQsZUFBZTtBQUNsRTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1DQUFtQyxLQUFLLHdCQUF3QixhQUFhO0FBQzdFO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHFCQUFxQixpREFBa0IsMERBQTBELGdEQUFpQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QyxVQUFV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O0FBQ047QUFDQSxNQUFNLHNEQUFvQjtBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnlhbmdveWFsL3JlYWwtdGltZS10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvbGliLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVwZGF0ZVlGcmFnbWVudCwgY3JlYXRlTm9kZUZyb21ZRWxlbWVudCwgeWF0dHIybWFya25hbWUsIGNyZWF0ZUVtcHR5TWV0YSB9IGZyb20gJy4vcGx1Z2lucy9zeW5jLXBsdWdpbi5qcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHsgeVN5bmNQbHVnaW5LZXkgfSBmcm9tICcuL3BsdWdpbnMva2V5cy5qcydcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IE5vZGUsIFNjaGVtYSwgRnJhZ21lbnQgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCcgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIGV2ZW50bG9vcCBmcm9tICdsaWIwL2V2ZW50bG9vcCdcblxuLyoqXG4gKiBFaXRoZXIgYSBub2RlIGlmIHR5cGUgaXMgWVhtbEVsZW1lbnQgb3IgYW4gQXJyYXkgb2YgdGV4dCBub2RlcyBpZiBZWG1sVGV4dFxuICogQHR5cGVkZWYge01hcDxZLkFic3RyYWN0VHlwZSwgTm9kZSB8IEFycmF5PE5vZGU+Pn0gUHJvc2VtaXJyb3JNYXBwaW5nXG4gKi9cblxuLyoqXG4gKiBJcyBudWxsIGlmIG5vIHRpbWVvdXQgaXMgaW4gcHJvZ3Jlc3MuXG4gKiBJcyBkZWZpbmVkIGlmIGEgdGltZW91dCBpcyBpbiBwcm9ncmVzcy5cbiAqIE1hcHMgZnJvbSB2aWV3XG4gKiBAdHlwZSB7TWFwPEVkaXRvclZpZXcsIE1hcDxhbnksIGFueT4+fG51bGx9XG4gKi9cbmxldCB2aWV3c1RvVXBkYXRlID0gbnVsbFxuXG5jb25zdCB1cGRhdGVNZXRhcyA9ICgpID0+IHtcbiAgY29uc3QgdXBzID0gLyoqIEB0eXBlIHtNYXA8RWRpdG9yVmlldywgTWFwPGFueSwgYW55Pj59ICovICh2aWV3c1RvVXBkYXRlKVxuICB2aWV3c1RvVXBkYXRlID0gbnVsbFxuICB1cHMuZm9yRWFjaCgobWV0YXMsIHZpZXcpID0+IHtcbiAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHJcbiAgICBjb25zdCBzeW5jU3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKVxuICAgIGlmIChzeW5jU3RhdGUgJiYgc3luY1N0YXRlLmJpbmRpbmcgJiYgIXN5bmNTdGF0ZS5iaW5kaW5nLmlzRGVzdHJveWVkKSB7XG4gICAgICBtZXRhcy5mb3JFYWNoKCh2YWwsIGtleSkgPT4ge1xuICAgICAgICB0ci5zZXRNZXRhKGtleSwgdmFsKVxuICAgICAgfSlcbiAgICAgIHZpZXcuZGlzcGF0Y2godHIpXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgY29uc3Qgc2V0TWV0YSA9ICh2aWV3LCBrZXksIHZhbHVlKSA9PiB7XG4gIGlmICghdmlld3NUb1VwZGF0ZSkge1xuICAgIHZpZXdzVG9VcGRhdGUgPSBuZXcgTWFwKClcbiAgICBldmVudGxvb3AudGltZW91dCgwLCB1cGRhdGVNZXRhcylcbiAgfVxuICBtYXAuc2V0SWZVbmRlZmluZWQodmlld3NUb1VwZGF0ZSwgdmlldywgbWFwLmNyZWF0ZSkuc2V0KGtleSwgdmFsdWUpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIFByb3NlbWlycm9yIGJhc2VkIGFic29sdXRlIHBvc2l0aW9uIHRvIGEgWWpzIEN1cnNvciAocmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIFlqcyBtb2RlbCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB0eXBlXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICogQHJldHVybiB7YW55fSByZWxhdGl2ZSBwb3NpdGlvblxuICovXG5leHBvcnQgY29uc3QgYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbiA9IChwb3MsIHR5cGUsIG1hcHBpbmcpID0+IHtcbiAgaWYgKHBvcyA9PT0gMCkge1xuICAgIC8vIGlmIHRoZSB0eXBlIGlzIGxhdGVyIHBvcHVsYXRlZCwgd2Ugd2FudCB0byByZXRhaW4gdGhlIDAgcG9zaXRpb24gKGhlbmNlIGFzc29jPS0xKVxuICAgIHJldHVybiBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHR5cGUsIDAsIHR5cGUubGVuZ3RoID09PSAwID8gLTEgOiAwKVxuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgbGV0IG4gPSB0eXBlLl9maXJzdCA9PT0gbnVsbCA/IG51bGwgOiAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovICh0eXBlLl9maXJzdC5jb250ZW50KS50eXBlXG4gIHdoaWxlIChuICE9PSBudWxsICYmIHR5cGUgIT09IG4pIHtcbiAgICBpZiAobiBpbnN0YW5jZW9mIFkuWG1sVGV4dCkge1xuICAgICAgaWYgKG4uX2xlbmd0aCA+PSBwb3MpIHtcbiAgICAgICAgcmV0dXJuIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgobiwgcG9zLCB0eXBlLmxlbmd0aCA9PT0gMCA/IC0xIDogMClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyAtPSBuLl9sZW5ndGhcbiAgICAgIH1cbiAgICAgIGlmIChuLl9pdGVtICE9PSBudWxsICYmIG4uX2l0ZW0ubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAobi5faXRlbS5uZXh0LmNvbnRlbnQpLnR5cGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBuID0gbi5faXRlbSA9PT0gbnVsbCA/IG51bGwgOiBuLl9pdGVtLnBhcmVudFxuICAgICAgICAgIHBvcy0tXG4gICAgICAgIH0gd2hpbGUgKG4gIT09IHR5cGUgJiYgbiAhPT0gbnVsbCAmJiBuLl9pdGVtICE9PSBudWxsICYmIG4uX2l0ZW0ubmV4dCA9PT0gbnVsbClcbiAgICAgICAgaWYgKG4gIT09IG51bGwgJiYgbiAhPT0gdHlwZSkge1xuICAgICAgICAgIC8vIEB0cy1nbm9yZSB3ZSBrbm93IHRoYXQgbi5uZXh0ICE9PSBudWxsIGJlY2F1c2Ugb2YgYWJvdmUgbG9vcCBjb25kaXRpdGlvblxuICAgICAgICAgIG4gPSBuLl9pdGVtID09PSBudWxsID8gbnVsbCA6IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKC8qKiBAdHlwZSBZLkl0ZW0gKi8gKG4uX2l0ZW0ubmV4dCkuY29udGVudCkudHlwZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBOb2RlU2l6ZSA9IC8qKiBAdHlwZSB7YW55fSAqLyAobWFwcGluZy5nZXQobikgfHwgeyBub2RlU2l6ZTogMCB9KS5ub2RlU2l6ZVxuICAgICAgaWYgKG4uX2ZpcnN0ICE9PSBudWxsICYmIHBvcyA8IHBOb2RlU2l6ZSkge1xuICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAobi5fZmlyc3QuY29udGVudCkudHlwZVxuICAgICAgICBwb3MtLVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gMSAmJiBuLl9sZW5ndGggPT09IDAgJiYgcE5vZGVTaXplID4gMSkge1xuICAgICAgICAgIC8vIGVkZ2UgY2FzZSwgc2hvdWxkIGVuZCBpbiB0aGlzIHBhcmFncmFwaFxuICAgICAgICAgIHJldHVybiBuZXcgWS5SZWxhdGl2ZVBvc2l0aW9uKG4uX2l0ZW0gPT09IG51bGwgPyBudWxsIDogbi5faXRlbS5pZCwgbi5faXRlbSA9PT0gbnVsbCA/IFkuZmluZFJvb3RUeXBlS2V5KG4pIDogbnVsbCwgbnVsbClcbiAgICAgICAgfVxuICAgICAgICBwb3MgLT0gcE5vZGVTaXplXG4gICAgICAgIGlmIChuLl9pdGVtICE9PSBudWxsICYmIG4uX2l0ZW0ubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgIG4gPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovIChuLl9pdGVtLm5leHQuY29udGVudCkudHlwZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwb3MgPT09IDApIHtcbiAgICAgICAgICAgIC8vIHNldCB0byBlbmQgb2Ygbi5wYXJlbnRcbiAgICAgICAgICAgIG4gPSBuLl9pdGVtID09PSBudWxsID8gbiA6IG4uX2l0ZW0ucGFyZW50XG4gICAgICAgICAgICByZXR1cm4gbmV3IFkuUmVsYXRpdmVQb3NpdGlvbihuLl9pdGVtID09PSBudWxsID8gbnVsbCA6IG4uX2l0ZW0uaWQsIG4uX2l0ZW0gPT09IG51bGwgPyBZLmZpbmRSb290VHlwZUtleShuKSA6IG51bGwsIG51bGwpXG4gICAgICAgICAgfVxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIG4gPSAvKiogQHR5cGUge1kuSXRlbX0gKi8gKG4uX2l0ZW0pLnBhcmVudFxuICAgICAgICAgICAgcG9zLS1cbiAgICAgICAgICB9IHdoaWxlIChuICE9PSB0eXBlICYmIC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAobi5faXRlbSkubmV4dCA9PT0gbnVsbClcbiAgICAgICAgICAvLyBpZiBuIGlzIG51bGwgYXQgdGhpcyBwb2ludCwgd2UgaGF2ZSBhbiB1bmV4cGVjdGVkIGNhc2VcbiAgICAgICAgICBpZiAobiAhPT0gdHlwZSkge1xuICAgICAgICAgICAgLy8gV2Uga25vdyB0aGF0IG4uX2l0ZW0ubmV4dCBpcyBkZWZpbmVkIGJlY2F1c2Ugb2YgYWJvdmUgbG9vcCBjb25kaXRpb25cbiAgICAgICAgICAgIG4gPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovICgvKiogQHR5cGUge1kuSXRlbX0gKi8gKC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAobi5faXRlbSkubmV4dCkuY29udGVudCkudHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICBpZiAocG9zID09PSAwICYmIG4uY29uc3RydWN0b3IgIT09IFkuWG1sVGV4dCAmJiBuICE9PSB0eXBlKSB7IC8vIFRPRE86IHNldCB0byA8PSAwXG4gICAgICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbihuLl9pdGVtLnBhcmVudCwgbi5faXRlbSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgodHlwZSwgdHlwZS5fbGVuZ3RoLCB0eXBlLmxlbmd0aCA9PT0gMCA/IC0xIDogMClcbn1cblxuY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiA9ICh0eXBlLCBpdGVtKSA9PiB7XG4gIGxldCB0eXBlaWQgPSBudWxsXG4gIGxldCB0bmFtZSA9IG51bGxcbiAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICB0bmFtZSA9IFkuZmluZFJvb3RUeXBlS2V5KHR5cGUpXG4gIH0gZWxzZSB7XG4gICAgdHlwZWlkID0gWS5jcmVhdGVJRCh0eXBlLl9pdGVtLmlkLmNsaWVudCwgdHlwZS5faXRlbS5pZC5jbG9jaylcbiAgfVxuICByZXR1cm4gbmV3IFkuUmVsYXRpdmVQb3NpdGlvbih0eXBlaWQsIHRuYW1lLCBpdGVtLmlkKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7WS5Eb2N9IHlcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0gZG9jdW1lbnRUeXBlIFRvcCBsZXZlbCB0eXBlIHRoYXQgaXMgYm91bmQgdG8gcFZpZXdcbiAqIEBwYXJhbSB7YW55fSByZWxQb3MgRW5jb2RlZCBZanMgYmFzZWQgcmVsYXRpdmUgcG9zaXRpb25cbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcmV0dXJuIHtudWxsfG51bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24gPSAoeSwgZG9jdW1lbnRUeXBlLCByZWxQb3MsIG1hcHBpbmcpID0+IHtcbiAgY29uc3QgZGVjb2RlZFBvcyA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKHJlbFBvcywgeSlcbiAgaWYgKGRlY29kZWRQb3MgPT09IG51bGwgfHwgKGRlY29kZWRQb3MudHlwZSAhPT0gZG9jdW1lbnRUeXBlICYmICFZLmlzUGFyZW50T2YoZG9jdW1lbnRUeXBlLCBkZWNvZGVkUG9zLnR5cGUuX2l0ZW0pKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgbGV0IHR5cGUgPSBkZWNvZGVkUG9zLnR5cGVcbiAgbGV0IHBvcyA9IDBcbiAgaWYgKHR5cGUuY29uc3RydWN0b3IgPT09IFkuWG1sVGV4dCkge1xuICAgIHBvcyA9IGRlY29kZWRQb3MuaW5kZXhcbiAgfSBlbHNlIGlmICh0eXBlLl9pdGVtID09PSBudWxsIHx8ICF0eXBlLl9pdGVtLmRlbGV0ZWQpIHtcbiAgICBsZXQgbiA9IHR5cGUuX2ZpcnN0XG4gICAgbGV0IGkgPSAwXG4gICAgd2hpbGUgKGkgPCB0eXBlLl9sZW5ndGggJiYgaSA8IGRlY29kZWRQb3MuaW5kZXggJiYgbiAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFuLmRlbGV0ZWQpIHtcbiAgICAgICAgY29uc3QgdCA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZVxuICAgICAgICBpKytcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBZLlhtbFRleHQpIHtcbiAgICAgICAgICBwb3MgKz0gdC5fbGVuZ3RoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zICs9IC8qKiBAdHlwZSB7YW55fSAqLyAobWFwcGluZy5nZXQodCkpLm5vZGVTaXplXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4gPSAvKiogQHR5cGUge1kuSXRlbX0gKi8gKG4ucmlnaHQpXG4gICAgfVxuICAgIHBvcyArPSAxIC8vIGluY3JlYXNlIGJlY2F1c2Ugd2UgZ28gb3V0IG9mIG5cbiAgfVxuICB3aGlsZSAodHlwZSAhPT0gZG9jdW1lbnRUeXBlICYmIHR5cGUuX2l0ZW0gIT09IG51bGwpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgcGFyZW50ID0gdHlwZS5faXRlbS5wYXJlbnRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHBhcmVudC5faXRlbSA9PT0gbnVsbCB8fCAhcGFyZW50Ll9pdGVtLmRlbGV0ZWQpIHtcbiAgICAgIHBvcyArPSAxIC8vIHRoZSBzdGFydCB0YWdcbiAgICAgIGxldCBuID0gLyoqIEB0eXBlIHtZLkFic3RyYWN0VHlwZX0gKi8gKHBhcmVudCkuX2ZpcnN0XG4gICAgICAvLyBub3cgaXRlcmF0ZSB1bnRpbCB3ZSBmb3VuZCB0eXBlXG4gICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZVxuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICAgICAgaWYgKGNvbnRlbnRUeXBlIGluc3RhbmNlb2YgWS5YbWxUZXh0KSB7XG4gICAgICAgICAgICBwb3MgKz0gY29udGVudFR5cGUuX2xlbmd0aFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gLyoqIEB0eXBlIHthbnl9ICovIChtYXBwaW5nLmdldChjb250ZW50VHlwZSkpLm5vZGVTaXplXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG4gPSBuLnJpZ2h0XG4gICAgICB9XG4gICAgfVxuICAgIHR5cGUgPSAvKiogQHR5cGUge1kuQWJzdHJhY3RUeXBlfSAqLyAocGFyZW50KVxuICB9XG4gIHJldHVybiBwb3MgLSAxIC8vIHdlIGRvbid0IGNvdW50IHRoZSBtb3N0IG91dGVyIHRhZywgYmVjYXVzZSBpdCBpcyBhIGZyYWdtZW50XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBhbiBZLkZyYWdtZW50IHRvIGEgUHJvc2VNaXJyb3IgZnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB5WG1sRnJhZ21lbnRcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqL1xuZXhwb3J0IGNvbnN0IHlYbWxGcmFnbWVudFRvUHJvc2VNaXJyb3JGcmFnbWVudCA9ICh5WG1sRnJhZ21lbnQsIHNjaGVtYSkgPT4ge1xuICBjb25zdCBmcmFnbWVudENvbnRlbnQgPSB5WG1sRnJhZ21lbnQudG9BcnJheSgpLm1hcCgodCkgPT5cbiAgICBjcmVhdGVOb2RlRnJvbVlFbGVtZW50KFxuICAgICAgLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnR9ICovICh0KSxcbiAgICAgIHNjaGVtYSxcbiAgICAgIGNyZWF0ZUVtcHR5TWV0YSgpXG4gICAgKVxuICApLmZpbHRlcigobikgPT4gbiAhPT0gbnVsbClcbiAgcmV0dXJuIEZyYWdtZW50LmZyb21BcnJheShmcmFnbWVudENvbnRlbnQpXG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBhbiBZLkZyYWdtZW50IHRvIGEgUHJvc2VNaXJyb3Igbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IHlYbWxGcmFnbWVudFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICovXG5leHBvcnQgY29uc3QgeVhtbEZyYWdtZW50VG9Qcm9zZU1pcnJvclJvb3ROb2RlID0gKHlYbWxGcmFnbWVudCwgc2NoZW1hKSA9PlxuICBzY2hlbWEudG9wTm9kZVR5cGUuY3JlYXRlKG51bGwsIHlYbWxGcmFnbWVudFRvUHJvc2VNaXJyb3JGcmFnbWVudCh5WG1sRnJhZ21lbnQsIHNjaGVtYSkpXG5cbi8qKlxuICogVGhlIGluaXRpYWwgUHJvc2VNaXJyb3IgY29udGVudCBzaG91bGQgYmUgc3VwcGxpZWQgYnkgWWpzLiBUaGlzIGZ1bmN0aW9uIHRyYW5zZm9ybXMgYSBZLkZyYWdtZW50XG4gKiB0byBhIFByb3NlTWlycm9yIERvYyBub2RlIGFuZCBjcmVhdGVzIGEgbWFwcGluZyB0aGF0IGlzIHVzZWQgYnkgdGhlIHN5bmMgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geVhtbEZyYWdtZW50XG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKlxuICogQHRvZG8gZGVwcmVjYXRlIG1hcHBpbmcgcHJvcGVydHlcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRQcm9zZU1pcnJvckRvYyA9ICh5WG1sRnJhZ21lbnQsIHNjaGVtYSkgPT4ge1xuICBjb25zdCBtZXRhID0gY3JlYXRlRW1wdHlNZXRhKClcbiAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0geVhtbEZyYWdtZW50LnRvQXJyYXkoKS5tYXAoKHQpID0+XG4gICAgY3JlYXRlTm9kZUZyb21ZRWxlbWVudChcbiAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50fSAqLyAodCksXG4gICAgICBzY2hlbWEsXG4gICAgICBtZXRhXG4gICAgKVxuICApLmZpbHRlcigobikgPT4gbiAhPT0gbnVsbClcbiAgY29uc3QgZG9jID0gc2NoZW1hLnRvcE5vZGVUeXBlLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tQXJyYXkoZnJhZ21lbnRDb250ZW50KSlcbiAgcmV0dXJuIHsgZG9jLCBtZXRhLCBtYXBwaW5nOiBtZXRhLm1hcHBpbmcgfVxufVxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGNvbnZlcnQgYSBQcm9zZW1pcnJvciBEb2MgTm9kZSBpbnRvIGEgWS5Eb2MuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB3aGVuIGltcG9ydGluZyBleGlzdGluZyBjb250ZW50IHRvIFkuRG9jIGZvciB0aGUgZmlyc3QgdGltZSxcbiAqIG5vdGUgdGhhdCB0aGlzIHNob3VsZCBub3QgYmUgdXNlZCB0byByZWh5ZHJhdGUgYSBZLkRvYyBmcm9tIGEgZGF0YWJhc2Ugb25jZVxuICogY29sbGFib3JhdGlvbiBoYXMgYmVndW4gYXMgYWxsIGhpc3Rvcnkgd2lsbCBiZSBsb3N0XG4gKlxuICogQHBhcmFtIHtOb2RlfSBkb2NcbiAqIEBwYXJhbSB7c3RyaW5nfSB4bWxGcmFnbWVudFxuICogQHJldHVybiB7WS5Eb2N9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9zZW1pcnJvclRvWURvYyAoZG9jLCB4bWxGcmFnbWVudCA9ICdwcm9zZW1pcnJvcicpIHtcbiAgY29uc3QgeWRvYyA9IG5ldyBZLkRvYygpXG4gIGNvbnN0IHR5cGUgPSAvKiogQHR5cGUge1kuWG1sRnJhZ21lbnR9ICovICh5ZG9jLmdldCh4bWxGcmFnbWVudCwgWS5YbWxGcmFnbWVudCkpXG4gIGlmICghdHlwZS5kb2MpIHtcbiAgICByZXR1cm4geWRvY1xuICB9XG5cbiAgcHJvc2VtaXJyb3JUb1lYbWxGcmFnbWVudChkb2MsIHR5cGUpXG4gIHJldHVybiB0eXBlLmRvY1xufVxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIHVwZGF0ZSBhbiBlbXB0eSBZLlhtbEZyYWdtZW50IHdpdGggY29udGVudCBmcm9tIGEgUHJvc2VtaXJyb3IgRG9jIE5vZGUuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB3aGVuIGltcG9ydGluZyBleGlzdGluZyBjb250ZW50IHRvIFkuRG9jIGZvciB0aGUgZmlyc3QgdGltZSxcbiAqIG5vdGUgdGhhdCB0aGlzIHNob3VsZCBub3QgYmUgdXNlZCB0byByZWh5ZHJhdGUgYSBZLkRvYyBmcm9tIGEgZGF0YWJhc2Ugb25jZVxuICogY29sbGFib3JhdGlvbiBoYXMgYmVndW4gYXMgYWxsIGhpc3Rvcnkgd2lsbCBiZSBsb3N0XG4gKlxuICogTm90ZTogVGhlIFkuWG1sRnJhZ21lbnQgZG9lcyBub3QgbmVlZCB0byBiZSBwYXJ0IG9mIGEgWS5Eb2MgZG9jdW1lbnQgYXQgdGhlIHRpbWUgdGhhdCB0aGlzXG4gKiBtZXRob2QgaXMgY2FsbGVkLCBidXQgaXQgbXVzdCBiZSBhZGRlZCBiZWZvcmUgYW55IG90aGVyIG9wZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCBvbiBpdC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IGRvYyBwcm9zZW1pcnJvciBkb2N1bWVudC5cbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0gW3htbEZyYWdtZW50XSBJZiBzdXBwbGllZCwgYW4geG1sIGZyYWdtZW50IHRvIGJlXG4gKiAgIHBvcHVsYXRlZCBmcm9tIHRoZSBwcm9zZW1pcnJvciBzdGF0ZTsgb3RoZXJ3aXNlIGEgbmV3IFhtbEZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm4ge1kuWG1sRnJhZ21lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9zZW1pcnJvclRvWVhtbEZyYWdtZW50IChkb2MsIHhtbEZyYWdtZW50KSB7XG4gIGNvbnN0IHR5cGUgPSB4bWxGcmFnbWVudCB8fCBuZXcgWS5YbWxGcmFnbWVudCgpXG4gIGNvbnN0IHlkb2MgPSB0eXBlLmRvYyA/IHR5cGUuZG9jIDogeyB0cmFuc2FjdDogKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbih1bmRlZmluZWQpIH1cbiAgdXBkYXRlWUZyYWdtZW50KHlkb2MsIHR5cGUsIGRvYywgeyBtYXBwaW5nOiBuZXcgTWFwKCksIGlzT01hcms6IG5ldyBNYXAoKSB9KVxuICByZXR1cm4gdHlwZVxufVxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGNvbnZlcnQgUHJvc2VtaXJyb3IgY29tcGF0aWJsZSBKU09OIGludG8gYSBZLkRvYy5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdoZW4gaW1wb3J0aW5nIGV4aXN0aW5nIGNvbnRlbnQgdG8gWS5Eb2MgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICogbm90ZSB0aGF0IHRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIHRvIHJlaHlkcmF0ZSBhIFkuRG9jIGZyb20gYSBkYXRhYmFzZSBvbmNlXG4gKiBjb2xsYWJvcmF0aW9uIGhhcyBiZWd1biBhcyBhbGwgaGlzdG9yeSB3aWxsIGJlIGxvc3RcbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge2FueX0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB4bWxGcmFnbWVudFxuICogQHJldHVybiB7WS5Eb2N9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9zZW1pcnJvckpTT05Ub1lEb2MgKHNjaGVtYSwgc3RhdGUsIHhtbEZyYWdtZW50ID0gJ3Byb3NlbWlycm9yJykge1xuICBjb25zdCBkb2MgPSBOb2RlLmZyb21KU09OKHNjaGVtYSwgc3RhdGUpXG4gIHJldHVybiBwcm9zZW1pcnJvclRvWURvYyhkb2MsIHhtbEZyYWdtZW50KVxufVxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGNvbnZlcnQgUHJvc2VtaXJyb3IgY29tcGF0aWJsZSBKU09OIHRvIGEgWS5YbWxGcmFnbWVudFxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgZXhpc3RpbmcgY29udGVudCB0byBZLkRvYyBmb3IgdGhlIGZpcnN0IHRpbWUsXG4gKiBub3RlIHRoYXQgdGhpcyBzaG91bGQgbm90IGJlIHVzZWQgdG8gcmVoeWRyYXRlIGEgWS5Eb2MgZnJvbSBhIGRhdGFiYXNlIG9uY2VcbiAqIGNvbGxhYm9yYXRpb24gaGFzIGJlZ3VuIGFzIGFsbCBoaXN0b3J5IHdpbGwgYmUgbG9zdFxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7YW55fSBzdGF0ZVxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSBbeG1sRnJhZ21lbnRdIElmIHN1cHBsaWVkLCBhbiB4bWwgZnJhZ21lbnQgdG8gYmVcbiAqICAgcG9wdWxhdGVkIGZyb20gdGhlIHByb3NlbWlycm9yIHN0YXRlOyBvdGhlcndpc2UgYSBuZXcgWG1sRnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkLlxuICogQHJldHVybiB7WS5YbWxGcmFnbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3NlbWlycm9ySlNPTlRvWVhtbEZyYWdtZW50IChzY2hlbWEsIHN0YXRlLCB4bWxGcmFnbWVudCkge1xuICBjb25zdCBkb2MgPSBOb2RlLmZyb21KU09OKHNjaGVtYSwgc3RhdGUpXG4gIHJldHVybiBwcm9zZW1pcnJvclRvWVhtbEZyYWdtZW50KGRvYywgeG1sRnJhZ21lbnQpXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yUm9vdE5vZGVgIGluc3RlYWRcbiAqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgWS5Eb2MgdG8gYSBQcm9zZW1pcnJvciBEb2Mgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge1kuRG9jfSB5ZG9jXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24geURvY1RvUHJvc2VtaXJyb3IgKHNjaGVtYSwgeWRvYykge1xuICBjb25zdCBzdGF0ZSA9IHlEb2NUb1Byb3NlbWlycm9ySlNPTih5ZG9jKVxuICByZXR1cm4gTm9kZS5mcm9tSlNPTihzY2hlbWEsIHN0YXRlKVxufVxuXG4vKipcbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHlYbWxGcmFnbWVudFRvUHJvc2VNaXJyb3JSb290Tm9kZWAgaW5zdGVhZFxuICpcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGNvbnZlcnQgYSBZLlhtbEZyYWdtZW50IHRvIGEgUHJvc2VtaXJyb3IgRG9jIG5vZGUuXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB4bWxGcmFnbWVudFxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlYbWxGcmFnbWVudFRvUHJvc2VtaXJyb3IgKHNjaGVtYSwgeG1sRnJhZ21lbnQpIHtcbiAgY29uc3Qgc3RhdGUgPSB5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9ySlNPTih4bWxGcmFnbWVudClcbiAgcmV0dXJuIE5vZGUuZnJvbUpTT04oc2NoZW1hLCBzdGF0ZSlcbn1cblxuLyoqXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yUm9vdE5vZGVgIGluc3RlYWRcbiAqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgWS5Eb2MgdG8gUHJvc2VtaXJyb3IgY29tcGF0aWJsZSBKU09OLlxuICpcbiAqIEBwYXJhbSB7WS5Eb2N9IHlkb2NcbiAqIEBwYXJhbSB7c3RyaW5nfSB4bWxGcmFnbWVudFxuICogQHJldHVybiB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlEb2NUb1Byb3NlbWlycm9ySlNPTiAoXG4gIHlkb2MsXG4gIHhtbEZyYWdtZW50ID0gJ3Byb3NlbWlycm9yJ1xuKSB7XG4gIHJldHVybiB5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9ySlNPTih5ZG9jLmdldFhtbEZyYWdtZW50KHhtbEZyYWdtZW50KSlcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHlYbWxGcmFnbWVudFRvUHJvc2VNaXJyb3JSb290Tm9kZWAgaW5zdGVhZFxuICpcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGNvbnZlcnQgYSBZLkRvYyB0byBQcm9zZW1pcnJvciBjb21wYXRpYmxlIEpTT04uXG4gKlxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB4bWxGcmFnbWVudCBUaGUgZnJhZ21lbnQsIHdoaWNoIG11c3QgYmUgcGFydCBvZiBhIFkuRG9jLlxuICogQHJldHVybiB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlYbWxGcmFnbWVudFRvUHJvc2VtaXJyb3JKU09OICh4bWxGcmFnbWVudCkge1xuICBjb25zdCBpdGVtcyA9IHhtbEZyYWdtZW50LnRvQXJyYXkoKVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuQWJzdHJhY3RUeXBlfSBpdGVtXG4gICAqL1xuICBjb25zdCBzZXJpYWxpemUgPSBpdGVtID0+IHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fSBOb2RlT2JqZWN0XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IE5vZGVPYmplY3QudHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPj19IE5vZGVPYmplY3QuYXR0cnNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5PE5vZGVPYmplY3Q+PX0gTm9kZU9iamVjdC5jb250ZW50XG4gICAgICovXG4gICAgbGV0IHJlc3BvbnNlXG5cbiAgICAvLyBUT0RPOiBNdXN0IGJlIGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGV4dCBub2RlcyB0aGFuIHRoaXNcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFkuWG1sVGV4dCkge1xuICAgICAgY29uc3QgZGVsdGEgPSBpdGVtLnRvRGVsdGEoKVxuICAgICAgcmVzcG9uc2UgPSBkZWx0YS5tYXAoLyoqIEBwYXJhbSB7YW55fSBkICovIChkKSA9PiB7XG4gICAgICAgIGNvbnN0IHRleHQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHRleHQ6IGQuaW5zZXJ0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuYXR0cmlidXRlcykge1xuICAgICAgICAgIHRleHQubWFya3MgPSBPYmplY3Qua2V5cyhkLmF0dHJpYnV0ZXMpLm1hcCgodHlwZV8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gZC5hdHRyaWJ1dGVzW3R5cGVfXVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHlhdHRyMm1hcmtuYW1lKHR5cGVfKVxuICAgICAgICAgICAgY29uc3QgbWFyayA9IHtcbiAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJzKSkge1xuICAgICAgICAgICAgICBtYXJrLmF0dHJzID0gYXR0cnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXJrXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dFxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQpIHtcbiAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICB0eXBlOiBpdGVtLm5vZGVOYW1lXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHJzID0gaXRlbS5nZXRBdHRyaWJ1dGVzKClcbiAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoKSB7XG4gICAgICAgIHJlc3BvbnNlLmF0dHJzID0gYXR0cnNcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBpdGVtLnRvQXJyYXkoKVxuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXNwb25zZS5jb250ZW50ID0gY2hpbGRyZW4ubWFwKHNlcmlhbGl6ZSkuZmxhdCgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4cGVjdGVkIGVpdGhlciBZLlhtbEVsZW1lbnQgb3IgWS5YbWxUZXh0XG4gICAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdkb2MnLFxuICAgIGNvbnRlbnQ6IGl0ZW1zLm1hcChzZXJpYWxpemUpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js":
/*!*****************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/cursor-plugin.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDecorations: () => (/* binding */ createDecorations),\n/* harmony export */   defaultAwarenessStateFilter: () => (/* binding */ defaultAwarenessStateFilter),\n/* harmony export */   defaultCursorBuilder: () => (/* binding */ defaultCursorBuilder),\n/* harmony export */   defaultSelectionBuilder: () => (/* binding */ defaultSelectionBuilder),\n/* harmony export */   yCursorPlugin: () => (/* binding */ yCursorPlugin)\n/* harmony export */ });\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! y-protocols/awareness */ \"(ssr)/./node_modules/y-protocols/dist/awareness.cjs\");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib.js */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n\n // eslint-disable-line\n // eslint-disable-line\n // eslint-disable-line\n\n\n\n\n\n/**\n * Default awareness state filter\n *\n * @param {number} currentClientId current client id\n * @param {number} userClientId user client id\n * @param {any} _user user data\n * @return {boolean}\n */\nconst defaultAwarenessStateFilter = (currentClientId, userClientId, _user) => currentClientId !== userClientId\n\n/**\n * Default generator for a cursor element\n *\n * @param {any} user user data\n * @return {HTMLElement}\n */\nconst defaultCursorBuilder = (user) => {\n  const cursor = document.createElement('span')\n  cursor.classList.add('ProseMirror-yjs-cursor')\n  cursor.setAttribute('style', `border-color: ${user.color}`)\n  const userDiv = document.createElement('div')\n  userDiv.setAttribute('style', `background-color: ${user.color}`)\n  userDiv.insertBefore(document.createTextNode(user.name), null)\n  const nonbreakingSpace1 = document.createTextNode('\\u2060')\n  const nonbreakingSpace2 = document.createTextNode('\\u2060')\n  cursor.insertBefore(nonbreakingSpace1, null)\n  cursor.insertBefore(userDiv, null)\n  cursor.insertBefore(nonbreakingSpace2, null)\n  return cursor\n}\n\n/**\n * Default generator for the selection attributes\n *\n * @param {any} user user data\n * @return {import('prosemirror-view').DecorationAttrs}\n */\nconst defaultSelectionBuilder = (user) => {\n  return {\n    style: `background-color: ${user.color}70`,\n    class: 'ProseMirror-yjs-selection'\n  }\n}\n\nconst rxValidColor = /^#[0-9a-fA-F]{6}$/\n\n/**\n * @param {any} state\n * @param {Awareness} awareness\n * @param {function(number, number, any):boolean} awarenessFilter\n * @param {(user: { name: string, color: string }, clientId: number) => Element} createCursor\n * @param {(user: { name: string, color: string }, clientId: number) => import('prosemirror-view').DecorationAttrs} createSelection\n * @return {any} DecorationSet\n */\nconst createDecorations = (\n  state,\n  awareness,\n  awarenessFilter,\n  createCursor,\n  createSelection\n) => {\n  const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(state)\n  const y = ystate.doc\n  const decorations = []\n  if (\n    ystate.snapshot != null || ystate.prevSnapshot != null ||\n    ystate.binding.mapping.size === 0\n  ) {\n    // do not render cursors while snapshot is active\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, [])\n  }\n  awareness.getStates().forEach((aw, clientId) => {\n    if (!awarenessFilter(y.clientID, clientId, aw)) {\n      return\n    }\n\n    if (aw.cursor != null) {\n      const user = aw.user || {}\n      if (user.color == null) {\n        user.color = '#ffa500'\n      } else if (!rxValidColor.test(user.color)) {\n        // We only support 6-digit RGB colors in y-prosemirror\n        console.warn('A user uses an unsupported color format', user)\n      }\n      if (user.name == null) {\n        user.name = `User: ${clientId}`\n      }\n      let anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(\n        y,\n        ystate.type,\n        yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(aw.cursor.anchor),\n        ystate.binding.mapping\n      )\n      let head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(\n        y,\n        ystate.type,\n        yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(aw.cursor.head),\n        ystate.binding.mapping\n      )\n      if (anchor !== null && head !== null) {\n        const maxsize = lib0_math__WEBPACK_IMPORTED_MODULE_5__.max(state.doc.content.size - 1, 0)\n        anchor = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(anchor, maxsize)\n        head = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(head, maxsize)\n        decorations.push(\n          prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget(head, () => createCursor(user, clientId), {\n            key: clientId + '',\n            side: 10\n          })\n        )\n        const from = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(anchor, head)\n        const to = lib0_math__WEBPACK_IMPORTED_MODULE_5__.max(anchor, head)\n        decorations.push(\n          prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.inline(from, to, createSelection(user, clientId), {\n            inclusiveEnd: true,\n            inclusiveStart: false\n          })\n        )\n      }\n    }\n  })\n  return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, decorations)\n}\n\n/**\n * A prosemirror plugin that listens to awareness information on Yjs.\n * This requires that a `prosemirrorPlugin` is also bound to the prosemirror.\n *\n * @public\n * @param {Awareness} awareness\n * @param {object} opts\n * @param {function(any, any, any):boolean} [opts.awarenessStateFilter]\n * @param {(user: any, clientId: number) => HTMLElement} [opts.cursorBuilder]\n * @param {(user: any, clientId: number) => import('prosemirror-view').DecorationAttrs} [opts.selectionBuilder]\n * @param {function(any):any} [opts.getSelection]\n * @param {string} [cursorStateField] By default all editor bindings use the awareness 'cursor' field to propagate cursor information.\n * @return {any}\n */\nconst yCursorPlugin = (\n  awareness,\n  {\n    awarenessStateFilter = defaultAwarenessStateFilter,\n    cursorBuilder = defaultCursorBuilder,\n    selectionBuilder = defaultSelectionBuilder,\n    getSelection = (state) => state.selection\n  } = {},\n  cursorStateField = 'cursor'\n) =>\n  new prosemirror_state__WEBPACK_IMPORTED_MODULE_6__.Plugin({\n    key: _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey,\n    state: {\n      init (_, state) {\n        return createDecorations(\n          state,\n          awareness,\n          awarenessStateFilter,\n          cursorBuilder,\n          selectionBuilder\n        )\n      },\n      apply (tr, prevState, _oldState, newState) {\n        const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(newState)\n        const yCursorState = tr.getMeta(_keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey)\n        if (\n          (ystate && ystate.isChangeOrigin) ||\n          (yCursorState && yCursorState.awarenessUpdated)\n        ) {\n          return createDecorations(\n            newState,\n            awareness,\n            awarenessStateFilter,\n            cursorBuilder,\n            selectionBuilder\n          )\n        }\n        return prevState.map(tr.mapping, tr.doc)\n      }\n    },\n    props: {\n      decorations: (state) => {\n        return _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey.getState(state)\n      }\n    },\n    view: (view) => {\n      const awarenessListener = () => {\n        // @ts-ignore\n        if (view.docView) {\n          (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.setMeta)(view, _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey, { awarenessUpdated: true })\n        }\n      }\n      const updateCursorInfo = () => {\n        const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(view.state)\n        // @note We make implicit checks when checking for the cursor property\n        const current = awareness.getLocalState() || {}\n        if (view.hasFocus()) {\n          const selection = getSelection(view.state)\n          /**\n           * @type {Y.RelativePosition}\n           */\n          const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.absolutePositionToRelativePosition)(\n            selection.anchor,\n            ystate.type,\n            ystate.binding.mapping\n          )\n          /**\n           * @type {Y.RelativePosition}\n           */\n          const head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.absolutePositionToRelativePosition)(\n            selection.head,\n            ystate.type,\n            ystate.binding.mapping\n          )\n          if (\n            current.cursor == null ||\n            !yjs__WEBPACK_IMPORTED_MODULE_4__.compareRelativePositions(\n              yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.anchor),\n              anchor\n            ) ||\n            !yjs__WEBPACK_IMPORTED_MODULE_4__.compareRelativePositions(\n              yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.head),\n              head\n            )\n          ) {\n            awareness.setLocalStateField(cursorStateField, {\n              anchor,\n              head\n            })\n          }\n        } else if (\n          current.cursor != null &&\n          (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(\n            ystate.doc,\n            ystate.type,\n            yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.anchor),\n            ystate.binding.mapping\n          ) !== null\n        ) {\n          // delete cursor information if current cursor information is owned by this editor binding\n          awareness.setLocalStateField(cursorStateField, null)\n        }\n      }\n      awareness.on('change', awarenessListener)\n      view.dom.addEventListener('focusin', updateCursorInfo)\n      view.dom.addEventListener('focusout', updateCursorInfo)\n      return {\n        update: updateCursorInfo,\n        destroy: () => {\n          view.dom.removeEventListener('focusin', updateCursorInfo)\n          view.dom.removeEventListener('focusout', updateCursorInfo)\n          awareness.off('change', awarenessListener)\n          awareness.setLocalStateField(cursorStateField, null)\n        }\n      }\n    }\n  })\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9jdXJzb3ItcGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUNxQyxDQUFDO0FBQ25CLENBQUM7QUFDTSxDQUFDO0FBS2pDO0FBQzBDOztBQUUzQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsRUFBRTs7QUFFdEM7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsdUNBQXVDO0FBQ2xELFdBQVcsU0FBUyw2QkFBNkIsZ0NBQWdDO0FBQ2pGLFdBQVcsU0FBUyw2QkFBNkIsbUVBQW1FO0FBQ3BILFlBQVksS0FBSztBQUNqQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9EQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQSxtQkFBbUIsMkVBQWtDO0FBQ3JEO0FBQ0E7QUFDQSxRQUFRLCtEQUFnQztBQUN4QztBQUNBO0FBQ0EsaUJBQWlCLDJFQUFrQztBQUNuRDtBQUNBO0FBQ0EsUUFBUSwrREFBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBDQUFRO0FBQ2hDLGlCQUFpQiwwQ0FBUTtBQUN6QixlQUFlLDBDQUFRO0FBQ3ZCO0FBQ0EsVUFBVSx3REFBVTtBQUNwQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EscUJBQXFCLDBDQUFRO0FBQzdCLG1CQUFtQiwwQ0FBUTtBQUMzQjtBQUNBLFVBQVUsd0RBQVU7QUFDcEI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUywyREFBYTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlDQUFpQztBQUM1QyxXQUFXLDhDQUE4QztBQUN6RCxXQUFXLDZFQUE2RTtBQUN4RixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0EsTUFBTSxxREFBTTtBQUNaLFNBQVMsc0RBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHVCQUF1QixvREFBYztBQUNyQyx3Q0FBd0Msc0RBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsc0RBQWdCO0FBQy9CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnREFBTyxPQUFPLHNEQUFnQixJQUFJLHdCQUF3QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0RBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHlCQUF5QiwyRUFBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHVCQUF1QiwyRUFBa0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5REFBMEI7QUFDdkMsY0FBYywrREFBZ0M7QUFDOUM7QUFDQTtBQUNBLGFBQWEseURBQTBCO0FBQ3ZDLGNBQWMsK0RBQWdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVUsMkVBQWtDO0FBQzVDO0FBQ0E7QUFDQSxZQUFZLCtEQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL2FyeWFuZ295YWwvcmVhbC10aW1lLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy9wbHVnaW5zL2N1cnNvci1wbHVnaW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0IH0gZnJvbSBcInByb3NlbWlycm9yLXZpZXdcIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IEF3YXJlbmVzcyB9IGZyb20gXCJ5LXByb3RvY29scy9hd2FyZW5lc3NcIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHtcbiAgYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbixcbiAgcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbixcbiAgc2V0TWV0YVxufSBmcm9tICcuLi9saWIuanMnXG5pbXBvcnQgeyB5Q3Vyc29yUGx1Z2luS2V5LCB5U3luY1BsdWdpbktleSB9IGZyb20gJy4va2V5cy5qcydcblxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5cbi8qKlxuICogRGVmYXVsdCBhd2FyZW5lc3Mgc3RhdGUgZmlsdGVyXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRDbGllbnRJZCBjdXJyZW50IGNsaWVudCBpZFxuICogQHBhcmFtIHtudW1iZXJ9IHVzZXJDbGllbnRJZCB1c2VyIGNsaWVudCBpZFxuICogQHBhcmFtIHthbnl9IF91c2VyIHVzZXIgZGF0YVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRBd2FyZW5lc3NTdGF0ZUZpbHRlciA9IChjdXJyZW50Q2xpZW50SWQsIHVzZXJDbGllbnRJZCwgX3VzZXIpID0+IGN1cnJlbnRDbGllbnRJZCAhPT0gdXNlckNsaWVudElkXG5cbi8qKlxuICogRGVmYXVsdCBnZW5lcmF0b3IgZm9yIGEgY3Vyc29yIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge2FueX0gdXNlciB1c2VyIGRhdGFcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdEN1cnNvckJ1aWxkZXIgPSAodXNlcikgPT4ge1xuICBjb25zdCBjdXJzb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgY3Vyc29yLmNsYXNzTGlzdC5hZGQoJ1Byb3NlTWlycm9yLXlqcy1jdXJzb3InKVxuICBjdXJzb3Iuc2V0QXR0cmlidXRlKCdzdHlsZScsIGBib3JkZXItY29sb3I6ICR7dXNlci5jb2xvcn1gKVxuICBjb25zdCB1c2VyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgdXNlckRpdi5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGJhY2tncm91bmQtY29sb3I6ICR7dXNlci5jb2xvcn1gKVxuICB1c2VyRGl2Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh1c2VyLm5hbWUpLCBudWxsKVxuICBjb25zdCBub25icmVha2luZ1NwYWNlMSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUyMDYwJylcbiAgY29uc3Qgbm9uYnJlYWtpbmdTcGFjZTIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MjA2MCcpXG4gIGN1cnNvci5pbnNlcnRCZWZvcmUobm9uYnJlYWtpbmdTcGFjZTEsIG51bGwpXG4gIGN1cnNvci5pbnNlcnRCZWZvcmUodXNlckRpdiwgbnVsbClcbiAgY3Vyc29yLmluc2VydEJlZm9yZShub25icmVha2luZ1NwYWNlMiwgbnVsbClcbiAgcmV0dXJuIGN1cnNvclxufVxuXG4vKipcbiAqIERlZmF1bHQgZ2VuZXJhdG9yIGZvciB0aGUgc2VsZWN0aW9uIGF0dHJpYnV0ZXNcbiAqXG4gKiBAcGFyYW0ge2FueX0gdXNlciB1c2VyIGRhdGFcbiAqIEByZXR1cm4ge2ltcG9ydCgncHJvc2VtaXJyb3ItdmlldycpLkRlY29yYXRpb25BdHRyc31cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRTZWxlY3Rpb25CdWlsZGVyID0gKHVzZXIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzdHlsZTogYGJhY2tncm91bmQtY29sb3I6ICR7dXNlci5jb2xvcn03MGAsXG4gICAgY2xhc3M6ICdQcm9zZU1pcnJvci15anMtc2VsZWN0aW9uJ1xuICB9XG59XG5cbmNvbnN0IHJ4VmFsaWRDb2xvciA9IC9eI1swLTlhLWZBLUZdezZ9JC9cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gc3RhdGVcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIsIGFueSk6Ym9vbGVhbn0gYXdhcmVuZXNzRmlsdGVyXG4gKiBAcGFyYW0geyh1c2VyOiB7IG5hbWU6IHN0cmluZywgY29sb3I6IHN0cmluZyB9LCBjbGllbnRJZDogbnVtYmVyKSA9PiBFbGVtZW50fSBjcmVhdGVDdXJzb3JcbiAqIEBwYXJhbSB7KHVzZXI6IHsgbmFtZTogc3RyaW5nLCBjb2xvcjogc3RyaW5nIH0sIGNsaWVudElkOiBudW1iZXIpID0+IGltcG9ydCgncHJvc2VtaXJyb3ItdmlldycpLkRlY29yYXRpb25BdHRyc30gY3JlYXRlU2VsZWN0aW9uXG4gKiBAcmV0dXJuIHthbnl9IERlY29yYXRpb25TZXRcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURlY29yYXRpb25zID0gKFxuICBzdGF0ZSxcbiAgYXdhcmVuZXNzLFxuICBhd2FyZW5lc3NGaWx0ZXIsXG4gIGNyZWF0ZUN1cnNvcixcbiAgY3JlYXRlU2VsZWN0aW9uXG4pID0+IHtcbiAgY29uc3QgeXN0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpXG4gIGNvbnN0IHkgPSB5c3RhdGUuZG9jXG4gIGNvbnN0IGRlY29yYXRpb25zID0gW11cbiAgaWYgKFxuICAgIHlzdGF0ZS5zbmFwc2hvdCAhPSBudWxsIHx8IHlzdGF0ZS5wcmV2U25hcHNob3QgIT0gbnVsbCB8fFxuICAgIHlzdGF0ZS5iaW5kaW5nLm1hcHBpbmcuc2l6ZSA9PT0gMFxuICApIHtcbiAgICAvLyBkbyBub3QgcmVuZGVyIGN1cnNvcnMgd2hpbGUgc25hcHNob3QgaXMgYWN0aXZlXG4gICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKHN0YXRlLmRvYywgW10pXG4gIH1cbiAgYXdhcmVuZXNzLmdldFN0YXRlcygpLmZvckVhY2goKGF3LCBjbGllbnRJZCkgPT4ge1xuICAgIGlmICghYXdhcmVuZXNzRmlsdGVyKHkuY2xpZW50SUQsIGNsaWVudElkLCBhdykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChhdy5jdXJzb3IgIT0gbnVsbCkge1xuICAgICAgY29uc3QgdXNlciA9IGF3LnVzZXIgfHwge31cbiAgICAgIGlmICh1c2VyLmNvbG9yID09IG51bGwpIHtcbiAgICAgICAgdXNlci5jb2xvciA9ICcjZmZhNTAwJ1xuICAgICAgfSBlbHNlIGlmICghcnhWYWxpZENvbG9yLnRlc3QodXNlci5jb2xvcikpIHtcbiAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IDYtZGlnaXQgUkdCIGNvbG9ycyBpbiB5LXByb3NlbWlycm9yXG4gICAgICAgIGNvbnNvbGUud2FybignQSB1c2VyIHVzZXMgYW4gdW5zdXBwb3J0ZWQgY29sb3IgZm9ybWF0JywgdXNlcilcbiAgICAgIH1cbiAgICAgIGlmICh1c2VyLm5hbWUgPT0gbnVsbCkge1xuICAgICAgICB1c2VyLm5hbWUgPSBgVXNlcjogJHtjbGllbnRJZH1gXG4gICAgICB9XG4gICAgICBsZXQgYW5jaG9yID0gcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihcbiAgICAgICAgeSxcbiAgICAgICAgeXN0YXRlLnR5cGUsXG4gICAgICAgIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGF3LmN1cnNvci5hbmNob3IpLFxuICAgICAgICB5c3RhdGUuYmluZGluZy5tYXBwaW5nXG4gICAgICApXG4gICAgICBsZXQgaGVhZCA9IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oXG4gICAgICAgIHksXG4gICAgICAgIHlzdGF0ZS50eXBlLFxuICAgICAgICBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihhdy5jdXJzb3IuaGVhZCksXG4gICAgICAgIHlzdGF0ZS5iaW5kaW5nLm1hcHBpbmdcbiAgICAgIClcbiAgICAgIGlmIChhbmNob3IgIT09IG51bGwgJiYgaGVhZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBtYXhzaXplID0gbWF0aC5tYXgoc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSAtIDEsIDApXG4gICAgICAgIGFuY2hvciA9IG1hdGgubWluKGFuY2hvciwgbWF4c2l6ZSlcbiAgICAgICAgaGVhZCA9IG1hdGgubWluKGhlYWQsIG1heHNpemUpXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2goXG4gICAgICAgICAgRGVjb3JhdGlvbi53aWRnZXQoaGVhZCwgKCkgPT4gY3JlYXRlQ3Vyc29yKHVzZXIsIGNsaWVudElkKSwge1xuICAgICAgICAgICAga2V5OiBjbGllbnRJZCArICcnLFxuICAgICAgICAgICAgc2lkZTogMTBcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGZyb20gPSBtYXRoLm1pbihhbmNob3IsIGhlYWQpXG4gICAgICAgIGNvbnN0IHRvID0gbWF0aC5tYXgoYW5jaG9yLCBoZWFkKVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFxuICAgICAgICAgIERlY29yYXRpb24uaW5saW5lKGZyb20sIHRvLCBjcmVhdGVTZWxlY3Rpb24odXNlciwgY2xpZW50SWQpLCB7XG4gICAgICAgICAgICBpbmNsdXNpdmVFbmQ6IHRydWUsXG4gICAgICAgICAgICBpbmNsdXNpdmVTdGFydDogZmFsc2VcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoc3RhdGUuZG9jLCBkZWNvcmF0aW9ucylcbn1cblxuLyoqXG4gKiBBIHByb3NlbWlycm9yIHBsdWdpbiB0aGF0IGxpc3RlbnMgdG8gYXdhcmVuZXNzIGluZm9ybWF0aW9uIG9uIFlqcy5cbiAqIFRoaXMgcmVxdWlyZXMgdGhhdCBhIGBwcm9zZW1pcnJvclBsdWdpbmAgaXMgYWxzbyBib3VuZCB0byB0aGUgcHJvc2VtaXJyb3IuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LCBhbnksIGFueSk6Ym9vbGVhbn0gW29wdHMuYXdhcmVuZXNzU3RhdGVGaWx0ZXJdXG4gKiBAcGFyYW0geyh1c2VyOiBhbnksIGNsaWVudElkOiBudW1iZXIpID0+IEhUTUxFbGVtZW50fSBbb3B0cy5jdXJzb3JCdWlsZGVyXVxuICogQHBhcmFtIHsodXNlcjogYW55LCBjbGllbnRJZDogbnVtYmVyKSA9PiBpbXBvcnQoJ3Byb3NlbWlycm9yLXZpZXcnKS5EZWNvcmF0aW9uQXR0cnN9IFtvcHRzLnNlbGVjdGlvbkJ1aWxkZXJdXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSk6YW55fSBbb3B0cy5nZXRTZWxlY3Rpb25dXG4gKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0YXRlRmllbGRdIEJ5IGRlZmF1bHQgYWxsIGVkaXRvciBiaW5kaW5ncyB1c2UgdGhlIGF3YXJlbmVzcyAnY3Vyc29yJyBmaWVsZCB0byBwcm9wYWdhdGUgY3Vyc29yIGluZm9ybWF0aW9uLlxuICogQHJldHVybiB7YW55fVxuICovXG5leHBvcnQgY29uc3QgeUN1cnNvclBsdWdpbiA9IChcbiAgYXdhcmVuZXNzLFxuICB7XG4gICAgYXdhcmVuZXNzU3RhdGVGaWx0ZXIgPSBkZWZhdWx0QXdhcmVuZXNzU3RhdGVGaWx0ZXIsXG4gICAgY3Vyc29yQnVpbGRlciA9IGRlZmF1bHRDdXJzb3JCdWlsZGVyLFxuICAgIHNlbGVjdGlvbkJ1aWxkZXIgPSBkZWZhdWx0U2VsZWN0aW9uQnVpbGRlcixcbiAgICBnZXRTZWxlY3Rpb24gPSAoc3RhdGUpID0+IHN0YXRlLnNlbGVjdGlvblxuICB9ID0ge30sXG4gIGN1cnNvclN0YXRlRmllbGQgPSAnY3Vyc29yJ1xuKSA9PlxuICBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IHlDdXJzb3JQbHVnaW5LZXksXG4gICAgc3RhdGU6IHtcbiAgICAgIGluaXQgKF8sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWNvcmF0aW9ucyhcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBhd2FyZW5lc3MsXG4gICAgICAgICAgYXdhcmVuZXNzU3RhdGVGaWx0ZXIsXG4gICAgICAgICAgY3Vyc29yQnVpbGRlcixcbiAgICAgICAgICBzZWxlY3Rpb25CdWlsZGVyXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBhcHBseSAodHIsIHByZXZTdGF0ZSwgX29sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgICBjb25zdCB5c3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZShuZXdTdGF0ZSlcbiAgICAgICAgY29uc3QgeUN1cnNvclN0YXRlID0gdHIuZ2V0TWV0YSh5Q3Vyc29yUGx1Z2luS2V5KVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKHlzdGF0ZSAmJiB5c3RhdGUuaXNDaGFuZ2VPcmlnaW4pIHx8XG4gICAgICAgICAgKHlDdXJzb3JTdGF0ZSAmJiB5Q3Vyc29yU3RhdGUuYXdhcmVuZXNzVXBkYXRlZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZURlY29yYXRpb25zKFxuICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICBhd2FyZW5lc3MsXG4gICAgICAgICAgICBhd2FyZW5lc3NTdGF0ZUZpbHRlcixcbiAgICAgICAgICAgIGN1cnNvckJ1aWxkZXIsXG4gICAgICAgICAgICBzZWxlY3Rpb25CdWlsZGVyXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGUubWFwKHRyLm1hcHBpbmcsIHRyLmRvYylcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBkZWNvcmF0aW9uczogKHN0YXRlKSA9PiB7XG4gICAgICAgIHJldHVybiB5Q3Vyc29yUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICAgICAgfVxuICAgIH0sXG4gICAgdmlldzogKHZpZXcpID0+IHtcbiAgICAgIGNvbnN0IGF3YXJlbmVzc0xpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh2aWV3LmRvY1ZpZXcpIHtcbiAgICAgICAgICBzZXRNZXRhKHZpZXcsIHlDdXJzb3JQbHVnaW5LZXksIHsgYXdhcmVuZXNzVXBkYXRlZDogdHJ1ZSB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB1cGRhdGVDdXJzb3JJbmZvID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB5c3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKVxuICAgICAgICAvLyBAbm90ZSBXZSBtYWtlIGltcGxpY2l0IGNoZWNrcyB3aGVuIGNoZWNraW5nIGZvciB0aGUgY3Vyc29yIHByb3BlcnR5XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpIHx8IHt9XG4gICAgICAgIGlmICh2aWV3Lmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24odmlldy5zdGF0ZSlcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdHlwZSB7WS5SZWxhdGl2ZVBvc2l0aW9ufVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24oXG4gICAgICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLFxuICAgICAgICAgICAgeXN0YXRlLnR5cGUsXG4gICAgICAgICAgICB5c3RhdGUuYmluZGluZy5tYXBwaW5nXG4gICAgICAgICAgKVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHtZLlJlbGF0aXZlUG9zaXRpb259XG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgaGVhZCA9IGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24oXG4gICAgICAgICAgICBzZWxlY3Rpb24uaGVhZCxcbiAgICAgICAgICAgIHlzdGF0ZS50eXBlLFxuICAgICAgICAgICAgeXN0YXRlLmJpbmRpbmcubWFwcGluZ1xuICAgICAgICAgIClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjdXJyZW50LmN1cnNvciA9PSBudWxsIHx8XG4gICAgICAgICAgICAhWS5jb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMoXG4gICAgICAgICAgICAgIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnJlbnQuY3Vyc29yLmFuY2hvciksXG4gICAgICAgICAgICAgIGFuY2hvclxuICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgIVkuY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zKFxuICAgICAgICAgICAgICBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihjdXJyZW50LmN1cnNvci5oZWFkKSxcbiAgICAgICAgICAgICAgaGVhZFxuICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZChjdXJzb3JTdGF0ZUZpZWxkLCB7XG4gICAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgICAgaGVhZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgY3VycmVudC5jdXJzb3IgIT0gbnVsbCAmJlxuICAgICAgICAgIHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oXG4gICAgICAgICAgICB5c3RhdGUuZG9jLFxuICAgICAgICAgICAgeXN0YXRlLnR5cGUsXG4gICAgICAgICAgICBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihjdXJyZW50LmN1cnNvci5hbmNob3IpLFxuICAgICAgICAgICAgeXN0YXRlLmJpbmRpbmcubWFwcGluZ1xuICAgICAgICAgICkgIT09IG51bGxcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gZGVsZXRlIGN1cnNvciBpbmZvcm1hdGlvbiBpZiBjdXJyZW50IGN1cnNvciBpbmZvcm1hdGlvbiBpcyBvd25lZCBieSB0aGlzIGVkaXRvciBiaW5kaW5nXG4gICAgICAgICAgYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZChjdXJzb3JTdGF0ZUZpZWxkLCBudWxsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FyZW5lc3Mub24oJ2NoYW5nZScsIGF3YXJlbmVzc0xpc3RlbmVyKVxuICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHVwZGF0ZUN1cnNvckluZm8pXG4gICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHVwZGF0ZUN1cnNvckluZm8pXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGU6IHVwZGF0ZUN1cnNvckluZm8sXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdXBkYXRlQ3Vyc29ySW5mbylcbiAgICAgICAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHVwZGF0ZUN1cnNvckluZm8pXG4gICAgICAgICAgYXdhcmVuZXNzLm9mZignY2hhbmdlJywgYXdhcmVuZXNzTGlzdGVuZXIpXG4gICAgICAgICAgYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZChjdXJzb3JTdGF0ZUZpZWxkLCBudWxsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js":
/*!********************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/keys.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   yCursorPluginKey: () => (/* binding */ yCursorPluginKey),\n/* harmony export */   ySyncPluginKey: () => (/* binding */ ySyncPluginKey),\n/* harmony export */   yUndoPluginKey: () => (/* binding */ yUndoPluginKey)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n // eslint-disable-line\n\n/**\n * The unique prosemirror plugin key for syncPlugin\n *\n * @public\n */\nconst ySyncPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('y-sync')\n\n/**\n * The unique prosemirror plugin key for undoPlugin\n *\n * @public\n * @type {PluginKey<import('./undo-plugin').UndoPluginState>}\n */\nconst yUndoPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('y-undo')\n\n/**\n * The unique prosemirror plugin key for cursorPlugin\n *\n * @public\n */\nconst yCursorPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('yjs-cursor')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9rZXlzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsd0RBQVM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ08sMkJBQTJCLHdEQUFTOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLHdEQUFTIiwic291cmNlcyI6WyIvVXNlcnMvYXJ5YW5nb3lhbC9yZWFsLXRpbWUtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL3ktcHJvc2VtaXJyb3Ivc3JjL3BsdWdpbnMva2V5cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbHVnaW5LZXkgfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZScgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIFRoZSB1bmlxdWUgcHJvc2VtaXJyb3IgcGx1Z2luIGtleSBmb3Igc3luY1BsdWdpblxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHlTeW5jUGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleSgneS1zeW5jJylcblxuLyoqXG4gKiBUaGUgdW5pcXVlIHByb3NlbWlycm9yIHBsdWdpbiBrZXkgZm9yIHVuZG9QbHVnaW5cbiAqXG4gKiBAcHVibGljXG4gKiBAdHlwZSB7UGx1Z2luS2V5PGltcG9ydCgnLi91bmRvLXBsdWdpbicpLlVuZG9QbHVnaW5TdGF0ZT59XG4gKi9cbmV4cG9ydCBjb25zdCB5VW5kb1BsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoJ3ktdW5kbycpXG5cbi8qKlxuICogVGhlIHVuaXF1ZSBwcm9zZW1pcnJvciBwbHVnaW4ga2V5IGZvciBjdXJzb3JQbHVnaW5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB5Q3Vyc29yUGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleSgneWpzLWN1cnNvcicpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/sync-plugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProsemirrorBinding: () => (/* binding */ ProsemirrorBinding),\n/* harmony export */   attributesToMarks: () => (/* binding */ attributesToMarks),\n/* harmony export */   createEmptyMeta: () => (/* binding */ createEmptyMeta),\n/* harmony export */   createNodeFromYElement: () => (/* binding */ createNodeFromYElement),\n/* harmony export */   getRelativeSelection: () => (/* binding */ getRelativeSelection),\n/* harmony export */   isVisible: () => (/* binding */ isVisible),\n/* harmony export */   updateYFragment: () => (/* binding */ updateYFragment),\n/* harmony export */   ySyncPlugin: () => (/* binding */ ySyncPlugin),\n/* harmony export */   yattr2markname: () => (/* binding */ yattr2markname)\n/* harmony export */ });\n/* harmony import */ var lib0_mutex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/mutex */ \"(ssr)/./node_modules/lib0/mutex.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n/* harmony import */ var lib0_object__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/object */ \"(ssr)/./node_modules/lib0/object.js\");\n/* harmony import */ var lib0_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/set */ \"(ssr)/./node_modules/lib0/set.js\");\n/* harmony import */ var lib0_diff__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/diff */ \"(ssr)/./node_modules/lib0/diff.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/error */ \"(ssr)/./node_modules/lib0/error.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib.js */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var lib0_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/random */ \"(ssr)/./node_modules/lib0/random.js\");\n/* harmony import */ var lib0_environment__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/environment */ \"(ssr)/./node_modules/lib0/environment.js\");\n/* harmony import */ var lib0_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/dom */ \"(ssr)/./node_modules/lib0/dom.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/eventloop */ \"(ssr)/./node_modules/lib0/eventloop.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lib0/map */ \"(ssr)/./node_modules/lib0/map.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/y-prosemirror/src/utils.js\");\n/**\n * @module bindings/prosemirror\n */\n\n\n\n // eslint-disable-line\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} BindingMetadata\n * @property {ProsemirrorMapping} BindingMetadata.mapping\n * @property {Map<import('prosemirror-model').MarkType, boolean>} BindingMetadata.isOMark - is overlapping mark\n */\n\n/**\n * @return {BindingMetadata}\n */\nconst createEmptyMeta = () => ({\n  mapping: new Map(),\n  isOMark: new Map()\n})\n\n/**\n * @param {Y.Item} item\n * @param {Y.Snapshot} [snapshot]\n */\nconst isVisible = (item, snapshot) =>\n  snapshot === undefined\n    ? !item.deleted\n    : (snapshot.sv.has(item.id.client) && /** @type {number} */\n      (snapshot.sv.get(item.id.client)) > item.id.clock &&\n      !yjs__WEBPACK_IMPORTED_MODULE_0__.isDeleted(snapshot.ds, item.id))\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType<any>, PModel.Node | Array<PModel.Node>>} ProsemirrorMapping\n */\n\n/**\n * @typedef {Object} ColorDef\n * @property {string} ColorDef.light\n * @property {string} ColorDef.dark\n */\n\n/**\n * @typedef {Object} YSyncOpts\n * @property {Array<ColorDef>} [YSyncOpts.colors]\n * @property {Map<string,ColorDef>} [YSyncOpts.colorMapping]\n * @property {Y.PermanentUserData|null} [YSyncOpts.permanentUserData]\n * @property {ProsemirrorMapping} [YSyncOpts.mapping]\n * @property {function} [YSyncOpts.onFirstRender] Fired when the content from Yjs is initially rendered to ProseMirror\n */\n\n/**\n * @type {Array<ColorDef>}\n */\nconst defaultColors = [{ light: '#ecd44433', dark: '#ecd444' }]\n\n/**\n * @param {Map<string,ColorDef>} colorMapping\n * @param {Array<ColorDef>} colors\n * @param {string} user\n * @return {ColorDef}\n */\nconst getUserColor = (colorMapping, colors, user) => {\n  // @todo do not hit the same color twice if possible\n  if (!colorMapping.has(user)) {\n    if (colorMapping.size < colors.length) {\n      const usedColors = lib0_set__WEBPACK_IMPORTED_MODULE_1__.create()\n      colorMapping.forEach((color) => usedColors.add(color))\n      colors = colors.filter((color) => !usedColors.has(color))\n    }\n    colorMapping.set(user, lib0_random__WEBPACK_IMPORTED_MODULE_2__.oneOf(colors))\n  }\n  return /** @type {ColorDef} */ (colorMapping.get(user))\n}\n\n/**\n * This plugin listens to changes in prosemirror view and keeps yXmlState and view in sync.\n *\n * This plugin also keeps references to the type and the shared document so other plugins can access it.\n * @param {Y.XmlFragment} yXmlFragment\n * @param {YSyncOpts} opts\n * @return {any} Returns a prosemirror plugin that binds to this type\n */\nconst ySyncPlugin = (yXmlFragment, {\n  colors = defaultColors,\n  colorMapping = new Map(),\n  permanentUserData = null,\n  onFirstRender = () => {},\n  mapping\n} = {}) => {\n  let initialContentChanged = false\n  const binding = new ProsemirrorBinding(yXmlFragment, mapping)\n  const plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({\n    props: {\n      editable: (state) => {\n        const syncState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey.getState(state)\n        return syncState.snapshot == null && syncState.prevSnapshot == null\n      }\n    },\n    key: _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey,\n    state: {\n      /**\n       * @returns {any}\n       */\n      init: (_initargs, _state) => {\n        return {\n          type: yXmlFragment,\n          doc: yXmlFragment.doc,\n          binding,\n          snapshot: null,\n          prevSnapshot: null,\n          isChangeOrigin: false,\n          isUndoRedoOperation: false,\n          addToHistory: true,\n          colors,\n          colorMapping,\n          permanentUserData\n        }\n      },\n      apply: (tr, pluginState) => {\n        const change = tr.getMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n        if (change !== undefined) {\n          pluginState = Object.assign({}, pluginState)\n          for (const key in change) {\n            pluginState[key] = change[key]\n          }\n        }\n        pluginState.addToHistory = tr.getMeta('addToHistory') !== false\n        // always set isChangeOrigin. If undefined, this is not change origin.\n        pluginState.isChangeOrigin = change !== undefined &&\n          !!change.isChangeOrigin\n        pluginState.isUndoRedoOperation = change !== undefined && !!change.isChangeOrigin && !!change.isUndoRedoOperation\n        if (binding.prosemirrorView !== null) {\n          if (\n            change !== undefined &&\n            (change.snapshot != null || change.prevSnapshot != null)\n          ) {\n            // snapshot changed, rerender next\n            lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, () => {\n              if (binding.prosemirrorView == null) {\n                return\n              }\n              if (change.restore == null) {\n                binding._renderSnapshot(\n                  change.snapshot,\n                  change.prevSnapshot,\n                  pluginState\n                )\n              } else {\n                binding._renderSnapshot(\n                  change.snapshot,\n                  change.snapshot,\n                  pluginState\n                )\n                // reset to current prosemirror state\n                delete pluginState.restore\n                delete pluginState.snapshot\n                delete pluginState.prevSnapshot\n                binding.mux(() => {\n                  binding._prosemirrorChanged(\n                    binding.prosemirrorView.state.doc\n                  )\n                })\n              }\n            })\n          }\n        }\n        return pluginState\n      }\n    },\n    view: (view) => {\n      binding.initView(view)\n      if (mapping == null) {\n        // force rerender to update the bindings mapping\n        binding._forceRerender()\n      }\n      onFirstRender()\n      return {\n        update: () => {\n          const pluginState = plugin.getState(view.state)\n          if (\n            pluginState.snapshot == null && pluginState.prevSnapshot == null\n          ) {\n            if (\n              // If the content doesn't change initially, we don't render anything to Yjs\n              // If the content was cleared by a user action, we want to catch the change and\n              // represent it in Yjs\n              initialContentChanged ||\n              view.state.doc.content.findDiffStart(\n                view.state.doc.type.createAndFill().content\n              ) !== null\n            ) {\n              initialContentChanged = true\n              if (\n                pluginState.addToHistory === false &&\n                !pluginState.isChangeOrigin\n              ) {\n                const yUndoPluginState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.yUndoPluginKey.getState(view.state)\n                /**\n                 * @type {Y.UndoManager}\n                 */\n                const um = yUndoPluginState && yUndoPluginState.undoManager\n                if (um) {\n                  um.stopCapturing()\n                }\n              }\n              binding.mux(() => {\n                /** @type {Y.Doc} */ (pluginState.doc).transact((tr) => {\n                  tr.meta.set('addToHistory', pluginState.addToHistory)\n                  binding._prosemirrorChanged(view.state.doc)\n                }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n              })\n            }\n          }\n        },\n        destroy: () => {\n          binding.destroy()\n        }\n      }\n    }\n  })\n  return plugin\n}\n\n/**\n * @param {import('prosemirror-state').Transaction} tr\n * @param {ReturnType<typeof getRelativeSelection>} relSel\n * @param {ProsemirrorBinding} binding\n */\nconst restoreRelativeSelection = (tr, relSel, binding) => {\n  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {\n    if (relSel.type === 'all') {\n      tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.AllSelection(tr.doc))\n    } else if (relSel.type === 'node') {\n      const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(\n        binding.doc,\n        binding.type,\n        relSel.anchor,\n        binding.mapping\n      )\n      tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.NodeSelection.create(tr.doc, anchor))\n    } else {\n      const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(\n        binding.doc,\n        binding.type,\n        relSel.anchor,\n        binding.mapping\n      )\n      const head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(\n        binding.doc,\n        binding.type,\n        relSel.head,\n        binding.mapping\n      )\n      if (anchor !== null && head !== null) {\n        const sel = prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.TextSelection.between(tr.doc.resolve(anchor), tr.doc.resolve(head))\n        tr.setSelection(sel)\n      }\n    }\n  }\n}\n\n/**\n * @param {ProsemirrorBinding} pmbinding\n * @param {import('prosemirror-state').EditorState} state\n */\nconst getRelativeSelection = (pmbinding, state) => ({\n  type: /** @type {any} */ (state.selection).jsonID,\n  anchor: (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.absolutePositionToRelativePosition)(\n    state.selection.anchor,\n    pmbinding.type,\n    pmbinding.mapping\n  ),\n  head: (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.absolutePositionToRelativePosition)(\n    state.selection.head,\n    pmbinding.type,\n    pmbinding.mapping\n  )\n})\n\n/**\n * Binding for prosemirror.\n *\n * @protected\n */\nclass ProsemirrorBinding {\n  /**\n   * @param {Y.XmlFragment} yXmlFragment The bind source\n   * @param {ProsemirrorMapping} mapping\n   */\n  constructor (yXmlFragment, mapping = new Map()) {\n    this.type = yXmlFragment\n    /**\n     * this will be set once the view is created\n     * @type {any}\n     */\n    this.prosemirrorView = null\n    this.mux = (0,lib0_mutex__WEBPACK_IMPORTED_MODULE_7__.createMutex)()\n    this.mapping = mapping\n    /**\n     * Is overlapping mark - i.e. mark does not exclude itself.\n     *\n     * @type {Map<import('prosemirror-model').MarkType, boolean>}\n     */\n    this.isOMark = new Map()\n    this._observeFunction = this._typeChanged.bind(this)\n    /**\n     * @type {Y.Doc}\n     */\n    // @ts-ignore\n    this.doc = yXmlFragment.doc\n    /**\n     * current selection as relative positions in the Yjs model\n     */\n    this.beforeTransactionSelection = null\n    this.beforeAllTransactions = () => {\n      if (this.beforeTransactionSelection === null && this.prosemirrorView != null) {\n        this.beforeTransactionSelection = getRelativeSelection(\n          this,\n          this.prosemirrorView.state\n        )\n      }\n    }\n    this.afterAllTransactions = () => {\n      this.beforeTransactionSelection = null\n    }\n    this._domSelectionInView = null\n  }\n\n  /**\n   * Create a transaction for changing the prosemirror state.\n   *\n   * @returns\n   */\n  get _tr () {\n    return this.prosemirrorView.state.tr.setMeta('addToHistory', false)\n  }\n\n  _isLocalCursorInView () {\n    if (!this.prosemirrorView.hasFocus()) return false\n    if (lib0_environment__WEBPACK_IMPORTED_MODULE_8__.isBrowser && this._domSelectionInView === null) {\n      // Calculate the domSelectionInView and clear by next tick after all events are finished\n      lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, () => {\n        this._domSelectionInView = null\n      })\n      this._domSelectionInView = this._isDomSelectionInView()\n    }\n    return this._domSelectionInView\n  }\n\n  _isDomSelectionInView () {\n    const selection = this.prosemirrorView._root.getSelection()\n\n    if (selection == null || selection.anchorNode == null) return false\n\n    const range = this.prosemirrorView._root.createRange()\n    range.setStart(selection.anchorNode, selection.anchorOffset)\n    range.setEnd(selection.focusNode, selection.focusOffset)\n\n    // This is a workaround for an edgecase where getBoundingClientRect will\n    // return zero values if the selection is collapsed at the start of a newline\n    // see reference here: https://stackoverflow.com/a/59780954\n    const rects = range.getClientRects()\n    if (rects.length === 0) {\n      // probably buggy newline behavior, explicitly select the node contents\n      if (range.startContainer && range.collapsed) {\n        range.selectNodeContents(range.startContainer)\n      }\n    }\n\n    const bounding = range.getBoundingClientRect()\n    const documentElement = lib0_dom__WEBPACK_IMPORTED_MODULE_9__.doc.documentElement\n\n    return bounding.bottom >= 0 && bounding.right >= 0 &&\n      bounding.left <=\n        (window.innerWidth || documentElement.clientWidth || 0) &&\n      bounding.top <= (window.innerHeight || documentElement.clientHeight || 0)\n  }\n\n  /**\n   * @param {Y.Snapshot} snapshot\n   * @param {Y.Snapshot} prevSnapshot\n   */\n  renderSnapshot (snapshot, prevSnapshot) {\n    if (!prevSnapshot) {\n      prevSnapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.createSnapshot(yjs__WEBPACK_IMPORTED_MODULE_0__.createDeleteSet(), new Map())\n    }\n    this.prosemirrorView.dispatch(\n      this._tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { snapshot, prevSnapshot })\n    )\n  }\n\n  unrenderSnapshot () {\n    this.mapping.clear()\n    this.mux(() => {\n      const fragmentContent = this.type.toArray().map((t) =>\n        createNodeFromYElement(\n          /** @type {Y.XmlElement} */ (t),\n          this.prosemirrorView.state.schema,\n          this\n        )\n      ).filter((n) => n !== null)\n      // @ts-ignore\n      const tr = this._tr.replace(\n        0,\n        this.prosemirrorView.state.doc.content.size,\n        new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0)\n      )\n      tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { snapshot: null, prevSnapshot: null })\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  _forceRerender () {\n    this.mapping.clear()\n    this.mux(() => {\n      // If this is a forced rerender, this might neither happen as a pm change nor within a Yjs\n      // transaction. Then the \"before selection\" doesn't exist. In this case, we need to create a\n      // relative position before replacing content. Fixes #126\n      const sel = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection\n      const fragmentContent = this.type.toArray().map((t) =>\n        createNodeFromYElement(\n          /** @type {Y.XmlElement} */ (t),\n          this.prosemirrorView.state.schema,\n          this\n        )\n      ).filter((n) => n !== null)\n      // @ts-ignore\n      const tr = this._tr.replace(\n        0,\n        this.prosemirrorView.state.doc.content.size,\n        new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0)\n      )\n      if (sel) {\n        /**\n         * If the Prosemirror document we just created from this.type is\n         * smaller than the previous document, the selection might be\n         * out of bound, which would make Prosemirror throw an error.\n         */\n        const clampedAnchor = lib0_math__WEBPACK_IMPORTED_MODULE_11__.min(lib0_math__WEBPACK_IMPORTED_MODULE_11__.max(sel.anchor, 0), tr.doc.content.size)\n        const clampedHead = lib0_math__WEBPACK_IMPORTED_MODULE_11__.min(lib0_math__WEBPACK_IMPORTED_MODULE_11__.max(sel.head, 0), tr.doc.content.size)\n\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.TextSelection.create(tr.doc, clampedAnchor, clampedHead))\n      }\n      this.prosemirrorView.dispatch(\n        tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { isChangeOrigin: true, binding: this })\n      )\n    })\n  }\n\n  /**\n   * @param {Y.Snapshot|Uint8Array} snapshot\n   * @param {Y.Snapshot|Uint8Array} prevSnapshot\n   * @param {Object} pluginState\n   */\n  _renderSnapshot (snapshot, prevSnapshot, pluginState) {\n    /**\n     * The document that contains the full history of this document.\n     * @type {Y.Doc}\n     */\n    let historyDoc = this.doc\n    let historyType = this.type\n    if (!snapshot) {\n      snapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(this.doc)\n    }\n    if (snapshot instanceof Uint8Array || prevSnapshot instanceof Uint8Array) {\n      if (!(snapshot instanceof Uint8Array) || !(prevSnapshot instanceof Uint8Array)) {\n        // expected both snapshots to be v2 updates\n        lib0_error__WEBPACK_IMPORTED_MODULE_12__.unexpectedCase()\n      }\n      historyDoc = new yjs__WEBPACK_IMPORTED_MODULE_0__.Doc({ gc: false })\n      yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdateV2(historyDoc, prevSnapshot)\n      prevSnapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(historyDoc)\n      yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdateV2(historyDoc, snapshot)\n      snapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(historyDoc)\n      if (historyType._item === null) {\n        /**\n         * If is a root type, we need to find the root key in the initial document\n         * and use it to get the history type.\n         */\n        const rootKey = Array.from(this.doc.share.keys()).find(\n          (key) => this.doc.share.get(key) === this.type\n        )\n        historyType = historyDoc.getXmlFragment(rootKey)\n      } else {\n        /**\n         * If it is a sub type, we use the item id to find the history type.\n         */\n        const historyStructs =\n          historyDoc.store.clients.get(historyType._item.id.client) ?? []\n        const itemIndex = yjs__WEBPACK_IMPORTED_MODULE_0__.findIndexSS(\n          historyStructs,\n          historyType._item.id.clock\n        )\n        const item = /** @type {Y.Item} */ (historyStructs[itemIndex])\n        const content = /** @type {Y.ContentType} */ (item.content)\n        historyType = /** @type {Y.XmlFragment} */ (content.type)\n      }\n    }\n    // clear mapping because we are going to rerender\n    this.mapping.clear()\n    this.mux(() => {\n      historyDoc.transact((transaction) => {\n        // before rendering, we are going to sanitize ops and split deleted ops\n        // if they were deleted by seperate users.\n        /**\n         * @type {Y.PermanentUserData}\n         */\n        const pud = pluginState.permanentUserData\n        if (pud) {\n          pud.dss.forEach((ds) => {\n            yjs__WEBPACK_IMPORTED_MODULE_0__.iterateDeletedStructs(transaction, ds, (_item) => {})\n          })\n        }\n        /**\n         * @param {'removed'|'added'} type\n         * @param {Y.ID} id\n         */\n        const computeYChange = (type, id) => {\n          const user = type === 'added'\n            ? pud.getUserByClientId(id.client)\n            : pud.getUserByDeletedId(id)\n          return {\n            user,\n            type,\n            color: getUserColor(\n              pluginState.colorMapping,\n              pluginState.colors,\n              user\n            )\n          }\n        }\n        // Create document fragment and render\n        const fragmentContent = yjs__WEBPACK_IMPORTED_MODULE_0__.typeListToArraySnapshot(\n          historyType,\n          new yjs__WEBPACK_IMPORTED_MODULE_0__.Snapshot(prevSnapshot.ds, snapshot.sv)\n        ).map((t) => {\n          if (\n            !t._item.deleted || isVisible(t._item, snapshot) ||\n            isVisible(t._item, prevSnapshot)\n          ) {\n            return createNodeFromYElement(\n              t,\n              this.prosemirrorView.state.schema,\n              { mapping: new Map(), isOMark: new Map() },\n              snapshot,\n              prevSnapshot,\n              computeYChange\n            )\n          } else {\n            // No need to render elements that are not visible by either snapshot.\n            // If a client adds and deletes content in the same snapshot the element is not visible by either snapshot.\n            return null\n          }\n        }).filter((n) => n !== null)\n        // @ts-ignore\n        const tr = this._tr.replace(\n          0,\n          this.prosemirrorView.state.doc.content.size,\n          new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0)\n        )\n        this.prosemirrorView.dispatch(\n          tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { isChangeOrigin: true })\n        )\n      }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    })\n  }\n\n  /**\n   * @param {Array<Y.YEvent<any>>} events\n   * @param {Y.Transaction} transaction\n   */\n  _typeChanged (events, transaction) {\n    if (this.prosemirrorView == null) return\n    const syncState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey.getState(this.prosemirrorView.state)\n    if (\n      events.length === 0 || syncState.snapshot != null ||\n      syncState.prevSnapshot != null\n    ) {\n      // drop out if snapshot is active\n      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot)\n      return\n    }\n    this.mux(() => {\n      /**\n       * @param {any} _\n       * @param {Y.AbstractType<any>} type\n       */\n      const delType = (_, type) => this.mapping.delete(type)\n      yjs__WEBPACK_IMPORTED_MODULE_0__.iterateDeletedStructs(\n        transaction,\n        transaction.deleteSet,\n        (struct) => {\n          if (struct.constructor === yjs__WEBPACK_IMPORTED_MODULE_0__.Item) {\n            const type = /** @type {Y.ContentType} */ (/** @type {Y.Item} */ (struct).content).type\n            type && this.mapping.delete(type)\n          }\n        }\n      )\n      transaction.changed.forEach(delType)\n      transaction.changedParentTypes.forEach(delType)\n      const fragmentContent = this.type.toArray().map((t) =>\n        createNodeIfNotExists(\n          /** @type {Y.XmlElement | Y.XmlHook} */ (t),\n          this.prosemirrorView.state.schema,\n          this\n        )\n      ).filter((n) => n !== null)\n      // @ts-ignore\n      let tr = this._tr.replace(\n        0,\n        this.prosemirrorView.state.doc.content.size,\n        new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0)\n      )\n      restoreRelativeSelection(tr, this.beforeTransactionSelection, this)\n      tr = tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { isChangeOrigin: true, isUndoRedoOperation: transaction.origin instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.UndoManager })\n      if (\n        this.beforeTransactionSelection !== null && this._isLocalCursorInView()\n      ) {\n        tr.scrollIntoView()\n      }\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  /**\n   * @param {import('prosemirror-model').Node} doc\n   */\n  _prosemirrorChanged (doc) {\n    this.doc.transact(() => {\n      updateYFragment(this.doc, this.type, doc, this)\n      this.beforeTransactionSelection = getRelativeSelection(\n        this,\n        this.prosemirrorView.state\n      )\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n  }\n\n  /**\n   * View is ready to listen to changes. Register observers.\n   * @param {any} prosemirrorView\n   */\n  initView (prosemirrorView) {\n    if (this.prosemirrorView != null) this.destroy()\n    this.prosemirrorView = prosemirrorView\n    this.doc.on('beforeAllTransactions', this.beforeAllTransactions)\n    this.doc.on('afterAllTransactions', this.afterAllTransactions)\n    this.type.observeDeep(this._observeFunction)\n  }\n\n  destroy () {\n    if (this.prosemirrorView == null) return\n    this.prosemirrorView = null\n    this.type.unobserveDeep(this._observeFunction)\n    this.doc.off('beforeAllTransactions', this.beforeAllTransactions)\n    this.doc.off('afterAllTransactions', this.afterAllTransactions)\n  }\n}\n\n/**\n * @private\n * @param {Y.XmlElement | Y.XmlHook} el\n * @param {PModel.Schema} schema\n * @param {BindingMetadata} meta\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null}\n */\nconst createNodeIfNotExists = (\n  el,\n  schema,\n  meta,\n  snapshot,\n  prevSnapshot,\n  computeYChange\n) => {\n  const node = /** @type {PModel.Node} */ (meta.mapping.get(el))\n  if (node === undefined) {\n    if (el instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n      return createNodeFromYElement(\n        el,\n        schema,\n        meta,\n        snapshot,\n        prevSnapshot,\n        computeYChange\n      )\n    } else {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_12__.methodUnimplemented() // we are currently not handling hooks\n    }\n  }\n  return node\n}\n\n/**\n * @private\n * @param {Y.XmlElement} el\n * @param {any} schema\n * @param {BindingMetadata} meta\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null} Returns node if node could be created. Otherwise it deletes the yjs type and returns null\n */\nconst createNodeFromYElement = (\n  el,\n  schema,\n  meta,\n  snapshot,\n  prevSnapshot,\n  computeYChange\n) => {\n  const children = []\n  /**\n   * @param {Y.XmlElement | Y.XmlText} type\n   */\n  const createChildren = (type) => {\n    if (type instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n      const n = createNodeIfNotExists(\n        type,\n        schema,\n        meta,\n        snapshot,\n        prevSnapshot,\n        computeYChange\n      )\n      if (n !== null) {\n        children.push(n)\n      }\n    } else {\n      // If the next ytext exists and was created by us, move the content to the current ytext.\n      // This is a fix for #160 -- duplication of characters when two Y.Text exist next to each\n      // other.\n      const nextytext = /** @type {Y.ContentType} */ (type._item.right?.content)?.type\n      if (nextytext instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Text && !nextytext._item.deleted && nextytext._item.id.client === nextytext.doc.clientID) {\n        type.applyDelta([\n          { retain: type.length },\n          ...nextytext.toDelta()\n        ])\n        nextytext.doc.transact(tr => {\n          nextytext._item.delete(tr)\n        })\n      }\n      // now create the prosemirror text nodes\n      const ns = createTextNodesFromYText(\n        type,\n        schema,\n        meta,\n        snapshot,\n        prevSnapshot,\n        computeYChange\n      )\n      if (ns !== null) {\n        ns.forEach((textchild) => {\n          if (textchild !== null) {\n            children.push(textchild)\n          }\n        })\n      }\n    }\n  }\n  if (snapshot === undefined || prevSnapshot === undefined) {\n    el.toArray().forEach(createChildren)\n  } else {\n    yjs__WEBPACK_IMPORTED_MODULE_0__.typeListToArraySnapshot(el, new yjs__WEBPACK_IMPORTED_MODULE_0__.Snapshot(prevSnapshot.ds, snapshot.sv))\n      .forEach(createChildren)\n  }\n  try {\n    const attrs = el.getAttributes(snapshot)\n    if (snapshot !== undefined) {\n      if (!isVisible(/** @type {Y.Item} */ (el._item), snapshot)) {\n        attrs.ychange = computeYChange\n          ? computeYChange('removed', /** @type {Y.Item} */ (el._item).id)\n          : { type: 'removed' }\n      } else if (!isVisible(/** @type {Y.Item} */ (el._item), prevSnapshot)) {\n        attrs.ychange = computeYChange\n          ? computeYChange('added', /** @type {Y.Item} */ (el._item).id)\n          : { type: 'added' }\n      }\n    }\n    const node = schema.node(el.nodeName, attrs, children)\n    meta.mapping.set(el, node)\n    return node\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n    /** @type {Y.Doc} */ (el.doc).transact((transaction) => {\n      /** @type {Y.Item} */ (el._item).delete(transaction)\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    meta.mapping.delete(el)\n    return null\n  }\n}\n\n/**\n * @private\n * @param {Y.XmlText} text\n * @param {import('prosemirror-model').Schema} schema\n * @param {BindingMetadata} _meta\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {Array<PModel.Node>|null}\n */\nconst createTextNodesFromYText = (\n  text,\n  schema,\n  _meta,\n  snapshot,\n  prevSnapshot,\n  computeYChange\n) => {\n  const nodes = []\n  const deltas = text.toDelta(snapshot, prevSnapshot, computeYChange)\n  try {\n    for (let i = 0; i < deltas.length; i++) {\n      const delta = deltas[i]\n      nodes.push(schema.text(delta.insert, attributesToMarks(delta.attributes, schema)))\n    }\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n    /** @type {Y.Doc} */ (text.doc).transact((transaction) => {\n      /** @type {Y.Item} */ (text._item).delete(transaction)\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    return null\n  }\n  // @ts-ignore\n  return nodes\n}\n\n/**\n * @private\n * @param {Array<any>} nodes prosemirror node\n * @param {BindingMetadata} meta\n * @return {Y.XmlText}\n */\nconst createTypeFromTextNodes = (nodes, meta) => {\n  const type = new yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText()\n  const delta = nodes.map((node) => ({\n    // @ts-ignore\n    insert: node.text,\n    attributes: marksToAttributes(node.marks, meta)\n  }))\n  type.applyDelta(delta)\n  meta.mapping.set(type, nodes)\n  return type\n}\n\n/**\n * @private\n * @param {any} node prosemirror node\n * @param {BindingMetadata} meta\n * @return {Y.XmlElement}\n */\nconst createTypeFromElementNode = (node, meta) => {\n  const type = new yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement(node.type.name)\n  for (const key in node.attrs) {\n    const val = node.attrs[key]\n    if (val !== null && key !== 'ychange') {\n      type.setAttribute(key, val)\n    }\n  }\n  type.insert(\n    0,\n    normalizePNodeContent(node).map((n) =>\n      createTypeFromTextOrElementNode(n, meta)\n    )\n  )\n  meta.mapping.set(type, node)\n  return type\n}\n\n/**\n * @private\n * @param {PModel.Node|Array<PModel.Node>} node prosemirror text node\n * @param {BindingMetadata} meta\n * @return {Y.XmlElement|Y.XmlText}\n */\nconst createTypeFromTextOrElementNode = (node, meta) =>\n  node instanceof Array\n    ? createTypeFromTextNodes(node, meta)\n    : createTypeFromElementNode(node, meta)\n\n/**\n * @param {any} val\n */\nconst isObject = (val) => typeof val === 'object' && val !== null\n\n/**\n * @param {any} pattrs\n * @param {any} yattrs\n */\nconst equalAttrs = (pattrs, yattrs) => {\n  const keys = Object.keys(pattrs).filter((key) => pattrs[key] !== null)\n  let eq =\n    keys.length ===\n      (yattrs == null ? 0 : Object.keys(yattrs).filter((key) => yattrs[key] !== null).length)\n  for (let i = 0; i < keys.length && eq; i++) {\n    const key = keys[i]\n    const l = pattrs[key]\n    const r = yattrs[key]\n    eq = key === 'ychange' || l === r ||\n      (isObject(l) && isObject(r) && equalAttrs(l, r))\n  }\n  return eq\n}\n\n/**\n * @typedef {Array<Array<PModel.Node>|PModel.Node>} NormalizedPNodeContent\n */\n\n/**\n * @param {any} pnode\n * @return {NormalizedPNodeContent}\n */\nconst normalizePNodeContent = (pnode) => {\n  const c = pnode.content.content\n  const res = []\n  for (let i = 0; i < c.length; i++) {\n    const n = c[i]\n    if (n.isText) {\n      const textNodes = []\n      for (let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]) {\n        textNodes.push(tnode)\n      }\n      i--\n      res.push(textNodes)\n    } else {\n      res.push(n)\n    }\n  }\n  return res\n}\n\n/**\n * @param {Y.XmlText} ytext\n * @param {Array<any>} ptexts\n */\nconst equalYTextPText = (ytext, ptexts) => {\n  const delta = ytext.toDelta()\n  return delta.length === ptexts.length &&\n    delta.every(/** @type {(d:any,i:number) => boolean} */ (d, i) =>\n      d.insert === /** @type {any} */ (ptexts[i]).text &&\n      lib0_object__WEBPACK_IMPORTED_MODULE_13__.keys(d.attributes || {}).length === ptexts[i].marks.length &&\n      lib0_object__WEBPACK_IMPORTED_MODULE_13__.every(d.attributes, (attr, yattrname) => {\n        const markname = yattr2markname(yattrname)\n        const pmarks = ptexts[i].marks\n        return equalAttrs(attr, pmarks.find(/** @param {any} mark */ mark => mark.type.name === markname)?.attrs)\n      })\n    )\n}\n\n/**\n * @param {Y.XmlElement|Y.XmlText|Y.XmlHook} ytype\n * @param {any|Array<any>} pnode\n */\nconst equalYTypePNode = (ytype, pnode) => {\n  if (\n    ytype instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && !(pnode instanceof Array) &&\n    matchNodeName(ytype, pnode)\n  ) {\n    const normalizedContent = normalizePNodeContent(pnode)\n    return ytype._length === normalizedContent.length &&\n      equalAttrs(ytype.getAttributes(), pnode.attrs) &&\n      ytype.toArray().every((ychild, i) =>\n        equalYTypePNode(ychild, normalizedContent[i])\n      )\n  }\n  return ytype instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText && pnode instanceof Array &&\n    equalYTextPText(ytype, pnode)\n}\n\n/**\n * @param {PModel.Node | Array<PModel.Node> | undefined} mapped\n * @param {PModel.Node | Array<PModel.Node>} pcontent\n */\nconst mappedIdentity = (mapped, pcontent) =>\n  mapped === pcontent ||\n  (mapped instanceof Array && pcontent instanceof Array &&\n    mapped.length === pcontent.length && mapped.every((a, i) =>\n    pcontent[i] === a\n  ))\n\n/**\n * @param {Y.XmlElement} ytype\n * @param {PModel.Node} pnode\n * @param {BindingMetadata} meta\n * @return {{ foundMappedChild: boolean, equalityFactor: number }}\n */\nconst computeChildEqualityFactor = (ytype, pnode, meta) => {\n  const yChildren = ytype.toArray()\n  const pChildren = normalizePNodeContent(pnode)\n  const pChildCnt = pChildren.length\n  const yChildCnt = yChildren.length\n  const minCnt = lib0_math__WEBPACK_IMPORTED_MODULE_11__.min(yChildCnt, pChildCnt)\n  let left = 0\n  let right = 0\n  let foundMappedChild = false\n  for (; left < minCnt; left++) {\n    const leftY = yChildren[left]\n    const leftP = pChildren[left]\n    if (mappedIdentity(meta.mapping.get(leftY), leftP)) {\n      foundMappedChild = true // definite (good) match!\n    } else if (!equalYTypePNode(leftY, leftP)) {\n      break\n    }\n  }\n  for (; left + right < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1]\n    const rightP = pChildren[pChildCnt - right - 1]\n    if (mappedIdentity(meta.mapping.get(rightY), rightP)) {\n      foundMappedChild = true\n    } else if (!equalYTypePNode(rightY, rightP)) {\n      break\n    }\n  }\n  return {\n    equalityFactor: left + right,\n    foundMappedChild\n  }\n}\n\n/**\n * @param {Y.Text} ytext\n */\nconst ytextTrans = (ytext) => {\n  let str = ''\n  /**\n   * @type {Y.Item|null}\n   */\n  let n = ytext._start\n  const nAttrs = {}\n  while (n !== null) {\n    if (!n.deleted) {\n      if (n.countable && n.content instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.ContentString) {\n        str += n.content.str\n      } else if (n.content instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.ContentFormat) {\n        nAttrs[n.content.key] = null\n      }\n    }\n    n = n.right\n  }\n  return {\n    str,\n    nAttrs\n  }\n}\n\n/**\n * @todo test this more\n *\n * @param {Y.Text} ytext\n * @param {Array<any>} ptexts\n * @param {BindingMetadata} meta\n */\nconst updateYText = (ytext, ptexts, meta) => {\n  meta.mapping.set(ytext, ptexts)\n  const { nAttrs, str } = ytextTrans(ytext)\n  const content = ptexts.map((p) => ({\n    insert: /** @type {any} */ (p).text,\n    attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks, meta))\n  }))\n  const { insert, remove, index } = (0,lib0_diff__WEBPACK_IMPORTED_MODULE_14__.simpleDiff)(\n    str,\n    content.map((c) => c.insert).join('')\n  )\n  ytext.delete(index, remove)\n  ytext.insert(index, insert)\n  ytext.applyDelta(\n    content.map((c) => ({ retain: c.insert.length, attributes: c.attributes }))\n  )\n}\n\nconst hashedMarkNameRegex = /(.*)(--[a-zA-Z0-9+/=]{8})$/\n/**\n * @param {string} attrName\n */\nconst yattr2markname = attrName => hashedMarkNameRegex.exec(attrName)?.[1] ?? attrName\n\n/**\n * @todo move this to markstoattributes\n *\n * @param {Object<string, any>} attrs\n * @param {import('prosemirror-model').Schema} schema\n */\nconst attributesToMarks = (attrs, schema) => {\n  /**\n   * @type {Array<import('prosemirror-model').Mark>}\n   */\n  const marks = []\n  for (const markName in attrs) {\n    // remove hashes if necessary\n    marks.push(schema.mark(yattr2markname(markName), attrs[markName]))\n  }\n  return marks\n}\n\n/**\n * @param {Array<import('prosemirror-model').Mark>} marks\n * @param {BindingMetadata} meta\n */\nconst marksToAttributes = (marks, meta) => {\n  const pattrs = {}\n  marks.forEach((mark) => {\n    if (mark.type.name !== 'ychange') {\n      const isOverlapping = lib0_map__WEBPACK_IMPORTED_MODULE_15__.setIfUndefined(meta.isOMark, mark.type, () => !mark.type.excludes(mark.type))\n      pattrs[isOverlapping ? `${mark.type.name}--${_utils_js__WEBPACK_IMPORTED_MODULE_16__.hashOfJSON(mark.toJSON())}` : mark.type.name] = mark.attrs\n    }\n  })\n  return pattrs\n}\n\n/**\n * Update a yDom node by syncing the current content of the prosemirror node.\n *\n * This is a y-prosemirror internal feature that you can use at your own risk.\n *\n * @private\n * @unstable\n *\n * @param {{transact: Function}} y\n * @param {Y.XmlFragment} yDomFragment\n * @param {any} pNode\n * @param {BindingMetadata} meta\n */\nconst updateYFragment = (y, yDomFragment, pNode, meta) => {\n  if (\n    yDomFragment instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement &&\n    yDomFragment.nodeName !== pNode.type.name\n  ) {\n    throw new Error('node name mismatch!')\n  }\n  meta.mapping.set(yDomFragment, pNode)\n  // update attributes\n  if (yDomFragment instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n    const yDomAttrs = yDomFragment.getAttributes()\n    const pAttrs = pNode.attrs\n    for (const key in pAttrs) {\n      if (pAttrs[key] !== null) {\n        if (yDomAttrs[key] !== pAttrs[key] && key !== 'ychange') {\n          yDomFragment.setAttribute(key, pAttrs[key])\n        }\n      } else {\n        yDomFragment.removeAttribute(key)\n      }\n    }\n    // remove all keys that are no longer in pAttrs\n    for (const key in yDomAttrs) {\n      if (pAttrs[key] === undefined) {\n        yDomFragment.removeAttribute(key)\n      }\n    }\n  }\n  // update children\n  const pChildren = normalizePNodeContent(pNode)\n  const pChildCnt = pChildren.length\n  const yChildren = yDomFragment.toArray()\n  const yChildCnt = yChildren.length\n  const minCnt = lib0_math__WEBPACK_IMPORTED_MODULE_11__.min(pChildCnt, yChildCnt)\n  let left = 0\n  let right = 0\n  // find number of matching elements from left\n  for (; left < minCnt; left++) {\n    const leftY = yChildren[left]\n    const leftP = pChildren[left]\n    if (!mappedIdentity(meta.mapping.get(leftY), leftP)) {\n      if (equalYTypePNode(leftY, leftP)) {\n        // update mapping\n        meta.mapping.set(leftY, leftP)\n      } else {\n        break\n      }\n    }\n  }\n  // find number of matching elements from right\n  for (; right + left < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1]\n    const rightP = pChildren[pChildCnt - right - 1]\n    if (!mappedIdentity(meta.mapping.get(rightY), rightP)) {\n      if (equalYTypePNode(rightY, rightP)) {\n        // update mapping\n        meta.mapping.set(rightY, rightP)\n      } else {\n        break\n      }\n    }\n  }\n  y.transact(() => {\n    // try to compare and update\n    while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {\n      const leftY = yChildren[left]\n      const leftP = pChildren[left]\n      const rightY = yChildren[yChildCnt - right - 1]\n      const rightP = pChildren[pChildCnt - right - 1]\n      if (leftY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText && leftP instanceof Array) {\n        if (!equalYTextPText(leftY, leftP)) {\n          updateYText(leftY, leftP, meta)\n        }\n        left += 1\n      } else {\n        let updateLeft = leftY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement &&\n          matchNodeName(leftY, leftP)\n        let updateRight = rightY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement &&\n          matchNodeName(rightY, rightP)\n        if (updateLeft && updateRight) {\n          // decide which which element to update\n          const equalityLeft = computeChildEqualityFactor(\n            /** @type {Y.XmlElement} */ (leftY),\n            /** @type {PModel.Node} */ (leftP),\n            meta\n          )\n          const equalityRight = computeChildEqualityFactor(\n            /** @type {Y.XmlElement} */ (rightY),\n            /** @type {PModel.Node} */ (rightP),\n            meta\n          )\n          if (\n            equalityLeft.foundMappedChild && !equalityRight.foundMappedChild\n          ) {\n            updateRight = false\n          } else if (\n            !equalityLeft.foundMappedChild && equalityRight.foundMappedChild\n          ) {\n            updateLeft = false\n          } else if (\n            equalityLeft.equalityFactor < equalityRight.equalityFactor\n          ) {\n            updateLeft = false\n          } else {\n            updateRight = false\n          }\n        }\n        if (updateLeft) {\n          updateYFragment(\n            y,\n            /** @type {Y.XmlFragment} */ (leftY),\n            /** @type {PModel.Node} */ (leftP),\n            meta\n          )\n          left += 1\n        } else if (updateRight) {\n          updateYFragment(\n            y,\n            /** @type {Y.XmlFragment} */ (rightY),\n            /** @type {PModel.Node} */ (rightP),\n            meta\n          )\n          right += 1\n        } else {\n          meta.mapping.delete(yDomFragment.get(left))\n          yDomFragment.delete(left, 1)\n          yDomFragment.insert(left, [\n            createTypeFromTextOrElementNode(leftP, meta)\n          ])\n          left += 1\n        }\n      }\n    }\n    const yDelLen = yChildCnt - left - right\n    if (\n      yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText\n    ) {\n      meta.mapping.delete(yChildren[0])\n      // Edge case handling https://github.com/yjs/y-prosemirror/issues/108\n      // Only delete the content of the Y.Text to retain remote changes on the same Y.Text object\n      yChildren[0].delete(0, yChildren[0].length)\n    } else if (yDelLen > 0) {\n      yDomFragment.slice(left, left + yDelLen).forEach(type => meta.mapping.delete(type))\n      yDomFragment.delete(left, yDelLen)\n    }\n    if (left + right < pChildCnt) {\n      const ins = []\n      for (let i = left; i < pChildCnt - right; i++) {\n        ins.push(createTypeFromTextOrElementNode(pChildren[i], meta))\n      }\n      yDomFragment.insert(left, ins)\n    }\n  }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n}\n\n/**\n * @function\n * @param {Y.XmlElement} yElement\n * @param {any} pNode Prosemirror Node\n */\nconst matchNodeName = (yElement, pNode) =>\n  !(pNode instanceof Array) && yElement.nodeName === pNode.type.name\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9zeW5jLXBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFd0M7QUFDRztBQUM0QyxDQUFDO0FBQ3ZEO0FBQ0k7QUFDTjtBQUNPO0FBQ0g7QUFDdUI7QUFDbEM7QUFJTjtBQUNtQjtBQUNVO0FBQ2hCO0FBQ1k7QUFDWjtBQUNLOztBQUVwQztBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG9EQUFvRDtBQUNsRTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQSxPQUFPLDBDQUFXOztBQUVsQjtBQUNBO0FBQ0EsYUFBYSw0REFBNEQ7QUFDekU7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGlCQUFpQjtBQUMvQixjQUFjLHNCQUFzQjtBQUNwQyxjQUFjLDBCQUEwQjtBQUN4QyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLFVBQVU7QUFDeEI7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx5QkFBeUIscUNBQXFDOztBQUU5RDtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQVk7QUFDdkM7QUFDQSxvQkFBb0IsVUFBVTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcs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QUFXLGNBQWM7QUFDekIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FyeWFuZ295YWwvcmVhbC10aW1lLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy9wbHVnaW5zL3N5bmMtcGx1Z2luLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBiaW5kaW5ncy9wcm9zZW1pcnJvclxuICovXG5cbmltcG9ydCB7IGNyZWF0ZU11dGV4IH0gZnJvbSAnbGliMC9tdXRleCdcbmltcG9ydCAqIGFzIFBNb2RlbCBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCdcbmltcG9ydCB7IEFsbFNlbGVjdGlvbiwgUGx1Z2luLCBUZXh0U2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uIH0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0ICogYXMgb2JqZWN0IGZyb20gJ2xpYjAvb2JqZWN0J1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJ2xpYjAvc2V0J1xuaW1wb3J0IHsgc2ltcGxlRGlmZiB9IGZyb20gJ2xpYjAvZGlmZidcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgeyB5U3luY1BsdWdpbktleSwgeVVuZG9QbHVnaW5LZXkgfSBmcm9tICcuL2tleXMuanMnXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCB7XG4gIGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24sXG4gIHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb25cbn0gZnJvbSAnLi4vbGliLmpzJ1xuaW1wb3J0ICogYXMgcmFuZG9tIGZyb20gJ2xpYjAvcmFuZG9tJ1xuaW1wb3J0ICogYXMgZW52aXJvbm1lbnQgZnJvbSAnbGliMC9lbnZpcm9ubWVudCdcbmltcG9ydCAqIGFzIGRvbSBmcm9tICdsaWIwL2RvbSdcbmltcG9ydCAqIGFzIGV2ZW50bG9vcCBmcm9tICdsaWIwL2V2ZW50bG9vcCdcbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJpbmRpbmdNZXRhZGF0YVxuICogQHByb3BlcnR5IHtQcm9zZW1pcnJvck1hcHBpbmd9IEJpbmRpbmdNZXRhZGF0YS5tYXBwaW5nXG4gKiBAcHJvcGVydHkge01hcDxpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuTWFya1R5cGUsIGJvb2xlYW4+fSBCaW5kaW5nTWV0YWRhdGEuaXNPTWFyayAtIGlzIG92ZXJsYXBwaW5nIG1hcmtcbiAqL1xuXG4vKipcbiAqIEByZXR1cm4ge0JpbmRpbmdNZXRhZGF0YX1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVtcHR5TWV0YSA9ICgpID0+ICh7XG4gIG1hcHBpbmc6IG5ldyBNYXAoKSxcbiAgaXNPTWFyazogbmV3IE1hcCgpXG59KVxuXG4vKipcbiAqIEBwYXJhbSB7WS5JdGVtfSBpdGVtXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmlzaWJsZSA9IChpdGVtLCBzbmFwc2hvdCkgPT5cbiAgc25hcHNob3QgPT09IHVuZGVmaW5lZFxuICAgID8gIWl0ZW0uZGVsZXRlZFxuICAgIDogKHNuYXBzaG90LnN2LmhhcyhpdGVtLmlkLmNsaWVudCkgJiYgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAoc25hcHNob3Quc3YuZ2V0KGl0ZW0uaWQuY2xpZW50KSkgPiBpdGVtLmlkLmNsb2NrICYmXG4gICAgICAhWS5pc0RlbGV0ZWQoc25hcHNob3QuZHMsIGl0ZW0uaWQpKVxuXG4vKipcbiAqIEVpdGhlciBhIG5vZGUgaWYgdHlwZSBpcyBZWG1sRWxlbWVudCBvciBhbiBBcnJheSBvZiB0ZXh0IG5vZGVzIGlmIFlYbWxUZXh0XG4gKiBAdHlwZWRlZiB7TWFwPFkuQWJzdHJhY3RUeXBlPGFueT4sIFBNb2RlbC5Ob2RlIHwgQXJyYXk8UE1vZGVsLk5vZGU+Pn0gUHJvc2VtaXJyb3JNYXBwaW5nXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb2xvckRlZlxuICogQHByb3BlcnR5IHtzdHJpbmd9IENvbG9yRGVmLmxpZ2h0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gQ29sb3JEZWYuZGFya1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gWVN5bmNPcHRzXG4gKiBAcHJvcGVydHkge0FycmF5PENvbG9yRGVmPn0gW1lTeW5jT3B0cy5jb2xvcnNdXG4gKiBAcHJvcGVydHkge01hcDxzdHJpbmcsQ29sb3JEZWY+fSBbWVN5bmNPcHRzLmNvbG9yTWFwcGluZ11cbiAqIEBwcm9wZXJ0eSB7WS5QZXJtYW5lbnRVc2VyRGF0YXxudWxsfSBbWVN5bmNPcHRzLnBlcm1hbmVudFVzZXJEYXRhXVxuICogQHByb3BlcnR5IHtQcm9zZW1pcnJvck1hcHBpbmd9IFtZU3luY09wdHMubWFwcGluZ11cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtZU3luY09wdHMub25GaXJzdFJlbmRlcl0gRmlyZWQgd2hlbiB0aGUgY29udGVudCBmcm9tIFlqcyBpcyBpbml0aWFsbHkgcmVuZGVyZWQgdG8gUHJvc2VNaXJyb3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxDb2xvckRlZj59XG4gKi9cbmNvbnN0IGRlZmF1bHRDb2xvcnMgPSBbeyBsaWdodDogJyNlY2Q0NDQzMycsIGRhcms6ICcjZWNkNDQ0JyB9XVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxDb2xvckRlZj59IGNvbG9yTWFwcGluZ1xuICogQHBhcmFtIHtBcnJheTxDb2xvckRlZj59IGNvbG9yc1xuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJcbiAqIEByZXR1cm4ge0NvbG9yRGVmfVxuICovXG5jb25zdCBnZXRVc2VyQ29sb3IgPSAoY29sb3JNYXBwaW5nLCBjb2xvcnMsIHVzZXIpID0+IHtcbiAgLy8gQHRvZG8gZG8gbm90IGhpdCB0aGUgc2FtZSBjb2xvciB0d2ljZSBpZiBwb3NzaWJsZVxuICBpZiAoIWNvbG9yTWFwcGluZy5oYXModXNlcikpIHtcbiAgICBpZiAoY29sb3JNYXBwaW5nLnNpemUgPCBjb2xvcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB1c2VkQ29sb3JzID0gc2V0LmNyZWF0ZSgpXG4gICAgICBjb2xvck1hcHBpbmcuZm9yRWFjaCgoY29sb3IpID0+IHVzZWRDb2xvcnMuYWRkKGNvbG9yKSlcbiAgICAgIGNvbG9ycyA9IGNvbG9ycy5maWx0ZXIoKGNvbG9yKSA9PiAhdXNlZENvbG9ycy5oYXMoY29sb3IpKVxuICAgIH1cbiAgICBjb2xvck1hcHBpbmcuc2V0KHVzZXIsIHJhbmRvbS5vbmVPZihjb2xvcnMpKVxuICB9XG4gIHJldHVybiAvKiogQHR5cGUge0NvbG9yRGVmfSAqLyAoY29sb3JNYXBwaW5nLmdldCh1c2VyKSlcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBsaXN0ZW5zIHRvIGNoYW5nZXMgaW4gcHJvc2VtaXJyb3IgdmlldyBhbmQga2VlcHMgeVhtbFN0YXRlIGFuZCB2aWV3IGluIHN5bmMuXG4gKlxuICogVGhpcyBwbHVnaW4gYWxzbyBrZWVwcyByZWZlcmVuY2VzIHRvIHRoZSB0eXBlIGFuZCB0aGUgc2hhcmVkIGRvY3VtZW50IHNvIG90aGVyIHBsdWdpbnMgY2FuIGFjY2VzcyBpdC5cbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geVhtbEZyYWdtZW50XG4gKiBAcGFyYW0ge1lTeW5jT3B0c30gb3B0c1xuICogQHJldHVybiB7YW55fSBSZXR1cm5zIGEgcHJvc2VtaXJyb3IgcGx1Z2luIHRoYXQgYmluZHMgdG8gdGhpcyB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCB5U3luY1BsdWdpbiA9ICh5WG1sRnJhZ21lbnQsIHtcbiAgY29sb3JzID0gZGVmYXVsdENvbG9ycyxcbiAgY29sb3JNYXBwaW5nID0gbmV3IE1hcCgpLFxuICBwZXJtYW5lbnRVc2VyRGF0YSA9IG51bGwsXG4gIG9uRmlyc3RSZW5kZXIgPSAoKSA9PiB7fSxcbiAgbWFwcGluZ1xufSA9IHt9KSA9PiB7XG4gIGxldCBpbml0aWFsQ29udGVudENoYW5nZWQgPSBmYWxzZVxuICBjb25zdCBiaW5kaW5nID0gbmV3IFByb3NlbWlycm9yQmluZGluZyh5WG1sRnJhZ21lbnQsIG1hcHBpbmcpXG4gIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgIHByb3BzOiB7XG4gICAgICBlZGl0YWJsZTogKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bmNTdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICAgICAgICByZXR1cm4gc3luY1N0YXRlLnNuYXBzaG90ID09IG51bGwgJiYgc3luY1N0YXRlLnByZXZTbmFwc2hvdCA9PSBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBrZXk6IHlTeW5jUGx1Z2luS2V5LFxuICAgIHN0YXRlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICAgKi9cbiAgICAgIGluaXQ6IChfaW5pdGFyZ3MsIF9zdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHlYbWxGcmFnbWVudCxcbiAgICAgICAgICBkb2M6IHlYbWxGcmFnbWVudC5kb2MsXG4gICAgICAgICAgYmluZGluZyxcbiAgICAgICAgICBzbmFwc2hvdDogbnVsbCxcbiAgICAgICAgICBwcmV2U25hcHNob3Q6IG51bGwsXG4gICAgICAgICAgaXNDaGFuZ2VPcmlnaW46IGZhbHNlLFxuICAgICAgICAgIGlzVW5kb1JlZG9PcGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgIGFkZFRvSGlzdG9yeTogdHJ1ZSxcbiAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgY29sb3JNYXBwaW5nLFxuICAgICAgICAgIHBlcm1hbmVudFVzZXJEYXRhXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhcHBseTogKHRyLCBwbHVnaW5TdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSB0ci5nZXRNZXRhKHlTeW5jUGx1Z2luS2V5KVxuICAgICAgICBpZiAoY2hhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwbHVnaW5TdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBsdWdpblN0YXRlKVxuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNoYW5nZSkge1xuICAgICAgICAgICAgcGx1Z2luU3RhdGVba2V5XSA9IGNoYW5nZVtrZXldXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBsdWdpblN0YXRlLmFkZFRvSGlzdG9yeSA9IHRyLmdldE1ldGEoJ2FkZFRvSGlzdG9yeScpICE9PSBmYWxzZVxuICAgICAgICAvLyBhbHdheXMgc2V0IGlzQ2hhbmdlT3JpZ2luLiBJZiB1bmRlZmluZWQsIHRoaXMgaXMgbm90IGNoYW5nZSBvcmlnaW4uXG4gICAgICAgIHBsdWdpblN0YXRlLmlzQ2hhbmdlT3JpZ2luID0gY2hhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAhIWNoYW5nZS5pc0NoYW5nZU9yaWdpblxuICAgICAgICBwbHVnaW5TdGF0ZS5pc1VuZG9SZWRvT3BlcmF0aW9uID0gY2hhbmdlICE9PSB1bmRlZmluZWQgJiYgISFjaGFuZ2UuaXNDaGFuZ2VPcmlnaW4gJiYgISFjaGFuZ2UuaXNVbmRvUmVkb09wZXJhdGlvblxuICAgICAgICBpZiAoYmluZGluZy5wcm9zZW1pcnJvclZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjaGFuZ2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKGNoYW5nZS5zbmFwc2hvdCAhPSBudWxsIHx8IGNoYW5nZS5wcmV2U25hcHNob3QgIT0gbnVsbClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIHNuYXBzaG90IGNoYW5nZWQsIHJlcmVuZGVyIG5leHRcbiAgICAgICAgICAgIGV2ZW50bG9vcC50aW1lb3V0KDAsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGJpbmRpbmcucHJvc2VtaXJyb3JWaWV3ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2hhbmdlLnJlc3RvcmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuX3JlbmRlclNuYXBzaG90KFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnByZXZTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgIHBsdWdpblN0YXRlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuX3JlbmRlclNuYXBzaG90KFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgcGx1Z2luU3RhdGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdG8gY3VycmVudCBwcm9zZW1pcnJvciBzdGF0ZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwbHVnaW5TdGF0ZS5yZXN0b3JlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpblN0YXRlLnNuYXBzaG90XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpblN0YXRlLnByZXZTbmFwc2hvdFxuICAgICAgICAgICAgICAgIGJpbmRpbmcubXV4KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGJpbmRpbmcuX3Byb3NlbWlycm9yQ2hhbmdlZChcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsdWdpblN0YXRlXG4gICAgICB9XG4gICAgfSxcbiAgICB2aWV3OiAodmlldykgPT4ge1xuICAgICAgYmluZGluZy5pbml0Vmlldyh2aWV3KVxuICAgICAgaWYgKG1hcHBpbmcgPT0gbnVsbCkge1xuICAgICAgICAvLyBmb3JjZSByZXJlbmRlciB0byB1cGRhdGUgdGhlIGJpbmRpbmdzIG1hcHBpbmdcbiAgICAgICAgYmluZGluZy5fZm9yY2VSZXJlbmRlcigpXG4gICAgICB9XG4gICAgICBvbkZpcnN0UmVuZGVyKClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBsdWdpblN0YXRlID0gcGx1Z2luLmdldFN0YXRlKHZpZXcuc3RhdGUpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGx1Z2luU3RhdGUuc25hcHNob3QgPT0gbnVsbCAmJiBwbHVnaW5TdGF0ZS5wcmV2U25hcHNob3QgPT0gbnVsbFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAvLyBJZiB0aGUgY29udGVudCBkb2Vzbid0IGNoYW5nZSBpbml0aWFsbHksIHdlIGRvbid0IHJlbmRlciBhbnl0aGluZyB0byBZanNcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvbnRlbnQgd2FzIGNsZWFyZWQgYnkgYSB1c2VyIGFjdGlvbiwgd2Ugd2FudCB0byBjYXRjaCB0aGUgY2hhbmdlIGFuZFxuICAgICAgICAgICAgICAvLyByZXByZXNlbnQgaXQgaW4gWWpzXG4gICAgICAgICAgICAgIGluaXRpYWxDb250ZW50Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICB2aWV3LnN0YXRlLmRvYy5jb250ZW50LmZpbmREaWZmU3RhcnQoXG4gICAgICAgICAgICAgICAgdmlldy5zdGF0ZS5kb2MudHlwZS5jcmVhdGVBbmRGaWxsKCkuY29udGVudFxuICAgICAgICAgICAgICApICE9PSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaW5pdGlhbENvbnRlbnRDaGFuZ2VkID0gdHJ1ZVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuYWRkVG9IaXN0b3J5ID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICFwbHVnaW5TdGF0ZS5pc0NoYW5nZU9yaWdpblxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5VW5kb1BsdWdpblN0YXRlID0geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSlcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7WS5VbmRvTWFuYWdlcn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCB1bSA9IHlVbmRvUGx1Z2luU3RhdGUgJiYgeVVuZG9QbHVnaW5TdGF0ZS51bmRvTWFuYWdlclxuICAgICAgICAgICAgICAgIGlmICh1bSkge1xuICAgICAgICAgICAgICAgICAgdW0uc3RvcENhcHR1cmluZygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJpbmRpbmcubXV4KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge1kuRG9jfSAqLyAocGx1Z2luU3RhdGUuZG9jKS50cmFuc2FjdCgodHIpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyLm1ldGEuc2V0KCdhZGRUb0hpc3RvcnknLCBwbHVnaW5TdGF0ZS5hZGRUb0hpc3RvcnkpXG4gICAgICAgICAgICAgICAgICBiaW5kaW5nLl9wcm9zZW1pcnJvckNoYW5nZWQodmlldy5zdGF0ZS5kb2MpXG4gICAgICAgICAgICAgICAgfSwgeVN5bmNQbHVnaW5LZXkpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgYmluZGluZy5kZXN0cm95KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHBsdWdpblxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCdwcm9zZW1pcnJvci1zdGF0ZScpLlRyYW5zYWN0aW9ufSB0clxuICogQHBhcmFtIHtSZXR1cm5UeXBlPHR5cGVvZiBnZXRSZWxhdGl2ZVNlbGVjdGlvbj59IHJlbFNlbFxuICogQHBhcmFtIHtQcm9zZW1pcnJvckJpbmRpbmd9IGJpbmRpbmdcbiAqL1xuY29uc3QgcmVzdG9yZVJlbGF0aXZlU2VsZWN0aW9uID0gKHRyLCByZWxTZWwsIGJpbmRpbmcpID0+IHtcbiAgaWYgKHJlbFNlbCAhPT0gbnVsbCAmJiByZWxTZWwuYW5jaG9yICE9PSBudWxsICYmIHJlbFNlbC5oZWFkICE9PSBudWxsKSB7XG4gICAgaWYgKHJlbFNlbC50eXBlID09PSAnYWxsJykge1xuICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBBbGxTZWxlY3Rpb24odHIuZG9jKSlcbiAgICB9IGVsc2UgaWYgKHJlbFNlbC50eXBlID09PSAnbm9kZScpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oXG4gICAgICAgIGJpbmRpbmcuZG9jLFxuICAgICAgICBiaW5kaW5nLnR5cGUsXG4gICAgICAgIHJlbFNlbC5hbmNob3IsXG4gICAgICAgIGJpbmRpbmcubWFwcGluZ1xuICAgICAgKVxuICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgYW5jaG9yKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYW5jaG9yID0gcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihcbiAgICAgICAgYmluZGluZy5kb2MsXG4gICAgICAgIGJpbmRpbmcudHlwZSxcbiAgICAgICAgcmVsU2VsLmFuY2hvcixcbiAgICAgICAgYmluZGluZy5tYXBwaW5nXG4gICAgICApXG4gICAgICBjb25zdCBoZWFkID0gcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihcbiAgICAgICAgYmluZGluZy5kb2MsXG4gICAgICAgIGJpbmRpbmcudHlwZSxcbiAgICAgICAgcmVsU2VsLmhlYWQsXG4gICAgICAgIGJpbmRpbmcubWFwcGluZ1xuICAgICAgKVxuICAgICAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBoZWFkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHNlbCA9IFRleHRTZWxlY3Rpb24uYmV0d2Vlbih0ci5kb2MucmVzb2x2ZShhbmNob3IpLCB0ci5kb2MucmVzb2x2ZShoZWFkKSlcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yQmluZGluZ30gcG1iaW5kaW5nXG4gKiBAcGFyYW0ge2ltcG9ydCgncHJvc2VtaXJyb3Itc3RhdGUnKS5FZGl0b3JTdGF0ZX0gc3RhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFJlbGF0aXZlU2VsZWN0aW9uID0gKHBtYmluZGluZywgc3RhdGUpID0+ICh7XG4gIHR5cGU6IC8qKiBAdHlwZSB7YW55fSAqLyAoc3RhdGUuc2VsZWN0aW9uKS5qc29uSUQsXG4gIGFuY2hvcjogYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbihcbiAgICBzdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLFxuICAgIHBtYmluZGluZy50eXBlLFxuICAgIHBtYmluZGluZy5tYXBwaW5nXG4gICksXG4gIGhlYWQ6IGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24oXG4gICAgc3RhdGUuc2VsZWN0aW9uLmhlYWQsXG4gICAgcG1iaW5kaW5nLnR5cGUsXG4gICAgcG1iaW5kaW5nLm1hcHBpbmdcbiAgKVxufSlcblxuLyoqXG4gKiBCaW5kaW5nIGZvciBwcm9zZW1pcnJvci5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9zZW1pcnJvckJpbmRpbmcge1xuICAvKipcbiAgICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB5WG1sRnJhZ21lbnQgVGhlIGJpbmQgc291cmNlXG4gICAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeVhtbEZyYWdtZW50LCBtYXBwaW5nID0gbmV3IE1hcCgpKSB7XG4gICAgdGhpcy50eXBlID0geVhtbEZyYWdtZW50XG4gICAgLyoqXG4gICAgICogdGhpcyB3aWxsIGJlIHNldCBvbmNlIHRoZSB2aWV3IGlzIGNyZWF0ZWRcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3ID0gbnVsbFxuICAgIHRoaXMubXV4ID0gY3JlYXRlTXV0ZXgoKVxuICAgIHRoaXMubWFwcGluZyA9IG1hcHBpbmdcbiAgICAvKipcbiAgICAgKiBJcyBvdmVybGFwcGluZyBtYXJrIC0gaS5lLiBtYXJrIGRvZXMgbm90IGV4Y2x1ZGUgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHR5cGUge01hcDxpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuTWFya1R5cGUsIGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHRoaXMuaXNPTWFyayA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX29ic2VydmVGdW5jdGlvbiA9IHRoaXMuX3R5cGVDaGFuZ2VkLmJpbmQodGhpcylcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7WS5Eb2N9XG4gICAgICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuZG9jID0geVhtbEZyYWdtZW50LmRvY1xuICAgIC8qKlxuICAgICAqIGN1cnJlbnQgc2VsZWN0aW9uIGFzIHJlbGF0aXZlIHBvc2l0aW9ucyBpbiB0aGUgWWpzIG1vZGVsXG4gICAgICovXG4gICAgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiA9IG51bGxcbiAgICB0aGlzLmJlZm9yZUFsbFRyYW5zYWN0aW9ucyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID09PSBudWxsICYmIHRoaXMucHJvc2VtaXJyb3JWaWV3ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiA9IGdldFJlbGF0aXZlU2VsZWN0aW9uKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGVcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFmdGVyQWxsVHJhbnNhY3Rpb25zID0gKCkgPT4ge1xuICAgICAgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiA9IG51bGxcbiAgICB9XG4gICAgdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRyYW5zYWN0aW9uIGZvciBjaGFuZ2luZyB0aGUgcHJvc2VtaXJyb3Igc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXQgX3RyICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUudHIuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpXG4gIH1cblxuICBfaXNMb2NhbEN1cnNvckluVmlldyAoKSB7XG4gICAgaWYgKCF0aGlzLnByb3NlbWlycm9yVmlldy5oYXNGb2N1cygpKSByZXR1cm4gZmFsc2VcbiAgICBpZiAoZW52aXJvbm1lbnQuaXNCcm93c2VyICYmIHRoaXMuX2RvbVNlbGVjdGlvbkluVmlldyA9PT0gbnVsbCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkb21TZWxlY3Rpb25JblZpZXcgYW5kIGNsZWFyIGJ5IG5leHQgdGljayBhZnRlciBhbGwgZXZlbnRzIGFyZSBmaW5pc2hlZFxuICAgICAgZXZlbnRsb29wLnRpbWVvdXQoMCwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9kb21TZWxlY3Rpb25JblZpZXcgPSBudWxsXG4gICAgICB9KVxuICAgICAgdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3ID0gdGhpcy5faXNEb21TZWxlY3Rpb25JblZpZXcoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3XG4gIH1cblxuICBfaXNEb21TZWxlY3Rpb25JblZpZXcgKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMucHJvc2VtaXJyb3JWaWV3Ll9yb290LmdldFNlbGVjdGlvbigpXG5cbiAgICBpZiAoc2VsZWN0aW9uID09IG51bGwgfHwgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT0gbnVsbCkgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCByYW5nZSA9IHRoaXMucHJvc2VtaXJyb3JWaWV3Ll9yb290LmNyZWF0ZVJhbmdlKClcbiAgICByYW5nZS5zZXRTdGFydChzZWxlY3Rpb24uYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvck9mZnNldClcbiAgICByYW5nZS5zZXRFbmQoc2VsZWN0aW9uLmZvY3VzTm9kZSwgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KVxuXG4gICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGFuIGVkZ2VjYXNlIHdoZXJlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB3aWxsXG4gICAgLy8gcmV0dXJuIHplcm8gdmFsdWVzIGlmIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkIGF0IHRoZSBzdGFydCBvZiBhIG5ld2xpbmVcbiAgICAvLyBzZWUgcmVmZXJlbmNlIGhlcmU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81OTc4MDk1NFxuICAgIGNvbnN0IHJlY3RzID0gcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKVxuICAgIGlmIChyZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIHByb2JhYmx5IGJ1Z2d5IG5ld2xpbmUgYmVoYXZpb3IsIGV4cGxpY2l0bHkgc2VsZWN0IHRoZSBub2RlIGNvbnRlbnRzXG4gICAgICBpZiAocmFuZ2Uuc3RhcnRDb250YWluZXIgJiYgcmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhyYW5nZS5zdGFydENvbnRhaW5lcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBib3VuZGluZyA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZG9tLmRvYy5kb2N1bWVudEVsZW1lbnRcblxuICAgIHJldHVybiBib3VuZGluZy5ib3R0b20gPj0gMCAmJiBib3VuZGluZy5yaWdodCA+PSAwICYmXG4gICAgICBib3VuZGluZy5sZWZ0IDw9XG4gICAgICAgICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgMCkgJiZcbiAgICAgIGJvdW5kaW5nLnRvcCA8PSAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuU25hcHNob3R9IHNuYXBzaG90XG4gICAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gcHJldlNuYXBzaG90XG4gICAqL1xuICByZW5kZXJTbmFwc2hvdCAoc25hcHNob3QsIHByZXZTbmFwc2hvdCkge1xuICAgIGlmICghcHJldlNuYXBzaG90KSB7XG4gICAgICBwcmV2U25hcHNob3QgPSBZLmNyZWF0ZVNuYXBzaG90KFkuY3JlYXRlRGVsZXRlU2V0KCksIG5ldyBNYXAoKSlcbiAgICB9XG4gICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2goXG4gICAgICB0aGlzLl90ci5zZXRNZXRhKHlTeW5jUGx1Z2luS2V5LCB7IHNuYXBzaG90LCBwcmV2U25hcHNob3QgfSlcbiAgICApXG4gIH1cblxuICB1bnJlbmRlclNuYXBzaG90ICgpIHtcbiAgICB0aGlzLm1hcHBpbmcuY2xlYXIoKVxuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50Q29udGVudCA9IHRoaXMudHlwZS50b0FycmF5KCkubWFwKCh0KSA9PlxuICAgICAgICBjcmVhdGVOb2RlRnJvbVlFbGVtZW50KFxuICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50fSAqLyAodCksXG4gICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuc2NoZW1hLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKVxuICAgICAgKS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB0ciA9IHRoaXMuX3RyLnJlcGxhY2UoXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsXG4gICAgICAgIG5ldyBQTW9kZWwuU2xpY2UoUE1vZGVsLkZyYWdtZW50LmZyb20oZnJhZ21lbnRDb250ZW50KSwgMCwgMClcbiAgICAgIClcbiAgICAgIHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgc25hcHNob3Q6IG51bGwsIHByZXZTbmFwc2hvdDogbnVsbCB9KVxuICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2godHIpXG4gICAgfSlcbiAgfVxuXG4gIF9mb3JjZVJlcmVuZGVyICgpIHtcbiAgICB0aGlzLm1hcHBpbmcuY2xlYXIoKVxuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBmb3JjZWQgcmVyZW5kZXIsIHRoaXMgbWlnaHQgbmVpdGhlciBoYXBwZW4gYXMgYSBwbSBjaGFuZ2Ugbm9yIHdpdGhpbiBhIFlqc1xuICAgICAgLy8gdHJhbnNhY3Rpb24uIFRoZW4gdGhlIFwiYmVmb3JlIHNlbGVjdGlvblwiIGRvZXNuJ3QgZXhpc3QuIEluIHRoaXMgY2FzZSwgd2UgbmVlZCB0byBjcmVhdGUgYVxuICAgICAgLy8gcmVsYXRpdmUgcG9zaXRpb24gYmVmb3JlIHJlcGxhY2luZyBjb250ZW50LiBGaXhlcyAjMTI2XG4gICAgICBjb25zdCBzZWwgPSB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uICE9PSBudWxsID8gbnVsbCA6IHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLnNlbGVjdGlvblxuICAgICAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0gdGhpcy50eXBlLnRvQXJyYXkoKS5tYXAoKHQpID0+XG4gICAgICAgIGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQoXG4gICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnR9ICovICh0KSxcbiAgICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5zY2hlbWEsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApXG4gICAgICApLmZpbHRlcigobikgPT4gbiAhPT0gbnVsbClcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHRyID0gdGhpcy5fdHIucmVwbGFjZShcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSxcbiAgICAgICAgbmV3IFBNb2RlbC5TbGljZShQTW9kZWwuRnJhZ21lbnQuZnJvbShmcmFnbWVudENvbnRlbnQpLCAwLCAwKVxuICAgICAgKVxuICAgICAgaWYgKHNlbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIFByb3NlbWlycm9yIGRvY3VtZW50IHdlIGp1c3QgY3JlYXRlZCBmcm9tIHRoaXMudHlwZSBpc1xuICAgICAgICAgKiBzbWFsbGVyIHRoYW4gdGhlIHByZXZpb3VzIGRvY3VtZW50LCB0aGUgc2VsZWN0aW9uIG1pZ2h0IGJlXG4gICAgICAgICAqIG91dCBvZiBib3VuZCwgd2hpY2ggd291bGQgbWFrZSBQcm9zZW1pcnJvciB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNsYW1wZWRBbmNob3IgPSBtYXRoLm1pbihtYXRoLm1heChzZWwuYW5jaG9yLCAwKSwgdHIuZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgY29uc3QgY2xhbXBlZEhlYWQgPSBtYXRoLm1pbihtYXRoLm1heChzZWwuaGVhZCwgMCksIHRyLmRvYy5jb250ZW50LnNpemUpXG5cbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgY2xhbXBlZEFuY2hvciwgY2xhbXBlZEhlYWQpKVxuICAgICAgfVxuICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2goXG4gICAgICAgIHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgaXNDaGFuZ2VPcmlnaW46IHRydWUsIGJpbmRpbmc6IHRoaXMgfSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5TbmFwc2hvdHxVaW50OEFycmF5fSBzbmFwc2hvdFxuICAgKiBAcGFyYW0ge1kuU25hcHNob3R8VWludDhBcnJheX0gcHJldlNuYXBzaG90XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5TdGF0ZVxuICAgKi9cbiAgX3JlbmRlclNuYXBzaG90IChzbmFwc2hvdCwgcHJldlNuYXBzaG90LCBwbHVnaW5TdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBkb2N1bWVudCB0aGF0IGNvbnRhaW5zIHRoZSBmdWxsIGhpc3Rvcnkgb2YgdGhpcyBkb2N1bWVudC5cbiAgICAgKiBAdHlwZSB7WS5Eb2N9XG4gICAgICovXG4gICAgbGV0IGhpc3RvcnlEb2MgPSB0aGlzLmRvY1xuICAgIGxldCBoaXN0b3J5VHlwZSA9IHRoaXMudHlwZVxuICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgIHNuYXBzaG90ID0gWS5zbmFwc2hvdCh0aGlzLmRvYylcbiAgICB9XG4gICAgaWYgKHNuYXBzaG90IGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBwcmV2U25hcHNob3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBpZiAoIShzbmFwc2hvdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8ICEocHJldlNuYXBzaG90IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgLy8gZXhwZWN0ZWQgYm90aCBzbmFwc2hvdHMgdG8gYmUgdjIgdXBkYXRlc1xuICAgICAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgICB9XG4gICAgICBoaXN0b3J5RG9jID0gbmV3IFkuRG9jKHsgZ2M6IGZhbHNlIH0pXG4gICAgICBZLmFwcGx5VXBkYXRlVjIoaGlzdG9yeURvYywgcHJldlNuYXBzaG90KVxuICAgICAgcHJldlNuYXBzaG90ID0gWS5zbmFwc2hvdChoaXN0b3J5RG9jKVxuICAgICAgWS5hcHBseVVwZGF0ZVYyKGhpc3RvcnlEb2MsIHNuYXBzaG90KVxuICAgICAgc25hcHNob3QgPSBZLnNuYXBzaG90KGhpc3RvcnlEb2MpXG4gICAgICBpZiAoaGlzdG9yeVR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGlzIGEgcm9vdCB0eXBlLCB3ZSBuZWVkIHRvIGZpbmQgdGhlIHJvb3Qga2V5IGluIHRoZSBpbml0aWFsIGRvY3VtZW50XG4gICAgICAgICAqIGFuZCB1c2UgaXQgdG8gZ2V0IHRoZSBoaXN0b3J5IHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByb290S2V5ID0gQXJyYXkuZnJvbSh0aGlzLmRvYy5zaGFyZS5rZXlzKCkpLmZpbmQoXG4gICAgICAgICAgKGtleSkgPT4gdGhpcy5kb2Muc2hhcmUuZ2V0KGtleSkgPT09IHRoaXMudHlwZVxuICAgICAgICApXG4gICAgICAgIGhpc3RvcnlUeXBlID0gaGlzdG9yeURvYy5nZXRYbWxGcmFnbWVudChyb290S2V5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGl0IGlzIGEgc3ViIHR5cGUsIHdlIHVzZSB0aGUgaXRlbSBpZCB0byBmaW5kIHRoZSBoaXN0b3J5IHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBoaXN0b3J5U3RydWN0cyA9XG4gICAgICAgICAgaGlzdG9yeURvYy5zdG9yZS5jbGllbnRzLmdldChoaXN0b3J5VHlwZS5faXRlbS5pZC5jbGllbnQpID8/IFtdXG4gICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IFkuZmluZEluZGV4U1MoXG4gICAgICAgICAgaGlzdG9yeVN0cnVjdHMsXG4gICAgICAgICAgaGlzdG9yeVR5cGUuX2l0ZW0uaWQuY2xvY2tcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBpdGVtID0gLyoqIEB0eXBlIHtZLkl0ZW19ICovIChoaXN0b3J5U3RydWN0c1tpdGVtSW5kZXhdKVxuICAgICAgICBjb25zdCBjb250ZW50ID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAoaXRlbS5jb250ZW50KVxuICAgICAgICBoaXN0b3J5VHlwZSA9IC8qKiBAdHlwZSB7WS5YbWxGcmFnbWVudH0gKi8gKGNvbnRlbnQudHlwZSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY2xlYXIgbWFwcGluZyBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byByZXJlbmRlclxuICAgIHRoaXMubWFwcGluZy5jbGVhcigpXG4gICAgdGhpcy5tdXgoKCkgPT4ge1xuICAgICAgaGlzdG9yeURvYy50cmFuc2FjdCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgLy8gYmVmb3JlIHJlbmRlcmluZywgd2UgYXJlIGdvaW5nIHRvIHNhbml0aXplIG9wcyBhbmQgc3BsaXQgZGVsZXRlZCBvcHNcbiAgICAgICAgLy8gaWYgdGhleSB3ZXJlIGRlbGV0ZWQgYnkgc2VwZXJhdGUgdXNlcnMuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7WS5QZXJtYW5lbnRVc2VyRGF0YX1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHB1ZCA9IHBsdWdpblN0YXRlLnBlcm1hbmVudFVzZXJEYXRhXG4gICAgICAgIGlmIChwdWQpIHtcbiAgICAgICAgICBwdWQuZHNzLmZvckVhY2goKGRzKSA9PiB7XG4gICAgICAgICAgICBZLml0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgZHMsIChfaXRlbSkgPT4ge30pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHsncmVtb3ZlZCd8J2FkZGVkJ30gdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1kuSUR9IGlkXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb21wdXRlWUNoYW5nZSA9ICh0eXBlLCBpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHVzZXIgPSB0eXBlID09PSAnYWRkZWQnXG4gICAgICAgICAgICA/IHB1ZC5nZXRVc2VyQnlDbGllbnRJZChpZC5jbGllbnQpXG4gICAgICAgICAgICA6IHB1ZC5nZXRVc2VyQnlEZWxldGVkSWQoaWQpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY29sb3I6IGdldFVzZXJDb2xvcihcbiAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuY29sb3JNYXBwaW5nLFxuICAgICAgICAgICAgICBwbHVnaW5TdGF0ZS5jb2xvcnMsXG4gICAgICAgICAgICAgIHVzZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGRvY3VtZW50IGZyYWdtZW50IGFuZCByZW5kZXJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0gWS50eXBlTGlzdFRvQXJyYXlTbmFwc2hvdChcbiAgICAgICAgICBoaXN0b3J5VHlwZSxcbiAgICAgICAgICBuZXcgWS5TbmFwc2hvdChwcmV2U25hcHNob3QuZHMsIHNuYXBzaG90LnN2KVxuICAgICAgICApLm1hcCgodCkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICF0Ll9pdGVtLmRlbGV0ZWQgfHwgaXNWaXNpYmxlKHQuX2l0ZW0sIHNuYXBzaG90KSB8fFxuICAgICAgICAgICAgaXNWaXNpYmxlKHQuX2l0ZW0sIHByZXZTbmFwc2hvdClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbVlFbGVtZW50KFxuICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5zY2hlbWEsXG4gICAgICAgICAgICAgIHsgbWFwcGluZzogbmV3IE1hcCgpLCBpc09NYXJrOiBuZXcgTWFwKCkgfSxcbiAgICAgICAgICAgICAgc25hcHNob3QsXG4gICAgICAgICAgICAgIHByZXZTbmFwc2hvdCxcbiAgICAgICAgICAgICAgY29tcHV0ZVlDaGFuZ2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byByZW5kZXIgZWxlbWVudHMgdGhhdCBhcmUgbm90IHZpc2libGUgYnkgZWl0aGVyIHNuYXBzaG90LlxuICAgICAgICAgICAgLy8gSWYgYSBjbGllbnQgYWRkcyBhbmQgZGVsZXRlcyBjb250ZW50IGluIHRoZSBzYW1lIHNuYXBzaG90IHRoZSBlbGVtZW50IGlzIG5vdCB2aXNpYmxlIGJ5IGVpdGhlciBzbmFwc2hvdC5cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9KS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgdHIgPSB0aGlzLl90ci5yZXBsYWNlKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSxcbiAgICAgICAgICBuZXcgUE1vZGVsLlNsaWNlKFBNb2RlbC5GcmFnbWVudC5mcm9tKGZyYWdtZW50Q29udGVudCksIDAsIDApXG4gICAgICAgIClcbiAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2goXG4gICAgICAgICAgdHIuc2V0TWV0YSh5U3luY1BsdWdpbktleSwgeyBpc0NoYW5nZU9yaWdpbjogdHJ1ZSB9KVxuICAgICAgICApXG4gICAgICB9LCB5U3luY1BsdWdpbktleSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8WS5ZRXZlbnQ8YW55Pj59IGV2ZW50c1xuICAgKiBAcGFyYW0ge1kuVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBfdHlwZUNoYW5nZWQgKGV2ZW50cywgdHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodGhpcy5wcm9zZW1pcnJvclZpZXcgPT0gbnVsbCkgcmV0dXJuXG4gICAgY29uc3Qgc3luY1N0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUodGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUpXG4gICAgaWYgKFxuICAgICAgZXZlbnRzLmxlbmd0aCA9PT0gMCB8fCBzeW5jU3RhdGUuc25hcHNob3QgIT0gbnVsbCB8fFxuICAgICAgc3luY1N0YXRlLnByZXZTbmFwc2hvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICAvLyBkcm9wIG91dCBpZiBzbmFwc2hvdCBpcyBhY3RpdmVcbiAgICAgIHRoaXMucmVuZGVyU25hcHNob3Qoc3luY1N0YXRlLnNuYXBzaG90LCBzeW5jU3RhdGUucHJldlNuYXBzaG90KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHthbnl9IF9cbiAgICAgICAqIEBwYXJhbSB7WS5BYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICAgICAgICovXG4gICAgICBjb25zdCBkZWxUeXBlID0gKF8sIHR5cGUpID0+IHRoaXMubWFwcGluZy5kZWxldGUodHlwZSlcbiAgICAgIFkuaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlU2V0LFxuICAgICAgICAoc3RydWN0KSA9PiB7XG4gICAgICAgICAgaWYgKHN0cnVjdC5jb25zdHJ1Y3RvciA9PT0gWS5JdGVtKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAoLyoqIEB0eXBlIHtZLkl0ZW19ICovIChzdHJ1Y3QpLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgICAgIHR5cGUgJiYgdGhpcy5tYXBwaW5nLmRlbGV0ZSh0eXBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgdHJhbnNhY3Rpb24uY2hhbmdlZC5mb3JFYWNoKGRlbFR5cGUpXG4gICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuZm9yRWFjaChkZWxUeXBlKVxuICAgICAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0gdGhpcy50eXBlLnRvQXJyYXkoKS5tYXAoKHQpID0+XG4gICAgICAgIGNyZWF0ZU5vZGVJZk5vdEV4aXN0cyhcbiAgICAgICAgICAvKiogQHR5cGUge1kuWG1sRWxlbWVudCB8IFkuWG1sSG9va30gKi8gKHQpLFxuICAgICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLnNjaGVtYSxcbiAgICAgICAgICB0aGlzXG4gICAgICAgIClcbiAgICAgICkuZmlsdGVyKChuKSA9PiBuICE9PSBudWxsKVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbGV0IHRyID0gdGhpcy5fdHIucmVwbGFjZShcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSxcbiAgICAgICAgbmV3IFBNb2RlbC5TbGljZShQTW9kZWwuRnJhZ21lbnQuZnJvbShmcmFnbWVudENvbnRlbnQpLCAwLCAwKVxuICAgICAgKVxuICAgICAgcmVzdG9yZVJlbGF0aXZlU2VsZWN0aW9uKHRyLCB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uLCB0aGlzKVxuICAgICAgdHIgPSB0ci5zZXRNZXRhKHlTeW5jUGx1Z2luS2V5LCB7IGlzQ2hhbmdlT3JpZ2luOiB0cnVlLCBpc1VuZG9SZWRvT3BlcmF0aW9uOiB0cmFuc2FjdGlvbi5vcmlnaW4gaW5zdGFuY2VvZiBZLlVuZG9NYW5hZ2VyIH0pXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24gIT09IG51bGwgJiYgdGhpcy5faXNMb2NhbEN1cnNvckluVmlldygpXG4gICAgICApIHtcbiAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgfVxuICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2godHIpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgncHJvc2VtaXJyb3ItbW9kZWwnKS5Ob2RlfSBkb2NcbiAgICovXG4gIF9wcm9zZW1pcnJvckNoYW5nZWQgKGRvYykge1xuICAgIHRoaXMuZG9jLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgIHVwZGF0ZVlGcmFnbWVudCh0aGlzLmRvYywgdGhpcy50eXBlLCBkb2MsIHRoaXMpXG4gICAgICB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID0gZ2V0UmVsYXRpdmVTZWxlY3Rpb24oXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlXG4gICAgICApXG4gICAgfSwgeVN5bmNQbHVnaW5LZXkpXG4gIH1cblxuICAvKipcbiAgICogVmlldyBpcyByZWFkeSB0byBsaXN0ZW4gdG8gY2hhbmdlcy4gUmVnaXN0ZXIgb2JzZXJ2ZXJzLlxuICAgKiBAcGFyYW0ge2FueX0gcHJvc2VtaXJyb3JWaWV3XG4gICAqL1xuICBpbml0VmlldyAocHJvc2VtaXJyb3JWaWV3KSB7XG4gICAgaWYgKHRoaXMucHJvc2VtaXJyb3JWaWV3ICE9IG51bGwpIHRoaXMuZGVzdHJveSgpXG4gICAgdGhpcy5wcm9zZW1pcnJvclZpZXcgPSBwcm9zZW1pcnJvclZpZXdcbiAgICB0aGlzLmRvYy5vbignYmVmb3JlQWxsVHJhbnNhY3Rpb25zJywgdGhpcy5iZWZvcmVBbGxUcmFuc2FjdGlvbnMpXG4gICAgdGhpcy5kb2Mub24oJ2FmdGVyQWxsVHJhbnNhY3Rpb25zJywgdGhpcy5hZnRlckFsbFRyYW5zYWN0aW9ucylcbiAgICB0aGlzLnR5cGUub2JzZXJ2ZURlZXAodGhpcy5fb2JzZXJ2ZUZ1bmN0aW9uKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgaWYgKHRoaXMucHJvc2VtaXJyb3JWaWV3ID09IG51bGwpIHJldHVyblxuICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3ID0gbnVsbFxuICAgIHRoaXMudHlwZS51bm9ic2VydmVEZWVwKHRoaXMuX29ic2VydmVGdW5jdGlvbilcbiAgICB0aGlzLmRvYy5vZmYoJ2JlZm9yZUFsbFRyYW5zYWN0aW9ucycsIHRoaXMuYmVmb3JlQWxsVHJhbnNhY3Rpb25zKVxuICAgIHRoaXMuZG9jLm9mZignYWZ0ZXJBbGxUcmFuc2FjdGlvbnMnLCB0aGlzLmFmdGVyQWxsVHJhbnNhY3Rpb25zKVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WS5YbWxFbGVtZW50IHwgWS5YbWxIb29rfSBlbFxuICogQHBhcmFtIHtQTW9kZWwuU2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7QmluZGluZ01ldGFkYXRhfSBtZXRhXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgWS5JRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gKiBAcmV0dXJuIHtQTW9kZWwuTm9kZSB8IG51bGx9XG4gKi9cbmNvbnN0IGNyZWF0ZU5vZGVJZk5vdEV4aXN0cyA9IChcbiAgZWwsXG4gIHNjaGVtYSxcbiAgbWV0YSxcbiAgc25hcHNob3QsXG4gIHByZXZTbmFwc2hvdCxcbiAgY29tcHV0ZVlDaGFuZ2VcbikgPT4ge1xuICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKG1ldGEubWFwcGluZy5nZXQoZWwpKVxuICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGVsIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21ZRWxlbWVudChcbiAgICAgICAgZWwsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgbWV0YSxcbiAgICAgICAgc25hcHNob3QsXG4gICAgICAgIHByZXZTbmFwc2hvdCxcbiAgICAgICAgY29tcHV0ZVlDaGFuZ2VcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpIC8vIHdlIGFyZSBjdXJyZW50bHkgbm90IGhhbmRsaW5nIGhvb2tzXG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WS5YbWxFbGVtZW50fSBlbFxuICogQHBhcmFtIHthbnl9IHNjaGVtYVxuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3NuYXBzaG90XVxuICogQHBhcmFtIHtZLlNuYXBzaG90fSBbcHJldlNuYXBzaG90XVxuICogQHBhcmFtIHtmdW5jdGlvbigncmVtb3ZlZCcgfCAnYWRkZWQnLCBZLklEKTphbnl9IFtjb21wdXRlWUNoYW5nZV1cbiAqIEByZXR1cm4ge1BNb2RlbC5Ob2RlIHwgbnVsbH0gUmV0dXJucyBub2RlIGlmIG5vZGUgY291bGQgYmUgY3JlYXRlZC4gT3RoZXJ3aXNlIGl0IGRlbGV0ZXMgdGhlIHlqcyB0eXBlIGFuZCByZXR1cm5zIG51bGxcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQgPSAoXG4gIGVsLFxuICBzY2hlbWEsXG4gIG1ldGEsXG4gIHNuYXBzaG90LFxuICBwcmV2U25hcHNob3QsXG4gIGNvbXB1dGVZQ2hhbmdlXG4pID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBbXVxuICAvKipcbiAgICogQHBhcmFtIHtZLlhtbEVsZW1lbnQgfCBZLlhtbFRleHR9IHR5cGVcbiAgICovXG4gIGNvbnN0IGNyZWF0ZUNoaWxkcmVuID0gKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCkge1xuICAgICAgY29uc3QgbiA9IGNyZWF0ZU5vZGVJZk5vdEV4aXN0cyhcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBtZXRhLFxuICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgcHJldlNuYXBzaG90LFxuICAgICAgICBjb21wdXRlWUNoYW5nZVxuICAgICAgKVxuICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChuKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgbmV4dCB5dGV4dCBleGlzdHMgYW5kIHdhcyBjcmVhdGVkIGJ5IHVzLCBtb3ZlIHRoZSBjb250ZW50IHRvIHRoZSBjdXJyZW50IHl0ZXh0LlxuICAgICAgLy8gVGhpcyBpcyBhIGZpeCBmb3IgIzE2MCAtLSBkdXBsaWNhdGlvbiBvZiBjaGFyYWN0ZXJzIHdoZW4gdHdvIFkuVGV4dCBleGlzdCBuZXh0IHRvIGVhY2hcbiAgICAgIC8vIG90aGVyLlxuICAgICAgY29uc3QgbmV4dHl0ZXh0ID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAodHlwZS5faXRlbS5yaWdodD8uY29udGVudCk/LnR5cGVcbiAgICAgIGlmIChuZXh0eXRleHQgaW5zdGFuY2VvZiBZLlRleHQgJiYgIW5leHR5dGV4dC5faXRlbS5kZWxldGVkICYmIG5leHR5dGV4dC5faXRlbS5pZC5jbGllbnQgPT09IG5leHR5dGV4dC5kb2MuY2xpZW50SUQpIHtcbiAgICAgICAgdHlwZS5hcHBseURlbHRhKFtcbiAgICAgICAgICB7IHJldGFpbjogdHlwZS5sZW5ndGggfSxcbiAgICAgICAgICAuLi5uZXh0eXRleHQudG9EZWx0YSgpXG4gICAgICAgIF0pXG4gICAgICAgIG5leHR5dGV4dC5kb2MudHJhbnNhY3QodHIgPT4ge1xuICAgICAgICAgIG5leHR5dGV4dC5faXRlbS5kZWxldGUodHIpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICAvLyBub3cgY3JlYXRlIHRoZSBwcm9zZW1pcnJvciB0ZXh0IG5vZGVzXG4gICAgICBjb25zdCBucyA9IGNyZWF0ZVRleHROb2Rlc0Zyb21ZVGV4dChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBtZXRhLFxuICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgcHJldlNuYXBzaG90LFxuICAgICAgICBjb21wdXRlWUNoYW5nZVxuICAgICAgKVxuICAgICAgaWYgKG5zICE9PSBudWxsKSB7XG4gICAgICAgIG5zLmZvckVhY2goKHRleHRjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmICh0ZXh0Y2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGV4dGNoaWxkKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHNuYXBzaG90ID09PSB1bmRlZmluZWQgfHwgcHJldlNuYXBzaG90ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbC50b0FycmF5KCkuZm9yRWFjaChjcmVhdGVDaGlsZHJlbilcbiAgfSBlbHNlIHtcbiAgICBZLnR5cGVMaXN0VG9BcnJheVNuYXBzaG90KGVsLCBuZXcgWS5TbmFwc2hvdChwcmV2U25hcHNob3QuZHMsIHNuYXBzaG90LnN2KSlcbiAgICAgIC5mb3JFYWNoKGNyZWF0ZUNoaWxkcmVuKVxuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgYXR0cnMgPSBlbC5nZXRBdHRyaWJ1dGVzKHNuYXBzaG90KVxuICAgIGlmIChzbmFwc2hvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIWlzVmlzaWJsZSgvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKSwgc25hcHNob3QpKSB7XG4gICAgICAgIGF0dHJzLnljaGFuZ2UgPSBjb21wdXRlWUNoYW5nZVxuICAgICAgICAgID8gY29tcHV0ZVlDaGFuZ2UoJ3JlbW92ZWQnLCAvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKS5pZClcbiAgICAgICAgICA6IHsgdHlwZTogJ3JlbW92ZWQnIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzVmlzaWJsZSgvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKSwgcHJldlNuYXBzaG90KSkge1xuICAgICAgICBhdHRycy55Y2hhbmdlID0gY29tcHV0ZVlDaGFuZ2VcbiAgICAgICAgICA/IGNvbXB1dGVZQ2hhbmdlKCdhZGRlZCcsIC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAoZWwuX2l0ZW0pLmlkKVxuICAgICAgICAgIDogeyB0eXBlOiAnYWRkZWQnIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHNjaGVtYS5ub2RlKGVsLm5vZGVOYW1lLCBhdHRycywgY2hpbGRyZW4pXG4gICAgbWV0YS5tYXBwaW5nLnNldChlbCwgbm9kZSlcbiAgICByZXR1cm4gbm9kZVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gYW4gZXJyb3Igb2NjdXJlZCB3aGlsZSBjcmVhdGluZyB0aGUgbm9kZS4gVGhpcyBpcyBwcm9iYWJseSBhIHJlc3VsdCBvZiBhIGNvbmN1cnJlbnQgYWN0aW9uLlxuICAgIC8qKiBAdHlwZSB7WS5Eb2N9ICovIChlbC5kb2MpLnRyYW5zYWN0KCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgLyoqIEB0eXBlIHtZLkl0ZW19ICovIChlbC5faXRlbSkuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgIH0sIHlTeW5jUGx1Z2luS2V5KVxuICAgIG1ldGEubWFwcGluZy5kZWxldGUoZWwpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1kuWG1sVGV4dH0gdGV4dFxuICogQHBhcmFtIHtpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuU2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7QmluZGluZ01ldGFkYXRhfSBfbWV0YVxuICogQHBhcmFtIHtZLlNuYXBzaG90fSBbc25hcHNob3RdXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtwcmV2U25hcHNob3RdXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCdyZW1vdmVkJyB8ICdhZGRlZCcsIFkuSUQpOmFueX0gW2NvbXB1dGVZQ2hhbmdlXVxuICogQHJldHVybiB7QXJyYXk8UE1vZGVsLk5vZGU+fG51bGx9XG4gKi9cbmNvbnN0IGNyZWF0ZVRleHROb2Rlc0Zyb21ZVGV4dCA9IChcbiAgdGV4dCxcbiAgc2NoZW1hLFxuICBfbWV0YSxcbiAgc25hcHNob3QsXG4gIHByZXZTbmFwc2hvdCxcbiAgY29tcHV0ZVlDaGFuZ2VcbikgPT4ge1xuICBjb25zdCBub2RlcyA9IFtdXG4gIGNvbnN0IGRlbHRhcyA9IHRleHQudG9EZWx0YShzbmFwc2hvdCwgcHJldlNuYXBzaG90LCBjb21wdXRlWUNoYW5nZSlcbiAgdHJ5IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGVsdGEgPSBkZWx0YXNbaV1cbiAgICAgIG5vZGVzLnB1c2goc2NoZW1hLnRleHQoZGVsdGEuaW5zZXJ0LCBhdHRyaWJ1dGVzVG9NYXJrcyhkZWx0YS5hdHRyaWJ1dGVzLCBzY2hlbWEpKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBhbiBlcnJvciBvY2N1cmVkIHdoaWxlIGNyZWF0aW5nIHRoZSBub2RlLiBUaGlzIGlzIHByb2JhYmx5IGEgcmVzdWx0IG9mIGEgY29uY3VycmVudCBhY3Rpb24uXG4gICAgLyoqIEB0eXBlIHtZLkRvY30gKi8gKHRleHQuZG9jKS50cmFuc2FjdCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAodGV4dC5faXRlbSkuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgIH0sIHlTeW5jUGx1Z2luS2V5KVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gbm9kZXNcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBub2RlcyBwcm9zZW1pcnJvciBub2RlXG4gKiBAcGFyYW0ge0JpbmRpbmdNZXRhZGF0YX0gbWV0YVxuICogQHJldHVybiB7WS5YbWxUZXh0fVxuICovXG5jb25zdCBjcmVhdGVUeXBlRnJvbVRleHROb2RlcyA9IChub2RlcywgbWV0YSkgPT4ge1xuICBjb25zdCB0eXBlID0gbmV3IFkuWG1sVGV4dCgpXG4gIGNvbnN0IGRlbHRhID0gbm9kZXMubWFwKChub2RlKSA9PiAoe1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnNlcnQ6IG5vZGUudGV4dCxcbiAgICBhdHRyaWJ1dGVzOiBtYXJrc1RvQXR0cmlidXRlcyhub2RlLm1hcmtzLCBtZXRhKVxuICB9KSlcbiAgdHlwZS5hcHBseURlbHRhKGRlbHRhKVxuICBtZXRhLm1hcHBpbmcuc2V0KHR5cGUsIG5vZGVzKVxuICByZXR1cm4gdHlwZVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2FueX0gbm9kZSBwcm9zZW1pcnJvciBub2RlXG4gKiBAcGFyYW0ge0JpbmRpbmdNZXRhZGF0YX0gbWV0YVxuICogQHJldHVybiB7WS5YbWxFbGVtZW50fVxuICovXG5jb25zdCBjcmVhdGVUeXBlRnJvbUVsZW1lbnROb2RlID0gKG5vZGUsIG1ldGEpID0+IHtcbiAgY29uc3QgdHlwZSA9IG5ldyBZLlhtbEVsZW1lbnQobm9kZS50eXBlLm5hbWUpXG4gIGZvciAoY29uc3Qga2V5IGluIG5vZGUuYXR0cnMpIHtcbiAgICBjb25zdCB2YWwgPSBub2RlLmF0dHJzW2tleV1cbiAgICBpZiAodmFsICE9PSBudWxsICYmIGtleSAhPT0gJ3ljaGFuZ2UnKSB7XG4gICAgICB0eXBlLnNldEF0dHJpYnV0ZShrZXksIHZhbClcbiAgICB9XG4gIH1cbiAgdHlwZS5pbnNlcnQoXG4gICAgMCxcbiAgICBub3JtYWxpemVQTm9kZUNvbnRlbnQobm9kZSkubWFwKChuKSA9PlxuICAgICAgY3JlYXRlVHlwZUZyb21UZXh0T3JFbGVtZW50Tm9kZShuLCBtZXRhKVxuICAgIClcbiAgKVxuICBtZXRhLm1hcHBpbmcuc2V0KHR5cGUsIG5vZGUpXG4gIHJldHVybiB0eXBlXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UE1vZGVsLk5vZGV8QXJyYXk8UE1vZGVsLk5vZGU+fSBub2RlIHByb3NlbWlycm9yIHRleHQgbm9kZVxuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqIEByZXR1cm4ge1kuWG1sRWxlbWVudHxZLlhtbFRleHR9XG4gKi9cbmNvbnN0IGNyZWF0ZVR5cGVGcm9tVGV4dE9yRWxlbWVudE5vZGUgPSAobm9kZSwgbWV0YSkgPT5cbiAgbm9kZSBpbnN0YW5jZW9mIEFycmF5XG4gICAgPyBjcmVhdGVUeXBlRnJvbVRleHROb2Rlcyhub2RlLCBtZXRhKVxuICAgIDogY3JlYXRlVHlwZUZyb21FbGVtZW50Tm9kZShub2RlLCBtZXRhKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWxcbiAqL1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGxcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gcGF0dHJzXG4gKiBAcGFyYW0ge2FueX0geWF0dHJzXG4gKi9cbmNvbnN0IGVxdWFsQXR0cnMgPSAocGF0dHJzLCB5YXR0cnMpID0+IHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBhdHRycykuZmlsdGVyKChrZXkpID0+IHBhdHRyc1trZXldICE9PSBudWxsKVxuICBsZXQgZXEgPVxuICAgIGtleXMubGVuZ3RoID09PVxuICAgICAgKHlhdHRycyA9PSBudWxsID8gMCA6IE9iamVjdC5rZXlzKHlhdHRycykuZmlsdGVyKChrZXkpID0+IHlhdHRyc1trZXldICE9PSBudWxsKS5sZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGggJiYgZXE7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICBjb25zdCBsID0gcGF0dHJzW2tleV1cbiAgICBjb25zdCByID0geWF0dHJzW2tleV1cbiAgICBlcSA9IGtleSA9PT0gJ3ljaGFuZ2UnIHx8IGwgPT09IHIgfHxcbiAgICAgIChpc09iamVjdChsKSAmJiBpc09iamVjdChyKSAmJiBlcXVhbEF0dHJzKGwsIHIpKVxuICB9XG4gIHJldHVybiBlcVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtBcnJheTxBcnJheTxQTW9kZWwuTm9kZT58UE1vZGVsLk5vZGU+fSBOb3JtYWxpemVkUE5vZGVDb250ZW50XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gcG5vZGVcbiAqIEByZXR1cm4ge05vcm1hbGl6ZWRQTm9kZUNvbnRlbnR9XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVBOb2RlQ29udGVudCA9IChwbm9kZSkgPT4ge1xuICBjb25zdCBjID0gcG5vZGUuY29udGVudC5jb250ZW50XG4gIGNvbnN0IHJlcyA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG4gPSBjW2ldXG4gICAgaWYgKG4uaXNUZXh0KSB7XG4gICAgICBjb25zdCB0ZXh0Tm9kZXMgPSBbXVxuICAgICAgZm9yIChsZXQgdG5vZGUgPSBjW2ldOyBpIDwgYy5sZW5ndGggJiYgdG5vZGUuaXNUZXh0OyB0bm9kZSA9IGNbKytpXSkge1xuICAgICAgICB0ZXh0Tm9kZXMucHVzaCh0bm9kZSlcbiAgICAgIH1cbiAgICAgIGktLVxuICAgICAgcmVzLnB1c2godGV4dE5vZGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMucHVzaChuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogQHBhcmFtIHtZLlhtbFRleHR9IHl0ZXh0XG4gKiBAcGFyYW0ge0FycmF5PGFueT59IHB0ZXh0c1xuICovXG5jb25zdCBlcXVhbFlUZXh0UFRleHQgPSAoeXRleHQsIHB0ZXh0cykgPT4ge1xuICBjb25zdCBkZWx0YSA9IHl0ZXh0LnRvRGVsdGEoKVxuICByZXR1cm4gZGVsdGEubGVuZ3RoID09PSBwdGV4dHMubGVuZ3RoICYmXG4gICAgZGVsdGEuZXZlcnkoLyoqIEB0eXBlIHsoZDphbnksaTpudW1iZXIpID0+IGJvb2xlYW59ICovIChkLCBpKSA9PlxuICAgICAgZC5pbnNlcnQgPT09IC8qKiBAdHlwZSB7YW55fSAqLyAocHRleHRzW2ldKS50ZXh0ICYmXG4gICAgICBvYmplY3Qua2V5cyhkLmF0dHJpYnV0ZXMgfHwge30pLmxlbmd0aCA9PT0gcHRleHRzW2ldLm1hcmtzLmxlbmd0aCAmJlxuICAgICAgb2JqZWN0LmV2ZXJ5KGQuYXR0cmlidXRlcywgKGF0dHIsIHlhdHRybmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBtYXJrbmFtZSA9IHlhdHRyMm1hcmtuYW1lKHlhdHRybmFtZSlcbiAgICAgICAgY29uc3QgcG1hcmtzID0gcHRleHRzW2ldLm1hcmtzXG4gICAgICAgIHJldHVybiBlcXVhbEF0dHJzKGF0dHIsIHBtYXJrcy5maW5kKC8qKiBAcGFyYW0ge2FueX0gbWFyayAqLyBtYXJrID0+IG1hcmsudHlwZS5uYW1lID09PSBtYXJrbmFtZSk/LmF0dHJzKVxuICAgICAgfSlcbiAgICApXG59XG5cbi8qKlxuICogQHBhcmFtIHtZLlhtbEVsZW1lbnR8WS5YbWxUZXh0fFkuWG1sSG9va30geXR5cGVcbiAqIEBwYXJhbSB7YW55fEFycmF5PGFueT59IHBub2RlXG4gKi9cbmNvbnN0IGVxdWFsWVR5cGVQTm9kZSA9ICh5dHlwZSwgcG5vZGUpID0+IHtcbiAgaWYgKFxuICAgIHl0eXBlIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50ICYmICEocG5vZGUgaW5zdGFuY2VvZiBBcnJheSkgJiZcbiAgICBtYXRjaE5vZGVOYW1lKHl0eXBlLCBwbm9kZSlcbiAgKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZENvbnRlbnQgPSBub3JtYWxpemVQTm9kZUNvbnRlbnQocG5vZGUpXG4gICAgcmV0dXJuIHl0eXBlLl9sZW5ndGggPT09IG5vcm1hbGl6ZWRDb250ZW50Lmxlbmd0aCAmJlxuICAgICAgZXF1YWxBdHRycyh5dHlwZS5nZXRBdHRyaWJ1dGVzKCksIHBub2RlLmF0dHJzKSAmJlxuICAgICAgeXR5cGUudG9BcnJheSgpLmV2ZXJ5KCh5Y2hpbGQsIGkpID0+XG4gICAgICAgIGVxdWFsWVR5cGVQTm9kZSh5Y2hpbGQsIG5vcm1hbGl6ZWRDb250ZW50W2ldKVxuICAgICAgKVxuICB9XG4gIHJldHVybiB5dHlwZSBpbnN0YW5jZW9mIFkuWG1sVGV4dCAmJiBwbm9kZSBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgZXF1YWxZVGV4dFBUZXh0KHl0eXBlLCBwbm9kZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BNb2RlbC5Ob2RlIHwgQXJyYXk8UE1vZGVsLk5vZGU+IHwgdW5kZWZpbmVkfSBtYXBwZWRcbiAqIEBwYXJhbSB7UE1vZGVsLk5vZGUgfCBBcnJheTxQTW9kZWwuTm9kZT59IHBjb250ZW50XG4gKi9cbmNvbnN0IG1hcHBlZElkZW50aXR5ID0gKG1hcHBlZCwgcGNvbnRlbnQpID0+XG4gIG1hcHBlZCA9PT0gcGNvbnRlbnQgfHxcbiAgKG1hcHBlZCBpbnN0YW5jZW9mIEFycmF5ICYmIHBjb250ZW50IGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICBtYXBwZWQubGVuZ3RoID09PSBwY29udGVudC5sZW5ndGggJiYgbWFwcGVkLmV2ZXJ5KChhLCBpKSA9PlxuICAgIHBjb250ZW50W2ldID09PSBhXG4gICkpXG5cbi8qKlxuICogQHBhcmFtIHtZLlhtbEVsZW1lbnR9IHl0eXBlXG4gKiBAcGFyYW0ge1BNb2RlbC5Ob2RlfSBwbm9kZVxuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqIEByZXR1cm4ge3sgZm91bmRNYXBwZWRDaGlsZDogYm9vbGVhbiwgZXF1YWxpdHlGYWN0b3I6IG51bWJlciB9fVxuICovXG5jb25zdCBjb21wdXRlQ2hpbGRFcXVhbGl0eUZhY3RvciA9ICh5dHlwZSwgcG5vZGUsIG1ldGEpID0+IHtcbiAgY29uc3QgeUNoaWxkcmVuID0geXR5cGUudG9BcnJheSgpXG4gIGNvbnN0IHBDaGlsZHJlbiA9IG5vcm1hbGl6ZVBOb2RlQ29udGVudChwbm9kZSlcbiAgY29uc3QgcENoaWxkQ250ID0gcENoaWxkcmVuLmxlbmd0aFxuICBjb25zdCB5Q2hpbGRDbnQgPSB5Q2hpbGRyZW4ubGVuZ3RoXG4gIGNvbnN0IG1pbkNudCA9IG1hdGgubWluKHlDaGlsZENudCwgcENoaWxkQ250KVxuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gMFxuICBsZXQgZm91bmRNYXBwZWRDaGlsZCA9IGZhbHNlXG4gIGZvciAoOyBsZWZ0IDwgbWluQ250OyBsZWZ0KyspIHtcbiAgICBjb25zdCBsZWZ0WSA9IHlDaGlsZHJlbltsZWZ0XVxuICAgIGNvbnN0IGxlZnRQID0gcENoaWxkcmVuW2xlZnRdXG4gICAgaWYgKG1hcHBlZElkZW50aXR5KG1ldGEubWFwcGluZy5nZXQobGVmdFkpLCBsZWZ0UCkpIHtcbiAgICAgIGZvdW5kTWFwcGVkQ2hpbGQgPSB0cnVlIC8vIGRlZmluaXRlIChnb29kKSBtYXRjaCFcbiAgICB9IGVsc2UgaWYgKCFlcXVhbFlUeXBlUE5vZGUobGVmdFksIGxlZnRQKSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgZm9yICg7IGxlZnQgKyByaWdodCA8IG1pbkNudDsgcmlnaHQrKykge1xuICAgIGNvbnN0IHJpZ2h0WSA9IHlDaGlsZHJlblt5Q2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgY29uc3QgcmlnaHRQID0gcENoaWxkcmVuW3BDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICBpZiAobWFwcGVkSWRlbnRpdHkobWV0YS5tYXBwaW5nLmdldChyaWdodFkpLCByaWdodFApKSB7XG4gICAgICBmb3VuZE1hcHBlZENoaWxkID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoIWVxdWFsWVR5cGVQTm9kZShyaWdodFksIHJpZ2h0UCkpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZXF1YWxpdHlGYWN0b3I6IGxlZnQgKyByaWdodCxcbiAgICBmb3VuZE1hcHBlZENoaWxkXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1kuVGV4dH0geXRleHRcbiAqL1xuY29uc3QgeXRleHRUcmFucyA9ICh5dGV4dCkgPT4ge1xuICBsZXQgc3RyID0gJydcbiAgLyoqXG4gICAqIEB0eXBlIHtZLkl0ZW18bnVsbH1cbiAgICovXG4gIGxldCBuID0geXRleHQuX3N0YXJ0XG4gIGNvbnN0IG5BdHRycyA9IHt9XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQpIHtcbiAgICAgIGlmIChuLmNvdW50YWJsZSAmJiBuLmNvbnRlbnQgaW5zdGFuY2VvZiBZLkNvbnRlbnRTdHJpbmcpIHtcbiAgICAgICAgc3RyICs9IG4uY29udGVudC5zdHJcbiAgICAgIH0gZWxzZSBpZiAobi5jb250ZW50IGluc3RhbmNlb2YgWS5Db250ZW50Rm9ybWF0KSB7XG4gICAgICAgIG5BdHRyc1tuLmNvbnRlbnQua2V5XSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHRcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0cixcbiAgICBuQXR0cnNcbiAgfVxufVxuXG4vKipcbiAqIEB0b2RvIHRlc3QgdGhpcyBtb3JlXG4gKlxuICogQHBhcmFtIHtZLlRleHR9IHl0ZXh0XG4gKiBAcGFyYW0ge0FycmF5PGFueT59IHB0ZXh0c1xuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqL1xuY29uc3QgdXBkYXRlWVRleHQgPSAoeXRleHQsIHB0ZXh0cywgbWV0YSkgPT4ge1xuICBtZXRhLm1hcHBpbmcuc2V0KHl0ZXh0LCBwdGV4dHMpXG4gIGNvbnN0IHsgbkF0dHJzLCBzdHIgfSA9IHl0ZXh0VHJhbnMoeXRleHQpXG4gIGNvbnN0IGNvbnRlbnQgPSBwdGV4dHMubWFwKChwKSA9PiAoe1xuICAgIGluc2VydDogLyoqIEB0eXBlIHthbnl9ICovIChwKS50ZXh0LFxuICAgIGF0dHJpYnV0ZXM6IE9iamVjdC5hc3NpZ24oe30sIG5BdHRycywgbWFya3NUb0F0dHJpYnV0ZXMocC5tYXJrcywgbWV0YSkpXG4gIH0pKVxuICBjb25zdCB7IGluc2VydCwgcmVtb3ZlLCBpbmRleCB9ID0gc2ltcGxlRGlmZihcbiAgICBzdHIsXG4gICAgY29udGVudC5tYXAoKGMpID0+IGMuaW5zZXJ0KS5qb2luKCcnKVxuICApXG4gIHl0ZXh0LmRlbGV0ZShpbmRleCwgcmVtb3ZlKVxuICB5dGV4dC5pbnNlcnQoaW5kZXgsIGluc2VydClcbiAgeXRleHQuYXBwbHlEZWx0YShcbiAgICBjb250ZW50Lm1hcCgoYykgPT4gKHsgcmV0YWluOiBjLmluc2VydC5sZW5ndGgsIGF0dHJpYnV0ZXM6IGMuYXR0cmlidXRlcyB9KSlcbiAgKVxufVxuXG5jb25zdCBoYXNoZWRNYXJrTmFtZVJlZ2V4ID0gLyguKikoLS1bYS16QS1aMC05Ky89XXs4fSkkL1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IHlhdHRyMm1hcmtuYW1lID0gYXR0ck5hbWUgPT4gaGFzaGVkTWFya05hbWVSZWdleC5leGVjKGF0dHJOYW1lKT8uWzFdID8/IGF0dHJOYW1lXG5cbi8qKlxuICogQHRvZG8gbW92ZSB0aGlzIHRvIG1hcmtzdG9hdHRyaWJ1dGVzXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBhdHRyc1xuICogQHBhcmFtIHtpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuU2NoZW1hfSBzY2hlbWFcbiAqL1xuZXhwb3J0IGNvbnN0IGF0dHJpYnV0ZXNUb01hcmtzID0gKGF0dHJzLCBzY2hlbWEpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuTWFyaz59XG4gICAqL1xuICBjb25zdCBtYXJrcyA9IFtdXG4gIGZvciAoY29uc3QgbWFya05hbWUgaW4gYXR0cnMpIHtcbiAgICAvLyByZW1vdmUgaGFzaGVzIGlmIG5lY2Vzc2FyeVxuICAgIG1hcmtzLnB1c2goc2NoZW1hLm1hcmsoeWF0dHIybWFya25hbWUobWFya05hbWUpLCBhdHRyc1ttYXJrTmFtZV0pKVxuICB9XG4gIHJldHVybiBtYXJrc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCdwcm9zZW1pcnJvci1tb2RlbCcpLk1hcms+fSBtYXJrc1xuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqL1xuY29uc3QgbWFya3NUb0F0dHJpYnV0ZXMgPSAobWFya3MsIG1ldGEpID0+IHtcbiAgY29uc3QgcGF0dHJzID0ge31cbiAgbWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgIGlmIChtYXJrLnR5cGUubmFtZSAhPT0gJ3ljaGFuZ2UnKSB7XG4gICAgICBjb25zdCBpc092ZXJsYXBwaW5nID0gbWFwLnNldElmVW5kZWZpbmVkKG1ldGEuaXNPTWFyaywgbWFyay50eXBlLCAoKSA9PiAhbWFyay50eXBlLmV4Y2x1ZGVzKG1hcmsudHlwZSkpXG4gICAgICBwYXR0cnNbaXNPdmVybGFwcGluZyA/IGAke21hcmsudHlwZS5uYW1lfS0tJHt1dGlscy5oYXNoT2ZKU09OKG1hcmsudG9KU09OKCkpfWAgOiBtYXJrLnR5cGUubmFtZV0gPSBtYXJrLmF0dHJzXG4gICAgfVxuICB9KVxuICByZXR1cm4gcGF0dHJzXG59XG5cbi8qKlxuICogVXBkYXRlIGEgeURvbSBub2RlIGJ5IHN5bmNpbmcgdGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgcHJvc2VtaXJyb3Igbm9kZS5cbiAqXG4gKiBUaGlzIGlzIGEgeS1wcm9zZW1pcnJvciBpbnRlcm5hbCBmZWF0dXJlIHRoYXQgeW91IGNhbiB1c2UgYXQgeW91ciBvd24gcmlzay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHVuc3RhYmxlXG4gKlxuICogQHBhcmFtIHt7dHJhbnNhY3Q6IEZ1bmN0aW9ufX0geVxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB5RG9tRnJhZ21lbnRcbiAqIEBwYXJhbSB7YW55fSBwTm9kZVxuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVlGcmFnbWVudCA9ICh5LCB5RG9tRnJhZ21lbnQsIHBOb2RlLCBtZXRhKSA9PiB7XG4gIGlmIChcbiAgICB5RG9tRnJhZ21lbnQgaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQgJiZcbiAgICB5RG9tRnJhZ21lbnQubm9kZU5hbWUgIT09IHBOb2RlLnR5cGUubmFtZVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGUgbmFtZSBtaXNtYXRjaCEnKVxuICB9XG4gIG1ldGEubWFwcGluZy5zZXQoeURvbUZyYWdtZW50LCBwTm9kZSlcbiAgLy8gdXBkYXRlIGF0dHJpYnV0ZXNcbiAgaWYgKHlEb21GcmFnbWVudCBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCkge1xuICAgIGNvbnN0IHlEb21BdHRycyA9IHlEb21GcmFnbWVudC5nZXRBdHRyaWJ1dGVzKClcbiAgICBjb25zdCBwQXR0cnMgPSBwTm9kZS5hdHRyc1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBBdHRycykge1xuICAgICAgaWYgKHBBdHRyc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh5RG9tQXR0cnNba2V5XSAhPT0gcEF0dHJzW2tleV0gJiYga2V5ICE9PSAneWNoYW5nZScpIHtcbiAgICAgICAgICB5RG9tRnJhZ21lbnQuc2V0QXR0cmlidXRlKGtleSwgcEF0dHJzW2tleV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlEb21GcmFnbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuICAgICAgfVxuICAgIH1cbiAgICAvLyByZW1vdmUgYWxsIGtleXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHBBdHRyc1xuICAgIGZvciAoY29uc3Qga2V5IGluIHlEb21BdHRycykge1xuICAgICAgaWYgKHBBdHRyc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeURvbUZyYWdtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIHVwZGF0ZSBjaGlsZHJlblxuICBjb25zdCBwQ2hpbGRyZW4gPSBub3JtYWxpemVQTm9kZUNvbnRlbnQocE5vZGUpXG4gIGNvbnN0IHBDaGlsZENudCA9IHBDaGlsZHJlbi5sZW5ndGhcbiAgY29uc3QgeUNoaWxkcmVuID0geURvbUZyYWdtZW50LnRvQXJyYXkoKVxuICBjb25zdCB5Q2hpbGRDbnQgPSB5Q2hpbGRyZW4ubGVuZ3RoXG4gIGNvbnN0IG1pbkNudCA9IG1hdGgubWluKHBDaGlsZENudCwgeUNoaWxkQ250KVxuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gMFxuICAvLyBmaW5kIG51bWJlciBvZiBtYXRjaGluZyBlbGVtZW50cyBmcm9tIGxlZnRcbiAgZm9yICg7IGxlZnQgPCBtaW5DbnQ7IGxlZnQrKykge1xuICAgIGNvbnN0IGxlZnRZID0geUNoaWxkcmVuW2xlZnRdXG4gICAgY29uc3QgbGVmdFAgPSBwQ2hpbGRyZW5bbGVmdF1cbiAgICBpZiAoIW1hcHBlZElkZW50aXR5KG1ldGEubWFwcGluZy5nZXQobGVmdFkpLCBsZWZ0UCkpIHtcbiAgICAgIGlmIChlcXVhbFlUeXBlUE5vZGUobGVmdFksIGxlZnRQKSkge1xuICAgICAgICAvLyB1cGRhdGUgbWFwcGluZ1xuICAgICAgICBtZXRhLm1hcHBpbmcuc2V0KGxlZnRZLCBsZWZ0UClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGZpbmQgbnVtYmVyIG9mIG1hdGNoaW5nIGVsZW1lbnRzIGZyb20gcmlnaHRcbiAgZm9yICg7IHJpZ2h0ICsgbGVmdCA8IG1pbkNudDsgcmlnaHQrKykge1xuICAgIGNvbnN0IHJpZ2h0WSA9IHlDaGlsZHJlblt5Q2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgY29uc3QgcmlnaHRQID0gcENoaWxkcmVuW3BDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICBpZiAoIW1hcHBlZElkZW50aXR5KG1ldGEubWFwcGluZy5nZXQocmlnaHRZKSwgcmlnaHRQKSkge1xuICAgICAgaWYgKGVxdWFsWVR5cGVQTm9kZShyaWdodFksIHJpZ2h0UCkpIHtcbiAgICAgICAgLy8gdXBkYXRlIG1hcHBpbmdcbiAgICAgICAgbWV0YS5tYXBwaW5nLnNldChyaWdodFksIHJpZ2h0UClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHkudHJhbnNhY3QoKCkgPT4ge1xuICAgIC8vIHRyeSB0byBjb21wYXJlIGFuZCB1cGRhdGVcbiAgICB3aGlsZSAoeUNoaWxkQ250IC0gbGVmdCAtIHJpZ2h0ID4gMCAmJiBwQ2hpbGRDbnQgLSBsZWZ0IC0gcmlnaHQgPiAwKSB7XG4gICAgICBjb25zdCBsZWZ0WSA9IHlDaGlsZHJlbltsZWZ0XVxuICAgICAgY29uc3QgbGVmdFAgPSBwQ2hpbGRyZW5bbGVmdF1cbiAgICAgIGNvbnN0IHJpZ2h0WSA9IHlDaGlsZHJlblt5Q2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgICBjb25zdCByaWdodFAgPSBwQ2hpbGRyZW5bcENoaWxkQ250IC0gcmlnaHQgLSAxXVxuICAgICAgaWYgKGxlZnRZIGluc3RhbmNlb2YgWS5YbWxUZXh0ICYmIGxlZnRQIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgaWYgKCFlcXVhbFlUZXh0UFRleHQobGVmdFksIGxlZnRQKSkge1xuICAgICAgICAgIHVwZGF0ZVlUZXh0KGxlZnRZLCBsZWZ0UCwgbWV0YSlcbiAgICAgICAgfVxuICAgICAgICBsZWZ0ICs9IDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB1cGRhdGVMZWZ0ID0gbGVmdFkgaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQgJiZcbiAgICAgICAgICBtYXRjaE5vZGVOYW1lKGxlZnRZLCBsZWZ0UClcbiAgICAgICAgbGV0IHVwZGF0ZVJpZ2h0ID0gcmlnaHRZIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50ICYmXG4gICAgICAgICAgbWF0Y2hOb2RlTmFtZShyaWdodFksIHJpZ2h0UClcbiAgICAgICAgaWYgKHVwZGF0ZUxlZnQgJiYgdXBkYXRlUmlnaHQpIHtcbiAgICAgICAgICAvLyBkZWNpZGUgd2hpY2ggd2hpY2ggZWxlbWVudCB0byB1cGRhdGVcbiAgICAgICAgICBjb25zdCBlcXVhbGl0eUxlZnQgPSBjb21wdXRlQ2hpbGRFcXVhbGl0eUZhY3RvcihcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50fSAqLyAobGVmdFkpLFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKGxlZnRQKSxcbiAgICAgICAgICAgIG1ldGFcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgZXF1YWxpdHlSaWdodCA9IGNvbXB1dGVDaGlsZEVxdWFsaXR5RmFjdG9yKFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnR9ICovIChyaWdodFkpLFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKHJpZ2h0UCksXG4gICAgICAgICAgICBtZXRhXG4gICAgICAgICAgKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGVxdWFsaXR5TGVmdC5mb3VuZE1hcHBlZENoaWxkICYmICFlcXVhbGl0eVJpZ2h0LmZvdW5kTWFwcGVkQ2hpbGRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHVwZGF0ZVJpZ2h0ID0gZmFsc2VcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgIWVxdWFsaXR5TGVmdC5mb3VuZE1hcHBlZENoaWxkICYmIGVxdWFsaXR5UmlnaHQuZm91bmRNYXBwZWRDaGlsZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdXBkYXRlTGVmdCA9IGZhbHNlXG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGVxdWFsaXR5TGVmdC5lcXVhbGl0eUZhY3RvciA8IGVxdWFsaXR5UmlnaHQuZXF1YWxpdHlGYWN0b3JcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHVwZGF0ZUxlZnQgPSBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVSaWdodCA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVMZWZ0KSB7XG4gICAgICAgICAgdXBkYXRlWUZyYWdtZW50KFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxGcmFnbWVudH0gKi8gKGxlZnRZKSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UE1vZGVsLk5vZGV9ICovIChsZWZ0UCksXG4gICAgICAgICAgICBtZXRhXG4gICAgICAgICAgKVxuICAgICAgICAgIGxlZnQgKz0gMVxuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZVJpZ2h0KSB7XG4gICAgICAgICAgdXBkYXRlWUZyYWdtZW50KFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxGcmFnbWVudH0gKi8gKHJpZ2h0WSksXG4gICAgICAgICAgICAvKiogQHR5cGUge1BNb2RlbC5Ob2RlfSAqLyAocmlnaHRQKSxcbiAgICAgICAgICAgIG1ldGFcbiAgICAgICAgICApXG4gICAgICAgICAgcmlnaHQgKz0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ldGEubWFwcGluZy5kZWxldGUoeURvbUZyYWdtZW50LmdldChsZWZ0KSlcbiAgICAgICAgICB5RG9tRnJhZ21lbnQuZGVsZXRlKGxlZnQsIDEpXG4gICAgICAgICAgeURvbUZyYWdtZW50Lmluc2VydChsZWZ0LCBbXG4gICAgICAgICAgICBjcmVhdGVUeXBlRnJvbVRleHRPckVsZW1lbnROb2RlKGxlZnRQLCBtZXRhKVxuICAgICAgICAgIF0pXG4gICAgICAgICAgbGVmdCArPSAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeURlbExlbiA9IHlDaGlsZENudCAtIGxlZnQgLSByaWdodFxuICAgIGlmIChcbiAgICAgIHlDaGlsZENudCA9PT0gMSAmJiBwQ2hpbGRDbnQgPT09IDAgJiYgeUNoaWxkcmVuWzBdIGluc3RhbmNlb2YgWS5YbWxUZXh0XG4gICAgKSB7XG4gICAgICBtZXRhLm1hcHBpbmcuZGVsZXRlKHlDaGlsZHJlblswXSlcbiAgICAgIC8vIEVkZ2UgY2FzZSBoYW5kbGluZyBodHRwczovL2dpdGh1Yi5jb20veWpzL3ktcHJvc2VtaXJyb3IvaXNzdWVzLzEwOFxuICAgICAgLy8gT25seSBkZWxldGUgdGhlIGNvbnRlbnQgb2YgdGhlIFkuVGV4dCB0byByZXRhaW4gcmVtb3RlIGNoYW5nZXMgb24gdGhlIHNhbWUgWS5UZXh0IG9iamVjdFxuICAgICAgeUNoaWxkcmVuWzBdLmRlbGV0ZSgwLCB5Q2hpbGRyZW5bMF0ubGVuZ3RoKVxuICAgIH0gZWxzZSBpZiAoeURlbExlbiA+IDApIHtcbiAgICAgIHlEb21GcmFnbWVudC5zbGljZShsZWZ0LCBsZWZ0ICsgeURlbExlbikuZm9yRWFjaCh0eXBlID0+IG1ldGEubWFwcGluZy5kZWxldGUodHlwZSkpXG4gICAgICB5RG9tRnJhZ21lbnQuZGVsZXRlKGxlZnQsIHlEZWxMZW4pXG4gICAgfVxuICAgIGlmIChsZWZ0ICsgcmlnaHQgPCBwQ2hpbGRDbnQpIHtcbiAgICAgIGNvbnN0IGlucyA9IFtdXG4gICAgICBmb3IgKGxldCBpID0gbGVmdDsgaSA8IHBDaGlsZENudCAtIHJpZ2h0OyBpKyspIHtcbiAgICAgICAgaW5zLnB1c2goY3JlYXRlVHlwZUZyb21UZXh0T3JFbGVtZW50Tm9kZShwQ2hpbGRyZW5baV0sIG1ldGEpKVxuICAgICAgfVxuICAgICAgeURvbUZyYWdtZW50Lmluc2VydChsZWZ0LCBpbnMpXG4gICAgfVxuICB9LCB5U3luY1BsdWdpbktleSlcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7WS5YbWxFbGVtZW50fSB5RWxlbWVudFxuICogQHBhcmFtIHthbnl9IHBOb2RlIFByb3NlbWlycm9yIE5vZGVcbiAqL1xuY29uc3QgbWF0Y2hOb2RlTmFtZSA9ICh5RWxlbWVudCwgcE5vZGUpID0+XG4gICEocE5vZGUgaW5zdGFuY2VvZiBBcnJheSkgJiYgeUVsZW1lbnQubm9kZU5hbWUgPT09IHBOb2RlLnR5cGUubmFtZVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/undo-plugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultDeleteFilter: () => (/* binding */ defaultDeleteFilter),\n/* harmony export */   defaultProtectedNodes: () => (/* binding */ defaultProtectedNodes),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoCommand: () => (/* binding */ redoCommand),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoCommand: () => (/* binding */ undoCommand),\n/* harmony export */   yUndoPlugin: () => (/* binding */ yUndoPlugin)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var _sync_plugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sync-plugin.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n\n\n\n\n\n\n/**\n * @typedef {Object} UndoPluginState\n * @property {import('yjs').UndoManager} undoManager\n * @property {ReturnType<typeof getRelativeSelection> | null} prevSel\n * @property {boolean} hasUndoOps\n * @property {boolean} hasRedoOps\n */\n\n/**\n * Undo the last user action\n *\n * @param {import('prosemirror-state').EditorState} state\n * @return {boolean} whether a change was undone\n */\nconst undo = state => _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state)?.undoManager?.undo() != null\n\n/**\n * Redo the last user action\n *\n * @param {import('prosemirror-state').EditorState} state\n * @return {boolean} whether a change was undone\n */\nconst redo = state => _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state)?.undoManager?.redo() != null\n\n/**\n * Undo the last user action if there are undo operations available\n * @type {import('prosemirror-state').Command}\n */\nconst undoCommand = (state, dispatch) => dispatch == null ? _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state)?.undoManager?.canUndo() : undo(state)\n\n/**\n * Redo the last user action if there are redo operations available\n * @type {import('prosemirror-state').Command}\n */\nconst redoCommand = (state, dispatch) => dispatch == null ? _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state)?.undoManager?.canRedo() : redo(state)\n\nconst defaultProtectedNodes = new Set(['paragraph'])\n\n/**\n * @param {import('yjs').Item} item\n * @param {Set<string>} protectedNodes\n * @returns {boolean}\n */\nconst defaultDeleteFilter = (item, protectedNodes) => !(item instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Item) ||\n  !(item.content instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.ContentType) ||\n  !(item.content.type instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Text ||\n  (item.content.type instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.XmlElement && protectedNodes.has(item.content.type.nodeName))) ||\n  item.content.type._length === 0\n\n/**\n * @param {object} [options]\n * @param {Set<string>} [options.protectedNodes]\n * @param {any[]} [options.trackedOrigins]\n * @param {import('yjs').UndoManager | null} [options.undoManager]\n */\nconst yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n  key: _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey,\n  state: {\n    init: (initargs, state) => {\n      // TODO: check if plugin order matches and fix\n      const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(state)\n      const _undoManager = undoManager || new yjs__WEBPACK_IMPORTED_MODULE_1__.UndoManager(ystate.type, {\n        trackedOrigins: new Set([_keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey].concat(trackedOrigins)),\n        deleteFilter: (item) => defaultDeleteFilter(item, protectedNodes),\n        captureTransaction: tr => tr.meta.get('addToHistory') !== false\n      })\n      return {\n        undoManager: _undoManager,\n        prevSel: null,\n        hasUndoOps: _undoManager.undoStack.length > 0,\n        hasRedoOps: _undoManager.redoStack.length > 0\n      }\n    },\n    apply: (tr, val, oldState, state) => {\n      const binding = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(state).binding\n      const undoManager = val.undoManager\n      const hasUndoOps = undoManager.undoStack.length > 0\n      const hasRedoOps = undoManager.redoStack.length > 0\n      if (binding) {\n        return {\n          undoManager,\n          prevSel: (0,_sync_plugin_js__WEBPACK_IMPORTED_MODULE_3__.getRelativeSelection)(binding, oldState),\n          hasUndoOps,\n          hasRedoOps\n        }\n      } else {\n        if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {\n          return Object.assign({}, val, {\n            hasUndoOps: undoManager.undoStack.length > 0,\n            hasRedoOps: undoManager.redoStack.length > 0\n          })\n        } else { // nothing changed\n          return val\n        }\n      }\n    }\n  },\n  view: view => {\n    const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(view.state)\n    const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(view.state).undoManager\n    undoManager.on('stack-item-added', ({ stackItem }) => {\n      const binding = ystate.binding\n      if (binding) {\n        stackItem.meta.set(binding, _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(view.state).prevSel)\n      }\n    })\n    undoManager.on('stack-item-popped', ({ stackItem }) => {\n      const binding = ystate.binding\n      if (binding) {\n        binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection\n      }\n    })\n    return {\n      destroy: () => {\n        undoManager.destroy()\n      }\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy91bmRvLXBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwQzs7QUFFYTtBQUNlO0FBQ1o7O0FBRTFEO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsMkJBQTJCO0FBQ3pDLGNBQWMsZ0RBQWdEO0FBQzlELGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5Q0FBeUM7QUFDcEQsWUFBWSxTQUFTO0FBQ3JCO0FBQ08sc0JBQXNCLG9EQUFjOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRCxZQUFZLFNBQVM7QUFDckI7QUFDTyxzQkFBc0Isb0RBQWM7O0FBRTNDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTyw0REFBNEQsb0RBQWM7O0FBRWpGO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTyw0REFBNEQsb0RBQWM7O0FBRTFFOztBQUVQO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxhQUFhO0FBQ3hCLGFBQWE7QUFDYjtBQUNPLHdFQUF3RSxxQ0FBSTtBQUNuRiw0QkFBNEIsNENBQVc7QUFDdkMsaUNBQWlDLHFDQUFJO0FBQ3JDLGdDQUFnQywyQ0FBVTtBQUMxQzs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsa0NBQWtDO0FBQzdDO0FBQ08sdUJBQXVCLGtGQUFrRixJQUFJLFNBQVMscURBQU07QUFDbkksT0FBTyxvREFBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQWM7QUFDbkMsOENBQThDLDRDQUFXO0FBQ3pELGlDQUFpQyxvREFBYztBQUMvQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixvREFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUVBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixvREFBYztBQUNqQyx3QkFBd0Isb0RBQWM7QUFDdEMsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBLG9DQUFvQyxvREFBYztBQUNsRDtBQUNBLEtBQUs7QUFDTCwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvYXJ5YW5nb3lhbC9yZWFsLXRpbWUtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL3ktcHJvc2VtaXJyb3Ivc3JjL3BsdWdpbnMvdW5kby1wbHVnaW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnXG5cbmltcG9ydCB7IGdldFJlbGF0aXZlU2VsZWN0aW9uIH0gZnJvbSAnLi9zeW5jLXBsdWdpbi5qcydcbmltcG9ydCB7IFVuZG9NYW5hZ2VyLCBJdGVtLCBDb250ZW50VHlwZSwgWG1sRWxlbWVudCwgVGV4dCB9IGZyb20gJ3lqcydcbmltcG9ydCB7IHlVbmRvUGx1Z2luS2V5LCB5U3luY1BsdWdpbktleSB9IGZyb20gJy4va2V5cy5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVbmRvUGx1Z2luU3RhdGVcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCd5anMnKS5VbmRvTWFuYWdlcn0gdW5kb01hbmFnZXJcbiAqIEBwcm9wZXJ0eSB7UmV0dXJuVHlwZTx0eXBlb2YgZ2V0UmVsYXRpdmVTZWxlY3Rpb24+IHwgbnVsbH0gcHJldlNlbFxuICogQHByb3BlcnR5IHtib29sZWFufSBoYXNVbmRvT3BzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhhc1JlZG9PcHNcbiAqL1xuXG4vKipcbiAqIFVuZG8gdGhlIGxhc3QgdXNlciBhY3Rpb25cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgncHJvc2VtaXJyb3Itc3RhdGUnKS5FZGl0b3JTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgYSBjaGFuZ2Ugd2FzIHVuZG9uZVxuICovXG5leHBvcnQgY29uc3QgdW5kbyA9IHN0YXRlID0+IHlVbmRvUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKT8udW5kb01hbmFnZXI/LnVuZG8oKSAhPSBudWxsXG5cbi8qKlxuICogUmVkbyB0aGUgbGFzdCB1c2VyIGFjdGlvblxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCdwcm9zZW1pcnJvci1zdGF0ZScpLkVkaXRvclN0YXRlfSBzdGF0ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciBhIGNoYW5nZSB3YXMgdW5kb25lXG4gKi9cbmV4cG9ydCBjb25zdCByZWRvID0gc3RhdGUgPT4geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpPy51bmRvTWFuYWdlcj8ucmVkbygpICE9IG51bGxcblxuLyoqXG4gKiBVbmRvIHRoZSBsYXN0IHVzZXIgYWN0aW9uIGlmIHRoZXJlIGFyZSB1bmRvIG9wZXJhdGlvbnMgYXZhaWxhYmxlXG4gKiBAdHlwZSB7aW1wb3J0KCdwcm9zZW1pcnJvci1zdGF0ZScpLkNvbW1hbmR9XG4gKi9cbmV4cG9ydCBjb25zdCB1bmRvQ29tbWFuZCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IGRpc3BhdGNoID09IG51bGwgPyB5VW5kb1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSk/LnVuZG9NYW5hZ2VyPy5jYW5VbmRvKCkgOiB1bmRvKHN0YXRlKVxuXG4vKipcbiAqIFJlZG8gdGhlIGxhc3QgdXNlciBhY3Rpb24gaWYgdGhlcmUgYXJlIHJlZG8gb3BlcmF0aW9ucyBhdmFpbGFibGVcbiAqIEB0eXBlIHtpbXBvcnQoJ3Byb3NlbWlycm9yLXN0YXRlJykuQ29tbWFuZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZG9Db21tYW5kID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4gZGlzcGF0Y2ggPT0gbnVsbCA/IHlVbmRvUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKT8udW5kb01hbmFnZXI/LmNhblJlZG8oKSA6IHJlZG8oc3RhdGUpXG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UHJvdGVjdGVkTm9kZXMgPSBuZXcgU2V0KFsncGFyYWdyYXBoJ10pXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJ3lqcycpLkl0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7U2V0PHN0cmluZz59IHByb3RlY3RlZE5vZGVzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHREZWxldGVGaWx0ZXIgPSAoaXRlbSwgcHJvdGVjdGVkTm9kZXMpID0+ICEoaXRlbSBpbnN0YW5jZW9mIEl0ZW0pIHx8XG4gICEoaXRlbS5jb250ZW50IGluc3RhbmNlb2YgQ29udGVudFR5cGUpIHx8XG4gICEoaXRlbS5jb250ZW50LnR5cGUgaW5zdGFuY2VvZiBUZXh0IHx8XG4gIChpdGVtLmNvbnRlbnQudHlwZSBpbnN0YW5jZW9mIFhtbEVsZW1lbnQgJiYgcHJvdGVjdGVkTm9kZXMuaGFzKGl0ZW0uY29udGVudC50eXBlLm5vZGVOYW1lKSkpIHx8XG4gIGl0ZW0uY29udGVudC50eXBlLl9sZW5ndGggPT09IDBcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge1NldDxzdHJpbmc+fSBbb3B0aW9ucy5wcm90ZWN0ZWROb2Rlc11cbiAqIEBwYXJhbSB7YW55W119IFtvcHRpb25zLnRyYWNrZWRPcmlnaW5zXVxuICogQHBhcmFtIHtpbXBvcnQoJ3lqcycpLlVuZG9NYW5hZ2VyIHwgbnVsbH0gW29wdGlvbnMudW5kb01hbmFnZXJdXG4gKi9cbmV4cG9ydCBjb25zdCB5VW5kb1BsdWdpbiA9ICh7IHByb3RlY3RlZE5vZGVzID0gZGVmYXVsdFByb3RlY3RlZE5vZGVzLCB0cmFja2VkT3JpZ2lucyA9IFtdLCB1bmRvTWFuYWdlciA9IG51bGwgfSA9IHt9KSA9PiBuZXcgUGx1Z2luKHtcbiAga2V5OiB5VW5kb1BsdWdpbktleSxcbiAgc3RhdGU6IHtcbiAgICBpbml0OiAoaW5pdGFyZ3MsIHN0YXRlKSA9PiB7XG4gICAgICAvLyBUT0RPOiBjaGVjayBpZiBwbHVnaW4gb3JkZXIgbWF0Y2hlcyBhbmQgZml4XG4gICAgICBjb25zdCB5c3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSlcbiAgICAgIGNvbnN0IF91bmRvTWFuYWdlciA9IHVuZG9NYW5hZ2VyIHx8IG5ldyBVbmRvTWFuYWdlcih5c3RhdGUudHlwZSwge1xuICAgICAgICB0cmFja2VkT3JpZ2luczogbmV3IFNldChbeVN5bmNQbHVnaW5LZXldLmNvbmNhdCh0cmFja2VkT3JpZ2lucykpLFxuICAgICAgICBkZWxldGVGaWx0ZXI6IChpdGVtKSA9PiBkZWZhdWx0RGVsZXRlRmlsdGVyKGl0ZW0sIHByb3RlY3RlZE5vZGVzKSxcbiAgICAgICAgY2FwdHVyZVRyYW5zYWN0aW9uOiB0ciA9PiB0ci5tZXRhLmdldCgnYWRkVG9IaXN0b3J5JykgIT09IGZhbHNlXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5kb01hbmFnZXI6IF91bmRvTWFuYWdlcixcbiAgICAgICAgcHJldlNlbDogbnVsbCxcbiAgICAgICAgaGFzVW5kb09wczogX3VuZG9NYW5hZ2VyLnVuZG9TdGFjay5sZW5ndGggPiAwLFxuICAgICAgICBoYXNSZWRvT3BzOiBfdW5kb01hbmFnZXIucmVkb1N0YWNrLmxlbmd0aCA+IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIGFwcGx5OiAodHIsIHZhbCwgb2xkU3RhdGUsIHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBiaW5kaW5nID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpLmJpbmRpbmdcbiAgICAgIGNvbnN0IHVuZG9NYW5hZ2VyID0gdmFsLnVuZG9NYW5hZ2VyXG4gICAgICBjb25zdCBoYXNVbmRvT3BzID0gdW5kb01hbmFnZXIudW5kb1N0YWNrLmxlbmd0aCA+IDBcbiAgICAgIGNvbnN0IGhhc1JlZG9PcHMgPSB1bmRvTWFuYWdlci5yZWRvU3RhY2subGVuZ3RoID4gMFxuICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bmRvTWFuYWdlcixcbiAgICAgICAgICBwcmV2U2VsOiBnZXRSZWxhdGl2ZVNlbGVjdGlvbihiaW5kaW5nLCBvbGRTdGF0ZSksXG4gICAgICAgICAgaGFzVW5kb09wcyxcbiAgICAgICAgICBoYXNSZWRvT3BzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoYXNVbmRvT3BzICE9PSB2YWwuaGFzVW5kb09wcyB8fCBoYXNSZWRvT3BzICE9PSB2YWwuaGFzUmVkb09wcykge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB2YWwsIHtcbiAgICAgICAgICAgIGhhc1VuZG9PcHM6IHVuZG9NYW5hZ2VyLnVuZG9TdGFjay5sZW5ndGggPiAwLFxuICAgICAgICAgICAgaGFzUmVkb09wczogdW5kb01hbmFnZXIucmVkb1N0YWNrLmxlbmd0aCA+IDBcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgeyAvLyBub3RoaW5nIGNoYW5nZWRcbiAgICAgICAgICByZXR1cm4gdmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHZpZXc6IHZpZXcgPT4ge1xuICAgIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpXG4gICAgY29uc3QgdW5kb01hbmFnZXIgPSB5VW5kb1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKS51bmRvTWFuYWdlclxuICAgIHVuZG9NYW5hZ2VyLm9uKCdzdGFjay1pdGVtLWFkZGVkJywgKHsgc3RhY2tJdGVtIH0pID0+IHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSB5c3RhdGUuYmluZGluZ1xuICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgc3RhY2tJdGVtLm1ldGEuc2V0KGJpbmRpbmcsIHlVbmRvUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpLnByZXZTZWwpXG4gICAgICB9XG4gICAgfSlcbiAgICB1bmRvTWFuYWdlci5vbignc3RhY2staXRlbS1wb3BwZWQnLCAoeyBzdGFja0l0ZW0gfSkgPT4ge1xuICAgICAgY29uc3QgYmluZGluZyA9IHlzdGF0ZS5iaW5kaW5nXG4gICAgICBpZiAoYmluZGluZykge1xuICAgICAgICBiaW5kaW5nLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID0gc3RhY2tJdGVtLm1ldGEuZ2V0KGJpbmRpbmcpIHx8IGJpbmRpbmcuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB7XG4gICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSlcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/y-prosemirror/src/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashOfJSON: () => (/* binding */ hashOfJSON)\n/* harmony export */ });\n/* harmony import */ var lib0_hash_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/hash/sha256 */ \"(ssr)/./node_modules/lib0/hash/sha256.node.js\");\n/* harmony import */ var lib0_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/buffer */ \"(ssr)/./node_modules/lib0/buffer.js\");\n\n\n\n/**\n * Custom function to transform sha256 hash to N byte\n *\n * @param {Uint8Array} digest\n */\nconst _convolute = digest => {\n  const N = 6\n  for (let i = N; i < digest.length; i++) {\n    digest[i % N] = digest[i % N] ^ digest[i]\n  }\n  return digest.slice(0, N)\n}\n\n/**\n * @param {any} json\n */\nconst hashOfJSON = (json) => lib0_buffer__WEBPACK_IMPORTED_MODULE_0__.toBase64(_convolute(lib0_hash_sha256__WEBPACK_IMPORTED_MODULE_1__.digest(lib0_buffer__WEBPACK_IMPORTED_MODULE_0__.encodeAny(json))))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBDO0FBQ1I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ08sNkJBQTZCLGlEQUFZLFlBQVksb0RBQWEsQ0FBQyxrREFBYSIsInNvdXJjZXMiOlsiL1VzZXJzL2FyeWFuZ295YWwvcmVhbC10aW1lLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzaGEyNTYgZnJvbSAnbGliMC9oYXNoL3NoYTI1NidcbmltcG9ydCAqIGFzIGJ1ZiBmcm9tICdsaWIwL2J1ZmZlcidcblxuLyoqXG4gKiBDdXN0b20gZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHNoYTI1NiBoYXNoIHRvIE4gYnl0ZVxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGlnZXN0XG4gKi9cbmNvbnN0IF9jb252b2x1dGUgPSBkaWdlc3QgPT4ge1xuICBjb25zdCBOID0gNlxuICBmb3IgKGxldCBpID0gTjsgaSA8IGRpZ2VzdC5sZW5ndGg7IGkrKykge1xuICAgIGRpZ2VzdFtpICUgTl0gPSBkaWdlc3RbaSAlIE5dIF4gZGlnZXN0W2ldXG4gIH1cbiAgcmV0dXJuIGRpZ2VzdC5zbGljZSgwLCBOKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBqc29uXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNoT2ZKU09OID0gKGpzb24pID0+IGJ1Zi50b0Jhc2U2NChfY29udm9sdXRlKHNoYTI1Ni5kaWdlc3QoYnVmLmVuY29kZUFueShqc29uKSkpKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/utils.js\n");

/***/ })

};
;